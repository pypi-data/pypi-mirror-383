# coding: utf-8

"""
DataCore API  - Sport

For more details, see openapi/init.py

The version of the OpenAPI document: v1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self


class StandingAdjustmentPostBody(BaseModel):
    """
    StandingAdjustmentPostBody
    """  # noqa: E501

    standing_adjustment_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the adjustment", alias="standingAdjustmentId"
    )
    season_id: StrictStr = Field(description="The unique identifier of the season", alias="seasonId")
    entity_id: StrictStr = Field(description="The unique identifier of the entity", alias="entityId")
    round_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the round. (Unique for season)", alias="roundCode"
    )
    round_number: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="The number given to the round", alias="roundNumber"
    )
    stage_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the stage. (Unique for season)", alias="stageCode"
    )
    pool_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the pool. (Unique for season)", alias="poolCode"
    )
    division_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the division", alias="divisionId"
    )
    conference_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the conference", alias="conferenceId"
    )
    apply_to_all_standings: Optional[StrictBool] = Field(
        default=None, description="Apply to all generated standing types ?", alias="applyToAllStandings"
    )
    adjustment_group: StrictStr = Field(
        description="Adjustment Group >- `IN_CONFERENCE` In Conference >- `IN_DIVISION` In Division >- `OUT_CONFERENCE` Out Conference >- `OUT_DIVISION` Out Division >- `OVERALL` Overall ",
        alias="adjustmentGroup",
    )
    adjustment_type: StrictStr = Field(
        description="Adjustment Type >- `ADD_MINUS` Add/Subtract Value >- `SET` Set Value ", alias="adjustmentType"
    )
    adjustment_field: StrictStr = Field(
        description="Adjustment field to calculate standings >- `byes` Byes >- `draws` Games Drawn >- `drawsAway` Games Drawn (Away) >- `drawsHome` Games Drawn (Home) >- `forfeitsGiven` Forfeits Given >- `forfeitsWonBy` Forfeits Won >- `highestScoreAgainst` Highest Score Against >- `highestScoreAgainstAway` Highest Score Against (Away) >- `highestScoreAgainstHome` Highest Score Against (Home) >- `highestScoreFor` Highest Score For >- `highestScoreForAway` Highest Score For (Away) >- `highestScoreForHome` Highest Score For (Home) >- `losses` Games Lost >- `lossesAway` Games Lost (Away) >- `lossesHome` Games Lost (Home) >- `lowestScoreAgainst` Lowest Score Against >- `lowestScoreAgainstAway` Lowest Score Against (Away) >- `lowestScoreAgainstHome` Lowest Score Against (Home) >- `lowestScoreFor` Lowest Score For >- `lowestScoreForAway` Lowest Score For (Away) >- `lowestScoreForHome` Lowest Score For (Home) >- `percentage` For versus Against Percentage >- `percentageAway` For versus Against Percentage (Away) >- `percentageHome` For versus Against Percentage (Home) >- `played` Games Played >- `playedAway` Games Played (Away) >- `playedHome` Games Played (Home) >- `pointDifference` Point Difference >- `pointDifferenceAway` Point Difference (Away) >- `pointDifferenceHome` Point Difference (Home) >- `position` Standings Position >- `scoredAgainst` Score Against >- `scoredAgainstAway` Score Against (Away) >- `scoredAgainstHome` Score Against (Home) >- `scoredFor` Score For >- `scoredForAway` Score For (Away) >- `scoredForHome` Score For (Home) >- `standingPoints` Standing Points for competitor >- `standingPointsAway` Standing Points for competitor (Away) >- `standingPointsGiven` Standing Points Given away >- `standingPointsHome` Standing Points for competitor (Home) >- `streak` Winning Streak for competitor >- `streakAway` Winning Streak for competitor (Away) >- `streakHome` Winning Streak for competitor (Home) >- `washouts` Washouts >- `winPercentage` Win Percentage >- `winPercentageAway` Win Percentage (Away) >- `winPercentageHome` Win Percentage (Home) >- `wins` Games Won >- `winsAway` Games Won (Away) >- `winsHome` Games Won (Home) ",
        alias="adjustmentField",
    )
    adjustment_value: Union[StrictFloat, StrictInt] = Field(
        description="Value of the adjustment field", alias="adjustmentValue"
    )
    reason_type: StrictStr = Field(description="Reason type of the adjustment", alias="reasonType")
    reason_description: Optional[StrictStr] = Field(
        default=None, description="Reason for the adjustment", alias="reasonDescription"
    )
    grouping_key: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(
        default=None, description="Grouping Key to allow bulk deletions or listing by the key", alias="groupingKey"
    )
    __properties: ClassVar[List[str]] = [
        "standingAdjustmentId",
        "seasonId",
        "entityId",
        "roundCode",
        "roundNumber",
        "stageCode",
        "poolCode",
        "divisionId",
        "conferenceId",
        "applyToAllStandings",
        "adjustmentGroup",
        "adjustmentType",
        "adjustmentField",
        "adjustmentValue",
        "reasonType",
        "reasonDescription",
        "groupingKey",
    ]

    @field_validator("adjustment_group")
    def adjustment_group_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(["OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"]):
            raise ValueError(
                "must be one of enum values ('OVERALL', 'IN_CONFERENCE', 'OUT_CONFERENCE', 'IN_DIVISION', 'OUT_DIVISION')"
            )
        return value

    @field_validator("adjustment_type")
    def adjustment_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(["SET", "ADD_MINUS"]):
            raise ValueError("must be one of enum values ('SET', 'ADD_MINUS')")
        return value

    @field_validator("adjustment_field")
    def adjustment_field_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(
            [
                "position",
                "played",
                "playedHome",
                "playedAway",
                "wins",
                "winsHome",
                "winsAway",
                "losses",
                "lossesHome",
                "lossesAway",
                "draws",
                "drawsHome",
                "drawsAway",
                "washouts",
                "byes",
                "forfeitsGiven",
                "forfeitsWonBy",
                "winPercentage",
                "winPercentageHome",
                "winPercentageAway",
                "scoredFor",
                "scoredForHome",
                "scoredForAway",
                "scoredAgainst",
                "scoredAgainstHome",
                "scoredAgainstAway",
                "percentage",
                "percentageHome",
                "percentageAway",
                "pointDifference",
                "pointDifferenceHome",
                "pointDifferenceAway",
                "lowestScoreFor",
                "lowestScoreForHome",
                "lowestScoreForAway",
                "highestScoreFor",
                "highestScoreForHome",
                "highestScoreForAway",
                "lowestScoreAgainst",
                "lowestScoreAgainstHome",
                "lowestScoreAgainstAway",
                "highestScoreAgainst",
                "highestScoreAgainstHome",
                "highestScoreAgainstAway",
                "streak",
                "streakHome",
                "streakAway",
                "standingPoints",
                "standingPointsHome",
                "standingPointsAway",
                "standingPointsGiven",
            ]
        ):
            raise ValueError(
                "must be one of enum values ('position', 'played', 'playedHome', 'playedAway', 'wins', 'winsHome', 'winsAway', 'losses', 'lossesHome', 'lossesAway', 'draws', 'drawsHome', 'drawsAway', 'washouts', 'byes', 'forfeitsGiven', 'forfeitsWonBy', 'winPercentage', 'winPercentageHome', 'winPercentageAway', 'scoredFor', 'scoredForHome', 'scoredForAway', 'scoredAgainst', 'scoredAgainstHome', 'scoredAgainstAway', 'percentage', 'percentageHome', 'percentageAway', 'pointDifference', 'pointDifferenceHome', 'pointDifferenceAway', 'lowestScoreFor', 'lowestScoreForHome', 'lowestScoreForAway', 'highestScoreFor', 'highestScoreForHome', 'highestScoreForAway', 'lowestScoreAgainst', 'lowestScoreAgainstHome', 'lowestScoreAgainstAway', 'highestScoreAgainst', 'highestScoreAgainstHome', 'highestScoreAgainstAway', 'streak', 'streakHome', 'streakAway', 'standingPoints', 'standingPointsHome', 'standingPointsAway', 'standingPointsGiven')"
            )
        return value

    @field_validator("grouping_key")
    def grouping_key_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
            raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of StandingAdjustmentPostBody from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if round_code (nullable) is None
        # and model_fields_set contains the field
        if self.round_code is None and "round_code" in self.model_fields_set:
            _dict["roundCode"] = None

        # set to None if round_number (nullable) is None
        # and model_fields_set contains the field
        if self.round_number is None and "round_number" in self.model_fields_set:
            _dict["roundNumber"] = None

        # set to None if stage_code (nullable) is None
        # and model_fields_set contains the field
        if self.stage_code is None and "stage_code" in self.model_fields_set:
            _dict["stageCode"] = None

        # set to None if pool_code (nullable) is None
        # and model_fields_set contains the field
        if self.pool_code is None and "pool_code" in self.model_fields_set:
            _dict["poolCode"] = None

        # set to None if division_id (nullable) is None
        # and model_fields_set contains the field
        if self.division_id is None and "division_id" in self.model_fields_set:
            _dict["divisionId"] = None

        # set to None if conference_id (nullable) is None
        # and model_fields_set contains the field
        if self.conference_id is None and "conference_id" in self.model_fields_set:
            _dict["conferenceId"] = None

        # set to None if reason_description (nullable) is None
        # and model_fields_set contains the field
        if self.reason_description is None and "reason_description" in self.model_fields_set:
            _dict["reasonDescription"] = None

        # set to None if grouping_key (nullable) is None
        # and model_fields_set contains the field
        if self.grouping_key is None and "grouping_key" in self.model_fields_set:
            _dict["groupingKey"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of StandingAdjustmentPostBody from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "standingAdjustmentId": obj.get("standingAdjustmentId"),
                "seasonId": obj.get("seasonId"),
                "entityId": obj.get("entityId"),
                "roundCode": obj.get("roundCode"),
                "roundNumber": obj.get("roundNumber"),
                "stageCode": obj.get("stageCode"),
                "poolCode": obj.get("poolCode"),
                "divisionId": obj.get("divisionId"),
                "conferenceId": obj.get("conferenceId"),
                "applyToAllStandings": obj.get("applyToAllStandings"),
                "adjustmentGroup": obj.get("adjustmentGroup"),
                "adjustmentType": obj.get("adjustmentType"),
                "adjustmentField": obj.get("adjustmentField"),
                "adjustmentValue": obj.get("adjustmentValue"),
                "reasonType": obj.get("reasonType"),
                "reasonDescription": obj.get("reasonDescription"),
                "groupingKey": obj.get("groupingKey"),
            }
        )
        return _obj
