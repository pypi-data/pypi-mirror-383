# coding: utf-8

"""
DataCore API  - Sport

For more details, see openapi/init.py

The version of the OpenAPI document: v1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
from atriumsports.datacore.openapi.models.fixtures_model_round import FixturesModelRound
from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_pool import (
    SeasonFixtureStagesPoolsListModelPool,
)
from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_stage import (
    SeasonFixtureStagesPoolsListModelStage,
)
from atriumsports.datacore.openapi.models.standing_adjustments_model_organization import (
    StandingAdjustmentsModelOrganization,
)
from typing import Optional, Set
from typing_extensions import Self


class StandingAdjustmentsModel(BaseModel):
    """
    StandingAdjustmentsModel
    """  # noqa: E501

    standing_adjustment_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the adjustment", alias="standingAdjustmentId"
    )
    season_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the season", alias="seasonId"
    )
    season: Optional[FixtureProgressionsModelSeason] = None
    entity_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the entity", alias="entityId"
    )
    entity: Optional[FixtureEntitiesModelEntity] = None
    organization_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the organization", alias="organizationId"
    )
    organization: Optional[StandingAdjustmentsModelOrganization] = None
    round_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the round. (Unique for season)", alias="roundCode"
    )
    round: Optional[FixturesModelRound] = None
    round_number: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="The number given to the round", alias="roundNumber"
    )
    stage_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the stage. (Unique for season)", alias="stageCode"
    )
    stage: Optional[SeasonFixtureStagesPoolsListModelStage] = None
    pool_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the pool. (Unique for season)", alias="poolCode"
    )
    pool: Optional[SeasonFixtureStagesPoolsListModelPool] = None
    division_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the division", alias="divisionId"
    )
    division: Optional[FixtureEntitiesModelDivision] = None
    conference_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the conference", alias="conferenceId"
    )
    conference: Optional[FixtureEntitiesModelConference] = None
    apply_to_all_standings: Optional[StrictBool] = Field(
        default=None, description="Apply to all generated standing types ?", alias="applyToAllStandings"
    )
    adjustment_group: Optional[StrictStr] = Field(
        default=None,
        description="Adjustment Group >- `IN_CONFERENCE` In Conference >- `IN_DIVISION` In Division >- `OUT_CONFERENCE` Out Conference >- `OUT_DIVISION` Out Division >- `OVERALL` Overall ",
        alias="adjustmentGroup",
    )
    adjustment_type: Optional[StrictStr] = Field(
        default=None,
        description="Adjustment Type >- `ADD_MINUS` Add/Subtract Value >- `SET` Set Value ",
        alias="adjustmentType",
    )
    adjustment_field: Optional[StrictStr] = Field(
        default=None,
        description="Adjustment field to calculate standings >- `byes` Byes >- `draws` Games Drawn >- `drawsAway` Games Drawn (Away) >- `drawsHome` Games Drawn (Home) >- `forfeitsGiven` Forfeits Given >- `forfeitsWonBy` Forfeits Won >- `highestScoreAgainst` Highest Score Against >- `highestScoreAgainstAway` Highest Score Against (Away) >- `highestScoreAgainstHome` Highest Score Against (Home) >- `highestScoreFor` Highest Score For >- `highestScoreForAway` Highest Score For (Away) >- `highestScoreForHome` Highest Score For (Home) >- `losses` Games Lost >- `lossesAway` Games Lost (Away) >- `lossesHome` Games Lost (Home) >- `lowestScoreAgainst` Lowest Score Against >- `lowestScoreAgainstAway` Lowest Score Against (Away) >- `lowestScoreAgainstHome` Lowest Score Against (Home) >- `lowestScoreFor` Lowest Score For >- `lowestScoreForAway` Lowest Score For (Away) >- `lowestScoreForHome` Lowest Score For (Home) >- `percentage` For versus Against Percentage >- `percentageAway` For versus Against Percentage (Away) >- `percentageHome` For versus Against Percentage (Home) >- `played` Games Played >- `playedAway` Games Played (Away) >- `playedHome` Games Played (Home) >- `pointDifference` Point Difference >- `pointDifferenceAway` Point Difference (Away) >- `pointDifferenceHome` Point Difference (Home) >- `position` Standings Position >- `scoredAgainst` Score Against >- `scoredAgainstAway` Score Against (Away) >- `scoredAgainstHome` Score Against (Home) >- `scoredFor` Score For >- `scoredForAway` Score For (Away) >- `scoredForHome` Score For (Home) >- `standingPoints` Standing Points for competitor >- `standingPointsAway` Standing Points for competitor (Away) >- `standingPointsGiven` Standing Points Given away >- `standingPointsHome` Standing Points for competitor (Home) >- `streak` Winning Streak for competitor >- `streakAway` Winning Streak for competitor (Away) >- `streakHome` Winning Streak for competitor (Home) >- `washouts` Washouts >- `winPercentage` Win Percentage >- `winPercentageAway` Win Percentage (Away) >- `winPercentageHome` Win Percentage (Home) >- `wins` Games Won >- `winsAway` Games Won (Away) >- `winsHome` Games Won (Home) ",
        alias="adjustmentField",
    )
    adjustment_value: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Value of the adjustment field", alias="adjustmentValue"
    )
    reason_type: Optional[StrictStr] = Field(
        default=None, description="Reason type of the adjustment", alias="reasonType"
    )
    reason_description: Optional[StrictStr] = Field(
        default=None, description="Reason for the adjustment", alias="reasonDescription"
    )
    grouping_key: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(
        default=None, description="Grouping Key to allow bulk deletions or listing by the key", alias="groupingKey"
    )
    updated: Optional[datetime] = Field(default=None, description="Date/time last modified. In UTC")
    added: Optional[datetime] = Field(default=None, description="Date/time added. In UTC")
    __properties: ClassVar[List[str]] = [
        "standingAdjustmentId",
        "seasonId",
        "season",
        "entityId",
        "entity",
        "organizationId",
        "organization",
        "roundCode",
        "round",
        "roundNumber",
        "stageCode",
        "stage",
        "poolCode",
        "pool",
        "divisionId",
        "division",
        "conferenceId",
        "conference",
        "applyToAllStandings",
        "adjustmentGroup",
        "adjustmentType",
        "adjustmentField",
        "adjustmentValue",
        "reasonType",
        "reasonDescription",
        "groupingKey",
        "updated",
        "added",
    ]

    @field_validator("adjustment_group")
    def adjustment_group_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"]):
            raise ValueError(
                "must be one of enum values ('OVERALL', 'IN_CONFERENCE', 'OUT_CONFERENCE', 'IN_DIVISION', 'OUT_DIVISION')"
            )
        return value

    @field_validator("adjustment_type")
    def adjustment_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["SET", "ADD_MINUS"]):
            raise ValueError("must be one of enum values ('SET', 'ADD_MINUS')")
        return value

    @field_validator("adjustment_field")
    def adjustment_field_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(
            [
                "position",
                "played",
                "playedHome",
                "playedAway",
                "wins",
                "winsHome",
                "winsAway",
                "losses",
                "lossesHome",
                "lossesAway",
                "draws",
                "drawsHome",
                "drawsAway",
                "washouts",
                "byes",
                "forfeitsGiven",
                "forfeitsWonBy",
                "winPercentage",
                "winPercentageHome",
                "winPercentageAway",
                "scoredFor",
                "scoredForHome",
                "scoredForAway",
                "scoredAgainst",
                "scoredAgainstHome",
                "scoredAgainstAway",
                "percentage",
                "percentageHome",
                "percentageAway",
                "pointDifference",
                "pointDifferenceHome",
                "pointDifferenceAway",
                "lowestScoreFor",
                "lowestScoreForHome",
                "lowestScoreForAway",
                "highestScoreFor",
                "highestScoreForHome",
                "highestScoreForAway",
                "lowestScoreAgainst",
                "lowestScoreAgainstHome",
                "lowestScoreAgainstAway",
                "highestScoreAgainst",
                "highestScoreAgainstHome",
                "highestScoreAgainstAway",
                "streak",
                "streakHome",
                "streakAway",
                "standingPoints",
                "standingPointsHome",
                "standingPointsAway",
                "standingPointsGiven",
            ]
        ):
            raise ValueError(
                "must be one of enum values ('position', 'played', 'playedHome', 'playedAway', 'wins', 'winsHome', 'winsAway', 'losses', 'lossesHome', 'lossesAway', 'draws', 'drawsHome', 'drawsAway', 'washouts', 'byes', 'forfeitsGiven', 'forfeitsWonBy', 'winPercentage', 'winPercentageHome', 'winPercentageAway', 'scoredFor', 'scoredForHome', 'scoredForAway', 'scoredAgainst', 'scoredAgainstHome', 'scoredAgainstAway', 'percentage', 'percentageHome', 'percentageAway', 'pointDifference', 'pointDifferenceHome', 'pointDifferenceAway', 'lowestScoreFor', 'lowestScoreForHome', 'lowestScoreForAway', 'highestScoreFor', 'highestScoreForHome', 'highestScoreForAway', 'lowestScoreAgainst', 'lowestScoreAgainstHome', 'lowestScoreAgainstAway', 'highestScoreAgainst', 'highestScoreAgainstHome', 'highestScoreAgainstAway', 'streak', 'streakHome', 'streakAway', 'standingPoints', 'standingPointsHome', 'standingPointsAway', 'standingPointsGiven')"
            )
        return value

    @field_validator("grouping_key")
    def grouping_key_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
            raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of StandingAdjustmentsModel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set(
            [
                "organization_id",
                "updated",
                "added",
            ]
        )

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of season
        if self.season:
            _dict["season"] = self.season.to_dict()
        # override the default output from pydantic by calling `to_dict()` of entity
        if self.entity:
            _dict["entity"] = self.entity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of organization
        if self.organization:
            _dict["organization"] = self.organization.to_dict()
        # override the default output from pydantic by calling `to_dict()` of round
        if self.round:
            _dict["round"] = self.round.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stage
        if self.stage:
            _dict["stage"] = self.stage.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pool
        if self.pool:
            _dict["pool"] = self.pool.to_dict()
        # override the default output from pydantic by calling `to_dict()` of division
        if self.division:
            _dict["division"] = self.division.to_dict()
        # override the default output from pydantic by calling `to_dict()` of conference
        if self.conference:
            _dict["conference"] = self.conference.to_dict()
        # set to None if round_code (nullable) is None
        # and model_fields_set contains the field
        if self.round_code is None and "round_code" in self.model_fields_set:
            _dict["roundCode"] = None

        # set to None if round_number (nullable) is None
        # and model_fields_set contains the field
        if self.round_number is None and "round_number" in self.model_fields_set:
            _dict["roundNumber"] = None

        # set to None if stage_code (nullable) is None
        # and model_fields_set contains the field
        if self.stage_code is None and "stage_code" in self.model_fields_set:
            _dict["stageCode"] = None

        # set to None if pool_code (nullable) is None
        # and model_fields_set contains the field
        if self.pool_code is None and "pool_code" in self.model_fields_set:
            _dict["poolCode"] = None

        # set to None if division_id (nullable) is None
        # and model_fields_set contains the field
        if self.division_id is None and "division_id" in self.model_fields_set:
            _dict["divisionId"] = None

        # set to None if conference_id (nullable) is None
        # and model_fields_set contains the field
        if self.conference_id is None and "conference_id" in self.model_fields_set:
            _dict["conferenceId"] = None

        # set to None if reason_description (nullable) is None
        # and model_fields_set contains the field
        if self.reason_description is None and "reason_description" in self.model_fields_set:
            _dict["reasonDescription"] = None

        # set to None if grouping_key (nullable) is None
        # and model_fields_set contains the field
        if self.grouping_key is None and "grouping_key" in self.model_fields_set:
            _dict["groupingKey"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of StandingAdjustmentsModel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "standingAdjustmentId": obj.get("standingAdjustmentId"),
                "seasonId": obj.get("seasonId"),
                "season": FixtureProgressionsModelSeason.from_dict(obj["season"])
                if obj.get("season") is not None
                else None,
                "entityId": obj.get("entityId"),
                "entity": FixtureEntitiesModelEntity.from_dict(obj["entity"])
                if obj.get("entity") is not None
                else None,
                "organizationId": obj.get("organizationId"),
                "organization": StandingAdjustmentsModelOrganization.from_dict(obj["organization"])
                if obj.get("organization") is not None
                else None,
                "roundCode": obj.get("roundCode"),
                "round": FixturesModelRound.from_dict(obj["round"]) if obj.get("round") is not None else None,
                "roundNumber": obj.get("roundNumber"),
                "stageCode": obj.get("stageCode"),
                "stage": SeasonFixtureStagesPoolsListModelStage.from_dict(obj["stage"])
                if obj.get("stage") is not None
                else None,
                "poolCode": obj.get("poolCode"),
                "pool": SeasonFixtureStagesPoolsListModelPool.from_dict(obj["pool"])
                if obj.get("pool") is not None
                else None,
                "divisionId": obj.get("divisionId"),
                "division": FixtureEntitiesModelDivision.from_dict(obj["division"])
                if obj.get("division") is not None
                else None,
                "conferenceId": obj.get("conferenceId"),
                "conference": FixtureEntitiesModelConference.from_dict(obj["conference"])
                if obj.get("conference") is not None
                else None,
                "applyToAllStandings": obj.get("applyToAllStandings"),
                "adjustmentGroup": obj.get("adjustmentGroup"),
                "adjustmentType": obj.get("adjustmentType"),
                "adjustmentField": obj.get("adjustmentField"),
                "adjustmentValue": obj.get("adjustmentValue"),
                "reasonType": obj.get("reasonType"),
                "reasonDescription": obj.get("reasonDescription"),
                "groupingKey": obj.get("groupingKey"),
                "updated": obj.get("updated"),
                "added": obj.get("added"),
            }
        )
        return _obj
