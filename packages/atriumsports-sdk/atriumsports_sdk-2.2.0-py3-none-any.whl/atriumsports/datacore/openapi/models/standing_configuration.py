# coding: utf-8

"""
DataCore API  - Sport

For more details, see openapi/init.py

The version of the OpenAPI document: v1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from atriumsports.datacore.openapi.models.head_to_head_identification import HeadToHeadIdentification
from atriumsports.datacore.openapi.models.head_to_head_identification_for_subsequent_checks import (
    HeadToHeadIdentificationForSubsequentChecks,
)
from atriumsports.datacore.openapi.models.head_to_head_resolution import HeadToHeadResolution
from atriumsports.datacore.openapi.models.head_to_head_resolution_for_extra_depth_h2h_s import (
    HeadToHeadResolutionForExtraDepthH2hS,
)
from atriumsports.datacore.openapi.models.sorting import Sorting
from typing import Optional, Set
from typing_extensions import Self


class StandingConfiguration(BaseModel):
    """
    Configuration definitions
    """  # noqa: E501

    losses_secondary_score_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Home Loss by Secondary Score", alias="lossesSecondaryScoreHomePoints"
    )
    losses_secondary_score_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Away Loss by Secondary Score", alias="lossesSecondaryScoreAwayPoints"
    )
    wins_secondary_score_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Home Win by Secondary Score", alias="winsSecondaryScoreHomePoints"
    )
    wins_secondary_score_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Away Win by Secondary Score", alias="winsSecondaryScoreAwayPoints"
    )
    wins_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Home Win", alias="winsHomePoints"
    )
    losses_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Home Loss", alias="lossesHomePoints"
    )
    draws_home_scored_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Home Draw where entity scored", alias="drawsHomeScoredPoints"
    )
    draws_home_zero_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Home Draw with zero score", alias="drawsHomeZeroPoints"
    )
    forfeit_won_by_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for won by Forfeit at home", alias="forfeitWonByHomePoints"
    )
    forfeits_won_by_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for won by Forfeit at home", alias="forfeitsWonByHomePoints"
    )
    forfeit_given_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for giving a forfeit at home", alias="forfeitGivenHomePoints"
    )
    wins_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Away Win", alias="winsAwayPoints"
    )
    losses_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Away Loss", alias="lossesAwayPoints"
    )
    draws_away_scored_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Away Draw where entity scored", alias="drawsAwayScoredPoints"
    )
    draws_away_zero_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for Away Draw with zero score", alias="drawsAwayZeroPoints"
    )
    forfeit_won_by_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for won by Forfeit at away", alias="forfeitWonByAwayPoints"
    )
    forfeit_given_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for giving a forfeit at away", alias="forfeitGivenAwayPoints"
    )
    secondary_score_draw_as_result: Optional[StrictBool] = Field(
        default=None,
        description="Is a secondary Score result a game result (resultPlace was a Draw)?",
        alias="secondaryScoreDrawAsResult",
    )
    check_secondary_scores: Optional[StrictBool] = Field(
        default=None, description="Check Secondary Score for calculations", alias="checkSecondaryScores"
    )
    bye_points: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Points for bye", alias="byePoints"
    )
    bye_is_played: Optional[StrictBool] = Field(
        default=None, description="Is a Bye added to played ?", alias="byeIsPlayed"
    )
    bye_added_wins: Optional[StrictBool] = Field(
        default=None, description="Is a Bye added to won count?", alias="byeAddedWins"
    )
    forfeit_won_by_added_wins: Optional[StrictBool] = Field(
        default=None,
        description="Is a forfeit won by (received) included in won count ?",
        alias="forfeitWonByAddedWins",
    )
    forfeit_won_by_added_played: Optional[StrictBool] = Field(
        default=None,
        description="Is a forfeit won by (received) included in played count ?",
        alias="forfeitWonByAddedPlayed",
    )
    forfeit_given_added_losses: Optional[StrictBool] = Field(
        default=None, description="Is a forfeit given included in losses count ?", alias="forfeitGivenAddedLosses"
    )
    forfeit_given_added_played: Optional[StrictBool] = Field(
        default=None, description="Is a forfeit given included in played count ?", alias="forfeitGivenAddedPlayed"
    )
    streak: Optional[StrictStr] = Field(default=None, description="How is a streak calculated ?")
    sorts: Optional[List[Sorting]] = Field(default=None, description="Sortings")
    head_to_head_identification: Optional[List[HeadToHeadIdentification]] = Field(
        default=None, description="Head to head identifications", alias="headToHeadIdentification"
    )
    head_to_head_identification_subsequent: Optional[List[HeadToHeadIdentificationForSubsequentChecks]] = Field(
        default=None,
        description="Head to head identifications for subsequent checks",
        alias="headToHeadIdentificationSubsequent",
    )
    head_to_head_use_all_fixtures: Optional[StrictBool] = Field(
        default=None,
        description="Use all fixtures in Head to head resolutions regardless of Stage & Pool?",
        alias="headToHeadUseAllFixtures",
    )
    head_to_head_use_adjustments: Optional[StrictBool] = Field(
        default=None,
        description="Apply Standing Adjustments when performing Head to head resolutions?",
        alias="headToHeadUseAdjustments",
    )
    head_to_head_single_round: Optional[StrictBool] = Field(
        default=None, description="Only use single round for Head to head resolutions?", alias="headToHeadSingleRound"
    )
    head_to_head_resolutions: Optional[List[HeadToHeadResolution]] = Field(
        default=None, description="Head to head resolutions", alias="headToHeadResolutions"
    )
    head_to_head_resolutions_subsequent: Optional[List[HeadToHeadResolutionForExtraDepthH2hS]] = Field(
        default=None,
        description="Head to head resolutions for extra depth h2h's",
        alias="headToHeadResolutionsSubsequent",
    )
    __properties: ClassVar[List[str]] = [
        "lossesSecondaryScoreHomePoints",
        "lossesSecondaryScoreAwayPoints",
        "winsSecondaryScoreHomePoints",
        "winsSecondaryScoreAwayPoints",
        "winsHomePoints",
        "lossesHomePoints",
        "drawsHomeScoredPoints",
        "drawsHomeZeroPoints",
        "forfeitWonByHomePoints",
        "forfeitsWonByHomePoints",
        "forfeitGivenHomePoints",
        "winsAwayPoints",
        "lossesAwayPoints",
        "drawsAwayScoredPoints",
        "drawsAwayZeroPoints",
        "forfeitWonByAwayPoints",
        "forfeitGivenAwayPoints",
        "secondaryScoreDrawAsResult",
        "checkSecondaryScores",
        "byePoints",
        "byeIsPlayed",
        "byeAddedWins",
        "forfeitWonByAddedWins",
        "forfeitWonByAddedPlayed",
        "forfeitGivenAddedLosses",
        "forfeitGivenAddedPlayed",
        "streak",
        "sorts",
        "headToHeadIdentification",
        "headToHeadIdentificationSubsequent",
        "headToHeadUseAllFixtures",
        "headToHeadUseAdjustments",
        "headToHeadSingleRound",
        "headToHeadResolutions",
        "headToHeadResolutionsSubsequent",
    ]

    @field_validator("streak")
    def streak_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["WON", "NONLOST"]):
            raise ValueError("must be one of enum values ('WON', 'NONLOST')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of StandingConfiguration from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in sorts (list)
        _items = []
        if self.sorts:
            for _item_sorts in self.sorts:
                if _item_sorts:
                    _items.append(_item_sorts.to_dict())
            _dict["sorts"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in head_to_head_identification (list)
        _items = []
        if self.head_to_head_identification:
            for _item_head_to_head_identification in self.head_to_head_identification:
                if _item_head_to_head_identification:
                    _items.append(_item_head_to_head_identification.to_dict())
            _dict["headToHeadIdentification"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in head_to_head_identification_subsequent (list)
        _items = []
        if self.head_to_head_identification_subsequent:
            for _item_head_to_head_identification_subsequent in self.head_to_head_identification_subsequent:
                if _item_head_to_head_identification_subsequent:
                    _items.append(_item_head_to_head_identification_subsequent.to_dict())
            _dict["headToHeadIdentificationSubsequent"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in head_to_head_resolutions (list)
        _items = []
        if self.head_to_head_resolutions:
            for _item_head_to_head_resolutions in self.head_to_head_resolutions:
                if _item_head_to_head_resolutions:
                    _items.append(_item_head_to_head_resolutions.to_dict())
            _dict["headToHeadResolutions"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in head_to_head_resolutions_subsequent (list)
        _items = []
        if self.head_to_head_resolutions_subsequent:
            for _item_head_to_head_resolutions_subsequent in self.head_to_head_resolutions_subsequent:
                if _item_head_to_head_resolutions_subsequent:
                    _items.append(_item_head_to_head_resolutions_subsequent.to_dict())
            _dict["headToHeadResolutionsSubsequent"] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of StandingConfiguration from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "lossesSecondaryScoreHomePoints": obj.get("lossesSecondaryScoreHomePoints"),
                "lossesSecondaryScoreAwayPoints": obj.get("lossesSecondaryScoreAwayPoints"),
                "winsSecondaryScoreHomePoints": obj.get("winsSecondaryScoreHomePoints"),
                "winsSecondaryScoreAwayPoints": obj.get("winsSecondaryScoreAwayPoints"),
                "winsHomePoints": obj.get("winsHomePoints"),
                "lossesHomePoints": obj.get("lossesHomePoints"),
                "drawsHomeScoredPoints": obj.get("drawsHomeScoredPoints"),
                "drawsHomeZeroPoints": obj.get("drawsHomeZeroPoints"),
                "forfeitWonByHomePoints": obj.get("forfeitWonByHomePoints"),
                "forfeitsWonByHomePoints": obj.get("forfeitsWonByHomePoints"),
                "forfeitGivenHomePoints": obj.get("forfeitGivenHomePoints"),
                "winsAwayPoints": obj.get("winsAwayPoints"),
                "lossesAwayPoints": obj.get("lossesAwayPoints"),
                "drawsAwayScoredPoints": obj.get("drawsAwayScoredPoints"),
                "drawsAwayZeroPoints": obj.get("drawsAwayZeroPoints"),
                "forfeitWonByAwayPoints": obj.get("forfeitWonByAwayPoints"),
                "forfeitGivenAwayPoints": obj.get("forfeitGivenAwayPoints"),
                "secondaryScoreDrawAsResult": obj.get("secondaryScoreDrawAsResult"),
                "checkSecondaryScores": obj.get("checkSecondaryScores"),
                "byePoints": obj.get("byePoints"),
                "byeIsPlayed": obj.get("byeIsPlayed"),
                "byeAddedWins": obj.get("byeAddedWins"),
                "forfeitWonByAddedWins": obj.get("forfeitWonByAddedWins"),
                "forfeitWonByAddedPlayed": obj.get("forfeitWonByAddedPlayed"),
                "forfeitGivenAddedLosses": obj.get("forfeitGivenAddedLosses"),
                "forfeitGivenAddedPlayed": obj.get("forfeitGivenAddedPlayed"),
                "streak": obj.get("streak"),
                "sorts": [Sorting.from_dict(_item) for _item in obj["sorts"]] if obj.get("sorts") is not None else None,
                "headToHeadIdentification": [
                    HeadToHeadIdentification.from_dict(_item) for _item in obj["headToHeadIdentification"]
                ]
                if obj.get("headToHeadIdentification") is not None
                else None,
                "headToHeadIdentificationSubsequent": [
                    HeadToHeadIdentificationForSubsequentChecks.from_dict(_item)
                    for _item in obj["headToHeadIdentificationSubsequent"]
                ]
                if obj.get("headToHeadIdentificationSubsequent") is not None
                else None,
                "headToHeadUseAllFixtures": obj.get("headToHeadUseAllFixtures"),
                "headToHeadUseAdjustments": obj.get("headToHeadUseAdjustments"),
                "headToHeadSingleRound": obj.get("headToHeadSingleRound"),
                "headToHeadResolutions": [
                    HeadToHeadResolution.from_dict(_item) for _item in obj["headToHeadResolutions"]
                ]
                if obj.get("headToHeadResolutions") is not None
                else None,
                "headToHeadResolutionsSubsequent": [
                    HeadToHeadResolutionForExtraDepthH2hS.from_dict(_item)
                    for _item in obj["headToHeadResolutionsSubsequent"]
                ]
                if obj.get("headToHeadResolutionsSubsequent") is not None
                else None,
            }
        )
        return _obj
