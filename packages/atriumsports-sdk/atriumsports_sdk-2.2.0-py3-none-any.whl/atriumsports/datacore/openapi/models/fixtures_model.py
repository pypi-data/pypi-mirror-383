# coding: utf-8

"""
DataCore API  - Sport

For more details, see openapi/init.py

The version of the OpenAPI document: v1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from atriumsports.datacore.openapi.models.broadcasts import Broadcasts
from atriumsports.datacore.openapi.models.environmental_details import EnvironmentalDetails
from atriumsports.datacore.openapi.models.fixture_competitor import FixtureCompetitor
from atriumsports.datacore.openapi.models.fixture_participant import FixtureParticipant
from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
from atriumsports.datacore.openapi.models.fixtures_model_fixture_profile import FixturesModelFixtureProfile
from atriumsports.datacore.openapi.models.fixtures_model_organization import FixturesModelOrganization
from atriumsports.datacore.openapi.models.fixtures_model_round import FixturesModelRound
from atriumsports.datacore.openapi.models.fixtures_model_series import FixturesModelSeries
from atriumsports.datacore.openapi.models.fixtures_model_venue import FixturesModelVenue
from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_pool import (
    SeasonFixtureStagesPoolsListModelPool,
)
from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_stage import (
    SeasonFixtureStagesPoolsListModelStage,
)
from atriumsports.datacore.openapi.models.social_media import SocialMedia
from typing import Optional, Set
from typing_extensions import Self


class FixturesModel(BaseModel):
    """
    FixturesModel
    """  # noqa: E501

    fixture_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the fixture", alias="fixtureId"
    )
    organization_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the organization", alias="organizationId"
    )
    organization: Optional[FixturesModelOrganization] = None
    season_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the season", alias="seasonId"
    )
    season: Optional[FixtureProgressionsModelSeason] = None
    practice_drill_type: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(
        default=None,
        description="Practice types >- None None >- `DRILL` Drill >- `FITNESS` Fitness >- `GAME` Practice Game >- `OTHER` Other ",
        alias="practiceDrillType",
    )
    international_reference: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None,
        description="The international reference for this fixture given by the sport governing body",
        alias="internationalReference",
    )
    status: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(
        default="SCHEDULED",
        description="Fixture status >- `ABANDONED` Abandoned - Fixture began but had to be stopped >- `ABOUT_TO_START` About to Start - Fixture is about to start >- `BYE` Bye - Entity has 'rest' >- `CANCELLED` Cancelled - Cancelled - will not be played >- `CONFIRMED` Confirmed - Fixture officially completed >- `DRAFT` Draft - Not fully scheduled >- `FINISHED` Finished - Fixture finished by not yet 'official' >- `IF_NEEDED` If Needed - Only played if needed >- `IN_PROGRESS` In Progress - Currently in play >- `ON_PITCH` On Pitch - Players appered on the playing field >- `PENDING` Pending - Ready to start >- `POSTPONED` Postponed - Will be played at a future time >- `SCHEDULED` Scheduled - Yet to be played >- `WARM_UP` Warm Up - Players have begun to warm up ",
    )
    fixture_number: Optional[StrictInt] = Field(
        default=None, description="Fixture number (range of -2147483648 to 2147483647)", alias="fixtureNumber"
    )
    name_local: Optional[Annotated[str, Field(strict=True, max_length=150)]] = Field(
        default=None,
        description="The name of the fixture in the [local](#section/Introduction/Character-Sets-and-Names) language",
        alias="nameLocal",
    )
    name_latin: Optional[Annotated[str, Field(strict=True, max_length=150)]] = Field(
        default=None,
        description="The name of the fixture in [latin](#section/Introduction/Character-Sets-and-Names) characters",
        alias="nameLatin",
    )
    start_time_local: Optional[datetime] = Field(default=None, description="Local start time", alias="startTimeLocal")
    start_time_utc: Optional[datetime] = Field(
        default=None,
        description="Start time (UTC). This is automatically generated based on the timezone of the venue.",
        alias="startTimeUTC",
    )
    finish_recording_time_utc: Optional[datetime] = Field(
        default=None, description="(TO BE REMOVED) Start time (UTC) + durationFull", alias="finishRecordingTimeUTC"
    )
    finish_recording_time_local: Optional[datetime] = Field(
        default=None, description="(TO BE REMOVED) Start time (Local) + durationFull", alias="finishRecordingTimeLocal"
    )
    start_time_actual_utc: Optional[datetime] = Field(
        default=None, description="Actual start time (UTC)", alias="startTimeActualUTC"
    )
    end_time_actual_utc: Optional[datetime] = Field(
        default=None, description="Actual end time (UTC)", alias="endTimeActualUTC"
    )
    times_unconfirmed: Optional[StrictBool] = Field(
        default=None, description="Is the fixture time yet to be confirmed ?", alias="timesUnconfirmed"
    )
    locked: Optional[StrictBool] = Field(default=None, description="Is the fixture locked (to prevent editing)?")
    placing_if_won: Optional[StrictInt] = Field(default=None, description="Place if Won?", alias="placingIfWon")
    placing_if_lost: Optional[StrictInt] = Field(default=None, description="Place if Lost?", alias="placingIfLost")
    attendance: Optional[Annotated[int, Field(le=999999, strict=True)]] = Field(
        default=None, description="Crowd attendance"
    )
    sellout: Optional[StrictBool] = Field(default=None, description="Was the fixture a sellout?")
    social: Optional[SocialMedia] = None
    environmental: Optional[EnvironmentalDetails] = None
    duration: Optional[StrictInt] = Field(default=None, description="Length, in minutes, of the fixture")
    duration_full: Optional[StrictInt] = Field(
        default=None, description="Full duration including breaks", alias="durationFull"
    )
    ticket_url: Optional[Annotated[str, Field(strict=True, max_length=200)]] = Field(
        default=None, description="Ticket URL", alias="ticketURL"
    )
    stage_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the stage. (Unique for season)", alias="stageCode"
    )
    stage: Optional[SeasonFixtureStagesPoolsListModelStage] = None
    series_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the season series. (Unique for season)", alias="seriesCode"
    )
    series: Optional[FixturesModelSeries] = None
    pool_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the pool. (Unique for season)", alias="poolCode"
    )
    pool: Optional[SeasonFixtureStagesPoolsListModelPool] = None
    round_code: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="A unique code for the round. (Unique for season)", alias="roundCode"
    )
    round: Optional[FixturesModelRound] = None
    round_number: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(
        default=None, description="The number given to the round", alias="roundNumber"
    )
    live_data_available: Optional[StrictBool] = Field(
        default=None, description="Is live data available?", alias="liveDataAvailable"
    )
    live_video_available: Optional[StrictBool] = Field(
        default=None, description="Is live video available ?", alias="liveVideoAvailable"
    )
    fixture_type: Optional[Annotated[str, Field(strict=True, max_length=50)]] = Field(
        default=None,
        description="Type of fixture >- `ALL_STAR` All Star >- `DEMONSTRATION` Demonstration >- `FINAL` Final >- `FRIENDLY` Friendly >- `PLAYOFF` Playoff >- `PRESEASON` Pre Season >- `REGULAR` Regular ",
        alias="fixtureType",
    )
    maximum_period_type_used: Optional[Annotated[str, Field(strict=True, max_length=50)]] = Field(
        default=None,
        description="Maximum Period Type Used >- None None >- `EXTRA_TIME` Extra Time >- `OVERTIME` Overtime >- `REGULAR` Regular >- `SHOOTOUT` Shoot-Out ",
        alias="maximumPeriodTypeUsed",
    )
    competitor_type: Optional[Annotated[str, Field(strict=True, max_length=50)]] = Field(
        default=None,
        description="The type of competitors in this fixture >- `ENTITY` Entity >- `PERSON` Person ",
        alias="competitorType",
    )
    participants: Optional[List[FixtureParticipant]] = Field(default=None, description="Array of fixture participants")
    competitors: Optional[List[FixtureCompetitor]] = Field(default=None, description="Array of fixture competitors")
    venue_id: Optional[StrictStr] = Field(
        default=None, description="The unique identifier of the venue", alias="venueId"
    )
    venue: Optional[FixturesModelVenue] = None
    external_id: Optional[Annotated[str, Field(strict=True, max_length=150)]] = Field(
        default=None, description="The Id of the data as set by the provider of the data", alias="externalId"
    )
    profile_id: Optional[StrictStr] = Field(
        default=None, description="The profile that this fixture belongs to", alias="profileId"
    )
    fixture_profile: Optional[FixturesModelFixtureProfile] = Field(default=None, alias="fixtureProfile")
    include_in_standings: Optional[StrictBool] = Field(
        default=True, description="Include the fixture in the standings calculation?", alias="includeInStandings"
    )
    updated: Optional[datetime] = Field(default=None, description="Date/time last modified. In UTC")
    added: Optional[datetime] = Field(default=None, description="Date/time added. In UTC")
    estimated_finish_time_utc: Optional[datetime] = Field(
        default=None, description="Estimated end of fixture", alias="estimatedFinishTimeUTC"
    )
    feature_match: Optional[StrictBool] = Field(
        default=None, description="Is this fixture a featured match?", alias="featureMatch"
    )
    series_fixture_number: Optional[StrictInt] = Field(
        default=None, description="The number of the fixture in a series of fixtures", alias="seriesFixtureNumber"
    )
    discipline: Optional[StrictStr] = Field(
        default=None, description="fixture discipline >- None None >- `INDOOR` Indoor >- `OUTDOOR` Outdoor "
    )
    broadcasts: Optional[List[Optional[Broadcasts]]] = None
    __properties: ClassVar[List[str]] = [
        "fixtureId",
        "organizationId",
        "organization",
        "seasonId",
        "season",
        "practiceDrillType",
        "internationalReference",
        "status",
        "fixtureNumber",
        "nameLocal",
        "nameLatin",
        "startTimeLocal",
        "startTimeUTC",
        "finishRecordingTimeUTC",
        "finishRecordingTimeLocal",
        "startTimeActualUTC",
        "endTimeActualUTC",
        "timesUnconfirmed",
        "locked",
        "placingIfWon",
        "placingIfLost",
        "attendance",
        "sellout",
        "social",
        "environmental",
        "duration",
        "durationFull",
        "ticketURL",
        "stageCode",
        "stage",
        "seriesCode",
        "series",
        "poolCode",
        "pool",
        "roundCode",
        "round",
        "roundNumber",
        "liveDataAvailable",
        "liveVideoAvailable",
        "fixtureType",
        "maximumPeriodTypeUsed",
        "competitorType",
        "participants",
        "competitors",
        "venueId",
        "venue",
        "externalId",
        "profileId",
        "fixtureProfile",
        "includeInStandings",
        "updated",
        "added",
        "estimatedFinishTimeUTC",
        "featureMatch",
        "seriesFixtureNumber",
        "discipline",
        "broadcasts",
    ]

    @field_validator("practice_drill_type")
    def practice_drill_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["DRILL", "GAME", "FITNESS", "OTHER"]):
            raise ValueError("must be one of enum values ('DRILL', 'GAME', 'FITNESS', 'OTHER')")
        return value

    @field_validator("status")
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(
            [
                "IF_NEEDED",
                "SCHEDULED",
                "BYE",
                "PENDING",
                "IN_PROGRESS",
                "FINISHED",
                "CONFIRMED",
                "POSTPONED",
                "CANCELLED",
                "ABANDONED",
                "WARM_UP",
                "DRAFT",
                "ON_PITCH",
                "ABOUT_TO_START",
            ]
        ):
            raise ValueError(
                "must be one of enum values ('IF_NEEDED', 'SCHEDULED', 'BYE', 'PENDING', 'IN_PROGRESS', 'FINISHED', 'CONFIRMED', 'POSTPONED', 'CANCELLED', 'ABANDONED', 'WARM_UP', 'DRAFT', 'ON_PITCH', 'ABOUT_TO_START')"
            )
        return value

    @field_validator("fixture_type")
    def fixture_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"]):
            raise ValueError(
                "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
            )
        return value

    @field_validator("maximum_period_type_used")
    def maximum_period_type_used_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"]):
            raise ValueError("must be one of enum values ('REGULAR', 'EXTRA_TIME', 'OVERTIME', 'SHOOTOUT')")
        return value

    @field_validator("competitor_type")
    def competitor_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["PERSON", "ENTITY"]):
            raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
        return value

    @field_validator("external_id")
    def external_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
            raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
        return value

    @field_validator("discipline")
    def discipline_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["INDOOR", "OUTDOOR"]):
            raise ValueError("must be one of enum values ('INDOOR', 'OUTDOOR')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FixturesModel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set(
            [
                "organization_id",
                "start_time_utc",
                "finish_recording_time_utc",
                "finish_recording_time_local",
                "updated",
                "added",
                "estimated_finish_time_utc",
            ]
        )

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of organization
        if self.organization:
            _dict["organization"] = self.organization.to_dict()
        # override the default output from pydantic by calling `to_dict()` of season
        if self.season:
            _dict["season"] = self.season.to_dict()
        # override the default output from pydantic by calling `to_dict()` of social
        if self.social:
            _dict["social"] = self.social.to_dict()
        # override the default output from pydantic by calling `to_dict()` of environmental
        if self.environmental:
            _dict["environmental"] = self.environmental.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stage
        if self.stage:
            _dict["stage"] = self.stage.to_dict()
        # override the default output from pydantic by calling `to_dict()` of series
        if self.series:
            _dict["series"] = self.series.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pool
        if self.pool:
            _dict["pool"] = self.pool.to_dict()
        # override the default output from pydantic by calling `to_dict()` of round
        if self.round:
            _dict["round"] = self.round.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in participants (list)
        _items = []
        if self.participants:
            for _item_participants in self.participants:
                if _item_participants:
                    _items.append(_item_participants.to_dict())
            _dict["participants"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in competitors (list)
        _items = []
        if self.competitors:
            for _item_competitors in self.competitors:
                if _item_competitors:
                    _items.append(_item_competitors.to_dict())
            _dict["competitors"] = _items
        # override the default output from pydantic by calling `to_dict()` of venue
        if self.venue:
            _dict["venue"] = self.venue.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fixture_profile
        if self.fixture_profile:
            _dict["fixtureProfile"] = self.fixture_profile.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in broadcasts (list)
        _items = []
        if self.broadcasts:
            for _item_broadcasts in self.broadcasts:
                if _item_broadcasts:
                    _items.append(_item_broadcasts.to_dict())
            _dict["broadcasts"] = _items
        # set to None if practice_drill_type (nullable) is None
        # and model_fields_set contains the field
        if self.practice_drill_type is None and "practice_drill_type" in self.model_fields_set:
            _dict["practiceDrillType"] = None

        # set to None if international_reference (nullable) is None
        # and model_fields_set contains the field
        if self.international_reference is None and "international_reference" in self.model_fields_set:
            _dict["internationalReference"] = None

        # set to None if fixture_number (nullable) is None
        # and model_fields_set contains the field
        if self.fixture_number is None and "fixture_number" in self.model_fields_set:
            _dict["fixtureNumber"] = None

        # set to None if name_local (nullable) is None
        # and model_fields_set contains the field
        if self.name_local is None and "name_local" in self.model_fields_set:
            _dict["nameLocal"] = None

        # set to None if name_latin (nullable) is None
        # and model_fields_set contains the field
        if self.name_latin is None and "name_latin" in self.model_fields_set:
            _dict["nameLatin"] = None

        # set to None if start_time_local (nullable) is None
        # and model_fields_set contains the field
        if self.start_time_local is None and "start_time_local" in self.model_fields_set:
            _dict["startTimeLocal"] = None

        # set to None if start_time_utc (nullable) is None
        # and model_fields_set contains the field
        if self.start_time_utc is None and "start_time_utc" in self.model_fields_set:
            _dict["startTimeUTC"] = None

        # set to None if start_time_actual_utc (nullable) is None
        # and model_fields_set contains the field
        if self.start_time_actual_utc is None and "start_time_actual_utc" in self.model_fields_set:
            _dict["startTimeActualUTC"] = None

        # set to None if end_time_actual_utc (nullable) is None
        # and model_fields_set contains the field
        if self.end_time_actual_utc is None and "end_time_actual_utc" in self.model_fields_set:
            _dict["endTimeActualUTC"] = None

        # set to None if placing_if_won (nullable) is None
        # and model_fields_set contains the field
        if self.placing_if_won is None and "placing_if_won" in self.model_fields_set:
            _dict["placingIfWon"] = None

        # set to None if placing_if_lost (nullable) is None
        # and model_fields_set contains the field
        if self.placing_if_lost is None and "placing_if_lost" in self.model_fields_set:
            _dict["placingIfLost"] = None

        # set to None if attendance (nullable) is None
        # and model_fields_set contains the field
        if self.attendance is None and "attendance" in self.model_fields_set:
            _dict["attendance"] = None

        # set to None if social (nullable) is None
        # and model_fields_set contains the field
        if self.social is None and "social" in self.model_fields_set:
            _dict["social"] = None

        # set to None if environmental (nullable) is None
        # and model_fields_set contains the field
        if self.environmental is None and "environmental" in self.model_fields_set:
            _dict["environmental"] = None

        # set to None if duration (nullable) is None
        # and model_fields_set contains the field
        if self.duration is None and "duration" in self.model_fields_set:
            _dict["duration"] = None

        # set to None if duration_full (nullable) is None
        # and model_fields_set contains the field
        if self.duration_full is None and "duration_full" in self.model_fields_set:
            _dict["durationFull"] = None

        # set to None if ticket_url (nullable) is None
        # and model_fields_set contains the field
        if self.ticket_url is None and "ticket_url" in self.model_fields_set:
            _dict["ticketURL"] = None

        # set to None if stage_code (nullable) is None
        # and model_fields_set contains the field
        if self.stage_code is None and "stage_code" in self.model_fields_set:
            _dict["stageCode"] = None

        # set to None if series_code (nullable) is None
        # and model_fields_set contains the field
        if self.series_code is None and "series_code" in self.model_fields_set:
            _dict["seriesCode"] = None

        # set to None if pool_code (nullable) is None
        # and model_fields_set contains the field
        if self.pool_code is None and "pool_code" in self.model_fields_set:
            _dict["poolCode"] = None

        # set to None if round_code (nullable) is None
        # and model_fields_set contains the field
        if self.round_code is None and "round_code" in self.model_fields_set:
            _dict["roundCode"] = None

        # set to None if round_number (nullable) is None
        # and model_fields_set contains the field
        if self.round_number is None and "round_number" in self.model_fields_set:
            _dict["roundNumber"] = None

        # set to None if maximum_period_type_used (nullable) is None
        # and model_fields_set contains the field
        if self.maximum_period_type_used is None and "maximum_period_type_used" in self.model_fields_set:
            _dict["maximumPeriodTypeUsed"] = None

        # set to None if participants (nullable) is None
        # and model_fields_set contains the field
        if self.participants is None and "participants" in self.model_fields_set:
            _dict["participants"] = None

        # set to None if competitors (nullable) is None
        # and model_fields_set contains the field
        if self.competitors is None and "competitors" in self.model_fields_set:
            _dict["competitors"] = None

        # set to None if venue_id (nullable) is None
        # and model_fields_set contains the field
        if self.venue_id is None and "venue_id" in self.model_fields_set:
            _dict["venueId"] = None

        # set to None if external_id (nullable) is None
        # and model_fields_set contains the field
        if self.external_id is None and "external_id" in self.model_fields_set:
            _dict["externalId"] = None

        # set to None if profile_id (nullable) is None
        # and model_fields_set contains the field
        if self.profile_id is None and "profile_id" in self.model_fields_set:
            _dict["profileId"] = None

        # set to None if series_fixture_number (nullable) is None
        # and model_fields_set contains the field
        if self.series_fixture_number is None and "series_fixture_number" in self.model_fields_set:
            _dict["seriesFixtureNumber"] = None

        # set to None if discipline (nullable) is None
        # and model_fields_set contains the field
        if self.discipline is None and "discipline" in self.model_fields_set:
            _dict["discipline"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FixturesModel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "fixtureId": obj.get("fixtureId"),
                "organizationId": obj.get("organizationId"),
                "organization": FixturesModelOrganization.from_dict(obj["organization"])
                if obj.get("organization") is not None
                else None,
                "seasonId": obj.get("seasonId"),
                "season": FixtureProgressionsModelSeason.from_dict(obj["season"])
                if obj.get("season") is not None
                else None,
                "practiceDrillType": obj.get("practiceDrillType"),
                "internationalReference": obj.get("internationalReference"),
                "status": obj.get("status") if obj.get("status") is not None else "SCHEDULED",
                "fixtureNumber": obj.get("fixtureNumber"),
                "nameLocal": obj.get("nameLocal"),
                "nameLatin": obj.get("nameLatin"),
                "startTimeLocal": obj.get("startTimeLocal"),
                "startTimeUTC": obj.get("startTimeUTC"),
                "finishRecordingTimeUTC": obj.get("finishRecordingTimeUTC"),
                "finishRecordingTimeLocal": obj.get("finishRecordingTimeLocal"),
                "startTimeActualUTC": obj.get("startTimeActualUTC"),
                "endTimeActualUTC": obj.get("endTimeActualUTC"),
                "timesUnconfirmed": obj.get("timesUnconfirmed"),
                "locked": obj.get("locked"),
                "placingIfWon": obj.get("placingIfWon"),
                "placingIfLost": obj.get("placingIfLost"),
                "attendance": obj.get("attendance"),
                "sellout": obj.get("sellout"),
                "social": SocialMedia.from_dict(obj["social"]) if obj.get("social") is not None else None,
                "environmental": EnvironmentalDetails.from_dict(obj["environmental"])
                if obj.get("environmental") is not None
                else None,
                "duration": obj.get("duration"),
                "durationFull": obj.get("durationFull"),
                "ticketURL": obj.get("ticketURL"),
                "stageCode": obj.get("stageCode"),
                "stage": SeasonFixtureStagesPoolsListModelStage.from_dict(obj["stage"])
                if obj.get("stage") is not None
                else None,
                "seriesCode": obj.get("seriesCode"),
                "series": FixturesModelSeries.from_dict(obj["series"]) if obj.get("series") is not None else None,
                "poolCode": obj.get("poolCode"),
                "pool": SeasonFixtureStagesPoolsListModelPool.from_dict(obj["pool"])
                if obj.get("pool") is not None
                else None,
                "roundCode": obj.get("roundCode"),
                "round": FixturesModelRound.from_dict(obj["round"]) if obj.get("round") is not None else None,
                "roundNumber": obj.get("roundNumber"),
                "liveDataAvailable": obj.get("liveDataAvailable"),
                "liveVideoAvailable": obj.get("liveVideoAvailable"),
                "fixtureType": obj.get("fixtureType"),
                "maximumPeriodTypeUsed": obj.get("maximumPeriodTypeUsed"),
                "competitorType": obj.get("competitorType"),
                "participants": [FixtureParticipant.from_dict(_item) for _item in obj["participants"]]
                if obj.get("participants") is not None
                else None,
                "competitors": [FixtureCompetitor.from_dict(_item) for _item in obj["competitors"]]
                if obj.get("competitors") is not None
                else None,
                "venueId": obj.get("venueId"),
                "venue": FixturesModelVenue.from_dict(obj["venue"]) if obj.get("venue") is not None else None,
                "externalId": obj.get("externalId"),
                "profileId": obj.get("profileId"),
                "fixtureProfile": FixturesModelFixtureProfile.from_dict(obj["fixtureProfile"])
                if obj.get("fixtureProfile") is not None
                else None,
                "includeInStandings": obj.get("includeInStandings")
                if obj.get("includeInStandings") is not None
                else True,
                "updated": obj.get("updated"),
                "added": obj.get("added"),
                "estimatedFinishTimeUTC": obj.get("estimatedFinishTimeUTC"),
                "featureMatch": obj.get("featureMatch"),
                "seriesFixtureNumber": obj.get("seriesFixtureNumber"),
                "discipline": obj.get("discipline"),
                "broadcasts": [Broadcasts.from_dict(_item) for _item in obj["broadcasts"]]
                if obj.get("broadcasts") is not None
                else None,
            }
        )
        return _obj
