# Prerequisites:
#
# - In GitHub repo - create the publishing environment (here, `pypi` / `testpypi`)
#   https://docs.github.com/en/actions/how-tos/deploy/configure-and-manage-deployments/manage-environments
#
# - Create a "Trusted Publisher" in the project settings on (test)PyPI
#   https://docs.pypi.org/trusted-publishers/adding-a-publisher/
#   https://pypi.org/manage/project/docstring-to-text/settings/publishing/

# Tutorials:
# https://packaging.python.org/en/latest/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows/
# https://www.youtube.com/watch?v=NMQwzI9hprg
# https://github.com/ArjanCodes/moneysnake/blob/main/.github/workflows/release.yaml

name: Publish Python üêç distribution üì¶ to PyPI

# ======= TRIGGERS =======

#on:
#  push:
#    tags:
#      # Trigger on tags with '[v]<int>.<int>whatever' pattern: 'v1.0.0', 'v2.1.4', etc
#      # https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax#filter-pattern-cheat-sheet
#      # https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax#onpushbranchestagsbranches-ignoretags-ignore
#      - 'v[0-9]+.[0-9]**'
#      - '[0-9]+.[0-9]**'

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - "src/docstring_to_text/___package_meta.py"

# ====== CONCURRENCY ======

# Prevent multiple simultaneous builds for the same version:
concurrency:
  group: pypi-publish
  # To group by version:
  #group: pypi-publish-${{ github.ref }}-${{ hashFiles('src/docstring_to_text/___package_meta.py') }}
  cancel-in-progress: false  # the second pending run is put into a queue, the third one is cancelled (GitHub limitation)

# ======= ENV VARS =======

env:
  # The name on PyPI:
  PACKAGE_NAME: 'docstring-to-text'
  VERSION_FILE: 'src/docstring_to_text/___package_meta.py'
  VERSION_MODULE: 'src.docstring_to_text.___package_meta'
  VERSION_VARIABLE: 'VERSION'

# ========= JOBS =========

jobs:

  detect-version:
    # https://emojidb.org/query-emojis
    name: Parse version üî¢
    # Just to be nice - let's check the GitHub user and prevent unwanted auto-runs on forks made solely for a PR:
    if: ${{ github.repository_owner == 'Lex-DRL' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed for tag creation
    outputs:
      tag_name: ${{ steps.parse.outputs.tag_name }}
      version_full: ${{ steps.parse.outputs.version_full }}
      version_num: ${{ steps.parse.outputs.version_num }}
      suffix: ${{ steps.parse.outputs.suffix }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history to avoid issues with tags and branches

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Extract version üî¢ from package meta üìù
        id: get_version_string
        run: |
          # Try doing it with Python first:
          VERSION=$(
            python -c \
            "from ${{ env.VERSION_MODULE }} import ${{ env.VERSION_VARIABLE }}; print(${{ env.VERSION_VARIABLE }})" \
            2>/dev/null \
            | head -1
          )
          if [ $? -ne 0 ] || [ -z "$VERSION" ]; then  # previous command had non-zero exit status or version is empty
            echo "Failed to retrieve version with python. Attempting to parse it directly from file, with regexp..."
            VERSION=$(
              grep -oP "^\s*${{ env.VERSION_VARIABLE }}\s*=\s*['\"]\K[^'\"]+" "${{ env.VERSION_FILE }}" \
              2>/dev/null \
              | head -1
            )
          fi
          if [ $? -ne 0 ] || [ -z "$VERSION" ]; then
            echo "Error: Failed to retrieve version." >&2
            exit 1
          fi
          echo "Version string: $VERSION"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      # TODO: get rid of the following bash insanity and just parse it with a special python script / shared module.
      # Writing the output would use:
      #   with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
      #     print(f"{key}={value}", file=fh)
#      - name: Parse Version with Python
#        id: parse-with-python
#        run: >-
#          python parse_version.py
#          "${{ steps.get_version_string.outputs.version }}"
#        # Alternatively:
#        #run: |
#        #  python -c "
#        #  # The entire python script inline
#        #  version_str = '${{ steps.get_version_string.outputs.version }}'.lstrip('v')
#        #  "

      - name: Parse Version into parts üß±
        id: parse
        # The main magic happens in regexps...
        # - `grep -qP`: verify that the tag matches the given pattern
        # - `sed -E 's/regex_pattern/replacement/optional_flags'`, with '\1' in replacement meaning first group
        # The regexp itself:
        # - '^v?([0-9]+\.[0-9]+\.[0-9]+)' - matches 'v1.2.3' / '1.2.3' from start of the string, 'v' stripped
        #   - '^' - start of the input string.
        #   - 'v?(...)' - optional 'v' prefix (might be missing), and what follows is captured as a group.
        #   - '[0-9]+' - a sequence of 1 or more digits.
        #   - '\.' - literal dot (just '.' matches any character).
        # - '(-.+)?$' - suffix captured as a group:
        #   - '-' - just a hyphen.
        #   - '.+' - any non-empty string (at least one any character - including another hyphen, dot or digit).
        #   - '(...)?$' - a group that might be present or not.
        #   - '$' - the end of the input string.
        run: |
          VERSION_STR="${{ steps.get_version_string.outputs.version }}"
          echo "Version string: $VERSION_STR"
          if echo "$VERSION_STR" | grep -qP '^v?[0-9]+\.[0-9]+\.[0-9]+(-.+)?$'; then
            VERSION_NUMBER=$(echo "$VERSION_STR" | sed -E 's/^v?([0-9]+\.[0-9]+\.[0-9]+)(-.+)?$/\1/')
            echo "Version number: $VERSION_NUMBER"
            if echo "$VERSION_STR" | grep -q '-'; then
              # We can only get into this branch if the initial grep regex worked AND '-' is there
              # So it's '[v]1.2.3-something'
              SUFFIX=$(echo "$VERSION_STR" | sed -E 's/^v?([0-9]+\.[0-9]+\.[0-9]+)-(.+)$/\2/')
              if echo "$SUFFIX" | grep -q '-'; then
                echo "Invalid suffix (it contains hyphen): $SUFFIX" >&2
                exit 1
              fi
              SUFFIX_WITH_SEP=$(echo "-$SUFFIX")
            else
              SUFFIX=""
              SUFFIX_WITH_SEP=""
            fi
            echo "Suffix: $SUFFIX"
          else
            echo "Version string doesn't match the '[v]1.2.3[-suffix]' pattern: $VERSION_STR" >&2
            exit 1
          fi
          VERSION_FULL=$(echo "${VERSION_NUMBER}${SUFFIX_WITH_SEP}")
          echo "Full parsed Version: $VERSION_FULL"
          TAG_NAME=$(echo "v${VERSION_FULL}")
          echo "Tag name: $TAG_NAME"
          echo "tag_name=$TAG_NAME" >> "$GITHUB_OUTPUT"
          echo "version_full=$VERSION_FULL" >> "$GITHUB_OUTPUT"
          echo "version_num=$VERSION_NUMBER" >> "$GITHUB_OUTPUT"
          echo "suffix=$SUFFIX" >> "$GITHUB_OUTPUT"

  # --------------------------------------------------------

  build:
    name: Build distribution üì¶
    needs: [detect-version]  # No need to even try, if we failed tag parsing
    if: >-
      github.repository_owner == 'Lex-DRL'
    # Second condition: only run on tag pushes...
    # It was in the template from official tutorial, but it got redundant with our deep version parsing and verification
    # Kept here just as a condition example:
    #  && startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        persist-credentials: false

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.x"

    - name: Install pypa/build
      run: >-
        python3 -m
        pip install
        build
        --user

    # TODO: run tests before the build

    - name: Build a binary wheel and a source tarball
      run: python3 -m build

    - name: Store the distribution packages
      uses: actions/upload-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

  # --------------------------------------------------------

  publish-to-pypi:
    name: >-
      Publish Python üêç distribution üì¶ to PyPI ‚¨ÜÔ∏è
    if: ${{ github.repository_owner == 'Lex-DRL' }}
    needs:
    - build  # Requires the previous 'build' job to succeed
    runs-on: ubuntu-latest

    environment:
      name: pypi
      url: https://pypi.org/p/${{ env.PACKAGE_NAME }}
    permissions:
      id-token: write  # IMPORTANT: mandatory for trusted publishing

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

    - name: Publish distribution üì¶ to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1

  # --------------------------------------------------------

#  publish-to-testpypi:
#    name: Publish Python üêç distribution üì¶ to TestPyPI ‚ùó
#    if: ${{ github.repository_owner == 'Lex-DRL' }}
#    needs:
#    - build  # Requires the previous 'build' job to succeed
#    runs-on: ubuntu-latest
#
#    environment:
#      #name: testpypi
#      # Yes, it's "not cool" to use the same environment for testing and publishing,
#      # but in this particular repo I only use the TestPyPI for initial debugging of the workflow
#      name: pypi
#      url: https://test.pypi.org/p/${{ env.PACKAGE_NAME }}
#    permissions:
#      id-token: write  # IMPORTANT: mandatory for trusted publishing
#
#    steps:
#    - name: Download all the dists
#      uses: actions/download-artifact@v4
#      with:
#        name: python-package-distributions
#        path: dist/
#
#    - name: Publish distribution üì¶ to TestPyPI
#      uses: pypa/gh-action-pypi-publish@release/v1
#      with:
#        repository-url: https://test.pypi.org/legacy/

  # --------------------------------------------------------

  github_release:
    name: GitHub Tag üè∑Ô∏è + Release üîÑ
    needs: [build, detect-version]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history to avoid issues with tags and branches

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

      - name: Create tag üè∑Ô∏è from version
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${process.env.TAG}`,
              sha: context.sha
            })
        env:
          TAG: ${{ needs.detect-version.outputs.tag_name }}

      - name: Create GitHub Release üîÑ
        id: create_release
        env:
          GH_TOKEN: ${{ github.token }}
        run: >-
          gh release create
          ${{ needs.detect-version.outputs.tag_name }}
          dist/*
          --title ${{ needs.detect-version.outputs.tag_name }}
          --generate-notes
