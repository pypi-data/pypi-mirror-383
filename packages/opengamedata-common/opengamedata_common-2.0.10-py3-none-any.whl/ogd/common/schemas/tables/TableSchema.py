## import standard libraries
import abc
import builtins
import json
import logging
from collections import Counter
from pathlib import Path
from typing import Any, Callable, Dict, Final, List, Optional, Tuple, Type, TypeAlias
## import local files
from ogd.common.schemas.tables import presets
from ogd.common.schemas.Schema import Schema
from ogd.common.schemas.tables.ColumnSchema import ColumnSchema
from ogd.common.schemas.tables.ColumnMapSchema import ColumnMapSchema, ColumnMapElement
from ogd.common.utils.helpers import find
from ogd.common.utils.Logger import Logger
from ogd.common.utils.typing import ExportRow, Map, conversions

ColumnMapIndex   : TypeAlias = Optional[int | List[int] | Dict[str,int]]

## @class TableSchema
class TableSchema(Schema):
    """Dumb struct to hold info about the structure of data for a particular game, from a particular source.
        In particular, it contains an ordered list of columns in the data source table,
        and a mapping of those columns to the corresponding elements of a formal OGD structure.
    """

    _DEFAULT_SCHEMA_PATH : Final[Path] = Path(presets.__file__).parent
    _DEFAULT_COLUMNS     : Final[List[ColumnSchema]] = [
        ColumnSchema.FromDict(name=elem.get("name", "Column"), unparsed_elements=elem) for elem in [
        {
            "name": "session_id",
            "readable": "Session ID",
            "description": "Unique identifier for the gameplay session",
            "type": "str"
        },
        {
            "name": "app_id",
            "readable": "App Name",
            "description": "A string identifying which game from which the event came",
            "type": "str"
        },
        {
            "name": "timestamp",
            "readable": "Timestamp",
            "description": "The time when the event was logged",
            "type": "datetime"
        },
        {
            "name": "event_name",
            "readable": "Event Type",
            "description": "The type of event logged",
            "type": "str"
        },
        {
            "name": "event_data",
            "readable": "Event Data",
            "description": "Data specific to an event type, encoded as a JSON string",
            "type": "json"
        },
        {
            "name": "event_source",
            "readable": "Event Source",
            "description": "An enum member indicating whether the event was generated by the Game, or by a Detector",
            "type": "enum('GAME', 'GENERATED')"
        },
        {
            "name": "app_version",
            "readable": "App Version",
            "description": "The version of the game from which the event came",
            "type": "str"
        },
        {
            "name": "app_branch",
            "readable": "App Branch",
            "description": "The branch of the game from which the event came",
            "type": "str"
        },
        {
            "name": "log_version",
            "readable": "Log Version",
            "description": "The version of the logging code for the game from which the event came",
            "type": "str"
        },
        {
            "name": "offset",
            "readable": "Time Offset",
            "description": "The local offset of the event time from GMT",
            "type": "timezone"
        },
        {
            "name": "user_id",
            "readable": "Player ID",
            "description": "A custom, per-player ID, only exists if player entered an ID on one of our custom portal pages, else null",
            "type": "str"
        },
        {
            "name": "user_data",
            "readable": "User Data",
            "description": "Metadata specific to a user, encoded as a JSON string",
            "type": "json"
        },
        {
            "name": "game_state",
            "readable": "Game State",
            "description": "Metadata about the state of the game when the event occurred, encoded as a JSON string",
            "type": "json"
        },
        {
            "name": "index",
            "readable": "Event-Sequence Index",
            "description": "Counter of events in the session, from 0. A row with session_n = i is the (i+1)-th event of the session",
            "type": "int"
        }
    ]
    ]

    # *** ABSTRACTS ***

    @property
    @abc.abstractmethod
    def ColumnMap(self) -> ColumnMapSchema:
        raise NotImplementedError(f"{self.__class__.__name__} has not implemented the ColumnMap function!")

    # *** BUILT-INS & PROPERTIES ***

    def __init__(self, name,
                 columns:Optional[List[ColumnSchema]],
                 other_elements:Optional[Map]=None
        ):
        """Constructor for the TableSchema class.
        
        If optional params are not given, data is searched for in `other_elements`.

        Expected format:

        ```
        {
            "column_map": {
                "session_id"           : "session_id",
                "app_id"               : null,
                "timestamp"            : ["client_time", "client_time_ms"],
                ...
            },

            "columns": [
                {
                    "name": "session_id",
                    "readable": "Session ID",
                    "description": "ID for the play session",
                    "type": "str"
                },
                {
                    "name": "client_time",
                    ...
                },
        },
        ```

        :param schema_name: The filename for the table schema JSON.
        :type schema_name: str
        :param schema_path: Path to find the given table schema file, defaults to "./schemas/tables/presets/"
        :type schema_path: str, optional
        :param is_legacy: [description], defaults to False
        :type is_legacy: bool, optional
        """
        unparsed_elements : Map = other_elements or {}

        # declare and initialize vars
        # self._schema            : Optional[Dict[str, Any]] = all_elements
        self._table_columns : List[ColumnSchema] = columns if columns is not None else self._parseColumns(unparsed_elements=unparsed_elements, schema_name=name)

        # after loading the file, take the stuff we need and store.
        super().__init__(name=name, other_elements=other_elements)

    @property
    def Columns(self) -> List[ColumnSchema]:
        return self._table_columns

    @property
    def ColumnNames(self) -> List[str]:
        """Function to get the names of all columns in the schema.

        :return: Names of each column in the schema.
        :rtype: List[str]
        """
        return [col.Name for col in self._table_columns]

    # *** IMPLEMENT ABSTRACT FUNCTIONS ***

    # *** PUBLIC STATICS ***

    # *** PUBLIC METHODS ***

    _conversion_warnings = Counter()
    def ColumnValueFromRow(self, row:ExportRow, mapping:ColumnMapElement, concatenator:str, column_name:Optional[str]=None, expected_type:Optional[Type]=None, fallback:Any=None) -> Any:
        ret_val : Any
        if mapping is not None:
            indices = self.IndexFromMapping(mapping)
            if isinstance(indices, int):
                # if there's a single index, use parse to get the value it is stated to be
                # print(f"About to parse value {row[indices]} as type {self.Columns[indices]},\nFull list from row is {row},\nFull list of columns is {self.Columns},\nwith names {self.ColumnNames}")
                ret_val = conversions.ConvertToType(value=row[indices], to_type=self.Columns[indices].ValueType)
            elif isinstance(indices, list):
                ret_val = concatenator.join([str(row[index]) for index in indices])
            elif isinstance(indices, dict):
                ret_val = {}
                for key,column_index in indices.items():
                    if column_index > len(row):
                        Logger.Log(f"Got column index of {column_index} for column {key}, but row only has {len(row)} columns!", logging.ERROR)
                    _val = conversions.ConvertToType(value=row[column_index], to_type=self._table_columns[column_index].ValueType)
                    ret_val.update(_val if isinstance(_val, dict) else {key:_val})

            if column_name and expected_type and not isinstance(ret_val, expected_type):
                if column_name not in self._conversion_warnings:
                    _msg = f"{self.Name} event table schema set {column_name} as {type(ret_val)}, but {column_name} was requested to use type {expected_type.__name__}"
                    Logger.Log(_msg, logging.WARN)
                self._conversion_warnings[column_name] += 1
        else:
            ret_val = fallback
        return ret_val

    def ColumnValueToRow(self, raw_value:Any, mapping:ColumnMapElement, concatenator:str, element_name:Optional[str]) -> Dict[int, Any]:
        ret_val : Dict[int, Any] = {}

        if isinstance(mapping, str):
            ret_val[self.ColumnNames.index(mapping)] = raw_value
        elif isinstance(mapping, list):
            if isinstance(raw_value, str):
                indices = [self.ColumnNames.index(col) for col in mapping]
                pieces = raw_value.split(concatenator, len(indices))
                for i in range(len(pieces)):
                    ret_val[indices[i]] = pieces[i]
            else:
                idx = self.ColumnNames.index(mapping[0])
                _msg = f"{element_name} of type {type(raw_value)} was not splittable, {self.Name} will reverse-map it to the {self.Columns[idx].Name} column, instead of splitting amongst {mapping}"
                Logger.Log(_msg)
                ret_val[idx] = raw_value
        elif isinstance(mapping, dict):
            # TODO : support reversing the mapping of dict data
            idx = self.ColumnNames.index(list(mapping.keys())[0])
            _msg = f"Reverse-mapping is not supported generally for dicts, {self.Name} will map {element_name} to the {self.Columns[idx].Name}, rather than splitting amongst {mapping}"
            Logger.Log(_msg)
            ret_val[idx] = raw_value

        return ret_val
    
    def IndexFromMapping(self, mapping:ColumnMapElement) -> ColumnMapIndex:
        """Function to take a ColumnMapElement and turn it into a ColumnMapIndex

        The only real difference is that a ColumnMapElement is a string, list of strings, or string mapping,
        which indicates which columns are mapped to a particular element,
        while a ColumnMapIndex is given in terms of integer indices (for a row)

        :param mapping: _description_
        :type mapping: ColumnMapElement
        :return: _description_
        :rtype: ColumnMapIndex
        """
        ret_val : ColumnMapIndex = None

        if isinstance(mapping, str):
            ret_val = self.ColumnNames.index(mapping)
        elif isinstance(mapping, list):
            ret_val = [self.ColumnNames.index(col_name) for col_name in mapping]
        elif isinstance(mapping, dict):
            ret_val = {key:self.ColumnNames.index(val) for key,val in mapping.items()}

        return ret_val

    # *** PRIVATE STATICS ***

    # *** PRIVATE METHODS ***

    def _formatMappedColumn(self, index:ColumnMapIndex):
        """Takes a column mapping index, and returns a nicely-formatted string of the columns included in the index.

        If the index is just an int, it will return the name of the column:
        > "ColumnName"

        If the index is a list, it will return a comma-separated list of the column names:
        > "ColumnName1, ColumnName2"

        If the index is a dict, it will return a JSON-formatted string mapping keys to column names:
        > { "key1" : "ColumnName1", "key2" : "ColumnName2 }

        :param index: _description_
        :type index: ColumnMapIndex
        :raises TypeError: _description_
        :return: _description_
        :rtype: _type_
        """
        ret_val : str

        if isinstance(index, int):
            ret_val = self.ColumnNames[index]
        elif isinstance(index, list):
            ret_val = ", ".join([self.ColumnNames[idx] for idx in index])
        elif isinstance(index, dict):
            ret_val = json.dumps({key: self.ColumnNames[i] for key,i in index.items()})
        else:
            raise TypeError(f"Column mapping can not be type {type(index)}!")
        
        return ret_val

    @staticmethod
    def _parseColumns(unparsed_elements:Map, schema_name:Optional[str]=None) -> List[ColumnSchema]:
        ret_val : List[ColumnSchema]

        _column_json_list = TableSchema.ParseElement(
            unparsed_elements=unparsed_elements,
            valid_keys=["columns"],
            to_type=list,
            default_value=None,
            remove_target=True,
            schema_name=schema_name
        )
        if _column_json_list:
            ret_val = [ColumnSchema.FromDict(name=column.get("name", "UNKNOWN COLUMN NAME"), unparsed_elements=column) for column in _column_json_list]
        else:
            ret_val = TableSchema._DEFAULT_COLUMNS

        return ret_val

    @classmethod
    def _loadDirectories(cls, schema_name:str) -> List[str | Path]:
        """Private function that can be optionally overridden to define additional directories in which cls.Load(...) searches for a file from which to load an instance of the class.

        These extra directories are treated as optional places to search,
        and so have a lower priority than the main search paths (./, ~/, etc.)

        :return: A list of nonstandard directories in which to search for a file from which to load an instance of the class.
        :rtype: List[str | Path]
        """
        return [cls._DEFAULT_SCHEMA_PATH]
