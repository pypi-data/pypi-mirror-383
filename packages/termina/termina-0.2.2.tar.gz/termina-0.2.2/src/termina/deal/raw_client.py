# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.content_too_large_error import ContentTooLargeError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.deal_extra_metadata_response import DealExtraMetadataResponse
from ..types.deal_metadata_tag import DealMetadataTag
from ..types.deal_search_filter import DealSearchFilter
from ..types.deal_with_files_response import DealWithFilesResponse
from ..types.http_validation_error import HttpValidationError
from ..types.list_deals_response import ListDealsResponse
from ..types.paginated_response_search_deal_response import PaginatedResponseSearchDealResponse
from ..types.priority import Priority
from .types.metadata import Metadata

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawDealClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        group_id: int,
        *,
        round_name: str,
        company_id: int,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealWithFilesResponse]:
        """
        Create a new deal.

        Parameters
        ----------
        group_id : int

        round_name : str
            The name of the round

        company_id : int

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal",
            method="POST",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list(
        self,
        group_id: int,
        *,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDealsResponse]:
        """
        Get all deals for a group.

        Parameters
        ----------
        group_id : int

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/all",
            method="GET",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search(
        self,
        group_id: int,
        *,
        round_name: typing.Optional[str] = None,
        notes: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        company_name: typing.Optional[str] = None,
        company_domain: typing.Optional[str] = None,
        categories: typing.Optional[str] = None,
        deal_lead: typing.Optional[str] = None,
        ignore_archived: typing.Optional[bool] = None,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDealsResponse]:
        """
        Search deals within a group.

        Parameters
        ----------
        group_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]

        tags : typing.Optional[str]

        company_name : typing.Optional[str]

        company_domain : typing.Optional[str]

        categories : typing.Optional[str]

        deal_lead : typing.Optional[str]

        ignore_archived : typing.Optional[bool]

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search",
            method="GET",
            params={
                "round_name": round_name,
                "notes": notes,
                "tags": tags,
                "company_name": company_name,
                "company_domain": company_domain,
                "categories": categories,
                "deal_lead": deal_lead,
                "ignore_archived": ignore_archived,
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search_advanced(
        self,
        group_id: int,
        *,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        filters: typing.Optional[DealSearchFilter] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedResponseSearchDealResponse]:
        """
        Search deals within a group using flexible filters.

        Parameters
        ----------
        group_id : int

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        filters : typing.Optional[DealSearchFilter]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedResponseSearchDealResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search-advanced",
            method="POST",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            json={
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=DealSearchFilter, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseSearchDealResponse,
                    parse_obj_as(
                        type_=PaginatedResponseSearchDealResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DealWithFilesResponse]:
        """
        Retrieve a deal by its ID.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        group_id: int,
        deal_id: int,
        *,
        round_name: typing.Optional[str] = OMIT,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        company_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealWithFilesResponse]:
        """
        Update a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        company_id : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="PUT",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        group_id: int,
        deal_id: int,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def extra_metadata(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DealExtraMetadataResponse]:
        """
        Retrieve extra metadata for a deal, such as questions and meeting times.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def set_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        request: Metadata,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DealExtraMetadataResponse]:
        """
        Create or update questions for a deal. If questions already exist for this deal, they will be updated.
        If no questions exist, they will be created.


        Limitations:
        - The metadata payload cannot exceed 2048 characters.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        request : Metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Metadata, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Delete questions for a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def order(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Submit an order for a deal scan to be performed.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/order-scan",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_comparable_deals(
        self,
        group_id: int,
        deal_id: int,
        *,
        category: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[DealWithFilesResponse]]:
        """
        Get deals comparable to the current deal.

        Categories are required for meaningful comparison. Only deals with overlapping categories
        will be returned. If the current deal has no categories, no comparable deals will be returned.

        Returns the top 5 most recent deals with overlapping categories, sorted by updated timestamp.

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[DealWithFilesResponse]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/comparable-deals",
            method="GET",
            params={
                "category": category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DealWithFilesResponse],
                    parse_obj_as(
                        type_=typing.List[DealWithFilesResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawDealClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        group_id: int,
        *,
        round_name: str,
        company_id: int,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealWithFilesResponse]:
        """
        Create a new deal.

        Parameters
        ----------
        group_id : int

        round_name : str
            The name of the round

        company_id : int

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal",
            method="POST",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list(
        self,
        group_id: int,
        *,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDealsResponse]:
        """
        Get all deals for a group.

        Parameters
        ----------
        group_id : int

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/all",
            method="GET",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search(
        self,
        group_id: int,
        *,
        round_name: typing.Optional[str] = None,
        notes: typing.Optional[str] = None,
        tags: typing.Optional[str] = None,
        company_name: typing.Optional[str] = None,
        company_domain: typing.Optional[str] = None,
        categories: typing.Optional[str] = None,
        deal_lead: typing.Optional[str] = None,
        ignore_archived: typing.Optional[bool] = None,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDealsResponse]:
        """
        Search deals within a group.

        Parameters
        ----------
        group_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]

        tags : typing.Optional[str]

        company_name : typing.Optional[str]

        company_domain : typing.Optional[str]

        categories : typing.Optional[str]

        deal_lead : typing.Optional[str]

        ignore_archived : typing.Optional[bool]

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDealsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search",
            method="GET",
            params={
                "round_name": round_name,
                "notes": notes,
                "tags": tags,
                "company_name": company_name,
                "company_domain": company_domain,
                "categories": categories,
                "deal_lead": deal_lead,
                "ignore_archived": ignore_archived,
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDealsResponse,
                    parse_obj_as(
                        type_=ListDealsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search_advanced(
        self,
        group_id: int,
        *,
        sort_by: typing.Optional[str] = None,
        sort_order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        filters: typing.Optional[DealSearchFilter] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedResponseSearchDealResponse]:
        """
        Search deals within a group using flexible filters.

        Parameters
        ----------
        group_id : int

        sort_by : typing.Optional[str]

        sort_order : typing.Optional[str]

        page : typing.Optional[int]

        page_size : typing.Optional[int]

        filters : typing.Optional[DealSearchFilter]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedResponseSearchDealResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/search-advanced",
            method="POST",
            params={
                "sort_by": sort_by,
                "sort_order": sort_order,
                "page": page,
                "page_size": page_size,
            },
            json={
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=DealSearchFilter, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedResponseSearchDealResponse,
                    parse_obj_as(
                        type_=PaginatedResponseSearchDealResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DealWithFilesResponse]:
        """
        Retrieve a deal by its ID.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        group_id: int,
        deal_id: int,
        *,
        round_name: typing.Optional[str] = OMIT,
        notes: typing.Optional[str] = OMIT,
        priority: typing.Optional[Priority] = OMIT,
        round_amount: typing.Optional[int] = OMIT,
        round_target: typing.Optional[int] = OMIT,
        tags: typing.Optional[typing.Sequence[str]] = OMIT,
        company_summary: typing.Optional[str] = OMIT,
        deal_lead_id: typing.Optional[int] = OMIT,
        company_id: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealWithFilesResponse]:
        """
        Update a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        round_name : typing.Optional[str]

        notes : typing.Optional[str]
            Notes about the deal

        priority : typing.Optional[Priority]
            The priority of the deal

        round_amount : typing.Optional[int]
            The dollar amount to be raised of the round

        round_target : typing.Optional[int]
            The target post-money dollar amount of the round

        tags : typing.Optional[typing.Sequence[str]]
            The tags associated with the deal

        company_summary : typing.Optional[str]
            The summary of the company

        deal_lead_id : typing.Optional[int]
            The id of the user who is the deal lead

        company_id : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealWithFilesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="PUT",
            json={
                "round_name": round_name,
                "notes": notes,
                "priority": priority,
                "round_amount": round_amount,
                "round_target": round_target,
                "tags": tags,
                "company_summary": company_summary,
                "deal_lead_id": deal_lead_id,
                "company_id": company_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealWithFilesResponse,
                    parse_obj_as(
                        type_=DealWithFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        group_id: int,
        deal_id: int,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def extra_metadata(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DealExtraMetadataResponse]:
        """
        Retrieve extra metadata for a deal, such as questions and meeting times.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def set_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        request: Metadata,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DealExtraMetadataResponse]:
        """
        Create or update questions for a deal. If questions already exist for this deal, they will be updated.
        If no questions exist, they will be created.


        Limitations:
        - The metadata payload cannot exceed 2048 characters.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        request : Metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DealExtraMetadataResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="PUT",
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Metadata, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DealExtraMetadataResponse,
                    parse_obj_as(
                        type_=DealExtraMetadataResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_metadata(
        self,
        group_id: int,
        deal_id: int,
        metadata_tag: DealMetadataTag,
        *,
        archive: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Delete questions for a deal.

        Parameters
        ----------
        group_id : int

        deal_id : int

        metadata_tag : DealMetadataTag

        archive : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/extra-metadata/{jsonable_encoder(metadata_tag)}",
            method="DELETE",
            params={
                "archive": archive,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def order(
        self, group_id: int, deal_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Submit an order for a deal scan to be performed.

        Parameters
        ----------
        group_id : int

        deal_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/order-scan",
            method="POST",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_comparable_deals(
        self,
        group_id: int,
        deal_id: int,
        *,
        category: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[DealWithFilesResponse]]:
        """
        Get deals comparable to the current deal.

        Categories are required for meaningful comparison. Only deals with overlapping categories
        will be returned. If the current deal has no categories, no comparable deals will be returned.

        Returns the top 5 most recent deals with overlapping categories, sorted by updated timestamp.

        Parameters
        ----------
        group_id : int

        deal_id : int

        category : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[DealWithFilesResponse]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/group/{jsonable_encoder(group_id)}/deal/{jsonable_encoder(deal_id)}/comparable-deals",
            method="GET",
            params={
                "category": category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DealWithFilesResponse],
                    parse_obj_as(
                        type_=typing.List[DealWithFilesResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
