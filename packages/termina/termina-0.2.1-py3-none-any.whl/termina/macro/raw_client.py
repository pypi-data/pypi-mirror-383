# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from ..types.weather_components import WeatherComponents
from ..types.weather_gauge import WeatherGauge
from ..types.weather_market_context import WeatherMarketContext
from ..types.weather_metadata import WeatherMetadata


class RawMacroClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_segmentations(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[str]]:
        """
        Returns the available segmentations for the weather module.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[str]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/data/weather/segmentations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_metadata(
        self, segmentation: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[WeatherMetadata]]:
        """
        Returns segmentation metadata for each of the classes of segmentations "geo" and "sector".

        The geography ("geo") segmentation type refers to major geographic segmentations.

        The "sector" segmentation type refers to major business model categories in the USA geography.

        The metadata includes parameters used to generate the respective indicators, and the metadata needed to
        retrieve the series from the API.

        Parameters
        ----------
        segmentation : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[WeatherMetadata]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherMetadata],
                    parse_obj_as(
                        type_=typing.List[WeatherMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_gauge(
        self,
        segmentation: str,
        *,
        slug: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[WeatherGauge]]:
        """
        Returns the overall weather indicator, combined across all stages, for the given segmentation slug(s).

        If no slug is provided, the endpoint will return the gauge for all available segmentations.

        Parameters
        ----------
        segmentation : str

        slug : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[WeatherGauge]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/gauges",
            method="GET",
            params={
                "slug": slug,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherGauge],
                    parse_obj_as(
                        type_=typing.List[WeatherGauge],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_components(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[WeatherComponents]]:
        """
        Returns the individual components of the weather indicator and some of the underlying inputs of those component gauges for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[WeatherComponents]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/components",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherComponents],
                    parse_obj_as(
                        type_=typing.List[WeatherComponents],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_market_context(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[WeatherMarketContext]]:
        """
        Returns simplified contextual metrics about relevant stages and market activity for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[WeatherMarketContext]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/market-context",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherMarketContext],
                    parse_obj_as(
                        type_=typing.List[WeatherMarketContext],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawMacroClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_segmentations(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[str]]:
        """
        Returns the available segmentations for the weather module.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[str]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/data/weather/segmentations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_metadata(
        self, segmentation: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[WeatherMetadata]]:
        """
        Returns segmentation metadata for each of the classes of segmentations "geo" and "sector".

        The geography ("geo") segmentation type refers to major geographic segmentations.

        The "sector" segmentation type refers to major business model categories in the USA geography.

        The metadata includes parameters used to generate the respective indicators, and the metadata needed to
        retrieve the series from the API.

        Parameters
        ----------
        segmentation : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[WeatherMetadata]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherMetadata],
                    parse_obj_as(
                        type_=typing.List[WeatherMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_gauge(
        self,
        segmentation: str,
        *,
        slug: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[WeatherGauge]]:
        """
        Returns the overall weather indicator, combined across all stages, for the given segmentation slug(s).

        If no slug is provided, the endpoint will return the gauge for all available segmentations.

        Parameters
        ----------
        segmentation : str

        slug : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[WeatherGauge]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/gauges",
            method="GET",
            params={
                "slug": slug,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherGauge],
                    parse_obj_as(
                        type_=typing.List[WeatherGauge],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_components(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[WeatherComponents]]:
        """
        Returns the individual components of the weather indicator and some of the underlying inputs of those component gauges for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[WeatherComponents]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/components",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherComponents],
                    parse_obj_as(
                        type_=typing.List[WeatherComponents],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_market_context(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[WeatherMarketContext]]:
        """
        Returns simplified contextual metrics about relevant stages and market activity for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[WeatherMarketContext]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/market-context",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WeatherMarketContext],
                    parse_obj_as(
                        type_=typing.List[WeatherMarketContext],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
