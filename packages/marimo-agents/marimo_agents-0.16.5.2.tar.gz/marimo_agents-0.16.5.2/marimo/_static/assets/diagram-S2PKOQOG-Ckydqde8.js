var g;import"./_Uint8Array-CPNtPV0k.js";import"./_baseIsEqual-Colb33IN.js";import"./_arrayReduce-BnF2698I.js";import"./toNumber-D8Yr4jg3.js";import"./toInteger-HqbAY1oN.js";import"./isArrayLikeObject-VZQcF0wU.js";import"./_getTag-DAtegGfi.js";import"./_baseUniq-C9yRQ2gm.js";import"./chunk-4KMFLZZN-CY26YA_6.js";import"./_toKey-ySt2z-83.js";import"./memoize-Dkaig2Zu.js";import"./get-DpPiA0nD.js";import"./_baseFlatten-fXFruJ9c.js";import"./_basePickBy-ZofuMBT_.js";import"./merge-BK4jEs5n.js";import"./_baseSlice-Uxm09S3C.js";import"./clone-LWFvUGYK.js";import"./_baseEach-D9MoMllW.js";import"./hasIn-B8CzC4pq.js";import"./_baseProperty-DbWSe5Dg.js";import"./_createAggregator-DXVrFTZa.js";import"./min-DOP7dRSW.js";import"./_baseMap-DpEJo8vx.js";import"./isEmpty-CgS1RHPI.js";import"./_baseSet-DydOhF3e.js";import"./preload-helper-VwE_myu3.js";import"./main-Bhvb2Udf.js";import"./timer-BQp7kwGJ.js";import"./src-BxsaLGej.js";import"./math-CJPGrKXj.js";import"./step-CU2Y1mmF.js";import{i as u}from"./chunk-S3R3BYOJ-DkagUBh0.js";import{n as f,r as y}from"./src-BYP9eq-z.js";import{B as C,C as v,U as P,_ as z,a as S,c as E,d as F,v as T,y as W,z as D}from"./chunk-ABZYJK2D-CHn8e59f.js";import{t as A}from"./chunk-EXTU4WIE-BZKh82b1.js";import"./dist-DB8I7jQZ.js";import"./chunk-JEIROHC2-BY2EU-rF.js";import"./chunk-BN7GFLIU-DO5HMFB8.js";import"./chunk-T44TD3VJ-C0KWOLbc.js";import"./chunk-KMC2YHZD-Cj5sqkCw.js";import"./chunk-WFWHJNB7-ssq6vNBh.js";import"./chunk-WFRQ32O7-Dhkf3nPa.js";import"./chunk-XRWGC2XP-DOkbSHfa.js";import{t as R}from"./chunk-4BX2VUAB-CLo-a5yO.js";import{t as Y}from"./mermaid-parser.core-BmfVzo1e.js";var _=F.packet,w=(g=class{constructor(){this.packet=[],this.setAccTitle=C,this.getAccTitle=T,this.setDiagramTitle=P,this.getDiagramTitle=v,this.getAccDescription=z,this.setAccDescription=D}getConfig(){let t=u({..._,...W().packet});return t.showBits&&(t.paddingY+=10),t}getPacket(){return this.packet}pushWord(t){t.length>0&&this.packet.push(t)}clear(){S(),this.packet=[]}},f(g,"PacketDB"),g),H=1e4,L=f((e,t)=>{R(e,t);let i=-1,a=[],l=1,{bitsPerRow:p}=t.getConfig();for(let{start:r,end:s,bits:d,label:n}of e.blocks){if(r!==void 0&&s!==void 0&&s<r)throw Error(`Packet block ${r} - ${s} is invalid. End must be greater than start.`);if(r??(r=i+1),r!==i+1)throw Error(`Packet block ${r} - ${s??r} is not contiguous. It should start from ${i+1}.`);if(d===0)throw Error(`Packet block ${r} is invalid. Cannot have a zero bit field.`);for(s??(s=r+(d??1)-1),d??(d=s-r+1),i=s,y.debug(`Packet block ${r} - ${i} with label ${n}`);a.length<=p+1&&t.getPacket().length<H;){let[c,o]=M({start:r,end:s,bits:d,label:n},l,p);if(a.push(c),c.end+1===l*p&&(t.pushWord(a),a=[],l++),!o)break;({start:r,end:s,bits:d,label:n}=o)}}t.pushWord(a)},"populate"),M=f((e,t,i)=>{if(e.start===void 0)throw Error("start should have been set during first phase");if(e.end===void 0)throw Error("end should have been set during first phase");if(e.start>e.end)throw Error(`Block start ${e.start} is greater than block end ${e.end}.`);if(e.end+1<=t*i)return[e,void 0];let a=t*i-1,l=t*i;return[{start:e.start,end:a,label:e.label,bits:a-e.start},{start:l,end:e.end,label:e.label,bits:e.end-l}]},"getNextFittingBlock"),x={parser:{yy:void 0},parse:f(async e=>{var a;let t=await Y("packet",e),i=(a=x.parser)==null?void 0:a.yy;if(!(i instanceof w))throw Error("parser.parser?.yy was not a PacketDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.");y.debug(t),L(t,i)},"parse")},j=f((e,t,i,a)=>{let l=a.db,p=l.getConfig(),{rowHeight:r,paddingY:s,bitWidth:d,bitsPerRow:n}=p,c=l.getPacket(),o=l.getDiagramTitle(),h=r+s,m=h*(c.length+1)-(o?0:r),b=d*n+2,k=A(t);k.attr("viewbox",`0 0 ${b} ${m}`),E(k,m,b,p.useMaxWidth);for(let[$,B]of c.entries())I(k,B,$,p);k.append("text").text(o).attr("x",b/2).attr("y",m-h/2).attr("dominant-baseline","middle").attr("text-anchor","middle").attr("class","packetTitle")},"draw"),I=f((e,t,i,{rowHeight:a,paddingX:l,paddingY:p,bitWidth:r,bitsPerRow:s,showBits:d})=>{let n=e.append("g"),c=i*(a+p)+p;for(let o of t){let h=o.start%s*r+1,m=(o.end-o.start+1)*r-l;if(n.append("rect").attr("x",h).attr("y",c).attr("width",m).attr("height",a).attr("class","packetBlock"),n.append("text").attr("x",h+m/2).attr("y",c+a/2).attr("class","packetLabel").attr("dominant-baseline","middle").attr("text-anchor","middle").text(o.label),!d)continue;let b=o.end===o.start,k=c-2;n.append("text").attr("x",h+(b?m/2:0)).attr("y",k).attr("class","packetByte start").attr("dominant-baseline","auto").attr("text-anchor",b?"middle":"start").text(o.start),b||n.append("text").attr("x",h+m).attr("y",k).attr("class","packetByte end").attr("dominant-baseline","auto").attr("text-anchor","end").text(o.end)}},"drawWord"),N={draw:j},U={byteFontSize:"10px",startByteColor:"black",endByteColor:"black",labelColor:"black",labelFontSize:"12px",titleColor:"black",titleFontSize:"14px",blockStrokeColor:"black",blockStrokeWidth:"1",blockFillColor:"#efefef"},X={parser:x,get db(){return new w},renderer:N,styles:f(({packet:e}={})=>{let t=u(U,e);return`
	.packetByte {
		font-size: ${t.byteFontSize};
	}
	.packetByte.start {
		fill: ${t.startByteColor};
	}
	.packetByte.end {
		fill: ${t.endByteColor};
	}
	.packetLabel {
		fill: ${t.labelColor};
		font-size: ${t.labelFontSize};
	}
	.packetTitle {
		fill: ${t.titleColor};
		font-size: ${t.titleFontSize};
	}
	.packetBlock {
		stroke: ${t.blockStrokeColor};
		stroke-width: ${t.blockStrokeWidth};
		fill: ${t.blockFillColor};
	}
	`},"styles")};export{X as diagram};
