# This file is auto-generated by Odoo Typing Classes Generator

from datetime import datetime
from typing import (
    Any,
    Callable,
    Generic,
    Iterator,
    List,
    Optional,
    Tuple,
    TypeVar,
    Union,
    Dict,
    Collection,
    Set,
)

from odoo.api import Environment
from odoo.fields import Field
from odoo.sql_db import Cursor
from odoo.tools import Query, SQL
from urllib3.connectionpool import HTTPConnectionPool

# odoo-typing-classes-generator: imports-insertion-point

T = TypeVar("T")
L = TypeVar("L")

Domain = List[Union[str, tuple]]


class AbstractModel(Generic[T]):
    create_date: datetime
    env: Environment
    id: int
    ids: List[int]
    write_date: datetime

    @classmethod
    def _build_model(cls, pool: HTTPConnectionPool, cr: Cursor):
        pass

    @classmethod
    def _build_model_attributes(cls, pool: HTTPConnectionPool):
        pass

    @classmethod
    def _build_model_check_base(cls):
        pass

    @classmethod
    def _build_model_check_parent(model_class, cls, parent_class):
        pass

    @classmethod
    def _init_constraints_onchanges(cls, foo: Any = None):
        pass

    @classmethod
    def clear_caches(cls):
        pass

    @classmethod
    def is_transient(cls):
        pass

    def __add__(self, other: T) -> T:
        pass

    def __and__(self, other: T) -> T:
        pass

    def __bool__(self) -> bool:
        pass

    def __contains__(self, item: T) -> bool:
        pass

    def __eq__(self, other: T) -> bool:
        pass

    def __ge__(self, other: T) -> bool:
        pass

    def __getitem__(self, key: Any) -> T:
        pass

    def __gt__(self, other: T) -> bool:
        pass

    def __hash__(self) -> int:
        pass

    def __int__(self) -> int:
        pass

    def __init__(
        self, env: Environment, ids: List[int], prefetch_ids: Optional[List[int]] = None
    ):
        pass

    def __iter__(self) -> Iterator[T]:
        pass

    def __le__(self, other: T) -> bool:
        pass

    def __len__(self) -> int:
        pass

    def __lt__(self, other: T) -> bool:
        pass

    def __new__(cls) -> None:
        pass

    def __nonzero__(self) -> bool:
        pass

    def __or__(self, other: T) -> bool:
        pass

    def __repr__(self) -> str:
        pass

    def __reversed__(self) -> tuple:
        pass

    def __setitem__(self, key: Any, value: Any):
        pass

    def __sub__(self, other: T) -> T:
        pass

    def _add_fake_fields(self, fields: dict) -> dict:
        pass

    def _add_field(self, name: str, field: Field):
        pass

    def _add_inherited_fields(self) -> None:
        pass

    def _add_missing_default_values(self, values: dict) -> dict:
        pass

    def _add_precomputed_values(self, vals_list: List[dict]) -> None:
        pass

    def _add_sql_constraints(self) -> None:
        pass

    def _apply_ir_rules(self, query, mode: str = "read") -> None:
        pass

    # TODO
    def _apply_onchange_methods(self, field_name, result):
        pass

    def _as_query(self, ordered: bool = True) -> Query:
        pass

    def _auto_init(self) -> None:
        pass

    def _check_company(self, fnames: Optional[List[str]] = None) -> None:
        pass

    def _check_company_domain(
        self,
        companies: Union["ResCompany", Collection[int]],  # noqa: F821
    ) -> Domain:
        pass

    def _check_m2m_recursion(self, field_name: str) -> bool:
        pass

    def _check_parent_path(self) -> None:
        pass

    def _check_qorder(self, word: str) -> bool:
        pass

    def _check_recursion(self, parent: Optional[str] = None) -> bool:
        pass

    def _check_removed_columns(self, log: bool = False):
        pass

    def _compute_display_name(self) -> None:
        pass

    def _compute_field_value(self, field: Field):
        pass

    def _convert_records(
        self, records: T, log: Callable[[T], None] = lambda a: None
    ) -> List[Tuple[Optional[int], Optional[str], dict]]:
        pass

    def _convert_to_record(self, values: dict) -> dict:
        pass

    def _convert_to_write(self, values: dict) -> dict:
        pass

    def _create(self, data_list: List[dict]) -> T:
        pass

    def _determine_fields_to_fetch(
        self, field_names: Optional[List[str]], ignore_when_in_cache: bool = False
    ) -> List[Field]:
        pass

    def _export_rows(
        self, fields: List[List[str]], *, _is_toplevel_call: bool = True
    ) -> List[list]:
        pass

    def _extract_records(
        self,
        fields_: List[List[str]],
        data: List[Any],
        log: Callable[[T], None] = lambda a: None,
        limit: Union[int, float] = float("inf"),
    ):
        pass

    def _fetch_field(self, field: Field) -> None:
        pass

    # TODO
    def _fetch_query(self, query, fields):
        pass

    def _field_properties_to_sql(
        self, alias: str, fname: str, property_name: str, query: Query
    ) -> SQL:
        pass

    def _field_to_sql(
        self, alias: str, fname: str, query: Optional[Query] = None
    ) -> SQL:
        pass

    def _filter_access_rules(self, operation: str) -> T:
        pass

    def _filter_access_rules_python(self, operation: str) -> T:
        pass

    def _flush(self, fnames: Optional[List[str]] = None):
        pass

    def _flush_search(
        self,
        domain: Domain,
        fields: Optional[List[str]] = None,
        order: Optional[str] = None,
        seen: Optional[Set[str]] = None,
    ) -> None:
        pass

    # TODO
    def _generate_order_by(self, order_spec, query):
        pass

    # TODO
    def _get_base_lang(self):
        pass

    # TODO
    def _get_external_ids(self):
        pass

    # TODO
    def _get_placeholder_filename(self, field=None):
        pass

    # TODO
    def _has_onchange(self, field, other_fields):
        pass

    # TODO
    def _in_cache_without(self, field, limit=1000):
        pass

    # TODO
    def _inherits_check(self):
        pass

    # TODO
    def _inherits_join_calc(self, alias, fname, query):
        pass

    # TODO
    def _init_column(self, column_name):
        pass

    # TODO
    def _invalidate_cache(self, fnames=None, ids=None):
        pass

    # TODO
    def _is_an_ordinary_table(self):
        pass

    # TODO
    def _load_records(self, data_list, update=False):
        pass

    # TODO
    def _load_records_create(self, values):
        pass

    # TODO
    def _load_records_write(self, values):
        pass

    # TODO
    def _mapped_func(self, func):
        pass

    # TODO
    def _modified(self, fields, create):
        pass

    # TODO
    def _modified_triggers(self, tree, create=False):
        pass

    # TODO
    def _name_search(self, name="", args=None, operator="ilike", limit=100):
        pass

    def _order_field_to_sql(
        self, alias: str, field_name: str, direction: SQL, nulls: SQL, query: Query
    ) -> SQL:
        pass

    def _order_to_sql(
        self,
        order: str,
        query: Query,
        alias: (str | None) = None,
        reverse: bool = False,
    ) -> SQL:
        pass

    # TODO
    def _parent_store_compute(self):
        pass

    # TODO
    def _parent_store_create(self):
        pass

    # TODO
    def _parent_store_update(self):
        pass

    # TODO
    def _parent_store_update_prepare(self, vals):
        pass

    # TODO
    def _pop_field(self, name):
        pass

    # TODO
    def _populate(self, size):
        pass

    # TODO
    def _populate_factories(self):
        pass

    # TODO
    def _prepare_create_values(self, vals_list):
        pass

    # TODO
    def _prepare_setup(self):
        pass

    # TODO
    def _read_format(self, fnames, load="_classic_read"):
        pass

    # TODO
    def _read_group(
        self,
        domain,
        groupby=(),
        aggregates=(),
        having=(),
        offset=0,
        limit=None,
        order=None,
    ):
        pass

    # TODO
    def _read_group_check_field_access_rights(self, field_names):
        pass

    # TODO
    def _read_group_empty_value(self, spec):
        pass

    # TODO
    def _read_group_expand_full(self, groups, domain, order):
        pass

    # TODO
    def _read_group_fill_results(
        self,
        domain,
        groupby,
        annoted_aggregates,
        read_group_result,
        read_group_order=None,
    ):
        pass

    # TODO
    def _read_group_fill_temporal(
        self,
        data,
        groupby,
        annoted_aggregates,
        fill_from=False,
        fill_to=False,
        min_groups=False,
    ):
        pass

    # TODO
    def _read_group_format_result(self, rows_dict, lazy_groupby):
        pass

    # TODO
    def _read_group_format_result_properties(self, rows_dict, group):
        pass

    # TODO
    def _read_group_get_annoted_groupby(self, groupby, lazy):
        pass

    def _read_group_groupby(
        self, groupby_spec: str, query: Query
    ) -> tuple[SQL, list[str]]:
        pass

    def _read_group_having(
        self, having_domain: list, query: Query
    ) -> tuple[SQL, list[str]]:
        pass

    def _read_group_orderby(
        self, order: str, groupby_terms: dict[str, SQL], query: Query
    ) -> tuple[SQL, SQL, list[str]]:
        pass

    # TODO
    def _read_group_postprocess_aggregate(self, aggregate_spec, raw_values):
        pass

    # TODO
    def _read_group_postprocess_groupby(self, groupby_spec, raw_values):
        pass

    def _read_group_select(
        self, aggregate_spec: str, query: Query
    ) -> tuple[SQL, list[str]]:
        pass

    # TODO
    def _rec_name_fallback(self):
        pass

    # TODO
    def _recompute_field(self, field, ids=None):
        pass

    # TODO
    def _recompute_model(self, fnames=None):
        pass

    # TODO
    def _recompute_recordset(self, fnames=None):
        pass

    # TODO
    def _register_hook(self):
        pass

    # TODO
    def _search(
        self,
        domain,
        offset=0,
        limit=None,
        order=None,
        access_rights_uid=None,
    ):
        pass

    # TODO
    def _setup_base(self):
        pass

    # TODO
    def _setup_complete(self):
        pass

    # TODO
    def _setup_fields(self):
        pass

    # TODO
    def _table_has_rows(self):
        pass

    # TODO
    def _unregister_hook(self):
        pass

    # TODO
    def _update_cache(self, values, validate=True):
        pass

    # TODO
    def _valid_field_parameter(self, field, name):
        pass

    # TODO
    def _validate_fields(self, field_names, excluded_names=()):
        pass

    # TODO
    def _where_calc(self, domain, active_test=True):
        pass

    # TODO
    def _write(self, vals):
        pass

    def action_archive(self) -> T:
        pass

    def action_unarchive(self) -> T:
        pass

    def browse(self, ids: Union[int, List[int]]) -> T:
        pass

    def check_access_rights(self, operation: str, raise_exception: bool = True) -> bool:
        pass

    def check_access_rule(self, operation: str) -> None:
        pass

    def check_field_access_rights(
        self, operation: str, fields: Optional[List[str]]
    ) -> list:
        pass

    def concat(self, *args: List[T]) -> T:
        pass

    def copy(self, default: Optional[dict] = None) -> T:
        pass

    def copy_data(self, default: Optional[dict] = None) -> T:
        pass

    def copy_multi(self, default: Optional[dict] = None) -> T:
        pass

    def copy_translations(self, new: T, excluded: Collection[str] = ()) -> None:
        pass

    def create(self, vals_list: Union[List[dict], dict]) -> T:
        pass

    def default_get(self, fields_list: List[str]) -> Dict[str, Any]:
        pass

    def ensure_one(self) -> T:
        pass

    def exists(self) -> T:
        pass

    def export_data(self, fields_to_export: List[str]) -> dict:
        pass

    def fetch(self, field_names: List[str]) -> None:
        pass

    def fields_get(
        self,
        allfields: Optional[List[str]] = None,
        attributes: Optional[List[str]] = None,
    ) -> dict:
        pass

    def filtered(self, func: Union[Callable[[T], bool], str]) -> T:
        pass

    def filtered_domain(self, domain: Optional[Domain]) -> T:
        pass

    def flush_model(self, fnames: List[str] = None) -> None:
        pass

    def flush_recordset(self, fnames: List[str] = None) -> None:
        pass

    def get_base_url(self) -> str:
        pass

    def get_external_id(self) -> Dict[str, str]:
        pass

    def get_field_translations(
        self, field_name: str, langs=None
    ) -> Tuple[Dict[str, str], Dict[str, Any]]:
        pass

    # TODO
    def get_metadata(self):
        pass

    # TODO
    def get_property_definition(self, full_name: str):
        pass

    def grouped(self, key: Union[Callable[[T], L], str]) -> Dict[L, T]:
        pass

    def init(self):
        pass

    def invalidate_model(
        self, fnames: Optional[List[str]] = None, flush: bool = True
    ) -> None:
        pass

    def invalidate_recordset(
        self, fnames: Optional[List[str]] = None, flush: bool = True
    ) -> None:
        pass

    def load(self, fields: List[str], data: List[List[str]]) -> dict:
        pass

    def mapped(
        self, func: Union[Callable[[T], L], str]
    ) -> Union[List[L], "AbstractModel[L]"]:
        pass

    # TODO
    def modified(self, fnames: List[str], create: bool = False, before: bool = False):
        pass

    def name_create(self, name: str) -> T:
        pass

    def name_get(self) -> List[Tuple[int, str]]:
        pass

    def name_search(
        self,
        name: str = "",
        args: Optional[Domain] = None,
        operator: str = "ilike",
        limit: int = 100,
    ) -> List[Tuple[int, str]]:
        pass

    def new(
        self,
        values: Optional[dict] = None,
        origin: Optional["Model"] = None,
        ref: Optional[str] = None,
    ):
        pass

    def onchange(
        self, values: dict, field_name: Union[str, List[str]], fields_spec: dict
    ) -> Optional[dict]:
        pass

    def read(
        self, fields: Optional[List[str]] = None, load: str = "_classic_read"
    ) -> List[dict]:
        pass

    def read_group(
        self,
        domain: Domain,
        fields: List[str],
        groupby: List[str],
        offset: int = 0,
        limit: Optional[int] = None,
        orderby: Optional[str] = False,
        lazy: bool = True,
    ) -> List[dict]:
        pass

    def search(
        self,
        domain: Domain,
        offset: int = 0,
        limit: Optional[int] = None,
        order: Optional[str] = None,
    ) -> T:
        pass

    def search_fetch(
        self,
        domain: Domain,
        field_names: List[str],
        offset: int = 0,
        limit: Optional[int] = None,
        order: Optional[str] = None,
    ) -> T:
        pass

    def search_count(self, domain: Domain, limit: Optional[int] = None) -> int:
        pass

    def search_read(
        self,
        domain: Optional[Domain] = None,
        fields: Union[List[str], tuple, None] = None,
        offset: int = 0,
        limit: Optional[int] = None,
        order: Optional[str] = None,
        **read_kwards,
    ) -> List[dict]:
        pass

    def sorted(self, key: Optional[Union[Callable[[T], Any], str]], reverse: bool) -> T:
        pass

    def sudo(self, flag: bool = True) -> T:
        pass

    def toggle_active(self) -> None:
        pass

    def union(self, *args: "Model") -> None:
        pass

    def unlink(self) -> bool:
        pass

    def update(self, values: dict) -> None:
        pass

    # TODO
    def update_field_translations(self, field_name, translations):
        pass

    # TODO
    def _update_field_translations(self, field_name, translations, digest=None):
        pass

    def user_has_groups(self, groups: str) -> bool:
        pass

    def write(self, vals: dict) -> bool:
        pass

    def with_company(self, company: "ResCompany") -> T:  # noqa: F821
        pass

    def with_context(self, *args, **kwargs) -> T:
        pass

    def with_env(self, env: Environment) -> T:
        pass

    def with_prefetch(self, prefetch_ids: Optional[List[int]] = None) -> T:
        pass

    def with_user(self, user: "ResUsers") -> T:  # noqa: F821
        pass


class Model(AbstractModel[T]):
    create_uid: Union["ResUsers", bool]  # noqa: F821
    display_name: str
    write_uid: Union["ResUsers", bool]  # noqa: F821


class TransientModel(Model[T]):
    def _transient_clean_old_rows(self, max_count: int):
        pass

    def _transient_clean_rows_older_than(self, seconds: int) -> None:
        pass

    def _transient_vacuum(self) -> None:
        pass


# odoo-typing-classes-generator: classes-insertion-point
