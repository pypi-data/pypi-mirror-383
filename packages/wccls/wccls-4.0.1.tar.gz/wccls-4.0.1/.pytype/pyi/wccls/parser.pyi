# (generated with --quick)

import bs4
import dataclasses
import datetime as _datetime
import enum
import functools
import logging
import wccls.wccls
from typing import Any, Callable, Dict, List, Match, Optional, Pattern, Tuple, Type, TypeVar, Union, overload

BeautifulSoup: Type[bs4.BeautifulSoup]
Checkout: Type[wccls.wccls.Checkout]
FormatType: Type[enum.Enum]
HoldInTransit: Type[wccls.wccls.HoldInTransit]
HoldNotReady: Type[wccls.wccls.HoldNotReady]
HoldPaused: Type[wccls.wccls.HoldPaused]
HoldReady: Type[wccls.wccls.HoldReady]
ParseError: Type[wccls.wccls.ParseError]
date: Type[_datetime.date]
datetime: Type[_datetime.datetime]
log: logging.Logger
partial: Type[functools.partial]

AnyStr = TypeVar('AnyStr', str, bytes)
_T = TypeVar('_T')

class Parser:
    _domain: str
    _handlers: dict
    _login: Any
    _password: Any
    items: list
    def Receive(self, url, response) -> Any: ...
    def _GetRequest(self, url, allowRedirects, function) -> Request: ...
    def _PostRequest(self, url, formData, allowRedirects, function) -> Request: ...
    def _ProcessItems(self, ParseFunction, response) -> List[nothing]: ...
    def _ProcessLogin(self, response) -> List[Request]: ...
    def _ProcessLoginAction(self, _) -> List[Request]: ...
    def __init__(self, subdomain, login, password) -> None: ...

@dataclasses.dataclass
class Request:
    verb: str
    url: str
    data: Optional[dict]
    allowRedirects: bool
    __dataclass_fields__: Dict[str, dataclasses.Field[Optional[Union[bool, dict, str]]]]
    def __init__(self, verb: str, url: str, data: Optional[dict], allowRedirects: bool) -> None: ...

def _IsDigital(format_) -> bool: ...
def _MakeSoup(response) -> bs4.BeautifulSoup: ...
def _ParseCheckedOut(listItem) -> wccls.wccls.Checkout: ...
def _ParseDate(listItem) -> _datetime.date: ...
def _ParseFormatInfo(element) -> Any: ...
def _ParseHoldPosition(listItem) -> Tuple[int, int]: ...
def _ParseInTransit(listItem) -> wccls.wccls.HoldInTransit: ...
def _ParseNotYetAvailable(listItem) -> wccls.wccls.HoldNotReady: ...
def _ParseReadyForPickup(listItem) -> wccls.wccls.HoldReady: ...
def _ParseRenewalCount(listItem) -> int: ...
def _ParseSuspended(listItem) -> wccls.wccls.HoldPaused: ...
def _ParseTitle(listItem) -> Any: ...
@overload
def dataclass(__cls: None) -> Callable[[Type[_T]], Type[_T]]: ...
@overload
def dataclass(__cls: Type[_T]) -> Type[_T]: ...
@overload
def dataclass(*, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ...) -> Callable[[Type[_T]], Type[_T]]: ...
def getLogger(name: Optional[str] = ...) -> logging.Logger: ...
def search(pattern: Union[Pattern[AnyStr], AnyStr], string: AnyStr, flags: int = ...) -> Optional[Match[AnyStr]]: ...
