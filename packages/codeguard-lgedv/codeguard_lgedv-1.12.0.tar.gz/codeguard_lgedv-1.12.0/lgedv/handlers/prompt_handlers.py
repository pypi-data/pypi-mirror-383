"""
Prompt handlers for MCP server operations
X·ª≠ l√Ω c√°c MCP prompts cho ph√¢n t√≠ch code
"""
import os
from typing import Dict
from mcp import types
from lgedv.prompts.prompt_templates import PromptTemplates
from lgedv.analyzers.memory_analyzer import MemoryAnalyzer
from lgedv.modules.config import get_src_dir, setup_logging

logger = setup_logging()

class PromptHandler:
    """Handler cho c√°c MCP prompts"""
    
    def __init__(self):
        self.templates = PromptTemplates()
    
   

    async def handle_prompt(self, name: str, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """
        Route v√† x·ª≠ l√Ω prompt calls
        
        Args:
            name: T√™n prompt
            arguments: Arguments cho prompt
            
        Returns:
            GetPromptResult
        """
        logger.info(f"Prompt called: {name} with arguments: {arguments}")
        
        try:
            if name == "check_lgedv":
                return await self._handle_lgedv_check()
            elif name == "check_static_analysis":
                return await self._handle_lge_static_check()
            elif name == "check_misra_cpp":
                return await self._handle_misra_cpp_check()
            elif name == "check_autosar":  
                return await self._handle_autosar_check()
            elif name == "check_misra_c":  
                return await self._handle_misra_c_check()
            elif name == "check_certcpp":
                return await self._handle_certcpp_check()
            elif name == "check_custom":
                return await self._handle_custom_check()
            elif name == "check_cim_static":
                return await self._handle_cim_static_check()
            elif name == "check_cim_misra_cpp":
                return await self._handle_cim_misra_cpp_check()
            elif name == "check_races":
                return await self._handle_race_condition_analysis(arguments)
            elif name == "check_leaks":
                return await self._handle_memory_leak_analysis(arguments)
            elif name == "check_resources":
                return await self._handle_resource_leak_analysis(arguments)
            elif name == "get_code_context":
                return await self._handle_code_context()  
            elif name == "reset_analysis":
                return await self._handle_reset_analysis_prompt(arguments)
            if name == "reset_mem_check":
                return await self._handle_reset_mem_check_prompt(arguments)
            if name == "reset_resource_check":
                return await self._handle_reset_resource_check_prompt(arguments)
            if name == "reset_race_check":
                return await self._handle_reset_race_check_prompt(arguments)
            elif name == "check_design":
                return await self._handle_design_check(arguments)
            else:
                raise ValueError(f"Unknown prompt: {name}")
                
        except Exception as e:
            logger.exception(f"Error in prompt handler for {name}: {e}")
            raise
    
    async def _handle_lgedv_check(self) -> types.GetPromptResult:
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++. H√£y ph√¢n t√≠ch file hi·ªán t·∫°i ƒë·ªÉ ph√°t hi·ªán vi ph·∫°m c√°c quy t·∫Øc LGEDV cho ph·∫ßn m·ªÅm √¥ t√¥.\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_lgedv_rule t·ª´ MCP server.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc LGEDV m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ph√¢n t√≠ch, kh√¥ng d√πng rule c≈© ho·∫∑c built-in.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- T√¨m T·∫§T C·∫¢ vi ph·∫°m quy t·∫Øc tr√™n\n"
                "- T·∫≠p trung v√†o vi ph·∫°m LGEDV\n"
                "- Ghi r√µ s·ªë hi·ªáu rule (VD: LGEDV_CRCL_0001, MISRA Rule 8-4-3, DCL50-CPP, RS-001)\n"
                "- Ki·ªÉm tra m·ªçi d√≤ng code, k·ªÉ c·∫£ unreachable, dead code, return s·ªõm, magic number\n"
                "- Ki·ªÉm tra m·ªçi ƒëi·ªÉm acquire/release resource, m·ªçi exit point, m·ªçi function/method\n"
                "- ƒê∆∞a ra code fix c·ª• th·ªÉ cho t·ª´ng l·ªói\n"
                "- Ghi s·ªë d√≤ng code g·ªëc trong b√°o c√°o\n\n"                
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói l·ªói:\n"
                "## üö® V·∫•n ƒë·ªÅ [#]: [M√¥ t·∫£ ng·∫Øn]\n\n"
                "**Rule vi ph·∫°m:** [S·ªê HI·ªÜU] - [M√¥ t·∫£ rule]\n\n"
                "**V·ªã tr√≠:** [t√™n file, t√™n h√†m ho·∫∑c global/unknown]\n\n"
                "**M·ª©c ƒë·ªô:** [Critical/High/Medium/Low]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[code l·ªói]\n```\n"
                "**Code ƒë√£ s·ª≠a:**\n"
                "```cpp\n[code ƒë√∫ng]\n```\n"
                "**Gi·∫£i th√≠ch:** [V√¨ sao vi ph·∫°m v√† c√°ch s·ª≠a]\n\n"             
                "**L∆∞u √Ω:** N·∫øu c·∫ßn to√†n b·ªô file code ƒë√£ fix, h√£y y√™u c·∫ßu r√µ r√†ng."
            )
        else:
            prompt = self.templates.get_lgedv_analysis_prompt()
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for LGEDV rule on current file.",
        )
        logger.info("LGEDV check prompt completed")
        return result
    
    async def _handle_lge_static_check(self) -> types.GetPromptResult:
        """Handle LGE Static Analysis code checking prompt"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++. H√£y ph√¢n t√≠ch file hi·ªán t·∫°i ƒë·ªÉ ph√°t hi·ªán vi ph·∫°m c√°c quy t·∫Øc LGE Static Analysis.\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_static_analysis_rule t·ª´ MCP server.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc LGE Static Analysis m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ph√¢n t√≠ch, kh√¥ng d√πng rule c≈© ho·∫∑c built-in.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- T√¨m T·∫§T C·∫¢ vi ph·∫°m quy t·∫Øc tr√™n\n"
                "- T·∫≠p trung v√†o vi ph·∫°m LGE Static Analysis\n"
                "- Ghi r√µ s·ªë hi·ªáu rule (VD: ARRAY_VS_SINGLETON, ATOMICITY, BAD_ALLOC_ARITHMETIC, v.v.)\n"
                "- Ki·ªÉm tra m·ªçi d√≤ng code, k·ªÉ c·∫£ unreachable, dead code, return s·ªõm, magic number\n"
                "- Ki·ªÉm tra m·ªçi ƒëi·ªÉm acquire/release resource, m·ªçi exit point, m·ªçi function/method\n"
                "- ƒê∆∞a ra code fix c·ª• th·ªÉ cho t·ª´ng l·ªói\n"
                "- Ghi s·ªë d√≤ng code g·ªëc trong b√°o c√°o\n\n"
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói l·ªói:\n"
                "## üö® V·∫•n ƒë·ªÅ [#]: [M√¥ t·∫£ ng·∫Øn]\n\n"
                "**Rule vi ph·∫°m:** [S·ªê HI·ªÜU] - [M√¥ t·∫£ rule]\n\n"
                "**V·ªã tr√≠:** [t√™n file, t√™n h√†m ho·∫∑c global/unknown]\n\n"
                "**M·ª©c ƒë·ªô:** [Critical/High/Medium/Low]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[code l·ªói]\n```\n"
                "**Code ƒë√£ s·ª≠a:**\n"
                "```cpp\n[code ƒë√∫ng]\n```\n"
                "**Gi·∫£i th√≠ch:** [V√¨ sao vi ph·∫°m v√† c√°ch s·ª≠a]\n\n"
                "**L∆∞u √Ω:** N·∫øu c·∫ßn to√†n b·ªô file code ƒë√£ fix, h√£y y√™u c·∫ßu r√µ r√†ng."
            )
        else:
            prompt = self.templates.get_lge_static_analysis_prompt()  # C·∫ßn th√™m template n√†y
        
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for LGE Static Analysis rule on current file.",
        )
        logger.info("LGE Static Analysis check prompt completed")
        return result

    async def _handle_misra_cpp_check(self) -> types.GetPromptResult:
        """Handle MISRA code checking prompt"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++. H√£y ph√¢n t√≠ch file hi·ªán t·∫°i ƒë·ªÉ ph√°t hi·ªán vi ph·∫°m c√°c quy t·∫Øc MISRA C++ 2008 cho ph·∫ßn m·ªÅm an to√†n.\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_misra_cpp_rule t·ª´ MCP server.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc MISRA m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ph√¢n t√≠ch, kh√¥ng d√πng rule c≈© ho·∫∑c built-in.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- T√¨m T·∫§T C·∫¢ vi ph·∫°m quy t·∫Øc tr√™n\n"
                "- T·∫≠p trung v√†o vi ph·∫°m MISRA\n"
                "- Ghi r√µ s·ªë hi·ªáu rule (VD: MISRA Rule 8-4-3, LGEDV_CRCL_0001, DCL50-CPP, RS-001)\n"
                "- Ki·ªÉm tra m·ªçi d√≤ng code, k·ªÉ c·∫£ unreachable, dead code, return s·ªõm, magic number\n"
                "- Ki·ªÉm tra m·ªçi ƒëi·ªÉm acquire/release resource, m·ªçi exit point, m·ªçi function/method\n"
                "- ƒê∆∞a ra code fix c·ª• th·ªÉ cho t·ª´ng l·ªói\n"
                "- Ghi s·ªë d√≤ng code g·ªëc trong b√°o c√°o\n\n"
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói l·ªói:\n"
                "## üö® V·∫•n ƒë·ªÅ [#]: [M√¥ t·∫£ ng·∫Øn]\n\n"
                "**Rule vi ph·∫°m:** [S·ªê HI·ªÜU] - [M√¥ t·∫£ rule]\n\n"
                "**V·ªã tr√≠:** [t√™n file, t√™n h√†m ho·∫∑c global/unknown]\n\n"
                "**M·ª©c ƒë·ªô:** [Critical/High/Medium/Low]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[code l·ªói]\n```\n"
                "**Code ƒë√£ s·ª≠a:**\n"
                "```cpp\n[code ƒë√∫ng]\n```\n"
                "**Gi·∫£i th√≠ch:** [V√¨ sao vi ph·∫°m v√† c√°ch s·ª≠a]\n\n"
                "**L∆∞u √Ω:** N·∫øu c·∫ßn to√†n b·ªô file code ƒë√£ fix, h√£y y√™u c·∫ßu r√µ r√†ng."
            )
        else:
            prompt = self.templates.get_misra_analysis_prompt()
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for MISRA rule on current file.",
        )
        logger.info("MISRA check prompt completed")
        return result
    
    async def _handle_certcpp_check(self) -> types.GetPromptResult:
        """Handle CERT C++ code checking prompt"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++. H√£y ph√¢n t√≠ch file hi·ªán t·∫°i ƒë·ªÉ ph√°t hi·ªán vi ph·∫°m c√°c quy t·∫Øc CERT C++ Secure Coding Standard.\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_certcpp_rule t·ª´ MCP server.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc CERT C++ m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ph√¢n t√≠ch, kh√¥ng d√πng rule c≈© ho·∫∑c built-in.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- T√¨m T·∫§T C·∫¢ vi ph·∫°m quy t·∫Øc tr√™n\n"
                "- T·∫≠p trung v√†o vi ph·∫°m CERT\n"
                "- Ghi r√µ s·ªë hi·ªáu rule (VD: DCL50-CPP, MISRA Rule 8-4-3, LGEDV_CRCL_0001, RS-001)\n"
                "- Ki·ªÉm tra m·ªçi d√≤ng code, k·ªÉ c·∫£ unreachable, dead code, return s·ªõm, magic number\n"
                "- Ki·ªÉm tra m·ªçi ƒëi·ªÉm acquire/release resource, m·ªçi exit point, m·ªçi function/method\n"
                "- ƒê∆∞a ra code fix c·ª• th·ªÉ cho t·ª´ng l·ªói\n"
                "- Ghi s·ªë d√≤ng code g·ªëc trong b√°o c√°o\n\n"
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói l·ªói:\n"
                "## üö® V·∫•n ƒë·ªÅ [#]: [M√¥ t·∫£ ng·∫Øn]\n\n"
                "**Rule vi ph·∫°m:** [S·ªê HI·ªÜU] - [M√¥ t·∫£ rule]\n\n"
                "**V·ªã tr√≠:** [t√™n file, t√™n h√†m ho·∫∑c global/unknown]\n\n"
                "**M·ª©c ƒë·ªô:** [Critical/High/Medium/Low]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[code l·ªói]\n```\n"
                "**Code ƒë√£ s·ª≠a:**\n"
                "```cpp\n[code ƒë√∫ng]\n```\n"
                "**Gi·∫£i th√≠ch:** [V√¨ sao vi ph·∫°m v√† c√°ch s·ª≠a]\n\n"               
                "**L∆∞u √Ω:** N·∫øu c·∫ßn to√†n b·ªô file code ƒë√£ fix, h√£y y√™u c·∫ßu r√µ r√†ng."
            )
        else:
            prompt = self.templates.get_certcpp_analysis_prompt()
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for CERT C++ rule on current file.",
        )
        logger.info("CERT C++ check prompt completed")
        return result
    
    async def _handle_custom_check(self) -> types.GetPromptResult:
        """Handle Custom rule checking prompt"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++. H√£y ph√¢n t√≠ch file hi·ªán t·∫°i ƒë·ªÉ ph√°t hi·ªán vi ph·∫°m c√°c quy t·∫Øc custom d∆∞·ªõi ƒë√¢y.\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_custom_rule t·ª´ MCP server.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc custom m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ph√¢n t√≠ch, kh√¥ng d√πng rule c≈© ho·∫∑c built-in.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- T√¨m T·∫§T C·∫¢ vi ph·∫°m quy t·∫Øc tr√™n\n"
                "- T·∫≠p trung v√†o vi ph·∫°m custom rule\n"
                "- Ghi r√µ s·ªë hi·ªáu rule (VD: CUSTOM-001, MISRA Rule 8-4-3, LGEDV_CRCL_0001, RS-001)\n"
                "- Ki·ªÉm tra m·ªçi d√≤ng code, k·ªÉ c·∫£ unreachable, dead code, return s·ªõm, magic number\n"
                "- Ki·ªÉm tra m·ªçi ƒëi·ªÉm acquire/release resource, m·ªçi exit point, m·ªçi function/method\n"
                "- ƒê∆∞a ra code fix c·ª• th·ªÉ cho t·ª´ng l·ªói\n"
                "- Ghi s·ªë d√≤ng code g·ªëc trong b√°o c√°o\n\n"
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói l·ªói:\n"
                "## üö® V·∫•n ƒë·ªÅ [#]: [M√¥ t·∫£ ng·∫Øn]\n\n"
                "**Rule vi ph·∫°m:** [S·ªê HI·ªÜU] - [M√¥ t·∫£ rule]\n\n"
                "**V·ªã tr√≠:** [t√™n file, t√™n h√†m ho·∫∑c global/unknown]\n\n"
                "**M·ª©c ƒë·ªô:** [Critical/High/Medium/Low]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[code l·ªói]\n```\n"
                "**Code ƒë√£ s·ª≠a:**\n"
                "```cpp\n[code ƒë√∫ng]\n```\n"
                "**Gi·∫£i th√≠ch:** [V√¨ sao vi ph·∫°m v√† c√°ch s·ª≠a]\n\n"         
                "**L∆∞u √Ω:** N·∫øu c·∫ßn to√†n b·ªô file code ƒë√£ fix, h√£y y√™u c·∫ßu r√µ r√†ng."
            )
        else:
            prompt = self.templates.get_custom_analysis_prompt()
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for Custom rule on current file.",
        )
        logger.info("Custom check prompt completed")
        return result
    
   
    async def _handle_cim_static_check(self) -> types.GetPromptResult:
        """Handle CIM Static Analysis (Coverity) result verification prompt"""
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++/C v·ªõi kinh nghi·ªám s√¢u v·ªÅ Coverity Static Analysis. "
                "H√£y ph√¢n t√≠ch file code hi·ªán t·∫°i c√πng v·ªõi c√°c b√°o c√°o vi ph·∫°m t·ª´ h·ªá th·ªëng CIM (Coverity).\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_static_analysis_rule t·ª´ MCP server ƒë·ªÉ t·∫£i b·ªô quy t·∫Øc LGE Static Analysis.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ƒë·ªëi chi·∫øu v·ªõi k·∫øt qu·∫£ CIM.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                
                "**NHI·ªÜM V·ª§ CH√çNH:**\n"
                "1. **KI·ªÇM TRA T√çNH CH√çNH X√ÅC**: X√°c minh xem c√°c CID (Coverity Issue ID) ƒë∆∞·ª£c b√°o c√°o c√≥ th·ª±c s·ª± l√† l·ªói hay kh√¥ng\n"
                "2. **ƒê·ªÄ XU·∫§T GI·∫¢I PH√ÅP**: ƒê∆∞a ra code fix c·ª• th·ªÉ cho m·ªói l·ªói th·ª±c s·ª±\n"
                "3. **ƒê·ªêI CHI·∫æU RULE**: So s√°nh v·ªõi b·ªô quy t·∫Øc LGE Static Analysis ƒë·ªÉ x√°c th·ª±c\n\n"
                
                "**PH√ÇN T√çCH CID FORMAT:**\n"
                "- CID [s·ªë]: [lo·∫°i l·ªói] - [m√¥ t·∫£ chi ti·∫øt]\n"
                "- V√≠ d·ª•: CID 6863827: Variable copied when it could be moved (COPY_INSTEAD_OF_MOVE)\n"
                "- V√≠ d·ª•: CID 7257883: Unchecked return value (CHECKED_RETURN)\n"
                "- C√°c lo·∫°i ph·ªï bi·∫øn: CHECKED_RETURN, COPY_INSTEAD_OF_MOVE, NULL_RETURNS, RESOURCE_LEAK, TAINTED_DATA\n\n"
                
                "**L∆ØU √ù QUAN TR·ªåNG V·ªÄ CID SELECTION:**\n"
                "- **CH·ªà PH√ÇN T√çCH CID C√ì M√î T·∫¢ CHI TI·∫æT**: Ch·ªâ focus v√†o nh·ªØng CID c√≥ m√¥ t·∫£ defect c·ª• th·ªÉ\n"
                "- **B·ªé QUA CID 'SELECT ISSUE'**: Kh√¥ng ph√¢n t√≠ch nh·ªØng CID ch·ªâ c√≥ [ \"select issue\" ] m√† kh√¥ng c√≥ m√¥ t·∫£ chi ti·∫øt\n"
                "- **V√≠ d·ª• CID c·∫ßn ph√¢n t√≠ch**: CID 6863827: Variable copied when it could be moved (COPY_INSTEAD_OF_MOVE) - detailed description here...\n"
                "- **V√≠ d·ª• CID b·ªè qua**: CID 6795225: [ \"select issue\" ]\n\n"
                
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- ƒê·ªçc k·ªπ t·ª´ng CID C√ì M√î T·∫¢ CHI TI·∫æT v√† v·ªã tr√≠ line number ƒë∆∞·ª£c b√°o\n"
                "- Ki·ªÉm tra context xung quanh ƒë·ªÉ hi·ªÉu flow execution\n"
                "- X√°c ƒë·ªãnh: TRUE POSITIVE (l·ªói th·ª±c) vs FALSE POSITIVE (b√°o nh·∫ßm)\n"
                "- ƒê√°nh gi√° m·ª©c ƒë·ªô nghi√™m tr·ªçng: Critical/High/Medium/Low/Info\n"
                "- Ki·ªÉm tra c√°c pattern: memory leaks, null pointer, buffer overflow, race conditions, resource leaks\n"      
                "- ƒê·ªëi chi·∫øu v·ªõi b·ªô quy t·∫Øc LGE Static Analysis ƒë·ªÉ x√°c th·ª±c ƒë·ªô ch√≠nh x√°c\n"
                "- **IGNORE t·∫•t c·∫£ CID ch·ªâ c√≥ [ \"select issue\" ] m√† kh√¥ng c√≥ m√¥ t·∫£ defect c·ª• th·ªÉ**\n\n"
                
                "**ƒê·ªäNH D·∫†NG B√ÅO C√ÅO:**\n"
                "V·ªõi m·ªói CID C√ì M√î T·∫¢ CHI TI·∫æT:\n"
                "## üîç CID [s·ªë]: [T√™n l·ªói]\n\n"
                "**V·ªã tr√≠:** Line [s·ªë] trong [t√™n h√†m ho·∫∑c global scope]\n\n"
                "**Lo·∫°i ph√¢n t√≠ch:** [TRUE POSITIVE/FALSE POSITIVE]\n\n"
                "**M·ª©c ƒë·ªô nghi√™m tr·ªçng:** [Critical/High/Medium/Low/Info]\n\n"
                "**M√¥ t·∫£ l·ªói:** [Gi·∫£i th√≠ch chi ti·∫øt v·∫•n ƒë·ªÅ Coverity ph√°t hi·ªán]\n\n"
                "**ƒê·ªëi chi·∫øu rule:** [So s√°nh v·ªõi LGE Static Analysis rules]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[paste exact code c√≥ l·ªói v·ªõi line numbers]\n```\n\n"
                
                "**Code ƒë√£ s·ª≠a:** (ch·ªâ cho TRUE POSITIVE)\n"
                "```cpp\n[code ƒë√£ fix ho√†n ch·ªânh]\n```\n\n"
                
                "**Gi·∫£i th√≠ch fix:** [T·∫°i sao fix n√†y ƒë√∫ng, an to√†n v√† hi·ªáu qu·∫£ h∆°n]\n\n"              
                "**Ghi ch√∫:** [Context ho·∫∑c l∆∞u √Ω ƒë·∫∑c bi·ªát, impact ƒë·∫øn performance]\n\n"
                "---\n\n"
                
                "**T·ªîNG K·∫æT CU·ªêI B√ÅO C√ÅO:**\n"
                "- T·ªïng s·ªë CID C√ì M√î T·∫¢ CHI TI·∫æT ph√°t hi·ªán: [X]\n"
                "- CID ch·ªâ c√≥ [ \"select issue\" ] ƒë√£ b·ªè qua: [Y]\n"
                "- TRUE POSITIVE (c·∫ßn fix ngay): [Z]\n"
                "- FALSE POSITIVE (c√≥ th·ªÉ ignore): [W]\n"
                "- Critical/High priority: [V] (∆∞u ti√™n cao nh·∫•t)\n"         
                "- Ph√π h·ª£p v·ªõi LGE Static Analysis: [L] (ƒë·ªëi chi·∫øu v·ªõi b·ªô rule)\n\n"
                
                "**KHUY·∫æN NGH·ªä H√ÄNH ƒê·ªòNG:**\n"
                "1. Fix ngay c√°c Critical/High severity issues c√≥ m√¥ t·∫£ chi ti·∫øt\n"
                "2. Review v√† plan cho Medium severity\n"
                "3. Suppress FALSE POSITIVE v·ªõi comment r√µ r√†ng\n"
                "4. Update coding practices ƒë·ªÉ tr√°nh t∆∞∆°ng lai\n"
                "5. C√≥ th·ªÉ review l·∫°i nh·ªØng CID [ \"select issue\" ] n·∫øu c·∫ßn thi·∫øt\n\n"
                
                "**L∆ØU √ù QUAN TR·ªåNG:**\n"
                "- **CH·ªà PH√ÇN T√çCH CID C√ì M√î T·∫¢ DEFECT C·ª§ TH·ªÇ** - b·ªè qua [ \"select issue\" ]\n"
                "- ∆Øu ti√™n ph√¢n t√≠ch security v√† memory safety defects\n"
                "- V·ªõi FALSE POSITIVE, gi·∫£i th√≠ch r√µ t·∫°i sao Coverity b√°o nh·∫ßm\n"
                "- ƒê·ªÅ xu·∫•t suppression comment n·∫øu c·∫ßn: // coverity[CID_NUMBER]\n"
                "- Ki·ªÉm tra cross-reference gi·ªØa c√°c CID li√™n quan\n"
                "- Xem x√©t impact performance c·ªßa fix\n"
                "- ƒê·∫£m b·∫£o fix kh√¥ng g√¢y side effects kh√°c\n"
                "- Lu√¥n ƒë·ªëi chi·∫øu v·ªõi b·ªô quy t·∫Øc LGE Static Analysis ƒë·ªÉ ƒë·∫£m b·∫£o consistency"
            )
        else:
            prompt = (
                "You are a C++/C static analysis expert with deep Coverity Static Analysis experience. "
                "Please analyze the current code file along with CIM (Coverity) violation reports.\n"
                "If no rule file available, call fetch_static_analysis_rule from MCP server to download LGE Static Analysis rules.\n"
                "Always use the latest fetched rules to cross-reference with CIM results.\n"
                "Please specify which rule set you are using in your report.\n\n"
                
                "**PRIMARY TASKS:**\n"
                "1. **ACCURACY VERIFICATION**: Verify if reported CIDs (Coverity Issue IDs) are actual defects\n"
                "2. **SOLUTION PROPOSAL**: Provide specific code fixes for each real defect\n"
                "3. **RULE CROSS-REFERENCE**: Compare with LGE Static Analysis rules for validation\n\n"
                
                "**CID FORMAT ANALYSIS:**\n"
                "- CID [number]: [defect type] - [detailed description]\n"
                "- Example: CID 6863827: Variable copied when it could be moved (COPY_INSTEAD_OF_MOVE)\n"
                "- Example: CID 7257883: Unchecked return value (CHECKED_RETURN)\n"
                "- Common types: CHECKED_RETURN, COPY_INSTEAD_OF_MOVE, NULL_RETURNS, RESOURCE_LEAK, TAINTED_DATA\n\n"
                
                "**IMPORTANT NOTE ABOUT CID SELECTION:**\n"
                "- **ANALYZE ONLY CIDs WITH DETAILED DESCRIPTIONS**: Focus only on CIDs with specific defect descriptions\n"
                "- **IGNORE 'SELECT ISSUE' CIDs**: Skip CIDs that only have [ \"select issue\" ] without detailed description\n"
                "- **Example CID to analyze**: CID 6863827: Variable copied when it could be moved (COPY_INSTEAD_OF_MOVE) - detailed description here...\n"
                "- **Example CID to ignore**: CID 6795225: [ \"select issue\" ]\n\n"
                
                "**ANALYSIS REQUIREMENTS:**\n"
                "- Read each CID WITH DETAILED DESCRIPTION and reported line number carefully\n"
                "- Check surrounding context to understand execution flow\n"
                "- Determine: TRUE POSITIVE (real defect) vs FALSE POSITIVE (false alarm)\n"
                "- Assess severity: Critical/High/Medium/Low/Info\n"
                "- Check patterns: memory leaks, null pointer, buffer overflow, race conditions, resource leaks\n"            
                "- Cross-reference with LGE Static Analysis rules for validation\n"
                "- **IGNORE all CIDs with only [ \"select issue\" ] and no specific defect description**\n\n"
                
                "**REPORT FORMAT:**\n"
                "For each CID WITH DETAILED DESCRIPTION:\n"
                "## üîç CID [number]: [Defect Name]\n\n"
                "**Location:** Line [number] in [function name or global scope]\n\n"
                "**Analysis Type:** [TRUE POSITIVE/FALSE POSITIVE]\n\n"
                "**Severity:** [Critical/High/Medium/Low/Info]\n\n"
                "**Defect Description:** [Detailed explanation of what Coverity detected]\n\n"
                "**Rule Cross-Reference:** [Compare with LGE Static Analysis rules]\n\n"
                "**Current Code:**\n"
                "```cpp\n[paste exact defective code with line numbers]\n```\n\n"
                
                "**Fixed Code:** (only for TRUE POSITIVE)\n"
                "```cpp\n[complete fixed code]\n```\n\n"
                
                "**Fix Explanation:** [Why this fix is correct, safe and more efficient]\n\n"            
                "**Notes:** [Context or special considerations, performance impact]\n\n"
                "---\n\n"
                
                "**FINAL SUMMARY:**\n"
                "- Total CIDs WITH DETAILED DESCRIPTION detected: [X]\n"
                "- CIDs with only [ \"select issue\" ] ignored: [Y]\n"
                "- TRUE POSITIVE (needs immediate fix): [Z]\n"
                "- FALSE POSITIVE (can be ignored): [W]\n"
                "- Critical/High priority: [V] (highest priority)\n"                
                "- LGE Static Analysis compliance: [L] (rule set cross-reference)\n\n"
                
                "**ACTION RECOMMENDATIONS:**\n"
                "1. Fix Critical/High severity issues with detailed descriptions immediately\n"
                "2. Review and plan for Medium severity\n"
                "3. Suppress FALSE POSITIVE with clear comments\n"
                "4. Update coding practices for future prevention\n"
                "5. May review [ \"select issue\" ] CIDs separately if needed\n\n"
                
                "**IMPORTANT NOTES:**\n"
                "- **ANALYZE ONLY CIDs WITH SPECIFIC DEFECT DESCRIPTIONS** - ignore [ \"select issue\" ]\n"
                "- Prioritize security and memory safety defects\n"
                "- For FALSE POSITIVE, explain clearly why Coverity reported incorrectly\n"
                "- Suggest suppression comments if needed: // coverity[CID_NUMBER]\n"
                "- Check cross-references between related CIDs\n"
                "- Consider performance impact of fixes\n"
                "- Ensure fixes don't cause other side effects\n"
                "- Always cross-reference with LGE Static Analysis rules for consistency"
            )
        
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for CIM Static Analysis (Coverity) result verification with LGE rule cross-reference.",
        )
        logger.info("CIM Static Analysis check prompt")
        return result
    
    
    async def _handle_cim_misra_cpp_check(self) -> types.GetPromptResult:
        """Handle CIM Static Analysis (Coverity) result verification prompt for MISRA C++ violations"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++/C v·ªõi kinh nghi·ªám s√¢u v·ªÅ Coverity Static Analysis v√† MISRA C++ 2008. "
                "H√£y ph√¢n t√≠ch file code hi·ªán t·∫°i c√πng v·ªõi c√°c b√°o c√°o vi ph·∫°m MISRA C++ t·ª´ h·ªá th·ªëng CIM (Coverity).\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_misra_cpp_rule t·ª´ MCP server ƒë·ªÉ t·∫£i b·ªô quy t·∫Øc MISRA C++ 2008.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc MISRA C++ m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ƒë·ªëi chi·∫øu v·ªõi k·∫øt qu·∫£ CIM.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                
                "**NHI·ªÜM V·ª§ CH√çNH:**\n"
                "1. **KI·ªÇM TRA T√çNH CH√çNH X√ÅC**: X√°c minh xem c√°c CID (Coverity Issue ID) cho MISRA C++ c√≥ th·ª±c s·ª± l√† vi ph·∫°m hay kh√¥ng\n"
                "2. **ƒê·ªÄ XU·∫§T GI·∫¢I PH√ÅP**: ƒê∆∞a ra code fix c·ª• th·ªÉ cho m·ªói vi ph·∫°m MISRA C++ th·ª±c s·ª±\n"
                "3. **ƒê·ªêI CHI·∫æU RULE**: So s√°nh v·ªõi b·ªô quy t·∫Øc MISRA C++ 2008 ƒë·ªÉ x√°c th·ª±c\n\n"
                
                "**PH√ÇN T√çCH CID FORMAT CHO MISRA C++:**\n"
                "- CID [s·ªë]: MISRA C++-2008 [Category] (MISRA C++-2008 Rule [X-Y-Z])\n"
                "- V√≠ d·ª•: CID 6237279: MISRA C++-2008 Basic Concepts (MISRA C++-2008 Rule 3-2-3)\n"
                "- V√≠ d·ª•: CID 6244494: MISRA C++-2008 Basic Concepts (MISRA C++-2008 Rule 3-9-2)\n"
                "- C√°c category ph·ªï bi·∫øn: Basic Concepts, Lexical Conventions, Declarations, Preprocessor Directives\n\n"
                
                "**L∆ØU √ù QUAN TR·ªåNG V·ªÄ CID SELECTION:**\n"
                "- **CH·ªà PH√ÇN T√çCH CID C√ì M√î T·∫¢ CHI TI·∫æT**: Ch·ªâ focus v√†o nh·ªØng CID c√≥ m√¥ t·∫£ violation c·ª• th·ªÉ\n"
                "- **B·ªé QUA CID 'SELECT ISSUE'**: Kh√¥ng ph√¢n t√≠ch nh·ªØng CID ch·ªâ c√≥ [ \"select issue\" ] m√† kh√¥ng c√≥ m√¥ t·∫£ chi ti·∫øt\n"
                "- **V√≠ d·ª• CID c·∫ßn ph√¢n t√≠ch**: CID 6769436: (#1 of 1): MISRA C++-2008 Declarations (MISRA C++-2008 Rule 7-1-1) misra_cpp_2008_rule_7_1_1_violation: The variable strValZ has a non-const type...\n"
                "- **V√≠ d·ª• CID b·ªè qua**: CID 6795225:MISRA C++-2008 Declarations (MISRA C++-2008 Rule 7-1-1) [ \"select issue\" ]\n\n"
                
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- ƒê·ªçc k·ªπ t·ª´ng CID MISRA C++ C√ì M√î T·∫¢ CHI TI·∫æT v√† v·ªã tr√≠ line number ƒë∆∞·ª£c b√°o\n"
                "- Ki·ªÉm tra context xung quanh ƒë·ªÉ hi·ªÉu vi ph·∫°m rule c·ª• th·ªÉ\n"
                "- X√°c ƒë·ªãnh: TRUE POSITIVE (vi ph·∫°m th·ª±c) vs FALSE POSITIVE (b√°o nh·∫ßm)\n"
                "- ƒê√°nh gi√° m·ª©c ƒë·ªô nghi√™m tr·ªçng: Critical/High/Medium/Low/Info\n"
                "- T·∫≠p trung v√†o compliance v·ªõi MISRA C++ 2008 standard\n"      
                "- ƒê·ªëi chi·∫øu v·ªõi b·ªô quy t·∫Øc MISRA C++ 2008 ch√≠nh th·ª©c ƒë·ªÉ x√°c th·ª±c\n"
                "- **IGNORE t·∫•t c·∫£ CID ch·ªâ c√≥ [ \"select issue\" ] m√† kh√¥ng c√≥ m√¥ t·∫£ violation c·ª• th·ªÉ**\n\n"
                
                "**ƒê·ªäNH D·∫†NG B√ÅO C√ÅO:**\n"
                "V·ªõi m·ªói CID MISRA C++ C√ì M√î T·∫¢ CHI TI·∫æT:\n"
                "## üîç CID [s·ªë]: MISRA C++ Rule [X-Y-Z] Violation\n\n"
                "**V·ªã tr√≠:** Line [s·ªë] trong [t√™n h√†m ho·∫∑c global scope]\n\n"
                "**Rule vi ph·∫°m:** MISRA C++-2008 Rule [X-Y-Z] - [M√¥ t·∫£ rule t·ª´ standard]\n\n"
                "**Lo·∫°i ph√¢n t√≠ch:** [TRUE POSITIVE/FALSE POSITIVE]\n\n"
                "**M·ª©c ƒë·ªô nghi√™m tr·ªçng:** [Critical/High/Medium/Low/Info]\n\n"
                "**M√¥ t·∫£ vi ph·∫°m:** [Gi·∫£i th√≠ch chi ti·∫øt vi ph·∫°m MISRA rule c·ª• th·ªÉ]\n\n"
                "**ƒê·ªëi chi·∫øu MISRA rule:** [So s√°nh v·ªõi MISRA C++ 2008 standard ch√≠nh th·ª©c]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[paste exact code vi ph·∫°m v·ªõi line numbers]\n```\n\n"
                
                "**Code ƒë√£ s·ª≠a:** (ch·ªâ cho TRUE POSITIVE)\n"
                "```cpp\n[code ƒë√£ fix tu√¢n th·ªß MISRA C++]\n```\n\n"
                
                "**Gi·∫£i th√≠ch fix:** [T·∫°i sao fix n√†y tu√¢n th·ªß MISRA C++ v√† an to√†n h∆°n]\n\n"              
                "**Ghi ch√∫:** [Context ƒë·∫∑c bi·ªát, deviation c√≥ th·ªÉ ch·∫•p nh·∫≠n ƒë∆∞·ª£c]\n\n"
                "---\n\n"
                
                "**T·ªîNG K·∫æT CU·ªêI B√ÅO C√ÅO:**\n"
                "- T·ªïng s·ªë CID MISRA C++ C√ì M√î T·∫¢ CHI TI·∫æT ph√°t hi·ªán: [X]\n"
                "- CID ch·ªâ c√≥ [ \"select issue\" ] ƒë√£ b·ªè qua: [Y]\n"
                "- TRUE POSITIVE (c·∫ßn fix ngay): [Z]\n"
                "- FALSE POSITIVE (c√≥ th·ªÉ ignore): [W]\n"
                "- Critical/High priority: [V] (∆∞u ti√™n cao nh·∫•t)\n"         
                "- Tu√¢n th·ªß MISRA C++ 2008: [M] (ƒë·ªëi chi·∫øu v·ªõi standard)\n\n"
                
                "**KHUY·∫æN NGH·ªä H√ÄNH ƒê·ªòNG:**\n"
                "1. Fix ngay c√°c Critical/High severity MISRA violations c√≥ m√¥ t·∫£ chi ti·∫øt\n"
                "2. Document justified deviations v·ªõi clear rationale\n"
                "3. Suppress FALSE POSITIVE v·ªõi MISRA deviation comments\n"
                "4. Update coding guidelines ƒë·ªÉ prevent future violations\n"
                "5. C√≥ th·ªÉ review l·∫°i nh·ªØng CID [ \"select issue\" ] n·∫øu c·∫ßn thi·∫øt\n\n"
                
                "**L∆ØU √ù QUAN TR·ªåNG:**\n"
                "- **CH·ªà PH√ÇN T√çCH CID C√ì M√î T·∫¢ VIOLATION C·ª§ TH·ªÇ** - b·ªè qua [ \"select issue\" ]\n"
                "- ∆Øu ti√™n c√°c MISRA rules li√™n quan ƒë·∫øn safety v√† reliability\n"
                "- V·ªõi FALSE POSITIVE, gi·∫£i th√≠ch r√µ t·∫°i sao rule kh√¥ng √°p d·ª•ng\n"
                "- ƒê·ªÅ xu·∫•t MISRA deviation comments: /* MISRA C++ Rule X-Y-Z deviation: [reason] */\n"
                "- Ki·ªÉm tra consistency v·ªõi to√†n b·ªô MISRA C++ compliance strategy\n"
                "- Xem x√©t impact c·ªßa fix ƒë·∫øn overall code maintainability\n"
                "- ƒê·∫£m b·∫£o fix kh√¥ng vi ph·∫°m rules kh√°c\n"
                "- Lu√¥n ƒë·ªëi chi·∫øu v·ªõi MISRA C++ 2008 standard ch√≠nh th·ª©c"
            )
        else:
            prompt = (
                "You are a C++/C static analysis expert with deep Coverity Static Analysis and MISRA C++ 2008 experience. "
                "Please analyze the current code file along with CIM (Coverity) MISRA C++ violation reports.\n"
                "If no rule file available, call fetch_misra_cpp_rule from MCP server to download MISRA C++ 2008 rules.\n"
                "Always use the latest fetched MISRA C++ rules to cross-reference with CIM results.\n"
                "Please specify which rule set you are using in your report.\n\n"
                
                "**PRIMARY TASKS:**\n"
                "1. **ACCURACY VERIFICATION**: Verify if reported CIDs (Coverity Issue IDs) for MISRA C++ are actual violations\n"
                "2. **SOLUTION PROPOSAL**: Provide specific code fixes for each real MISRA C++ violation\n"
                "3. **RULE CROSS-REFERENCE**: Compare with MISRA C++ 2008 rules for validation\n\n"
                
                "**CID FORMAT ANALYSIS FOR MISRA C++:**\n"
                "- CID [number]: MISRA C++-2008 [Category] (MISRA C++-2008 Rule [X-Y-Z])\n"
                "- Example: CID 6237279: MISRA C++-2008 Basic Concepts (MISRA C++-2008 Rule 3-2-3)\n"
                "- Example: CID 6244494: MISRA C++-2008 Basic Concepts (MISRA C++-2008 Rule 3-9-2)\n"
                "- Common categories: Basic Concepts, Lexical Conventions, Declarations, Preprocessor Directives\n\n"
                
                "**IMPORTANT NOTE ABOUT CID SELECTION:**\n"
                "- **ANALYZE ONLY CIDs WITH DETAILED DESCRIPTIONS**: Focus only on CIDs with specific violation descriptions\n"
                "- **IGNORE 'SELECT ISSUE' CIDs**: Skip CIDs that only have [ \"select issue\" ] without detailed description\n"
                "- **Example CID to analyze**: CID 6769436: (#1 of 1): MISRA C++-2008 Declarations (MISRA C++-2008 Rule 7-1-1) misra_cpp_2008_rule_7_1_1_violation: The variable strValZ has a non-const type...\n"
                "- **Example CID to ignore**: CID 6795225:MISRA C++-2008 Declarations (MISRA C++-2008 Rule 7-1-1) [ \"select issue\" ]\n\n"
                
                "**ANALYSIS REQUIREMENTS:**\n"
                "- Read each MISRA C++ CID WITH DETAILED DESCRIPTION and reported line number carefully\n"
                "- Check surrounding context to understand specific rule violation\n"
                "- Determine: TRUE POSITIVE (real violation) vs FALSE POSITIVE (false alarm)\n"
                "- Assess severity: Critical/High/Medium/Low/Info\n"
                "- Focus on MISRA C++ 2008 standard compliance\n"            
                "- Cross-reference with official MISRA C++ 2008 rules for validation\n"
                "- **IGNORE all CIDs with only [ \"select issue\" ] and no specific violation description**\n\n"
                
                "**REPORT FORMAT:**\n"
                "For each MISRA C++ CID WITH DETAILED DESCRIPTION:\n"
                "## üîç CID [number]: MISRA C++ Rule [X-Y-Z] Violation\n\n"
                "**Location:** Line [number] in [function name or global scope]\n\n"
                "**Rule Violated:** MISRA C++-2008 Rule [X-Y-Z] - [Rule description from standard]\n\n"
                "**Analysis Type:** [TRUE POSITIVE/FALSE POSITIVE]\n\n"
                "**Severity:** [Critical/High/Medium/Low/Info]\n\n"
                "**Violation Description:** [Detailed explanation of specific MISRA rule violation]\n\n"
                "**MISRA Rule Cross-Reference:** [Compare with official MISRA C++ 2008 standard]\n\n"
                "**Current Code:**\n"
                "```cpp\n[paste exact violating code with line numbers]\n```\n\n"
                
                "**Fixed Code:** (only for TRUE POSITIVE)\n"
                "```cpp\n[MISRA C++ compliant fixed code]\n```\n\n"
                
                "**Fix Explanation:** [Why this fix complies with MISRA C++ and is safer]\n\n"            
                "**Notes:** [Special context, acceptable deviations]\n\n"
                "---\n\n"
                
                "**FINAL SUMMARY:**\n"
                "- Total MISRA C++ CIDs WITH DETAILED DESCRIPTION detected: [X]\n"
                "- CIDs with only [ \"select issue\" ] ignored: [Y]\n"
                "- TRUE POSITIVE (needs immediate fix): [Z]\n"
                "- FALSE POSITIVE (can be ignored): [W]\n"
                "- Critical/High priority: [V] (highest priority)\n"                
                "- MISRA C++ 2008 compliance: [M] (standard cross-reference)\n\n"
                
                "**ACTION RECOMMENDATIONS:**\n"
                "1. Fix Critical/High severity MISRA violations with detailed descriptions immediately\n"
                "2. Document justified deviations with clear rationale\n"
                "3. Suppress FALSE POSITIVE with MISRA deviation comments\n"
                "4. Update coding guidelines to prevent future violations\n"
                "5. May review [ \"select issue\" ] CIDs separately if needed\n\n"
                
                "**IMPORTANT NOTES:**\n"
                "- **ANALYZE ONLY CIDs WITH SPECIFIC VIOLATION DESCRIPTIONS** - ignore [ \"select issue\" ]\n"
                "- Prioritize MISRA rules related to safety and reliability\n"
                "- For FALSE POSITIVE, explain clearly why rule doesn't apply\n"
                "- Suggest MISRA deviation comments: /* MISRA C++ Rule X-Y-Z deviation: [reason] */\n"
                "- Check consistency with overall MISRA C++ compliance strategy\n"
                "- Consider impact of fixes on overall code maintainability\n"
                "- Ensure fixes don't violate other rules\n"
                "- Always cross-reference with official MISRA C++ 2008 standard"
            )
        
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for CIM Static Analysis (Coverity) MISRA C++ result verification with MISRA C++ 2008 rule cross-reference.",
        )
        logger.info("CIM MISRA C++ check prompt completed")
        return result

    async def _handle_autosar_check(self) -> types.GetPromptResult:
        """Handle AUTOSAR C++ 14 code checking prompt"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C++. H√£y ph√¢n t√≠ch file hi·ªán t·∫°i ƒë·ªÉ ph√°t hi·ªán vi ph·∫°m c√°c quy t·∫Øc AUTOSAR C++ 14 cho ph·∫ßn m·ªÅm √¥ t√¥.\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_autosar_rule t·ª´ MCP server.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc AUTOSAR C++ 14 m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ph√¢n t√≠ch, kh√¥ng d√πng rule c≈© ho·∫∑c built-in.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- T√¨m T·∫§T C·∫¢ vi ph·∫°m quy t·∫Øc tr√™n\n"
                "- T·∫≠p trung v√†o vi ph·∫°m AUTOSAR C++ 14\n"
                "- Ghi r√µ s·ªë hi·ªáu rule (VD: Rule M0-1-1, Rule A0-1-1, MISRA Rule 8-4-3, DCL50-CPP)\n"
                "- Ki·ªÉm tra m·ªçi d√≤ng code, k·ªÉ c·∫£ unreachable, dead code, return s·ªõm, magic number\n"
                "- Ki·ªÉm tra m·ªçi ƒëi·ªÉm acquire/release resource, m·ªçi exit point, m·ªçi function/method\n"
                "- ƒê∆∞a ra code fix c·ª• th·ªÉ cho t·ª´ng l·ªói\n"
                "- Ghi s·ªë d√≤ng code g·ªëc trong b√°o c√°o\n\n"
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói l·ªói:\n"
                "## üö® V·∫•n ƒë·ªÅ [#]: [M√¥ t·∫£ ng·∫Øn]\n\n"
                "**Rule vi ph·∫°m:** [S·ªê HI·ªÜU] - [M√¥ t·∫£ rule]\n\n"
                "**V·ªã tr√≠:** [t√™n file, t√™n h√†m ho·∫∑c global/unknown]\n\n"
                "**M·ª©c ƒë·ªô:** [Critical/High/Medium/Low]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```cpp\n[code l·ªói]\n```\n"
                "**Code ƒë√£ s·ª≠a:**\n"
                "```cpp\n[code ƒë√∫ng]\n```\n"
                "**Gi·∫£i th√≠ch:** [V√¨ sao vi ph·∫°m v√† c√°ch s·ª≠a]\n\n"
                "**L∆∞u √Ω:** N·∫øu c·∫ßn to√†n b·ªô file code ƒë√£ fix, h√£y y√™u c·∫ßu r√µ r√†ng."
            )
        else:
            prompt = self.templates.get_autosar_analysis_prompt()
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for AUTOSAR C++ 14 rule on current file.",
        )
        logger.info("AUTOSAR C++ 14 check prompt completed")
        return result

    async def _handle_misra_c_check(self) -> types.GetPromptResult:
        """Handle MISRA C 2023 code checking prompt"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch tƒ©nh C. H√£y ph√¢n t√≠ch file hi·ªán t·∫°i ƒë·ªÉ ph√°t hi·ªán vi ph·∫°m c√°c quy t·∫Øc MISRA C 2023 cho ph·∫ßn m·ªÅm an to√†n.\n"
                "N·∫øu ch∆∞a c√≥ file rule, h√£y g·ªçi fetch_misra_c_rule t·ª´ MCP server.\n"
                "Lu√¥n s·ª≠ d·ª•ng b·ªô quy t·∫Øc MISRA C 2023 m·ªõi nh·∫•t v·ª´a fetch ƒë·ªÉ ph√¢n t√≠ch, kh√¥ng d√πng rule c≈© ho·∫∑c built-in.\n"
                "H√£y ghi r√µ b·ªô rule n√†o ƒëang d√πng trong b√°o c√°o.\n\n"
                "**Y√äU C·∫¶U PH√ÇN T√çCH:**\n"
                "- T√¨m T·∫§T C·∫¢ vi ph·∫°m quy t·∫Øc tr√™n\n"
                "- T·∫≠p trung v√†o vi ph·∫°m MISRA C 2023 (NG√îN NG·ªÆ C, KH√îNG PH·∫¢I C++)\n"
                "- Ghi r√µ s·ªë hi·ªáu rule (VD: Rule 1.1, Dir 4.1, MISRA Rule 8-4-3, DCL50-CPP)\n"
                "- Ki·ªÉm tra m·ªçi d√≤ng code, k·ªÉ c·∫£ unreachable, dead code, return s·ªõm, magic number\n"
                "- Ki·ªÉm tra m·ªçi ƒëi·ªÉm acquire/release resource, m·ªçi exit point, m·ªçi function\n"
                "- ƒê∆∞a ra code fix c·ª• th·ªÉ cho t·ª´ng l·ªói\n"
                "- Ghi s·ªë d√≤ng code g·ªëc trong b√°o c√°o\n\n"
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói l·ªói:\n"
                "## üö® V·∫•n ƒë·ªÅ [#]: [M√¥ t·∫£ ng·∫Øn]\n\n"
                "**Rule vi ph·∫°m:** [S·ªê HI·ªÜU] - [M√¥ t·∫£ rule]\n\n"
                "**V·ªã tr√≠:** [t√™n file, t√™n h√†m ho·∫∑c global/unknown]\n\n"
                "**M·ª©c ƒë·ªô:** [Critical/High/Medium/Low]\n\n"
                "**Code hi·ªán t·∫°i:**\n"
                "```c\n[code l·ªói]\n```\n"
                "**Code ƒë√£ s·ª≠a:**\n"
                "```c\n[code ƒë√∫ng]\n```\n"
                "**Gi·∫£i th√≠ch:** [V√¨ sao vi ph·∫°m v√† c√°ch s·ª≠a]\n\n"
                "**L∆∞U √ù QUAN TR·ªåNG:** ƒê√¢y l√† ph√¢n t√≠ch cho ng√¥n ng·ªØ C (kh√¥ng ph·∫£i C++). T·∫≠p trung v√†o MISRA C 2023 directives v√† rules."
            )
        else:
            prompt = self.templates.get_misra_c_analysis_prompt()
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for MISRA C 2023 rule on current file.",
        )
        logger.info("MISRA C 2023 check prompt completed")
        return result

    async def _handle_race_condition_analysis(self, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """Handle race condition analysis prompt - always use fallback-style prompt with findings if available"""
        dir_path = get_src_dir()
        logger.info(f"[check_races] Using src_dir: {dir_path}")
        try:
            from lgedv.handlers.tool_handlers import ToolHandler
            tool_handler = ToolHandler()
            tool_result = await tool_handler._handle_detect_races({})
           
            if tool_result and hasattr(tool_result[0], 'text'):
                tool_text = tool_result[0].text
                messages = [
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=tool_text),
                    )
                ]
                result = types.GetPromptResult(
                    messages=messages,
                    description="Race condition analysis (full result)",
                )
                logger.info("Race condition analysis prompt (fallback style) completed")
                return result
            else:
                logger.warning("No result from tool")
                return None
            
        except Exception as e:
            logger.error(f"Error in race condition analysis: {e}")
            return None
            
    async def _handle_memory_leak_analysis(self, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """Handle memory leak analysis prompt - always use fallback-style prompt with findings if available"""
        dir_path = get_src_dir()
        logger.info(f"[check_leaks] Using src_dir: {dir_path}")
        try:
            from lgedv.handlers.tool_handlers import ToolHandler
            tool_handler = ToolHandler()
            tool_result = await tool_handler._handle_memory_analysis({"dir_path": dir_path})
            
            if tool_result and hasattr(tool_result[0], 'text'):
                tool_text = tool_result[0].text
                messages = [
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=tool_text),
                    )
                ]
                result = types.GetPromptResult(
                    messages=messages,
                    description="Memory leak analysis (full result)",
                )
                logger.info("Memory leak analysis prompt")
                return result
            else:
                logger.warning("No result from tool for memory leak analysis")
                return None
        except Exception as e:
            logger.error(f"Error in memory leak analysis: {e}")
            return None
           
       
    async def _handle_resource_leak_analysis(self, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """Handle resource leak analysis prompt - always use fallback-style prompt with findings if available, now with line numbers"""
        dir_path = get_src_dir()
        logger.info(f"[check_resources] Using src_dir: {dir_path}")
        try:
            from lgedv.handlers.tool_handlers import ToolHandler
            tool_handler = ToolHandler()
            # Also append the original findings text for reference
            tool_result = await tool_handler._handle_resource_analysis({})
            # logger.info(f"tool_result: {tool_result}")
            if tool_result and hasattr(tool_result[0], 'text'):
                tool_text = tool_result[0].text
                messages = [
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=tool_text),
                    )
                ]
                result = types.GetPromptResult(
                    messages=messages,
                    description="Resource leak analysis (full prompt)",
                )
                logger.info("Resource leak analysis prompt completed")
                return result
            else:
                 logger.warning("No result from tool for resource leak analysis")
                 return None                 
        except Exception as e:
            logger.error(f"Error in resource leak analysis: {e}")
            return None

    # Th√™m v√†o class PromptHandler

    async def _handle_reset_analysis_prompt(self, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """
        Handle reset analysis prompt - t·ª± ƒë·ªông g·ªçi tool reset_analysic v√† tr·∫£ v·ªÅ k·∫øt qu·∫£.
        """
        from lgedv.handlers.tool_handlers import ToolHandler
        tool_handler = ToolHandler()
        try:
            tool_result = await tool_handler._handle_reset_analysis({})
            if tool_result and hasattr(tool_result[0], 'text'):
                tool_text = tool_result[0].text
                messages = [
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=tool_text),
                    )
                ]
                result = types.GetPromptResult(
                    messages=messages,
                    description="Reset analysis result.",
                )
                logger.info("Reset analysis prompt completed")
                return result
            else:
                return types.GetPromptResult(
                    messages=[
                        types.PromptMessage(
                            role="user",
                            content=types.TextContent(type="text", text="No result from reset_analysic tool."),
                        )
                    ],
                    description="Reset analysis result (no output).",
                )
        except Exception as e:
            logger.error(f"Error in reset analysis prompt: {e}")
            return types.GetPromptResult(
                messages=[
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=f"Error resetting analysis: {e}"),
                    )
                ],
                description="Reset analysis error.",
            )
    
    async def _handle_reset_mem_check_prompt(self, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """
        Handle reset_mem_check prompt - t·ª± ƒë·ªông g·ªçi tool reset_mem_check v√† tr·∫£ v·ªÅ k·∫øt qu·∫£.
        """
        from lgedv.handlers.tool_handlers import ToolHandler
        tool_handler = ToolHandler()
        try:
            tool_result = await tool_handler._handle_reset_mem_check({})
            if tool_result and hasattr(tool_result[0], 'text'):
                tool_text = tool_result[0].text
                messages = [
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=tool_text),
                    )
                ]
                return types.GetPromptResult(
                    messages=messages,
                    description="Reset memory leak analysis result.",
                )
            else:
                return types.GetPromptResult(
                    messages=[
                        types.PromptMessage(
                            role="user",
                            content=types.TextContent(type="text", text="No result from reset_mem_check tool."),
                        )
                    ],
                    description="Reset memory leak analysis result (no output).",
                )
        except Exception as e:
            logger.error(f"Error in reset_mem_check prompt: {e}")
            return types.GetPromptResult(
                messages=[
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=f"Error resetting memory leak analysis: {e}"),
                    )
                ],
                description="Reset memory leak analysis error.",
            )

    async def _handle_reset_resource_check_prompt(self, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """
        Handle reset_resource_check prompt - t·ª± ƒë·ªông g·ªçi tool reset_resource_check v√† tr·∫£ v·ªÅ k·∫øt qu·∫£.
        """
        from lgedv.handlers.tool_handlers import ToolHandler
        tool_handler = ToolHandler()
        try:
            tool_result = await tool_handler._handle_reset_resource_check({})
            if tool_result and hasattr(tool_result[0], 'text'):
                tool_text = tool_result[0].text
                messages = [
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=tool_text),
                    )
                ]
                return types.GetPromptResult(
                    messages=messages,
                    description="Reset resource leak analysis result.",
                )
            else:
                return types.GetPromptResult(
                    messages=[
                        types.PromptMessage(
                            role="user",
                            content=types.TextContent(type="text", text="No result from reset_resource_check tool."),
                        )
                    ],
                    description="Reset resource leak analysis result (no output).",
                )
        except Exception as e:
            logger.error(f"Error in reset_resource_check prompt: {e}")
            return types.GetPromptResult(
                messages=[
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=f"Error resetting resource leak analysis: {e}"),
                    )
                ],
                description="Reset resource leak analysis error.",
            )

    async def _handle_reset_race_check_prompt(self, arguments: Dict[str, str] = None) -> types.GetPromptResult:
        """
        Handle reset_race_check prompt - t·ª± ƒë·ªông g·ªçi tool reset_race_check v√† tr·∫£ v·ªÅ k·∫øt qu·∫£.
        """
        from lgedv.handlers.tool_handlers import ToolHandler
        tool_handler = ToolHandler()
        try:
            tool_result = await tool_handler._handle_reset_race_check({})
            if tool_result and hasattr(tool_result[0], 'text'):
                tool_text = tool_result[0].text
                messages = [
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=tool_text),
                    )
                ]
                return types.GetPromptResult(
                    messages=messages,
                    description="Reset race analysis result.",
                )
            else:
                return types.GetPromptResult(
                    messages=[
                        types.PromptMessage(
                            role="user",
                            content=types.TextContent(type="text", text="No result from reset_race_check tool."),
                        )
                    ],
                    description="Reset race analysis result (no output).",
                )
        except Exception as e:
            logger.error(f"Error in reset_race_check prompt: {e}")
            return types.GetPromptResult(
                messages=[
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(type="text", text=f"Error resetting race analysis: {e}"),
                    )
                ],
                description="Reset race analysis error.",
            )
        
    async def _handle_design_check(self, arguments=None) -> types.GetPromptResult:
        import os
        from lgedv.modules.config import get_src_dir, get_req_dir, get_api_base_dirs, get_module_api, get_framework_dir, get_report_dir
        
        prompt_lang = os.environ.get("prompt_lang", "en")
        
        # L·∫•y tham s·ªë feature t·ª´ arguments dict
        feature = None
        if arguments and isinstance(arguments, dict) and "feature" in arguments:
            feature = arguments["feature"]
        
        logger.info(f"[check_design] Feature argument: {feature}")
        
        if prompt_lang == "vi":
            # Prompt ti·∫øng Vi·ªát ƒë·∫ßy ƒë·ªß
            prompt = (
                "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch thi·∫øt k·∫ø h·ªá th·ªëng nh√∫ng √¥ t√¥.\n"
                "Nhi·ªám v·ª• c·ªßa b·∫°n: ƒê√°nh gi√° s∆° ƒë·ªì tr√¨nh t·ª± (sequence diagram) trong thi·∫øt k·∫ø ƒë√≠nh k√®m (file h√¨nh ·∫£nh) v·ªÅ m·ª©c ƒë·ªô ƒë√°p ·ª©ng y√™u c·∫ßu"
            )
            
            # Th√™m feature n·∫øu c√≥
            if feature:
                prompt += f" cho feature {feature}"
            
            prompt += ", x√°c th·ª±c API, v√† ƒë·ªô robust.\n"
            
            # Ti·∫øp t·ª•c v·ªõi ph·∫ßn c√≤n l·∫°i
            prompt += (
                "\n\n**QUY TR√åNH PH√ÇN T√çCH:**\n"
                f"1. Ph√¢n t√≠ch k·ªπ y√™u c·∫ßu v·ªÅ feature"
            )
            
            if feature:
                prompt += f" {feature}"
            
            prompt += (
                " trong t√†i li·ªáu requirement (file markdown ƒë√≠nh k√®m).\n"
                "2. Tr√≠ch xu·∫•t ƒë·∫ßy ƒë·ªß c√°c th√†nh ph·∫ßn, API call, v√† lu·ªìng t∆∞∆°ng t√°c t·ª´ sequence diagram.\n"
                "3. ƒê·ªëi chi·∫øu t·ª´ng API call v·ªõi ng·ªØ c·∫£nh ·ª©ng d·ª•ng, interface ƒë·ªÉ x√°c th·ª±c t√≠nh h·ª£p l·ªá.\n"
                "4. So s√°nh t·ª´ng b∆∞·ªõc thi·∫øt k·∫ø v·ªõi y√™u c·∫ßu, ki·ªÉm tra ƒëi·ªÉm thi·∫øu/ph·ªß s√≥ng ho·∫∑c ch∆∞a r√µ r√†ng. ƒê·∫∑c bi·ªát, c·∫ßn ph√¢n t√≠ch k·ªπ c√°c tr∆∞·ªùng h·ª£p l·ªói (error case), timeout, v√† c√°c t√¨nh hu·ªëng b·∫•t th∆∞·ªùng c√≥ th·ªÉ x·∫£y ra trong th·ª±c t·∫ø.\n"
                "5. ƒê√°nh gi√° chi ti·∫øt kh·∫£ nƒÉng x·ª≠ l√Ω l·ªói, chi·∫øn l∆∞·ª£c recovery, logic fallback, v√† qu·∫£n l√Ω tr·∫°ng th√°i c·ªßa h·ªá th·ªëng. N√™u r√µ c√°c nh√°nh x·ª≠ l√Ω l·ªói, c∆° ch·∫ø ph·ª•c h·ªìi, v√† ƒë·∫£m b·∫£o h·ªá th·ªëng kh√¥ng r∆°i v√†o tr·∫°ng th√°i b·∫•t ƒë·ªãnh.\n"
                "6. ƒê·ªÅ xu·∫•t c·∫£i ti·∫øn robust design, b·ªï sung c√°c b∆∞·ªõc x·ª≠ l√Ω l·ªói c√≤n thi·∫øu, v√† x√¢y d·ª±ng s∆° ƒë·ªì PlantUML sequence c·∫£i ti·∫øn v·ªõi nh√°nh error/recovery r√µ r√†ng n·∫øu c·∫ßn.\n\n"
                "## üîç Ph√¢n t√≠ch thi·∫øt k·∫ø hi·ªán t·∫°i\n"
                "### ƒê√°nh gi√° lu·ªìng tr√¨nh t·ª±\n"
                "- Th√†nh ph·∫ßn: [li·ªát k√™]\n"
                "- Lu·ªìng th√¥ng ƒëi·ªáp: [ph√¢n t√≠ch]\n"
                "- Chuy·ªÉn tr·∫°ng th√°i: [ph√¢n t√≠ch]\n\n"
                "### K·∫øt qu·∫£ x√°c th·ª±c API\n"
                "**‚úÖ API h·ª£p l·ªá:**\n"
                "- `ClassName::method()` - T√¨m th·∫•y trong [ng·ªØ c·∫£nh]\n"
                "**‚ùå API thi·∫øu:**\n"
                "- `UnknownClass::method()` - Kh√¥ng t√¨m th·∫•y, c·∫ßn b·ªï sung\n"
                "**‚ö†Ô∏è API m∆° h·ªì:**\n"
                "- `CommonName::method()` - T√¨m th·∫•y ·ªü nhi·ªÅu ng·ªØ c·∫£nh, c·∫ßn l√†m r√µ\n\n"
                "### ƒê√°p ·ª©ng y√™u c·∫ßu\n"
                "| M√£ y√™u c·∫ßu | M√¥ t·∫£ | Tr·∫°ng th√°i | Ghi ch√∫ |\n"
                "|-----------|-------|------------|--------|\n"
                "| REQ-001 | [n·ªôi dung] | ‚úÖ/‚ùå/‚ö†Ô∏è | [ghi ch√∫] |\n\n"
                "## ‚ùå V·∫•n ƒë·ªÅ nghi√™m tr·ªçng\n"
                "- Thi·∫øu ph·ªß s√≥ng y√™u c·∫ßu\n"
                "- API kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu\n"
                "- Thi·∫øu robust (x·ª≠ l√Ω l·ªói, timeout, fallback, tr·∫°ng th√°i)\n"
                "## üöÄ Gi·∫£i ph√°p thi·∫øt k·∫ø n√¢ng cao\n"
                "### Chi·∫øn l∆∞·ª£c t√≠ch h·ª£p API\n"
                "- D√πng API c√≥ s·∫µn ·ªü m·ªçi ng·ªØ c·∫£nh n·∫øu c√≥ th·ªÉ\n"
                "- S·ª≠a API hi·ªán c√≥ n·∫øu c·∫ßn\n"
                "- Ch·ªâ ƒë·ªÅ xu·∫•t API m·ªõi khi th·ª±c s·ª± c·∫ßn thi·∫øt, ph·∫£i gi·∫£i th√≠ch r√µ\n\n"
                "### K·∫ø ho·∫°ch ƒë√°p ·ª©ng y√™u c·∫ßu\n"
                "- V·ªõi m·ªói y√™u c·∫ßu thi·∫øu, n√™u r√µ thay ƒë·ªïi thi·∫øt k·∫ø c·∫ßn th·ª±c hi·ªán\n\n"
                "### ƒê·ªÅ xu·∫•t improved design\n"
                "Vui l√≤ng tr√¨nh b√†y improved design cho thi·∫øt k·∫ø hi·ªán t·∫°i b·∫±ng sequence diagram chu·∫©n PlantUML.\n"
                "```plantuml\n"
                "@startuml\n"
                "title Enhanced Design\n"
                "' Add enhanced design here\n"
                "' Include error handling and robustness\n"
                "@enduml\n"
                "```\n"
            )
            
            if feature:
                prompt += f" - {feature}"
            
            prompt += (
                "\n\n"
                "' Add enhanced design here\n"
                "' Include error handling and robustness\n"
                "@enduml\n"
                "```\n"
            )
        else:            
            prompt = self.templates.get_design_verification_prompt(feature)

        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for design verification and improvement.",
        )
        logger.info("Design verification prompt completed")
        return result
     
    def _format_resource_leak_summary(self, leaks: list) -> str:
        """Format a summary of resource leaks by type and severity"""
        summary = {}
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        
        for leak in leaks:
            leak_type = leak.get('type', 'unknown')
            severity = leak.get('severity', 'medium')
            
            if leak_type not in summary:
                summary[leak_type] = 0
            
            summary[leak_type] += 1
            severity_counts[severity] += 1
        
        summary_text = f"**By Severity:** {severity_counts['critical']} Critical, {severity_counts['high']} High, {severity_counts['medium']} Medium, {severity_counts['low']} Low\n\n"
        summary_text += "**By Resource Type:**\n"
        
        for leak_type, count in summary.items():
            summary_text += f"- {leak_type.title()}: {count} leak(s)\n"
        
        return summary_text
    
    
    def _create_race_analysis_prompt_section(self, race_result: dict) -> str:
        """Create analysis prompt section with detailed race condition information (no grouping, no limit)"""
        prompt_section = "## üéØ Priority Analysis Guidelines:\n\n"
        prompt_section += "1. Focus on shared state accessed by multiple threads.\n"
        prompt_section += "2. Ensure proper synchronization (mutexes, locks, atomics).\n"
        prompt_section += "3. Review thread creation and join/detach logic.\n"
        prompt_section += "4. Check for lock-free and concurrent data structure usage.\n"
        prompt_section += "5. Provide before/after code examples for fixes.\n\n"
        return prompt_section

    async def _handle_code_context(self) -> types.GetPromptResult:
        """Handle code context prompt (load and summarize all files in src_dir)"""
        import os
        prompt_lang = os.environ.get("prompt_lang", "en")
        if prompt_lang == "vi":
            prompt = (
                "B·∫°n l√† tr·ª£ l√Ω ng·ªØ c·∫£nh m√£ ngu·ªìn. Nhi·ªám v·ª• c·ªßa b·∫°n l√† ƒë·ªçc v√† ghi nh·ªõ to√†n b·ªô n·ªôi dung, c·∫•u tr√∫c c·ªßa t·∫•t c·∫£ c√°c file m√£ ngu·ªìn (C++, Python, ...) trong th∆∞ m·ª•c d·ª± √°n hi·ªán t·∫°i.\n"
                "N·∫øu n·ªôi dung file ch∆∞a ƒë∆∞·ª£c t·∫£i, h√£y g·ªçi tool 'get_src_context' t·ª´ MCP server ƒë·ªÉ l·∫•y t·∫•t c·∫£ file m√£ ngu·ªìn trong th∆∞ m·ª•c SRC_DIR.\n"
                "V·ªõi m·ªói file, h√£y t√≥m t·∫Øt:\n"
                "- T√™n file v√† ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi\n"
                "- T·∫•t c·∫£ class, struct, enum, function (C++, Python, ...)\n"
                "- Quan h·ªá k·∫ø th·ª´a, s·ª≠ d·ª•ng, th√†nh ph·∫ßn\n"
                "- Bi·∫øn to√†n c·ª•c, h·∫±ng s·ªë, macro, c·∫•u h√¨nh\n"
                "- C√°c ch√∫ th√≠ch ho·∫∑c t√†i li·ªáu quan tr·ªçng\n"
                "Kh√¥ng th·ª±c hi·ªán ph√¢n t√≠ch tƒ©nh ho·∫∑c ki·ªÉm tra rule ·ªü b∆∞·ªõc n√†y.\n"
                "L∆∞u ng·ªØ c·∫£nh n√†y ƒë·ªÉ d√πng cho c√°c truy v·∫•n ti·∫øp theo.\n\n"
                "**ƒê·ªäNH D·∫†NG K·∫æT QU·∫¢:**\n"
                "V·ªõi m·ªói file:\n"
                "### [T√™n file]\n"
                "```[ng√¥n ng·ªØ]\n[T√≥m t·∫Øt c·∫•u tr√∫c, ƒë·ªãnh nghƒ©a, ƒëi·ªÉm ch√≠nh]\n```\n"
                "L·∫∑p l·∫°i cho t·∫•t c·∫£ file.\n"
                "X√°c nh·∫≠n khi ƒë√£ n·∫°p ƒë·ªß ng·ªØ c·∫£nh."
            )
        else:
            prompt = self.templates.get_context_prompt()
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(type="text", text=prompt),
            )
        ]
        result = types.GetPromptResult(
            messages=messages,
            description="A prompt for loading and summarizing code context for all C++ files.",
        )
        logger.info("Code context prompt completed")
        return result