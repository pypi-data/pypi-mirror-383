{
  "alter_extension": "ALTER EXTENSION {extension} {opts};",
  "alter_schema": "ALTER SCHEMA {schema} {opts};",
  "create_schema": "CREATE SCHEMA {schema} {options};",
  "database_alter": "ALTER DATABASE {database} {options};",
  "database_create": "CREATE DATABASE {database} {options};",
  "database_default_acl": "WITH default_acls AS (\n    SELECT\n        pg_namespace.nspname AS schema,\n        pg_default_acl.defaclobjtype AS objtype,\n        aclexplode(pg_default_acl.defaclacl) AS acl\n    FROM\n        pg_default_acl\n        JOIN pg_namespace ON pg_namespace.oid = pg_default_acl.defaclnamespace\n)\nSELECT\n    current_database() AS database,\n    default_acls.schema,\n    pg_roles.rolname AS role,\n    CASE default_acls.objtype\n    WHEN 'f' THEN\n        'FUNCTION'\n    WHEN 'r' THEN\n        'TABLE'\n    WHEN 'S' THEN\n        'SEQUENCE'\n    WHEN 'T' THEN\n        'TYPE'\n    WHEN 'n' THEN\n        'SCHEMA'\n    ELSE\n        'UNKNOWN'\n    END AS object_type,\n    array_agg(DISTINCT (default_acls.acl).privilege_type) AS privileges\nFROM\n    default_acls\n    JOIN pg_roles ON ((acl).grantee = pg_roles.oid)\n{where_clause}\nGROUP BY\n    schema,\n    role,\n    object_type\nORDER BY\n    schema,\n    role,\n    object_type;",
  "database_drop": "DROP DATABASE {database} {options};",
  "database_encoding": "SELECT\n    pg_encoding_to_char(encoding) AS encoding\nFROM pg_database WHERE datname = current_database();",
  "database_exists": "SELECT EXISTS(SELECT true FROM pg_database WHERE datname = %(database)s);",
  "database_inspect": "SELECT\n    db.datname as name,\n    r.rolname AS owner,\n    (\n        SELECT s.setconfig FROM pg_db_role_setting s\n        WHERE s.setdatabase = db.oid AND s.setrole = 0\n    ) AS settings,\n    t.spcname AS tablespace\nFROM\n    pg_database db\n    JOIN pg_authid r ON db.datdba = r.oid\n    JOIN pg_tablespace t ON db.dattablespace = t.oid\nWHERE\n    db.datname = %(database)s;",
  "database_list": "SELECT d.datname as \"name\",\n    pg_catalog.pg_get_userbyid(d.datdba) as \"owner\",\n    pg_catalog.pg_encoding_to_char(d.encoding) as \"encoding\",\n    d.datcollate as \"collation\",\n    d.datctype as \"ctype\",\n    coalesce(d.datacl, '{{}}'::aclitem[]) AS \"acls\",\n    pg_catalog.pg_database_size(d.datname) as \"size\",\n    t.spcname as \"tablespace\",\n    pg_catalog.pg_tablespace_location(t.oid) as \"tablespace_location\",\n    pg_catalog.pg_tablespace_size(t.oid) as \"tablespace_size\",\n    pg_catalog.shobj_description(d.oid, 'pg_database') as \"description\"\nFROM pg_catalog.pg_database d\nJOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid\nWHERE datallowconn {where_clause}\nORDER BY 1;",
  "database_locale": "SELECT\n    d.datcollate as \"locale\"\nFROM pg_catalog.pg_database d\nWHERE\n    d.datname = %(database)s\n    AND d.datcollate = d.datctype;",
  "database_privileges": "WITH relacl AS (\n    SELECT\n        c.oid,\n        rolname,\n        array_agg(relacl.privilege_type) AS relacl\n    FROM\n        pg_catalog.pg_class c\n        CROSS JOIN aclexplode(c.relacl) as relacl\n        JOIN pg_roles ON (relacl.grantee = pg_roles.oid)\n        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n    GROUP BY 1, 2\n),\nattacl AS (\n    SELECT\n        c.oid,\n        attname,\n        rolname,\n        array_agg(attacl.privilege_type) AS attacl\n    FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_attribute ON attrelid = c.oid\n        CROSS JOIN aclexplode(pg_catalog.pg_attribute.attacl) as attacl\n        JOIN pg_roles ON (attacl.grantee = pg_roles.oid)\n    WHERE\n        NOT attisdropped\n        AND attacl IS NOT NULL\n    GROUP BY 1, 2, 3\n),\nattacl_agg AS (\n    SELECT\n        oid,\n        attacl.rolname,\n        json_object_agg(\n            attacl.attname,\n            attacl.attacl\n        ) as attacl\n    FROM attacl\n    GROUP BY 1, 2\n)\nSELECT\n    current_database() AS database,\n    n.nspname AS schema,\n    c.relname AS object_name,\n    CASE c.relkind\n        WHEN 'r' THEN\n            'TABLE'\n        WHEN 'v' THEN\n            'VIEW'\n        WHEN 'm' THEN\n            'MATERIALIZED VIEW'\n        WHEN 'S' THEN\n            'SEQUENCE'\n        WHEN 'f' THEN\n            'FOREIGN TABLE'\n        WHEN 'p' THEN\n            'PARTITIONED TABLE'\n        ELSE\n            'UNKNOWN'\n        END\n    AS object_type,\n    pg_roles.rolname AS role,\n    coalesce(a.relacl, '{{}}'::text[]) AS privileges,\n    coalesce(b.attacl, '{{}}'::json) AS column_privileges\nFROM pg_class c\nCROSS JOIN pg_roles\nLEFT JOIN relacl a ON c.oid = a.oid AND pg_roles.rolname = a.rolname\nLEFT JOIN attacl_agg b ON c.oid = b.oid AND pg_roles.rolname = b.rolname\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\nWHERE\n    c.relkind IN ('r', 'v', 'm', 'S', 'f', 'p')\n    AND n.nspname !~ '^pg_|information_schema'\n    AND (a.relacl IS NOT NULL OR attacl IS NOT NULL)\n    {where_clause};",
  "drop_extension": "DROP EXTENSION IF EXISTS {extension} CASCADE;",
  "drop_schema": "DROP SCHEMA {schema} CASCADE;",
  "extension_default_version": "SELECT default_version FROM pg_available_extensions WHERE name = %(extension_name)s;",
  "list_extensions": "SELECT\n    extname AS name,\n    s.nspname AS schema,\n    extversion AS version\nFROM pg_extension\nLEFT JOIN pg_namespace s ON s.oid = pg_extension.extnamespace\nWHERE extname != 'plpgsql' ORDER BY extname;",
  "list_schemas": "SELECT\n    n.nspname AS name,\n    r.rolname AS owner\nFROM pg_catalog.pg_namespace n\nLEFT JOIN pg_roles r on n.nspowner = r.oid\nWHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema'\nORDER BY 1;",
  "profile_read-only": "ALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT SELECT\n        ON TABLES\n        TO {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT SELECT\n        ON SEQUENCES\n        TO {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT EXECUTE\n        ON FUNCTIONS\n        TO {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT USAGE\n        ON TYPES\n        TO {username};\nGRANT SELECT\n    ON ALL TABLES\n    IN SCHEMA {schemaname}\n    TO {username};\nGRANT SELECT\n    ON ALL SEQUENCES\n    IN SCHEMA {schemaname}\n    TO {username};\nGRANT EXECUTE\n    ON ALL FUNCTIONS\n    IN SCHEMA {schemaname}\n    TO {username};",
  "profile_read-write": "ALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT SELECT, INSERT, DELETE, UPDATE, REFERENCES, TRUNCATE\n        ON TABLES\n        TO {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT SELECT, UPDATE\n        ON SEQUENCES\n        TO {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT EXECUTE\n        ON FUNCTIONS\n        TO {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    GRANT USAGE\n        ON TYPES\n        TO {username};\nGRANT SELECT, INSERT, DELETE, UPDATE, REFERENCES, TRUNCATE\n    ON ALL TABLES\n    IN SCHEMA {schemaname}\n    TO {username};\nGRANT SELECT, UPDATE\n    ON ALL SEQUENCES\n    IN SCHEMA {schemaname}\n    TO {username};\nGRANT EXECUTE\n    ON ALL FUNCTIONS\n    IN SCHEMA {schemaname}\n    TO {username};",
  "profile_reset": "REVOKE ALL\n    ON DATABASE {dbname}\n    FROM {username};\nREVOKE ALL\n    ON SCHEMA {schemaname}\n    FROM {username};\nREVOKE ALL PRIVILEGES\n    ON ALL TABLES\n    IN SCHEMA {schemaname}\n    FROM {username};\nREVOKE ALL PRIVILEGES\n    ON ALL FUNCTIONS\n    IN SCHEMA {schemaname}\n    FROM {username};\nREVOKE ALL PRIVILEGES\n    ON ALL SEQUENCES\n    IN SCHEMA {schemaname}\n    FROM {username};\nGRANT CONNECT ON DATABASE {dbname}\n    TO {username};\nGRANT USAGE ON SCHEMA {schemaname}\n    TO {username};\nALTER DEFAULT PRIVILEGES\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON TABLES\n        FROM {username};\nALTER DEFAULT PRIVILEGES\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON SEQUENCES\n        FROM {username};\nALTER DEFAULT PRIVILEGES\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON FUNCTIONS\n        FROM {username};\nALTER DEFAULT PRIVILEGES\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON TYPES\n        FROM {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON TABLES\n        FROM {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON SEQUENCES\n        FROM {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON FUNCTIONS\n        FROM {username};\nALTER DEFAULT PRIVILEGES\n    FOR ROLE {grantor}\n    IN SCHEMA {schemaname}\n    REVOKE ALL\n        ON TYPES\n        FROM {username};",
  "publications": "SELECT\n    pubname AS name\nFROM\n    pg_publication\nORDER BY\n   pubname;",
  "replication_slots": "SELECT\n    slot_name AS name\nFROM\n    pg_replication_slots\nORDER BY\n   slot_name;",
  "role_alter": "ALTER ROLE {username} {options};",
  "role_create": "CREATE ROLE {username} {options};",
  "role_drop": "DROP ROLE {username};",
  "role_drop_owned": "DROP OWNED BY {username};",
  "role_drop_reassign": "REASSIGN OWNED BY {oldowner} TO {newowner};",
  "role_exists": "SELECT EXISTS(SELECT true FROM pg_roles WHERE rolname = %(username)s);",
  "role_grant": "GRANT {rolname} TO {rolspec};",
  "role_inspect": "SELECT\n    r.rolname AS name,\n    r.rolpassword IS NOT NULL AS has_password,\n    r.rolinherit AS inherit,\n    r.rolcanlogin AS login,\n    r.rolsuper AS superuser,\n    r.rolcreatedb AS createdb,\n    r.rolcreaterole AS createrole,\n    r.rolreplication AS replication,\n    CASE WHEN r.rolconnlimit <> - 1 THEN\n        r.rolconnlimit\n    ELSE\n        NULL\n    END AS connection_limit,\n    r.rolvaliduntil AS valid_until,\n    ARRAY(SELECT a.rolname\n          FROM pg_catalog.pg_auth_members m\n          JOIN pg_catalog.pg_authid a ON (m.roleid = a.oid)\n          WHERE m.member = r.oid) as memberships\nFROM\n    pg_authid r\nWHERE\n    r.rolname = %(username)s;",
  "role_list": "SELECT\n    r.rolname as name,\n    r.rolpassword IS NOT NULL AS has_password,\n    r.rolinherit AS inherit,\n    r.rolcanlogin AS login,\n    r.rolsuper AS superuser,\n    r.rolcreatedb AS createdb,\n    r.rolcreaterole AS createrole,\n    r.rolreplication AS replication,\n    CASE WHEN r.rolconnlimit <> - 1 THEN\n        r.rolconnlimit\n    ELSE\n        NULL\n    END AS connection_limit,\n    r.rolvaliduntil AS valid_until,\n    ARRAY(SELECT a.rolname\n          FROM pg_catalog.pg_auth_members m\n          JOIN pg_catalog.pg_authid a ON (m.roleid = a.oid)\n          WHERE m.member = r.oid) as memberships\nFROM\n    pg_catalog.pg_authid r\nWHERE\n    r.rolname !~ '^pg_'\nORDER BY 1;",
  "role_list_names": "SELECT rolname from pg_roles ORDER BY rolname;",
  "role_revoke": "REVOKE {rolname} FROM {rolspec};",
  "schema_owner": "SELECT r.rolname AS owner\nFROM pg_roles r\nJOIN pg_catalog.pg_namespace n ON n.nspowner = r.oid\nWHERE n.nspname = %(name)s;",
  "subscriptions": "SELECT\n    subname AS name,\n    subconninfo AS connection,\n    subpublications AS publications,\n    subenabled AS enabled\nFROM\n    pg_subscription JOIN pg_database ON pg_subscription.subdbid = pg_database.oid\nWHERE\n    pg_database.datname = %(datname)s\nORDER BY\n   subname;",
  "tablespace": "SELECT\n    t.spcname AS tablespace\nFROM\n    pg_database db\n    JOIN pg_tablespace t ON db.dattablespace = t.oid\nWHERE\n    db.datname = %(database_name)s;"
}
