{
    ".gitignore": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n#.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# Append\n.idea\n.vscode\n*.sqlite\ncelerybeat-schedule.*\n",
    "LICENSE": "Copyright (c) 2024 axiner\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
    "README.md": "# fastapi-scaff\n\n## What is this?\n\n- by: axiner\n- fastapi-scaff\n- This is a fastapi scaff.\n    - new project\n    - add api\n    - about project:\n        - auto init project (conf, db, log...)\n        - auto register router\n        - auto register middleware\n        - ...\n        - integrated sqlalchemy\n        - integrated jwt\\api-key\n        - integrated celery\n        - ...\n    - more documents: [\u8bf7\u70b9\u51fb\u94fe\u63a5](https://blog.csdn.net/atpuxiner/article/details/144291336?fromshare=blogdetail&sharetype=blogdetail&sharerId=144291336&sharerefer=PC&sharesource=atpuxiner&sharefrom=from_link)\n\n## Project structure\n\n- ASM: ASM\u6a21\u5f0f\n    - A api\n    - S services(&schemas)\n    - M models\n- \u8c03\u7528\u8fc7\u7a0b: main.py(initializer) -> (middleware) - api - services(&schemas) - (models)\n- \u7ed3\u6784\u5982\u4e0b: (\u547d\u540d\u7ecf\u8fc7\u591a\u6b21\u4fee\u6539\u6572\u5b9a\uff0c\u7b80\u6d01\u6613\u61c2)\n  ```\n  \u2514\u2500\u2500 fastapi-scaff\n      \u251c\u2500\u2500 app                         (\u5e94\u7528)\n      \u2502   \u251c\u2500\u2500 api                     \u251c\u2500\u2500 (api)\n      \u2502   \u2502   \u2514\u2500\u2500 v1                  \u2502   \u2514\u2500\u2500 (v1)\n      \u2502   \u251c\u2500\u2500 initializer             \u251c\u2500\u2500 (\u521d\u59cb\u5316)\n      \u2502   \u2502   \u251c\u2500\u2500 conf                \u2502   \u251c\u2500\u2500 (\u914d\u7f6e)\n      \u2502   \u2502   \u251c\u2500\u2500 db                  \u2502   \u251c\u2500\u2500 (\u6570\u636e\u5e93)\n      \u2502   \u2502   \u251c\u2500\u2500 log                 \u2502   \u251c\u2500\u2500 (\u65e5\u5fd7)\n      \u2502   \u2502   \u2514\u2500\u2500 ...                 \u2502   \u2514\u2500\u2500 (...)\n      \u2502   \u251c\u2500\u2500 middleware              \u251c\u2500\u2500 (\u4e2d\u95f4\u4ef6)\n      \u2502   \u251c\u2500\u2500 models                  \u251c\u2500\u2500 (\u6570\u636e\u6a21\u578b)\n      \u2502   \u251c\u2500\u2500 schemas                 \u251c\u2500\u2500 (\u6570\u636e\u7ed3\u6784)\n      \u2502   \u251c\u2500\u2500 services                \u251c\u2500\u2500 (\u4e1a\u52a1\u903b\u8f91)\n      \u2502   \u251c\u2500\u2500 utils                   \u251c\u2500\u2500 (utils)\n      \u2502   \u2514\u2500\u2500 main.py                 \u2514\u2500\u2500 (main.py)\n      \u251c\u2500\u2500 app_celery                  (\u5e94\u7528-celery)\n      \u251c\u2500\u2500 config                      (\u914d\u7f6e\u76ee\u5f55)\n      \u251c\u2500\u2500 deploy                      (\u90e8\u7f72\u76ee\u5f55)\n      \u251c\u2500\u2500 docs                        (\u6587\u6863\u76ee\u5f55)\n      \u251c\u2500\u2500 logs                        (\u65e5\u5fd7\u76ee\u5f55)\n      \u251c\u2500\u2500 tests                       (\u6d4b\u8bd5\u76ee\u5f55)\n      \u251c\u2500\u2500 .gitignore\n      \u251c\u2500\u2500 LICENSE\n      \u251c\u2500\u2500 README.md\n      \u251c\u2500\u2500 requirements.txt\n      \u2514\u2500\u2500 runcbeat.py\n      \u2514\u2500\u2500 runcworker.py\n      \u2514\u2500\u2500 runserver.py\n  ```\n  \n- \u3010\u53e6\uff1a**\u8f7b\u91cf\u7248** > **\u5b8c\u6574\u7ed3\u6784** \u3011\u8bf7\u81ea\u884c\u521b\u5efa\u67e5\u770b\uff08`new`\u9879\u76ee\u65f6\u6307\u5b9a\u53c2\u6570`--light`\uff09\n\n## Installation\n\nThis package can be installed using pip (Python>=3.11):\n> pip install fastapi-scaff\n\n## Scaff usage\n\n- 1\uff09help document\n    - `fastapi-scaff -h`\n- 2\uff09new project\n    - `fastapi-scaff new <myproj>`\n    - *light structure*: `fastapi-scaff new <myproj> --light`\n- 3\uff09add api\n    - `cd to project root dir`\n    - `fastapi-scaff add <myapi>`\n\n## Project run\n\n- 1\uff09cd to project root dir\n- 2\uff09modify the configuration, such as for the database\n- 3\uff09`pip install -r requirements.txt`\n- 4\uff09`python runserver.py`\n    - more parameters see:\n      - about uvicorn: [click here](https://www.uvicorn.org/)\n      - about gunicorn: [click here](https://docs.gunicorn.org/en/stable/)\n\n## License\n\nThis project is released under the MIT License (MIT). See [LICENSE](LICENSE)\n",
    "requirements.txt": "# -*- coding: utf-8 -*-\n# Python>=3.11\nfastapi==0.119.0\nuvicorn==0.37.0\norjson==3.11.3\ntoollib==1.7.9\npython-dotenv==1.1.1\nPyYAML==6.0.3\nloguru==0.7.3\nSQLAlchemy==2.0.44\naiosqlite==0.21.0\nredis==6.4.0\nPyJWT==2.10.1\nbcrypt==5.0.0\ncelery==5.5.3",
    "runcbeat.py": "\"\"\"\n@author axiner\n@version v1.0.0\n@created 2025/09/20 10:10\n@abstract runcbeat\uff08\u66f4\u591a\u53c2\u6570\u8bf7\u81ea\u884c\u6307\u5b9a\uff09\n@description\n@history\n\"\"\"\nimport argparse\nimport subprocess\n\n\ndef main(\n        loglevel: str = \"info\",\n        scheduler: str = None,\n        pidfile: str = None,\n        max_interval: int = 5,\n):\n    parser = argparse.ArgumentParser(description=\"CeleryBeat\u542f\u52a8\u5668\")\n    parser.add_argument(\"-l\", \"--loglevel\", type=str, default=\"info\", metavar=\"\", help=\"\u65e5\u5fd7\u7b49\u7ea7\")\n    parser.add_argument(\"-S\", \"--scheduler\", type=str, default=None, metavar=\"\", help=\"\u8c03\u5ea6\u5668\u7c7b\u578b\")\n    parser.add_argument(\"--pidfile\", type=str, default=None, metavar=\"\", help=\"pid\u6587\u4ef6\")\n    parser.add_argument(\"--max-interval\", type=int, default=5, metavar=\"\", help=\"\u68c0\u6d4b\u4efb\u52a1\u95f4\u9694\")\n    args = parser.parse_args()\n    loglevel = args.loglevel or loglevel\n    scheduler = args.scheduler or scheduler\n    pidfile = args.pidfile or pidfile\n    max_interval = args.max_interval or max_interval\n    command = [\n        \"celery\",\n        \"-A\",\n        \"app_celery.consumer\",\n        \"beat\",\n        f\"--loglevel={loglevel}\",\n        f\"--max-interval={max_interval}\",\n    ]\n    if scheduler:\n        command.extend([\"--scheduler\", scheduler])\n    if pidfile:\n        command.extend([\"--pidfile\", pidfile])\n    subprocess.run(command, check=True)\n\n\nif __name__ == '__main__':\n    main()\n",
    "runcworker.py": "\"\"\"\n@author axiner\n@version v1.0.0\n@created 2025/09/20 10:10\n@abstract runcworker\uff08\u66f4\u591a\u53c2\u6570\u8bf7\u81ea\u884c\u6307\u5b9a\uff09\n@description\n@history\n\"\"\"\nimport argparse\nimport platform\nimport subprocess\nfrom os import cpu_count\n\n\ndef main(\n        name: str,  # `app_celery/consumer/workers`\u4e0b\u7684\u6a21\u5757\u540d\n        loglevel: str = \"info\",\n        concurrency: int = None,\n        pool: str = None,\n):\n    parser = argparse.ArgumentParser(description=\"CeleryWorker\u542f\u52a8\u5668\")\n    parser.add_argument(\"-n\", \"--name\", type=str, metavar=\"\", help=\"\u540d\u79f0\")\n    parser.add_argument(\"-l\", \"--loglevel\", type=str, default=\"info\", metavar=\"\", help=\"\u65e5\u5fd7\u7b49\u7ea7\")\n    parser.add_argument(\"-c\", \"--concurrency\", type=int, default=None, metavar=\"\", help=\"\u5e76\u53d1\u6570\")\n    parser.add_argument(\"-P\", \"--pool\", type=str, default=None, metavar=\"\", help=\"\u5e76\u53d1\u6a21\u578b\")\n    args = parser.parse_args()\n    name = args.name or name\n    loglevel = args.loglevel or loglevel\n    concurrency = args.concurrency or concurrency\n    pool = args.pool or pool\n    if pool is None:\n        if platform.system().lower().startswith(\"win\"):\n            pool = 'gevent'\n            if not concurrency:\n                concurrency = 100\n        else:\n            pool = 'prefork'\n            if not concurrency:\n                concurrency = cpu_count()\n    command = [\n        \"celery\",\n        \"-A\",\n        f\"app_celery.consumer.workers.{name}\",\n        \"worker\",\n        f\"--loglevel={loglevel}\",\n        f\"--concurrency={concurrency}\",\n        f\"--pool={pool}\",\n    ]\n    subprocess.run(\n        command,\n        check=True,\n    )\n\n\nif __name__ == '__main__':\n    main(\n        name=\"ping\",\n    )\n",
    "runserver.py": "\"\"\"\n@author axiner\n@version v1.0.0\n@created 2024/07/29 22:22\n@abstract runserver\uff08\u66f4\u591a\u53c2\u6570\u8bf7\u81ea\u884c\u6307\u5b9a\uff09\n@description\n@history\n\"\"\"\nimport argparse\nimport subprocess\nimport sys\n\nimport uvicorn\n\n\ndef run_by_unicorn(\n        host: str,\n        port: int,\n        workers: int,\n        log_level: str,\n        is_reload: bool,\n):\n    log_config = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"formatters\": {\n            \"default\": {\n                \"()\": \"uvicorn.logging.DefaultFormatter\",\n                \"fmt\": \"%(asctime)s %(levelname)s %(filename)s:%(lineno)d %(message)s\",\n                \"use_colors\": None\n            },\n            \"access\": {\n                \"()\": \"uvicorn.logging.AccessFormatter\",\n                \"fmt\": \"%(asctime)s %(levelname)s %(client_addr)s - \\\"%(request_line)s\\\" %(status_code)s\"\n            }\n        },\n        \"handlers\": {\n            \"default\": {\n                \"formatter\": \"default\",\n                \"class\": \"logging.StreamHandler\",\n                \"stream\": \"ext://sys.stderr\"\n            },\n            \"access\": {\n                \"formatter\": \"access\",\n                \"class\": \"logging.StreamHandler\",\n                \"stream\": \"ext://sys.stdout\"\n            }\n        },\n        \"loggers\": {\n            \"uvicorn\": {\n                \"handlers\": [\n                    \"default\"\n                ],\n                \"level\": \"INFO\",\n                \"propagate\": False\n            },\n            \"uvicorn.error\": {\n                \"level\": \"INFO\"\n            },\n            \"uvicorn.access\": {\n                \"handlers\": [\n                    \"access\"\n                ],\n                \"level\": \"INFO\",\n                \"propagate\": False\n            }\n        }\n    }\n    uvicorn.run(\n        app=\"app.main:app\",\n        host=host,\n        port=port,\n        workers=workers,\n        log_level=log_level,\n        log_config=log_config,\n        reload=is_reload,\n    )\n\n\ndef run_by_gunicorn(\n        host: str,\n        port: int,\n        workers: int,\n        log_level: str,\n        is_reload: bool,\n):\n    cmd = (\n        \"gunicorn app.main:app \"\n        \"--worker-class=uvicorn.workers.UvicornWorker \"\n        \"--bind={host}:{port} \"\n        \"--workers={workers} \"\n        \"--log-level={log_level} \"\n        \"--access-logfile=- \"\n        \"--error-logfile=- \"\n        .format(\n            host=host,\n            port=port,\n            workers=workers,\n            log_level=log_level,\n        )\n    )\n    if is_reload:\n        cmd += f\" --reload\"\n    subprocess.run(cmd, shell=True)\n\n\ndef main(\n        host: str,\n        port: int,\n        workers: int,\n        log_level: str,\n        is_reload: bool,\n        is_gunicorn: bool,\n):\n    parser = argparse.ArgumentParser(description=\"App\u542f\u52a8\u5668\")\n    parser.add_argument(\"--host\", type=str, metavar=\"\", help=\"host\")\n    parser.add_argument(\"--port\", type=int, metavar=\"\", help=\"port\")\n    parser.add_argument(\"--workers\", type=int, metavar=\"\", help=\"\u8fdb\u7a0b\u6570\")\n    parser.add_argument(\"--log-level\", type=str, metavar=\"\", help=\"\u65e5\u5fd7\u7b49\u7ea7\")\n    parser.add_argument(\"--is-reload\", action=\"store_true\", help=\"\u662f\u5426reload\")\n    parser.add_argument(\"--is-gunicorn\", action=\"store_true\", help=\"\u662f\u5426gunicorn\")\n    args = parser.parse_args()\n    kwargs = {\n        \"host\": args.host or host,\n        \"port\": args.port or port,\n        \"workers\": args.workers or workers,\n        \"log_level\": args.log_level or log_level,\n        \"is_reload\": args.is_reload or is_reload,\n    }\n    if (args.is_gunicorn or is_gunicorn) and not sys.platform.lower().startswith(\"win\"):\n        try:\n            import gunicorn  # noqa\n        except ImportError:\n            sys.stderr.write(\"gunicorn\u672a\u627e\u5230\uff0c\u6b63\u5728\u5c1d\u8bd5\u81ea\u52a8\u5b89\u88c5...\\n\")\n            try:\n                subprocess.run(\n                    [\"pip\", \"install\", \"gunicorn\"],\n                    check=True,\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE)\n                sys.stderr.write(\"gunicorn\u5b89\u88c5\u6210\u529f\\n\")\n            except subprocess.CalledProcessError as e:\n                sys.stderr.write(f\"gunicorn\u5b89\u88c5\u5931\u8d25: {e.stderr.decode().strip()}\\n\")\n                raise\n        run_by_gunicorn(**kwargs)\n    else:\n        run_by_unicorn(**kwargs)\n\n\nif __name__ == '__main__':\n    main(\n        host=\"0.0.0.0\",\n        port=8000,\n        workers=3,\n        log_level=\"debug\",\n        is_reload=False,  # \u9002\u7528\u4e8edev\n        is_gunicorn=False,  # \u4e0d\u652f\u6301win\n    )\n",
    "app/main.py": "\"\"\"\n@author axiner\n@version v1.0.0\n@created 2024/07/29 22:22\n@abstract main\n@description\n@history\n\"\"\"\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastapi.responses import ORJSONResponse\n\nfrom app import (\n    api,\n    middleware,\n)\nfrom app.initializer import g\n\ng.setup()\n# #\nopenapi_url = \"/openapi.json\"\ndocs_url = \"/docs\"\nredoc_url = \"/redoc\"\nif g.config.app_disable_docs is True:\n    openapi_url, docs_url, redoc_url = None, None, None\n\n\n@asynccontextmanager\nasync def lifespan(app_: FastAPI):\n    g.logger.info(f\"Application env '{g.config.app_env}'\")\n    g.logger.info(f\"Application yaml '{g.config.app_yaml}'\")\n    g.logger.info(f\"Application title '{g.config.app_title}'\")\n    g.logger.info(f\"Application version '{g.config.app_version}'\")\n    # #\n    g.logger.info(\"Application server running\")\n    yield\n    g.logger.info(\"Application server shutdown\")\n\n\napp = FastAPI(\n    title=g.config.app_title,\n    summary=g.config.app_summary,\n    description=g.config.app_description,\n    version=g.config.app_version,\n    debug=g.config.app_debug,\n    openapi_url=openapi_url,\n    docs_url=docs_url,\n    redoc_url=redoc_url,\n    lifespan=lifespan,\n    default_response_class=ORJSONResponse,\n)\n# #\napi.register_routers(app)\nmiddleware.register_middlewares(app)\n",
    "app/__init__.py": "\"\"\"\n@author axiner\n@version v1.0.0\n@created 2024/07/29 22:22\n@abstract app\n@description\n@history\n\"\"\"\nfrom pathlib import Path\n\nAPP_DIR = Path(__file__).absolute().parent\n",
    "app/api/exceptions.py": "from typing import Any\n\nfrom app.api.status import Status\n\n\nclass CustomException(Exception):\n\n    def __init__(\n            self,\n            msg: str = None,\n            code: int = None,\n            data: Any = None,\n            status: Status = Status.FAILURE,\n    ):\n        self.msg = msg or status.msg\n        self.code = code or status.code\n        self.data = data\n        self.status = status\n\n    def __str__(self) -> str:\n        return f\"{self.code} {self.msg}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}: ({self.code!r}, {self.msg!r})>\"\n",
    "app/api/responses.py": "import json\nfrom typing import Mapping, get_type_hints, Any\n\nfrom fastapi.encoders import jsonable_encoder\nfrom starlette.background import BackgroundTask\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, StreamingResponse, ContentStream\nfrom toollib.utils import map_jsontype\n\nfrom app.api.status import Status\n\n\nclass Responses:\n\n    @staticmethod\n    def success(\n            data: dict | list | str | None = None,\n            msg: str = None,\n            code: int = None,\n            status: Status = Status.SUCCESS,\n            is_encode_data: bool = False,\n            request: Request = None,\n            status_code: int = 200,\n            headers: Mapping[str, str] | None = None,\n            media_type: str | None = None,\n            background: BackgroundTask | None = None,\n    ) -> JSONResponse:\n        content = {\n            \"msg\": msg or status.msg,\n            \"code\": code or status.code,\n            \"data\": Responses.encode_data(data) if is_encode_data else data,\n        }\n        if request:\n            if request_id := getattr(request.state, 'request_id', None):\n                content[\"request_id\"] = request_id\n        return JSONResponse(\n            content=content,\n            status_code=status_code,\n            headers=headers,\n            media_type=media_type,\n            background=background,\n        )\n\n    @staticmethod\n    def failure(\n            msg: str = None,\n            code: int = None,\n            error: str | Exception | None = None,\n            data: dict | list | str | None = None,\n            status: Status = Status.FAILURE,\n            is_encode_data: bool = False,\n            request: Request = None,\n            status_code: int = 200,\n            headers: Mapping[str, str] | None = None,\n            media_type: str | None = None,\n            background: BackgroundTask | None = None,\n    ) -> JSONResponse:\n        content = {\n            \"msg\": msg or status.msg,\n            \"code\": code or status.code,\n            \"error\": str(error) if error else None,\n            \"data\": Responses.encode_data(data) if is_encode_data else data,\n        }\n        if request:\n            if request_id := getattr(request.state, 'request_id', None):\n                content[\"request_id\"] = request_id\n        return JSONResponse(\n            content=content,\n            status_code=status_code,\n            headers=headers,\n            media_type=media_type,\n            background=background,\n        )\n\n    @staticmethod\n    def encode_data(data: Any) -> Any:\n        if data is None or isinstance(data, (str, int, float, bool)):\n            return data\n        if isinstance(data, (dict, list)):\n            try:\n                json.dumps(data)\n                return data\n            except (TypeError, OverflowError):\n                pass\n        return jsonable_encoder(data)\n\n    @staticmethod\n    def stream(\n            content: ContentStream,\n            status_code: int = 200,\n            headers: Mapping[str, str] | None = None,\n            media_type: str | None = None,\n            background: BackgroundTask | None = None,\n    ) -> StreamingResponse:\n        return StreamingResponse(\n            content=content,\n            status_code=status_code,\n            headers=headers,\n            media_type=media_type,\n            background=background,\n        )\n\n\ndef response_docs(\n        model=None,  # \u6a21\u578b(BaseModel): \u81ea\u52a8\u4ece\u6a21\u578b\u4e2d\u89e3\u6790\u5b57\u6bb5\u4e0e\u7c7b\u578b\n        data: dict | str = None,  # \u6570\u636e(dict/str): \u76f4\u63a5\u7ed9\u5b9a\u5b57\u6bb5\u4e0e\u7c7b\u578b/\u7c7b\u578b\n        is_listwrap: bool = False,\n        listwrap_key: str = None,\n        listwrap_key_extra: dict = None,\n        docs_extra: dict = None,\n):\n    \"\"\"\u54cd\u5e94\u6587\u6863\"\"\"\n\n    def _data_from_model(model_, default: str = \"\u672a\u77e5\") -> dict:\n        \"\"\"\u6570\u636e\u6a21\u677f\"\"\"\n        data_ = {}\n        if hasattr(model_, \"response_fields\"):\n            all_fields = set(model_.response_fields())\n        else:\n            all_fields = set(model_.model_fields.keys())\n        type_hints = get_type_hints(model_)\n        for field_name in all_fields:\n            try:\n                t = type_hints.get(field_name)\n                t = str(t).replace(\"<class '\", \"\").replace(\"'>\", \"\") if t else default\n            except Exception:\n                t = default\n            data_[field_name] = t\n        return data_\n\n    final_data = {}\n    if model:\n        final_data = _data_from_model(model)\n    if data:\n        if isinstance(data, dict):\n            final_data.update(data)\n        else:\n            final_data = data\n    if is_listwrap:\n        final_data = [final_data] if not isinstance(final_data, list) else final_data\n        if listwrap_key:\n            final_data = {listwrap_key: final_data}\n            if listwrap_key_extra:\n                final_data.update(listwrap_key_extra)\n\n    def _format_value(value):\n        if isinstance(value, str):\n            _value = value.split(\"|\")\n            if len(_value) > 1:\n                return \" | \".join([map_jsontype(_v.strip(), is_keep_integer=True) for _v in _value])\n            return map_jsontype(value, is_keep_integer=True)\n        elif isinstance(value, dict):\n            return {k: _format_value(v) for k, v in value.items()}\n        elif isinstance(value, (list, tuple)):\n            return [_format_value(item) for item in value]\n        else:\n            return str(value)\n\n    format_data = _format_value(final_data)\n\n    docs = {\n        200: {\n            \"description\": \"\u64cd\u4f5c\u6210\u529f\u3010code\u4e3a0 & http\u72b6\u6001\u7801200\u3011\",\n            \"content\": {\n                \"application/json\": {\n                    \"example\": {\n                        \"msg\": \"string\",\n                        \"code\": \"integer\",\n                        \"data\": format_data or \"object | array | ...\",\n                        \"request_id\": \"string\",\n                    }\n                }\n            }\n        },\n        422: {\n            \"description\": \"\u64cd\u4f5c\u5931\u8d25\u3010code\u975e0 & http\u72b6\u6001\u7801200\u3011\",\n            \"content\": {\n                \"application/json\": {\n                    \"example\": {\n                        \"msg\": \"string\",\n                        \"code\": \"integer\",\n                        \"error\": \"string\",\n                        \"data\": \"object | array | ...\",\n                        \"request_id\": \"string\",\n                    }\n                }\n            }\n        },\n    }\n    if docs_extra:\n        docs.update(docs_extra)\n    return docs\n",
    "app/api/status.py": "from enum import Enum\n\n\nclass Status(Enum):\n    SUCCESS = (0, '\u64cd\u4f5c\u6210\u529f')\n    FAILURE = (1, '\u64cd\u4f5c\u5931\u8d25')\n\n    PARAMS_ERROR = (400, '\u53c2\u6570\u9519\u8bef')\n    UNAUTHORIZED_ERROR = (401, '\u8ba4\u8bc1\u5931\u8d25')\n    FORBIDDEN_ERROR = (403, '\u65e0\u6743\u9650')\n    # \u5efa\u8bae\uff1a\u4e1a\u52a1\u6a21\u5757\u9519\u8bef\u7801\u4ece10000\u5f00\u59cb\n    RECORD_NOT_EXIST_ERROR = (10000, '\u8bb0\u5f55\u4e0d\u5b58\u5728')\n    RECORD_EXISTS_ERROR = (10001, '\u8bb0\u5f55\u5df2\u5b58\u5728')\n    USER_OR_PASSWORD_ERROR = (10002, '\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef')\n\n    @property\n    def code(self):\n        return self.value[0]\n\n    @property\n    def msg(self):\n        return self.value[1]\n\n    @classmethod\n    def collect_status(cls):\n        text = \"\"\n        for s in cls:\n            text += f\"{s.code} {s.msg}\\n\"\n        return text\n",
    "app/api/__init__.py": "\"\"\"\napi\n\"\"\"\nimport importlib\nimport sys\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, APIRouter\nfrom loguru import logger\n\nfrom app import APP_DIR\n\n_API_MOD_DIR = APP_DIR.joinpath(\"api\")\n_API_MOD_BASE = \"app.api\"\n\n\ndef register_routers(\n        app: FastAPI,\n        mod_dir: Path = _API_MOD_DIR,\n        mod_base: str = _API_MOD_BASE,\n        name: str = \"router\",\n        prefix: str = \"\",\n        depth: int = 0,\n        max_depth: int = 2\n):\n    \"\"\"\n    \u6ce8\u518c\u8def\u7531\n    \u8981\u6c42\uff1a\n        \u8def\u7531\u6a21\u5757\uff1a\u975e'__'\u5f00\u5934\u7684\u6a21\u5757\n        \u8def\u7531\u540d\u79f0\uff1a{name}\n    :param app: FastAPI\u5e94\u7528\n    :param mod_dir: api\u6a21\u5757\u76ee\u5f55\n    :param mod_base: api\u6a21\u5757\u57fa\u7840\n    :param name: \u8def\u7531\u540d\u79f0\n    :param prefix: url\u524d\u7f00\n    :param depth: \u5f53\u524d\u9012\u5f52\u6df1\u5ea6\n    :param max_depth: \u6700\u5927\u9012\u5f52\u6df1\u5ea6\n    \"\"\"\n    if depth > max_depth:\n        return\n    for item in mod_dir.iterdir():\n        if item.name.startswith(\"__\"):\n            continue\n        if item.is_dir():\n            new_mod_dir = item\n            new_mod_base = f\"{mod_base}.{item.name}\"\n            new_prefix = prefix\n            try:\n                mod = importlib.import_module(new_mod_base)\n                _prefix = getattr(mod, \"_prefix\", None)\n                if _prefix:\n                    new_prefix = f\"{new_prefix}/{_prefix}\"\n            except ImportError:\n                logger.error(f\"Register router failed to import module: {new_mod_base}\")\n                continue\n            register_routers(\n                app=app,\n                mod_dir=new_mod_dir,\n                mod_base=new_mod_base,\n                prefix=new_prefix,\n                name=name,\n                depth=depth + 1,\n                max_depth=max_depth\n            )\n        elif item.is_file() and item.suffix == \".py\" and depth > 0:\n            mod_name = item.stem\n            final_mod = f\"{mod_base}.{mod_name}\"\n            try:\n                mod = importlib.import_module(final_mod)\n                if not getattr(mod, \"_active\", True):\n                    logger.info(f\"Register router skipping inactive module: {final_mod}\")\n                    sys.modules.pop(final_mod)\n                    continue\n                if router := getattr(mod, name, None):\n                    if isinstance(router, APIRouter):\n                        tag = getattr(mod, \"_tag\", None)\n                        if not tag:\n                            tag = item.parent.stem if depth > 1 else mod_name\n                        app.include_router(\n                            router=router,\n                            prefix=prefix.replace(\"//\", \"/\").rstrip(\"/\"),\n                            tags=[tag]\n                        )\n            except ImportError:\n                logger.error(f\"Register router failed to import module: {final_mod}\")\n                continue\n",
    "app/api/default/aping.py": "from fastapi import APIRouter\n\nfrom app_celery.producer.publisher import publish\n\nrouter = APIRouter()\n\n\n@router.get(\n    path=\"/aping\",\n    summary=\"aping\",\n)\ndef ping():\n    task_id = publish(\"ping\")\n    return f\"pong > {task_id}\"\n",
    "app/api/default/ping.py": "from fastapi import APIRouter\n\nrouter = APIRouter()\n\n\n@router.get(\n    path=\"/ping\",\n    summary=\"ping\",\n)\ndef ping():\n    return \"pong\"\n",
    "app/api/default/__init__.py": "\"\"\"\napi-default\n\"\"\"\n\n_prefix = \"/api\"\n",
    "app/api/v1/user.py": "import traceback\n\nfrom fastapi import APIRouter, Depends\nfrom starlette.requests import Request\n\nfrom app.api.responses import Responses, response_docs\nfrom app.api.status import Status\nfrom app.initializer import g\nfrom app.initializer.dependencies import JWTUser, get_current_user\nfrom app.services.user import (\n    UserDetailSvc,\n    UserListSvc,\n    UserCreateSvc,\n    UserUpdateSvc,\n    UserDeleteSvc,\n    UserLoginSvc,\n    UserTokenSvc,\n)\n\nrouter = APIRouter()\n_active = True  # \u6fc0\u6d3b\u72b6\u6001\uff08\u9ed8\u8ba4\u6fc0\u6d3b\uff09\n_tag = \"user\"  # \u6807\u7b7e\uff08\u9ed8\u8ba4\u6a21\u5757\u540d\uff09\n\n\n# \u6ce8\u610f\uff1a`user`\u4ec5\u4e3a\u6a21\u5757\u793a\u4f8b\uff0c\u8bf7\u6839\u636e\u81ea\u8eab\u9700\u6c42\u4fee\u6539\n# \u6ce8\u610f\uff1a`user`\u4ec5\u4e3a\u6a21\u5757\u793a\u4f8b\uff0c\u8bf7\u6839\u636e\u81ea\u8eab\u9700\u6c42\u4fee\u6539\n# \u6ce8\u610f\uff1a`user`\u4ec5\u4e3a\u6a21\u5757\u793a\u4f8b\uff0c\u8bf7\u6839\u636e\u81ea\u8eab\u9700\u6c42\u4fee\u6539\n\n\n@router.get(\n    path=\"/user/{user_id}\",\n    summary=\"userDetail\",\n    responses=response_docs(\n        model=UserDetailSvc,\n    ),\n)\nasync def detail(\n        request: Request,\n        user_id: str,\n        current_user: JWTUser = Depends(get_current_user),  # \u8ba4\u8bc1\n):\n    try:\n        user_svc = UserDetailSvc(id=user_id)\n        data = await user_svc.detail()\n        if not data:\n            return Responses.failure(status=Status.RECORD_NOT_EXIST_ERROR)\n    except Exception as e:\n        g.logger.error(traceback.format_exc())\n        return Responses.failure(msg=\"userDetail\u5931\u8d25\", error=e, request=request)\n    return Responses.success(data=data, request=request)\n\n\n@router.get(\n    path=\"/user\",\n    summary=\"userList\",\n    responses=response_docs(\n        model=UserListSvc,\n        is_listwrap=True,\n        listwrap_key=\"items\",\n        listwrap_key_extra={\n            \"total\": \"int\",\n        },\n    ),\n)\nasync def lst(\n        request: Request,\n        page: int = 1,\n        size: int = 10,\n        current_user: JWTUser = Depends(get_current_user),\n):\n    try:\n        user_svc = UserListSvc(page=page, size=size)\n        data, total = await user_svc.lst()\n    except Exception as e:\n        g.logger.error(traceback.format_exc())\n        return Responses.failure(msg=\"userList\u5931\u8d25\", error=e, request=request)\n    return Responses.success(data={\"items\": data, \"total\": total}, request=request)\n\n\n@router.post(\n    path=\"/user\",\n    summary=\"userCreate\",\n    responses=response_docs(data={\n        \"id\": \"str\",\n    }),\n)\nasync def create(\n        request: Request,\n        user_svc: UserCreateSvc,\n):\n    try:\n        user_id = await user_svc.create()\n        if not user_id:\n            return Responses.failure(status=Status.RECORD_EXISTS_ERROR, request=request)\n    except Exception as e:\n        g.logger.error(traceback.format_exc())\n        return Responses.failure(msg=\"userCreate\u5931\u8d25\", error=e, request=request)\n    return Responses.success(data={\"id\": user_id}, request=request)\n\n\n@router.put(\n    path=\"/user/{user_id}\",\n    summary=\"userUpdate\",\n    responses=response_docs(data={\n        \"id\": \"str\",\n    }),\n)\nasync def update(\n        request: Request,\n        user_id: str,\n        user_svc: UserUpdateSvc,\n        current_user: JWTUser = Depends(get_current_user),\n):\n    try:\n        updated_ids = await user_svc.update(user_id)\n        if not updated_ids:\n            return Responses.failure(status=Status.RECORD_NOT_EXIST_ERROR, request=request)\n    except Exception as e:\n        g.logger.error(traceback.format_exc())\n        return Responses.failure(msg=\"userUpdate\u5931\u8d25\", error=e, request=request)\n    return Responses.success(data={\"id\": user_id}, request=request)\n\n\n@router.delete(\n    path=\"/user/{user_id}\",\n    summary=\"userDelete\",\n    responses=response_docs(data={\n        \"id\": \"str\",\n    }),\n)\nasync def delete(\n        request: Request,\n        user_id: str,\n        current_user: JWTUser = Depends(get_current_user),\n):\n    try:\n        user_svc = UserDeleteSvc()\n        deleted_ids = await user_svc.delete(user_id)\n        if not deleted_ids:\n            return Responses.failure(status=Status.RECORD_NOT_EXIST_ERROR, request=request)\n    except Exception as e:\n        g.logger.error(traceback.format_exc())\n        return Responses.failure(msg=\"userDelete\u5931\u8d25\", error=e, request=request)\n    return Responses.success(data={\"id\": user_id}, request=request)\n\n\n@router.post(\n    path=\"/user/login\",\n    summary=\"userLogin\",\n    responses=response_docs(data={\n        \"token\": \"str\",\n    }),\n)\nasync def login(\n        request: Request,\n        user_svc: UserLoginSvc,\n):\n    try:\n        data = await user_svc.login()\n        if not data:\n            return Responses.failure(status=Status.USER_OR_PASSWORD_ERROR, request=request)\n    except Exception as e:\n        g.logger.error(traceback.format_exc())\n        return Responses.failure(msg=\"userLogin\u5931\u8d25\", error=e, request=request)\n    return Responses.success(data={\"token\": data}, request=request)\n\n\n@router.post(\n    path=\"/user/token\",\n    summary=\"userToken\",\n    responses=response_docs(data={\n        \"token\": \"str\",\n    }),\n)\nasync def token(\n        request: Request,\n        user_svc: UserTokenSvc,\n        current_user: JWTUser = Depends(get_current_user),\n):\n    try:\n        data = await user_svc.token()\n        if not data:\n            return Responses.failure(status=Status.RECORD_NOT_EXIST_ERROR, request=request)\n    except Exception as e:\n        g.logger.error(traceback.format_exc())\n        return Responses.failure(msg=\"userToken\u5931\u8d25\", error=e, request=request)\n    return Responses.success(data={\"token\": data}, request=request)\n",
    "app/api/v1/__init__.py": "\"\"\"\napi-v1\n\"\"\"\n\n_prefix = \"/api/v1\"\n",
    "app/initializer/context.py": "from contextvars import ContextVar\n\nrequest_id_ctx_var: ContextVar[str] = ContextVar(\"request_id\", default=\"N/A\")\n",
    "app/initializer/dependencies.py": "from fastapi import Depends, Security\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials, APIKeyHeader\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom pydantic import BaseModel\nfrom starlette.requests import Request\n\nfrom app.api.exceptions import CustomException\nfrom app.api.status import Status\nfrom app.initializer import g\nfrom app.utils.db_async_util import sqlfetch_one\nfrom app.utils.jwt_util import verify_jwt\n\n\n# ======= jwt =======\n\nclass JWTUser(BaseModel):\n    # \u4e0e\u5b9e\u9645`user`\u5bf9\u9f50\n    id: str = None\n    phone: str = None\n    name: str = None\n    age: int = None\n    gender: int = None\n\n    @staticmethod\n    async def get_user_jwt_key(user_id: str) -> str:\n        # \u5efa\u8bae\uff1ajwt_key\u8fdb\u884credis\u7f13\u5b58\n        async with g.db_async_session() as session:\n            data = await sqlfetch_one(\n                session=session,\n                sql='SELECT jwt_key FROM \"user\" WHERE id = :id',  # noqa\n                params={\"id\": user_id},\n            )\n            return data.get(\"jwt_key\")\n\n\nclass JWTAuthorizationCredentials(HTTPAuthorizationCredentials):\n    jwt_user: JWTUser\n\n\nclass JWTBearer(HTTPBearer):\n\n    async def __call__(\n            self, request: Request\n    ) -> JWTAuthorizationCredentials | None:\n        authorization = request.headers.get(\"Authorization\")\n        scheme, credentials = get_authorization_scheme_param(authorization)\n        if not (authorization and scheme and credentials):\n            if self.auto_error:\n                raise CustomException(\n                    msg=\"Not authenticated\",\n                    status=Status.UNAUTHORIZED_ERROR,\n                )\n            else:\n                return None\n        if scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise CustomException(\n                    msg=\"Invalid authentication credentials\",\n                    status=Status.UNAUTHORIZED_ERROR,\n                )\n            else:\n                return None\n        jwt_user = await self.verify_credentials(credentials)\n        return JWTAuthorizationCredentials(scheme=scheme, credentials=credentials, jwt_user=jwt_user)\n\n    async def verify_credentials(self, credentials: str) -> JWTUser:\n        playload = await self._verify_jwt(credentials)\n        if playload is None:\n            raise CustomException(status=Status.UNAUTHORIZED_ERROR)\n        user_jwt_key = await JWTUser.get_user_jwt_key(playload.get(\"id\"))\n        if not user_jwt_key:\n            raise CustomException(status=Status.UNAUTHORIZED_ERROR)\n        await self._verify_jwt(credentials, jwt_key=user_jwt_key)\n        return JWTUser(\n            id=playload.get(\"id\"),\n            phone=playload.get(\"phone\"),\n            name=playload.get(\"name\"),\n            age=playload.get(\"age\"),\n            gender=playload.get(\"gender\"),\n        )\n\n    @staticmethod\n    async def _verify_jwt(token: str, jwt_key: str = None) -> dict:\n        try:\n            return verify_jwt(token=token, jwt_key=jwt_key)\n        except Exception as e:\n            raise CustomException(status=Status.UNAUTHORIZED_ERROR, msg=str(e))\n\n\ndef get_current_user(\n        credentials: JWTAuthorizationCredentials | None = Depends(JWTBearer(auto_error=True))\n) -> JWTUser:\n    if not credentials:\n        return JWTUser()\n    return credentials.jwt_user\n\n\n# ======= api key =======\n\n_API_KEY_HEADER = APIKeyHeader(name=\"X-API-Key\", auto_error=False)\n\n\nclass ApiKeyUser(BaseModel):\n\n    @staticmethod\n    def get_user_api_key(user_id: str = None) -> list:\n        if user_id:\n            return g.config.api_keys.get(user_id)\n        return g.config.api_keys\n\n\nasync def get_current_api_key(api_key: str | None = Security(_API_KEY_HEADER)):\n    if not api_key:\n        raise CustomException(status=Status.FORBIDDEN_ERROR)\n    user_api_key = ApiKeyUser.get_user_api_key()\n    if not user_api_key:\n        raise CustomException(status=Status.UNAUTHORIZED_ERROR)\n    if api_key not in user_api_key:\n        raise CustomException(status=Status.UNAUTHORIZED_ERROR)\n    return api_key\n",
    "app/initializer/_conf.py": "import os\nfrom pathlib import Path\n\nimport yaml\nfrom dotenv import load_dotenv\nfrom toollib.utils import get_cls_attrs, parse_variable\n\nfrom app import APP_DIR\n\n_CONFIG_DIR = APP_DIR.parent.joinpath(\"config\")\n\nload_dotenv(dotenv_path=os.environ.setdefault(\n    key=\"env_path\",\n    value=str(_CONFIG_DIR.joinpath(\".env\")))\n)\n# #\napp_yaml = Path(\n    os.environ.get(\"app_yaml\") or\n    _CONFIG_DIR.joinpath(f\"app_{os.environ.setdefault(key='app_env', value='dev')}.yaml\")\n)\nif not app_yaml.is_file():\n    raise RuntimeError(f\"\u914d\u7f6e\u6587\u4ef6\u4e0d\u5b58\u5728\uff1a{app_yaml}\")\n\n\nclass Config:\n    \"\"\"\u914d\u7f6e\"\"\"\n    _yaml_conf: dict = None\n    # from env\n    app_env: str = \"dev\"\n    app_yaml: str = app_yaml.name\n    api_keys: list = []\n    snow_datacenter_id: int = None\n    # from yaml\n    app_title: str = \"xApp\"\n    app_summary: str = \"xxApp\"\n    app_description: str = \"xxxApp\"\n    app_version: str = \"1.0.0\"\n    app_debug: bool = True\n    app_log_dir: str = \"./logs\"\n    app_disable_docs: bool = True\n    app_allow_origins: list = [\"*\"]\n    # #\n    redis_host: str = None\n    redis_port: int = None\n    redis_db: int = None\n    redis_password: str = None\n    redis_max_connections: int = None\n    db_url: str = None\n    db_async_url: str = None\n\n    def setup(self):\n        self.setattr_from_env_or_yaml()\n        return self\n\n    def setattr_from_env_or_yaml(self):\n        cls_attrs = get_cls_attrs(Config)\n        for k, item in cls_attrs.items():\n            v_type, v = item\n            if callable(v_type):\n                if k in os.environ:  # \u4f18\u5148\u73af\u5883\u53d8\u91cf\n                    v = parse_variable(k=k, v_type=v_type, v_from=os.environ, default=v)\n                else:\n                    v = parse_variable(k=k, v_type=v_type, v_from=self.load_yaml(), default=v)\n            setattr(self, k, v)\n\n    def load_yaml(self, reload: bool = False) -> dict:\n        if self._yaml_conf and not reload:\n            return self._yaml_conf\n        with open(app_yaml, mode=\"r\", encoding=\"utf-8\") as file:\n            self._yaml_conf = yaml.load(file, Loader=yaml.FullLoader)\n            return self._yaml_conf\n\n\ndef init_config() -> Config:\n    return Config().setup()\n",
    "app/initializer/_db.py": "import asyncio\nimport importlib\nimport re\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker, scoped_session\nfrom sqlalchemy.orm.decl_api import DeclarativeAttributeIntercept\n\nfrom app import APP_DIR\n\n_MODELS_MOD_DIR = APP_DIR.joinpath(\"models\")\n_MODELS_MOD_BASE = \"app.models\"\n_DECL_BASE_NAME = \"DeclBase\"\n_TABLES_CREATED = False\n\n\ndef init_db_session(\n        db_url: str,\n        db_echo: bool,\n        db_pool_size: int = 10,\n        db_max_overflow: int = 5,\n        db_pool_recycle: int = 3600,\n        is_create_tables: bool = False,\n) -> scoped_session:\n    db_echo = db_echo or False\n    kwargs = {\n        \"pool_size\": db_pool_size,\n        \"max_overflow\": db_max_overflow,\n        \"pool_recycle\": db_pool_recycle,\n    }\n    if db_url.startswith(\"sqlite\"):\n        kwargs = {}\n    engine = create_engine(\n        url=db_url,\n        echo=db_echo,\n        echo_pool=db_echo,\n        **kwargs,\n    )\n    db_session = sessionmaker(engine, expire_on_commit=False)\n\n    def create_tables():\n        decl_base = _import_tables()\n        if decl_base:\n            try:\n                decl_base.metadata.create_all(engine)  # noqa\n            except Exception as e:\n                if \"already exists\" not in str(e):\n                    raise\n\n    global _TABLES_CREATED\n    if is_create_tables and not _TABLES_CREATED:\n        create_tables()\n        _TABLES_CREATED = True\n\n    return scoped_session(db_session)\n\n\ndef init_db_async_session(\n        db_url: str,\n        db_echo: bool,\n        db_pool_size: int = 10,\n        db_max_overflow: int = 5,\n        db_pool_recycle: int = 3600,\n        is_create_tables: bool = False,\n) -> sessionmaker:\n    db_echo = db_echo or False\n    kwargs = {\n        \"pool_size\": db_pool_size,\n        \"max_overflow\": db_max_overflow,\n        \"pool_recycle\": db_pool_recycle,\n    }\n    if db_url.startswith(\"sqlite\"):\n        kwargs = {}\n    async_engine = create_async_engine(\n        url=db_url,\n        echo=db_echo,\n        echo_pool=db_echo,\n        **kwargs,\n    )\n    db_async_session = sessionmaker(async_engine, class_=AsyncSession, expire_on_commit=False)  # noqa\n\n    async def create_tables():\n        decl_base = _import_tables()\n        if decl_base:\n            async with async_engine.begin() as conn:\n                try:\n                    await conn.run_sync(decl_base.metadata.create_all)  # noqa\n                except Exception as e:\n                    if \"already exists\" not in str(e):\n                        raise\n\n    global _TABLES_CREATED\n    if is_create_tables and not _TABLES_CREATED:\n        try:\n            loop = asyncio.get_running_loop()\n        except RuntimeError:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n        task = loop.create_task(create_tables())\n        task.add_done_callback(lambda t: t.result() if not t.cancelled() else None)\n        if not loop.is_running():\n            loop.run_until_complete(task)\n        _TABLES_CREATED = True\n    return db_async_session\n\n\ndef _import_tables() -> DeclarativeAttributeIntercept | None:\n    decl_base = getattr(importlib.import_module(_MODELS_MOD_BASE), _DECL_BASE_NAME, None)\n    if isinstance(decl_base, DeclarativeAttributeIntercept):\n        pat = re.compile(rf\"^\\s*class\\s+[A-Za-z_]\\w*\\s*\\(\\s*{_DECL_BASE_NAME}\\s*\\)\\s*:\", re.MULTILINE)\n        for f in _MODELS_MOD_DIR.rglob(\"*.py\"):\n            if f.name.startswith(\"__\"):\n                continue\n            if pat.search(f.read_text(\"utf-8\")):\n                rel = f.relative_to(_MODELS_MOD_DIR).with_suffix(\"\")\n                _ = importlib.import_module(f\"{_MODELS_MOD_BASE}.{'.'.join(rel.parts)}\")\n        return decl_base\n",
    "app/initializer/_log.py": "import os\nimport sys\nfrom pathlib import Path\n\nfrom loguru import logger\nfrom loguru._logger import Logger  # noqa\n\nfrom app.initializer.context import request_id_ctx_var\n\n_LOG_CONSOLE_FORMAT = \"{time:YYYY-MM-DD HH:mm:ss.SSS} {level} {extra[request_id]} {file}:{line} {message}\"\n_LOG_FILE_FORMAT = \"{time:YYYY-MM-DD HH:mm:ss.SSS} {level} {extra[request_id]} {file}:{line} {message}\"\n_LOG_FILE_PREFIX = \"app\"\n_LOG_ROTATION = \"100 MB\"\n_LOG_RETENTION = \"15 days\"\n_LOG_COMPRESSION = None\n_LOG_ENQUEUE = True\n_LOG_BACKTRACE = False\n_LOG_DIAGNOSE = False\n_LOG_CATCH = False\n_LOG_PID = False\n\n\ndef init_logger(\n        debug: bool,\n        log_dir: str = None,\n) -> Logger:\n    logger.remove(None)\n    _lever = \"DEBUG\" if debug else \"INFO\"\n\n    def _filter(record: dict) -> bool:\n        record[\"extra\"][\"request_id\"] = request_id_ctx_var.get()\n        return True\n\n    logger.add(\n        sys.stdout,\n        format=_LOG_CONSOLE_FORMAT,\n        level=_lever,\n        enqueue=_LOG_ENQUEUE,\n        backtrace=_LOG_BACKTRACE,\n        diagnose=_LOG_DIAGNOSE,\n        catch=_LOG_CATCH,\n        filter=_filter,\n    )\n    if log_dir:\n        _log_dir = Path(log_dir)\n        _log_access_file = _log_dir.joinpath(f\"{_LOG_FILE_PREFIX}-access.log\")\n        _log_error_file = _log_dir.joinpath(f\"{_LOG_FILE_PREFIX}-error.log\")\n        if _LOG_PID:\n            _log_access_file = str(_log_access_file).replace(\".log\", f\".{os.getpid()}.log\")\n            _log_error_file = str(_log_error_file).replace(\".log\", f\".{os.getpid()}.log\")\n        logger.add(\n            _log_access_file,\n            encoding=\"utf-8\",\n            format=_LOG_FILE_FORMAT,\n            level=_lever,\n            rotation=_LOG_ROTATION,\n            retention=_LOG_RETENTION,\n            compression=_LOG_COMPRESSION,\n            enqueue=_LOG_ENQUEUE,\n            backtrace=_LOG_BACKTRACE,\n            diagnose=_LOG_DIAGNOSE,\n            catch=_LOG_CATCH,\n        )\n        logger.add(\n            _log_error_file,\n            encoding=\"utf-8\",\n            format=_LOG_FILE_FORMAT,\n            level=\"ERROR\",\n            rotation=_LOG_ROTATION,\n            retention=_LOG_RETENTION,\n            compression=_LOG_COMPRESSION,\n            enqueue=_LOG_ENQUEUE,\n            backtrace=_LOG_BACKTRACE,\n            diagnose=_LOG_DIAGNOSE,\n            catch=_LOG_CATCH,\n        )\n    return logger\n",
    "app/initializer/_redis.py": "from toollib.rediser import RedisClient\n\n\ndef init_redis_client(\n        host: str,\n        port: int,\n        db: int,\n        password: str = None,\n        max_connections: int = None,\n        **kwargs,\n) -> RedisClient:\n    if not host:\n        return RedisClient()\n    return RedisClient(\n        host=host,\n        port=port,\n        db=db,\n        password=password,\n        max_connections=max_connections,\n        **kwargs,\n    )\n",
    "app/initializer/_snow.py": "import os\nimport sys\nfrom datetime import datetime\n\nfrom toollib.guid import SnowFlake\nfrom toollib.rediser import RedisClient\nfrom toollib.utils import localip\n\n_CACHE_KEY_SNOW_WORKER_ID_INCR = \"config:snow_worker_id_incr\"\n_CACHE_KEY_SNOW_DATACENTER_ID_INCR = \"config:snow_datacenter_id_incr\"\n_CACHE_EXPIRE_SNOW = 120\n\n\ndef init_snow_client(\n        redis_client: RedisClient,\n        datacenter_id: int = None,\n        to_str: bool = True,\n) -> SnowFlake:  # \u5efa\u8bae\uff1a\u91c7\u7528\u670d\u52a1\u7684\u65b9\u5f0f\u8c03\u7528api\u83b7\u53d6\n    if datacenter_id is None:\n        datacenter_id = _snow_incr(redis_client, _CACHE_KEY_SNOW_DATACENTER_ID_INCR, _CACHE_EXPIRE_SNOW)\n        if datacenter_id is None:\n            local_ip = localip()\n            if local_ip:\n                ip_parts = list(map(int, local_ip.split('.')))\n                ip_int = (ip_parts[0] << 24) + (ip_parts[1] << 16) + (ip_parts[2] << 8) + ip_parts[3]\n                datacenter_id = ip_int % 32\n    worker_id = _snow_incr(redis_client, _CACHE_KEY_SNOW_WORKER_ID_INCR, _CACHE_EXPIRE_SNOW)\n    if worker_id is None:\n        worker_id = os.getpid() % 32\n    return SnowFlake(worker_id=worker_id, datacenter_id=datacenter_id, to_str=to_str)\n\n\ndef _snow_incr(redis_client, cache_key: str, cache_expire: int):\n    incr = None\n    try:\n        with redis_client.connection() as r:\n            resp = r.ping()\n            if resp:\n                lua_script = \"\"\"\n                    if redis.call('exists', KEYS[1]) == 1 then\n                        redis.call('expire', KEYS[1], ARGV[1])\n                        return redis.call('incr', KEYS[1])\n                    else\n                        redis.call('set', KEYS[1], 0)\n                        redis.call('expire', KEYS[1], ARGV[1])\n                        return 0\n                    end\n                    \"\"\"\n                incr = r.eval(lua_script, 1, cache_key, cache_expire)\n    except Exception as e:\n        sys.stderr.write(\n            f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S,%f')[:-3]} \"\n            f\"WARNING initializer \"\n            f\"snow\u521d\u59cb\u5316id\u5c06\u91c7\u7528\u672c\u5730\u65b9\u5f0f\uff0c\u7531\u4e8e\uff08{e}\uff09\"\n            f\"\\n\"\n        )\n    return incr\n",
    "app/initializer/__init__.py": "\"\"\"\n\u521d\u59cb\u5316\n\"\"\"\nimport sys\nimport threading\nfrom datetime import datetime\nfrom functools import cached_property\n\nfrom loguru._logger import Logger  # noqa\nfrom sqlalchemy.orm import sessionmaker, scoped_session\nfrom toollib.guid import SnowFlake\nfrom toollib.rediser import RedisClient\nfrom toollib.utils import Singleton\n\nfrom app.initializer._conf import Config, init_config\nfrom app.initializer._db import init_db_session, init_db_async_session\nfrom app.initializer._log import init_logger\nfrom app.initializer._redis import init_redis_client\nfrom app.initializer._snow import init_snow_client\n\n\nclass G(metaclass=Singleton):\n    \"\"\"\n    \u5168\u5c40\u53d8\u91cf\n    \"\"\"\n    _initialized = False\n    _init_lock = threading.Lock()\n    _init_properties = [\n        'config',\n        'logger',\n        'redis_client',\n        'snow_client',\n        # 'db_session',\n        'db_async_session',\n    ]\n\n    def __init__(self):\n        self._initialized = False\n\n    @cached_property\n    def config(self) -> Config:\n        return init_config()\n\n    @cached_property\n    def logger(self) -> Logger:\n        return init_logger(\n            debug=self.config.app_debug,\n            log_dir=self.config.app_log_dir,\n        )\n\n    @cached_property\n    def redis_client(self) -> RedisClient:\n        return init_redis_client(\n            host=self.config.redis_host,\n            port=self.config.redis_port,\n            db=self.config.redis_db,\n            password=self.config.redis_password,\n            max_connections=self.config.redis_max_connections,\n        )\n\n    @cached_property\n    def snow_client(self) -> SnowFlake:\n        return init_snow_client(\n            redis_client=self.redis_client,\n            datacenter_id=self.config.snow_datacenter_id,\n        )\n\n    @cached_property\n    def db_session(self) -> scoped_session:\n        return init_db_session(\n            db_url=self.config.db_url,\n            db_echo=self.config.app_debug,\n            is_create_tables=True,\n        )\n\n    @cached_property\n    def db_async_session(self) -> sessionmaker:\n        return init_db_async_session(\n            db_url=self.config.db_async_url,\n            db_echo=self.config.app_debug,\n            is_create_tables=True,\n        )\n\n    def setup(self):\n        with self._init_lock:\n            if not self._initialized:\n                for prop_name in self._init_properties:\n                    if hasattr(self, prop_name):\n                        getattr(self, prop_name)\n                    else:\n                        sys.stderr.write(\n                            f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S,%f')[:-3]} \"\n                            f\"WARNING initializer \"\n                            f\"{prop_name} not found\"\n                            f\"\\n\"\n                        )\n                self._initialized = True\n\n\ng = G()\n",
    "app/middleware/cors.py": "from fastapi.middleware.cors import CORSMiddleware\n\nfrom app.initializer import g\n\n\nclass Cors:\n    middleware_class = CORSMiddleware\n    allow_origins = g.config.app_allow_origins\n    allow_credentials = True\n    allow_methods = [\"*\"]\n    allow_headers = [\"*\"]\n",
    "app/middleware/exceptions.py": "import traceback\n\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\n\nfrom app.api.exceptions import CustomException\nfrom app.api.responses import Responses\nfrom app.api.status import Status\nfrom app.initializer import g\n\n\nclass ExceptionsHandler:\n\n    @staticmethod\n    async def custom_exception_handler(\n            request: Request,\n            exc: CustomException,\n            is_traceback: bool = False,\n    ) -> JSONResponse:\n        lmsg = f'- \"{request.method} {request.url.path}\" {exc.code} {exc.msg}'\n        if is_traceback:\n            lmsg = traceback.format_exc()\n        g.logger.error(lmsg)\n        return Responses.failure(\n            msg=exc.msg,\n            code=exc.code,\n            data=exc.data,\n            request=request,\n        )\n\n    @staticmethod\n    async def http_exception_handler(\n            request: Request,\n            exc: HTTPException,\n            is_traceback: bool = False,\n    ) -> JSONResponse:\n        lmsg = f'- \"{request.method} {request.url.path}\" {exc.status_code} {exc.detail}'\n        if is_traceback:\n            lmsg = traceback.format_exc()\n        g.logger.error(lmsg)\n        return Responses.failure(\n            msg=exc.detail,\n            code=exc.status_code,\n            request=request,\n        )\n\n    @staticmethod\n    async def validation_exception_handler(\n            request: Request,\n            exc: RequestValidationError,\n            is_display_all: bool = False,\n            is_traceback: bool = False,\n    ) -> JSONResponse:\n        if is_display_all:\n            msg = \", \".join([f\"'{item['loc'][1] if len(item['loc']) > 1 else item['loc'][0]}' {item['msg'].lower()}\" for item in exc.errors()])  # noqa: E501\n        else:\n            _first_error = exc.errors()[0]\n            msg = f\"'{_first_error['loc'][1] if len(_first_error['loc']) > 1 else _first_error['loc'][0]}' {_first_error['msg'].lower()}\"  # noqa: E501\n        lmsg = f'- \"{request.method} {request.url.path}\" {Status.PARAMS_ERROR.code} {msg}'\n        if is_traceback:\n            lmsg = traceback.format_exc()\n        g.logger.error(lmsg)\n        return Responses.failure(\n            msg=msg,\n            status=Status.PARAMS_ERROR,\n            request=request,\n        )\n",
    "app/middleware/headers.py": "import uuid\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\n\nfrom app.initializer.context import request_id_ctx_var\n\n\nclass HeadersMiddleware(BaseHTTPMiddleware):\n    \"\"\"\u5934\u5904\u7406\u4e2d\u95f4\u4ef6\"\"\"\n    _HEADERS = {\n        # \u53ef\u6dfb\u52a0\u76f8\u5173\u5934\n    }\n\n    async def dispatch(self, request: Request, call_next):\n        request_id = self._get_or_create_request_id(request)\n        request.state.request_id = request_id\n        ctx_token = request_id_ctx_var.set(request_id)\n        try:\n            response = await call_next(request)\n            response.headers[\"X-Request-ID\"] = request_id\n            for key, value in self._HEADERS.items():\n                if key not in response.headers:\n                    response.headers[key] = value\n            return response\n        finally:\n            request_id_ctx_var.reset(ctx_token)\n\n    @staticmethod\n    def _get_or_create_request_id(request: Request) -> str:\n        request_id = request.headers.get(\"X-Request-ID\")\n        if not request_id:\n            request_id = f\"req-{uuid.uuid4()}\"\n        return request_id\n",
    "app/middleware/__init__.py": "\"\"\"\n\u4e2d\u95f4\u4ef6\n\"\"\"\nfrom fastapi import FastAPI\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException\n\nfrom app.api.exceptions import CustomException\nfrom app.middleware.cors import Cors\nfrom app.middleware.exceptions import ExceptionsHandler\nfrom app.middleware.headers import HeadersMiddleware\n\n\ndef register_middlewares(app: FastAPI):\n    \"\"\"\u6ce8\u518c\u4e2d\u95f4\u4ef6\"\"\"\n    app.add_middleware(HeadersMiddleware)  # type: ignore\n    app.add_middleware(\n        middleware_class=Cors.middleware_class,\n        allow_origins=Cors.allow_origins,\n        allow_credentials=Cors.allow_credentials,\n        allow_methods=Cors.allow_methods,\n        allow_headers=Cors.allow_headers,\n    )\n    app.add_exception_handler(CustomException, ExceptionsHandler.custom_exception_handler)  # type: ignore\n    app.add_exception_handler(HTTPException, ExceptionsHandler.http_exception_handler)  # type: ignore\n    app.add_exception_handler(RequestValidationError, ExceptionsHandler.validation_exception_handler)  # type: ignore\n",
    "app/models/user.py": "from sqlalchemy import Column, BigInteger, Integer, String\nfrom toollib.utils import now2timestamp\n\nfrom app.initializer import g\nfrom app.models import DeclBase\n\n\nclass User(DeclBase):\n    __tablename__ = \"user\"\n\n    id = Column(String(20), primary_key=True, default=g.snow_client.gen_uid, comment=\"\u4e3b\u952e\")\n    phone = Column(String(15), unique=True, index=True, nullable=False, comment=\"\u624b\u673a\u53f7\")\n    password = Column(String(128), nullable=True, comment=\"\u5bc6\u7801\")\n    jwt_key = Column(String(128), nullable=True, comment=\"jwtKey\")\n    name = Column(String(50), nullable=True, comment=\"\u540d\u79f0\")\n    age = Column(Integer, nullable=True, comment=\"\u5e74\u9f84\")\n    gender = Column(Integer, nullable=True, comment=\"\u6027\u522b\")\n    created_at = Column(BigInteger, default=now2timestamp, comment=\"\u521b\u5efa\u65f6\u95f4\")\n    updated_at = Column(BigInteger, default=now2timestamp, onupdate=now2timestamp, comment=\"\u66f4\u65b0\u65f6\u95f4\")\n",
    "app/models/__init__.py": "\"\"\"\n\u6570\u636e\u6a21\u578b\n\"\"\"\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass DeclBase(DeclarativeBase):\n    pass\n",
    "app/schemas/user.py": "import re\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, field_validator\n\nfrom app.schemas import filter_fields\n\n\nclass UserDetail(BaseModel):\n    id: str = Field(...)\n    # #\n    phone: str = None\n    name: str = None\n    age: int = None\n    gender: int = None\n    created_at: int = None\n    updated_at: int = None\n\n    @classmethod\n    def response_fields(cls):\n        return filter_fields(\n            cls,\n            exclude=[]\n        )\n\n\nclass UserList(BaseModel):\n    page: int = Field(1, ge=1)\n    size: int = Field(10, ge=1)\n    # #\n    id: str = None\n    phone: str = None\n    name: str = None\n    age: int = None\n    gender: int = None\n    created_at: int = None\n    updated_at: int = None\n\n    @classmethod\n    def response_fields(cls):\n        return filter_fields(\n            cls,\n            exclude=[\n                \"page\",\n                \"size\",\n            ]\n        )\n\n\nclass UserCreate(BaseModel):\n    phone: str = Field(..., pattern=r\"^1[3-9]\\d{9}$\")\n    password: str = Field(...)\n    name: str | None = Field(None)\n    age: int | None = Field(None, ge=0, le=200)\n    gender: Literal[1, 2] | None = Field(None)\n\n    @field_validator(\"password\")\n    def validate_password(cls, v):\n        if not re.match(r\"^(?=.*[A-Za-z])(?=.*\\d)\\S{6,20}$\", v):\n            raise ValueError(\"\u5bc6\u7801\u5fc5\u987b\u5305\u542b\u81f3\u5c11\u4e00\u4e2a\u5b57\u6bcd\u548c\u4e00\u4e2a\u6570\u5b57\uff0c\u957f\u5ea6\u4e3a6-20\u4f4d\u7684\u975e\u7a7a\u767d\u5b57\u7b26\u7ec4\u5408\")\n        return v\n\n    @field_validator(\"name\")\n    def validate_name(cls, v, info):\n        if not v and (phone := info.data.get(\"phone\")):\n            return f\"\u7528\u6237{phone[-4:]}\"\n        if v and not re.match(r\"^[\\u4e00-\\u9fffA-Za-z0-9_\\-.]{1,50}$\", v):\n            raise ValueError(\"\u540d\u79f0\u4ec5\u96501-50\u4f4d\u7684\u4e2d\u6587\u3001\u82f1\u6587\u3001\u6570\u5b57\u3001_-.\u7ec4\u5408\")\n        return v\n\n\nclass UserUpdate(BaseModel):\n    name: str | None = Field(None)\n    age: int | None = Field(None, ge=0, le=200)\n    gender: Literal[1, 2] | None = Field(None)\n\n    @field_validator(\"name\")\n    def validate_name(cls, v):\n        if v and not re.match(r\"^[\\u4e00-\\u9fffA-Za-z0-9_\\-.]{1,50}$\", v):\n            raise ValueError(\"\u540d\u79f0\u4ec5\u96501-50\u4f4d\u7684\u4e2d\u6587\u3001\u82f1\u6587\u3001\u6570\u5b57\u3001_-.\u7ec4\u5408\")\n        return v\n\n\nclass UserDelete(BaseModel):\n    pass\n\n\nclass UserLogin(BaseModel):\n    phone: str = Field(...)\n    password: str = Field(...)\n\n\nclass UserToken(BaseModel):\n    id: str = Field(...)\n    exp_minutes: int = Field(24 * 60 * 30, ge=1)\n",
    "app/schemas/__init__.py": "\"\"\"\n\u6570\u636e\u7ed3\u6784\n\"\"\"\n\n\ndef filter_fields(\n        model,\n        exclude: list = None,\n):\n    if exclude:\n        return list(set(model.model_fields.keys()) - set(exclude))\n    return list(model.model_fields.keys())\n",
    "app/services/user.py": "from app.initializer import g\nfrom app.models.user import User\nfrom app.schemas.user import (\n    UserDetail,\n    UserList,\n    UserCreate,\n    UserUpdate,\n    UserDelete,\n    UserLogin,\n    UserToken,\n)\nfrom app.utils import jwt_util, db_async_util\n\n\nclass UserDetailSvc(UserDetail):\n    model_config = {\n        \"json_schema_extra\": {\n            \"title\": \"UserDetail\"\n        }\n    }\n\n    async def detail(self):\n        async with g.db_async_session() as session:\n            data = await db_async_util.fetch_one(\n                session=session,\n                model=User,\n                fields=self.response_fields(),\n                filter_by={\"id\": self.id},\n            )\n            return data\n\n\nclass UserListSvc(UserList):\n    model_config = {\n        \"json_schema_extra\": {\n            \"title\": \"UserList\"\n        }\n    }\n\n    async def lst(self):\n        async with g.db_async_session() as session:\n            data = await db_async_util.fetch_all(\n                session=session,\n                model=User,\n                fields=self.response_fields(),\n                page=self.page,\n                size=self.size,\n            )\n            total = await db_async_util.fetch_total(session, User)\n            return data, total\n\n\nclass UserCreateSvc(UserCreate):\n    model_config = {\n        \"json_schema_extra\": {\n            \"title\": \"UserCreate\"\n        }\n    }\n\n    async def create(self):\n        async with g.db_async_session() as session:\n            return await db_async_util.create(\n                session=session,\n                model=User,\n                data={\n                    \"name\": self.name,\n                    \"phone\": self.phone,\n                    \"age\": self.age,\n                    \"gender\": self.gender,\n                    \"password\": jwt_util.hash_password(self.password),\n                    \"jwt_key\": jwt_util.gen_jwt_key(),\n                },\n                filter_by={\"phone\": self.phone},\n            )\n\n\nclass UserUpdateSvc(UserUpdate):\n    model_config = {\n        \"json_schema_extra\": {\n            \"title\": \"UserUpdate\"\n        }\n    }\n\n    async def update(self, user_id: str):\n        async with g.db_async_session() as session:\n            return await db_async_util.update(\n                session=session,\n                model=User,\n                data=self.model_dump(),\n                filter_by={\"id\": user_id},\n            )\n\n\nclass UserDeleteSvc(UserDelete):\n    model_config = {\n        \"json_schema_extra\": {\n            \"title\": \"UserDelete\"\n        }\n    }\n\n    @staticmethod\n    async def delete(user_id: str):\n        async with g.db_async_session() as session:\n            return await db_async_util.delete(\n                session=session,\n                model=User,\n                filter_by={\"id\": user_id},\n            )\n\n\nclass UserLoginSvc(UserLogin):\n    model_config = {\n        \"json_schema_extra\": {\n            \"title\": \"UserLogin\"\n        }\n    }\n\n    async def login(self):\n        async with g.db_async_session() as session:\n            data = await db_async_util.fetch_one(\n                session=session,\n                model=User,\n                filter_by={\"phone\": self.phone},\n            )\n            if not data or not jwt_util.verify_password(self.password, data.get(\"password\")):\n                return None\n            new_jwt_key = jwt_util.gen_jwt_key()\n            token = jwt_util.gen_jwt(\n                payload={\n                    \"id\": data.get(\"id\"),\n                    \"phone\": data.get(\"phone\"),\n                    \"name\": data.get(\"name\"),\n                    \"age\": data.get(\"age\"),\n                    \"gender\": data.get(\"gender\"),\n                },\n                jwt_key=new_jwt_key,\n                exp_minutes=24 * 60 * 30,\n            )\n            # \u66f4\u65b0jwt_key\n            await db_async_util.update(\n                session=session,\n                model=User,\n                data={\"jwt_key\": new_jwt_key},\n                filter_by={\"phone\": self.phone},\n            )\n            return token\n\n\nclass UserTokenSvc(UserToken):\n    model_config = {\n        \"json_schema_extra\": {\n            \"title\": \"UserToken\"\n        }\n    }\n\n    async def token(self):\n        async with g.db_async_session() as session:\n            data = await db_async_util.fetch_one(\n                session=session,\n                model=User,\n                filter_by={\"id\": self.id},\n            )\n            if not data:\n                return None\n            new_jwt_key = jwt_util.gen_jwt_key()\n            token = jwt_util.gen_jwt(\n                payload={\n                    \"id\": data.get(\"id\"),\n                    \"phone\": data.get(\"phone\"),\n                    \"name\": data.get(\"name\"),\n                    \"age\": data.get(\"age\"),\n                    \"gender\": data.get(\"gender\"),\n                },\n                jwt_key=new_jwt_key,\n                exp_minutes=self.exp_minutes,\n            )\n            # \u66f4\u65b0jwt_key\n            await db_async_util.update(\n                session=session,\n                model=User,\n                data={\"jwt_key\": new_jwt_key},\n                filter_by={\"id\": self.id},\n            )\n            return token\n",
    "app/services/__init__.py": "\"\"\"\n\u4e1a\u52a1\u903b\u8f91\n\"\"\"\n",
    "app/utils/api_key_util.py": "import secrets\n\n_API_KEY_LENGTH = 45\n\n\ndef gen_api_key(prefix: str = \"\", length: int = _API_KEY_LENGTH) -> str:\n    api_key = secrets.token_urlsafe(length)[:length]\n    if prefix:\n        return f\"{prefix}_{api_key}\"\n    return api_key\n",
    "app/utils/db_async_util.py": "from sqlalchemy import (\n    select,\n    func,\n    inspect,\n    text,\n    update as update_,\n    delete as delete_,\n)\n\n\ndef format_all(\n        rows,\n        fields: list[str],\n) -> list[dict]:\n    if not rows:\n        return list()\n    return [dict(zip(fields, row)) for row in rows]\n\n\ndef format_one(\n        row,\n        fields: list[str],\n) -> dict:\n    if not row:\n        return {}\n    return dict(zip(fields, row))\n\n\ndef model_dict(\n        model,\n        fields: list[str] = None,\n) -> dict:\n    if not model:\n        return {}\n    if not fields:\n        fields = [field.name for field in model.__table__.columns]\n    return {field: getattr(model, field) for field in fields}\n\n\nasync def fetch_one(\n        session,\n        model,\n        fields: list[str] = None,\n        filter_by: dict = None,\n) -> dict:\n    if not fields:\n        fields = [field.name for field in model.__table__.columns]\n    query = select(*[getattr(model, field) for field in fields if hasattr(model, field)]).select_from(model)\n    if filter_by:\n        query = query.filter_by(**filter_by)\n    result = await session.execute(query)\n    return format_one(result.fetchone(), fields)\n\n\nasync def fetch_all(\n        session,\n        model,\n        fields: list[str] = None,\n        filter_by: dict = None,\n        page: int = None,\n        size: int = None,\n) -> list[dict]:\n    if not fields:\n        fields = [field.name for field in model.__table__.columns]\n    query = select(*[getattr(model, field) for field in fields if hasattr(model, field)]).select_from(model)\n    if filter_by:\n        query = query.filter_by(**filter_by)\n    if page and size:\n        query = query.offset((page - 1) * size).limit(size)\n    result = await session.execute(query)\n    return format_all(result.fetchall(), fields)\n\n\nasync def fetch_total(\n        session,\n        model,\n        filter_by: dict = None,\n        column: str = None,\n) -> int:\n    if column is None:\n        primary_key = inspect(model).primary_key\n        if primary_key:\n            column = primary_key[0]\n        else:\n            column = 1\n    query = select(func.count(column)).select_from(model)\n    if filter_by:\n        query = query.filter_by(**filter_by)\n    result = await session.execute(query)\n    return result.scalar()\n\n\nasync def create(\n        session,\n        model,\n        data: dict,\n        filter_by: dict = None,\n) -> int:\n    try:\n        if filter_by:\n            result = await fetch_one(session, model, filter_by=filter_by)\n            if result:\n                return 0\n        stmt = model(**data)\n        session.add(stmt)\n        await session.commit()\n    except Exception:\n        await session.rollback()\n        raise\n    return stmt.id\n\n\nasync def update(\n        session,\n        model,\n        data: dict,\n        filter_by: dict | None,\n        is_exclude_none: bool = True,\n) -> list:\n    try:\n        if is_exclude_none:\n            data = {k: v for k, v in data.items() if v is not None}\n        stmt = update_(model).values(**data)\n        if filter_by:\n            stmt = stmt.filter_by(**filter_by)\n        if session.bind.dialect.name == \"postgresql\":\n            stmt = stmt.returning(model.id)\n            result = await session.execute(stmt)\n            updated_ids = [row[0] for row in result]\n        else:\n            query_stmt = select(model.id).filter_by(**filter_by)\n            result = await session.execute(query_stmt)\n            updated_ids = result.scalars().all()\n            if updated_ids:\n                await session.execute(stmt)\n        await session.commit()\n    except Exception:\n        await session.rollback()\n        raise\n    return updated_ids\n\n\nasync def delete(\n        session,\n        model,\n        filter_by: dict | None,\n) -> list:\n    try:\n        stmt = delete_(model)\n        if filter_by:\n            stmt = stmt.filter_by(**filter_by)\n        if session.bind.dialect.name == \"postgresql\":\n            stmt = stmt.returning(model.id)\n            result = await session.execute(stmt)\n            deleted_ids = [row[0] for row in result]\n        else:\n            query_stmt = select(model.id).filter_by(**filter_by)\n            result = await session.execute(query_stmt)\n            deleted_ids = result.scalars().all()\n            if deleted_ids:\n                await session.execute(stmt)\n        await session.commit()\n    except Exception:\n        await session.rollback()\n        raise\n    return deleted_ids\n\n\nasync def sqlfetch_one(\n        session,\n        sql: str,\n        params: dict = None,\n) -> dict:\n    result = await session.execute(text(sql), params)\n    row = result.fetchone()\n    if row is None:\n        return {}\n    return row._asdict()  # noqa\n\n\nasync def sqlfetch_all(\n        session,\n        sql: str,\n        params: dict = None,\n) -> list[dict]:\n    result = await session.execute(text(sql), params)\n    rows = result.fetchall()\n    return [row._asdict() for row in rows]  # noqa\n",
    "app/utils/jwt_util.py": "import secrets\nfrom datetime import datetime, timedelta\n\nimport bcrypt\nimport jwt\n\n_JWT_ALGORITHM = \"HS256\"\n\n\ndef gen_jwt(payload: dict, jwt_key: str, exp_minutes: int = 24 * 60 * 30, algorithm: str = _JWT_ALGORITHM):\n    payload.update({\"exp\": datetime.utcnow() + timedelta(minutes=exp_minutes)})\n    encoded_jwt = jwt.encode(payload=payload, key=jwt_key, algorithm=algorithm)\n    return encoded_jwt\n\n\ndef verify_jwt(token: str, jwt_key: str = None, algorithms: tuple = (_JWT_ALGORITHM,)) -> dict:\n    if not jwt_key:\n        return jwt.decode(jwt=token, options={\"verify_signature\": False})\n    return jwt.decode(jwt=token, key=jwt_key, algorithms=algorithms)\n\n\ndef gen_jwt_key():\n    return secrets.token_hex(16)\n\n\ndef hash_password(password: str) -> str:\n    salt = bcrypt.gensalt()\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\n    return hashed_password.decode('utf-8')\n\n\ndef verify_password(password: str, hashed_password: str) -> bool:\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))\n",
    "app/utils/__init__.py": "\"\"\"\nutils\n\"\"\"\n",
    "app_celery/conf.py": "import os\nfrom pathlib import Path\n\nimport yaml\nfrom dotenv import load_dotenv\nfrom toollib.utils import get_cls_attrs, parse_variable\n\nfrom app import APP_DIR\n\n_CONFIG_DIR = APP_DIR.parent.joinpath(\"config\")\n\nload_dotenv(dotenv_path=os.environ.setdefault(\n    key=\"env_path\",\n    value=str(_CONFIG_DIR.joinpath(\".env\")))\n)\n# #\napp_yaml = Path(\n    os.environ.get(\"app_yaml\") or\n    _CONFIG_DIR.joinpath(f\"app_{os.environ.setdefault(key='app_env', value='dev')}.yaml\")\n)\nif not app_yaml.is_file():\n    raise RuntimeError(f\"\u914d\u7f6e\u6587\u4ef6\u4e0d\u5b58\u5728\uff1a{app_yaml}\")\n\n\nclass Config:\n    \"\"\"\u914d\u7f6e\"\"\"\n    _yaml_conf: dict = None\n    yaml_name: str = app_yaml.name\n    #\n    celery_broker_url: str\n    celery_backend_url: str\n    celery_timezone: str = \"Asia/Shanghai\"\n    celery_enable_utc: bool = True\n    celery_task_serializer: str = \"json\"\n    celery_result_serializer: str = \"json\"\n    celery_accept_content: list = [\"json\"]\n    celery_task_ignore_result: bool = False\n    celery_result_expire: int = 86400\n    celery_task_track_started: bool = True\n    celery_worker_concurrency: int = 8\n    celery_worker_prefetch_multiplier: int = 2\n    celery_worker_max_tasks_per_child: int = 100\n    celery_broker_connection_retry_on_startup: bool = True\n    celery_task_reject_on_worker_lost: bool = True\n\n    def setup(self):\n        self.setattr_from_env_or_yaml()\n        return self\n\n    def setattr_from_env_or_yaml(self):\n        cls_attrs = get_cls_attrs(Config)\n        for k, item in cls_attrs.items():\n            v_type, v = item\n            if callable(v_type):\n                if k in os.environ:  # \u4f18\u5148\u73af\u5883\u53d8\u91cf\n                    v = parse_variable(k=k, v_type=v_type, v_from=os.environ, default=v)\n                else:\n                    v = parse_variable(k=k, v_type=v_type, v_from=self.load_yaml(), default=v)\n            setattr(self, k, v)\n\n    def load_yaml(self, reload: bool = False) -> dict:\n        if self._yaml_conf and not reload:\n            return self._yaml_conf\n        with open(app_yaml, mode=\"r\", encoding=\"utf-8\") as file:\n            self._yaml_conf = yaml.load(file, Loader=yaml.FullLoader)\n            return self._yaml_conf\n\n\nconfig = Config().setup()\n",
    "app_celery/README.md": "# app-celery\n\n## \u7b80\u4ecb\n\n### producer\uff1a\u751f\u4ea7\u8005\uff08\u53d1\u5e03\u4efb\u52a1\uff09\n\n- register\uff1a\u6ce8\u518c\u4e2d\u5fc3\n  - \u5c06`consumer`\u7684`tasks`\u6ce8\u518c\u5230`producer`\u7684`register`\u4e2d\n- publisher\uff1a\u53d1\u5e03\u8005\n    - \u9879\u76ee\u4e2d\u901a\u8fc7\u53d1\u5e03\u8005\u6765\u53d1\u5e03\u4efb\u52a1\uff1a\u53ef\u53c2\u8003`app/api/default/aping.py`\uff08\u8fd9\u91cc\u53ea\u662f\u7b80\u5355\u793a\u4f8b\uff0c\u5b9e\u9645\u4e0a\u5e94\u8be5\u5728`services`\u5c42\u8c03\u7528\uff09\n\n### consumer\uff1a\u6d88\u8d39\u8005\uff08\u6267\u884c\u4efb\u52a1\uff09\n\n- tasks: \u4efb\u52a1\n  - \u5b9a\u65f6\u4efb\u52a1\uff08beat_xxx\uff09\n    - 1\u3002\u521b\u5efa\u5b9a\u65f6\u4efb\u52a1\n    - 2\u3002\u53d1\u5e03\u5b9a\u65f6\u4efb\u52a1\uff08\u901a\u8fc7celery\u5185\u90e8\u7684`beat`\u8c03\u7528\uff09\n      - \u8fdb\u5165`app_celery`\u7236\u7ea7\u76ee\u5f55\uff0c\u5373\u5de5\u4f5c\u76ee\u5f55\n      - \u542f\u52a8\u547d\u4ee4\uff1a\uff08\u66f4\u591a\u53c2\u6570\u8bf7\u81ea\u884c\u6307\u5b9a\uff09\n        - \u65b9\u5f0f1\u3002\u76f4\u63a5\u6267\u884c\u811a\u672c: `python runcbeat.py`\n        - \u65b9\u5f0f2\u3002\u4f7f\u7528\u547d\u4ee4\u884c\uff1a`celery -A app_celery.consumer beat --loglevel=info --max-interval=5`\n    - 3\u3002\u542f\u52a8\u6d88\u8d39\u8005worker\n  - \u5f02\u6b65\u4efb\u52a1\uff08xxx)\n    - 1\u3002\u521b\u5efa\u5f02\u6b65\u4efb\u52a1\uff0c\u5e76\u6ce8\u518c\u5230`producer`\u7684`register`\uff0c\u6839\u636e\u6ce8\u518c\u7684\u89c4\u5219\u8fdb\u884c`\u4efb\u52a1\u8c03\u7528`\u548c`worker\u542f\u52a8`\n    - 2\u3002\u53d1\u5e03\u5f02\u6b65\u4efb\u52a1\uff08\u901a\u8fc7\u751f\u4ea7\u8005\u7684`publisher`\u8c03\u7528\uff09\n      - \u53ef\u53c2\u8003`app/api/default/aping.py`\uff08\u8fd9\u91cc\u53ea\u662f\u7b80\u5355\u793a\u4f8b\uff0c\u5b9e\u9645\u4e0a\u5e94\u8be5\u5728`services`\u5c42\u8c03\u7528\uff09\n    - 3\u3002\u542f\u52a8\u6d88\u8d39\u8005worker\n- workers: \u5de5\u4f5c\u8005\n  - 1\u3002\u521b\u5efaworker\u670d\u52a1\uff0c\u5b9a\u4e49\u961f\u5217\u7b49\u5c5e\u6027\uff08\u4e3a\u65b9\u4fbf\u6269\u5c55\u5efa\u8bae\u4e00\u7c7b\u4efb\u52a1\u4e00\u4e2a\u670d\u52a1\uff09\n  - 2\u3002\u542f\u52a8worker\u670d\u52a1\uff1a\n      - 1\u3002\u8fdb\u5165`app_celery`\u7236\u7ea7\u76ee\u5f55\uff0c\u5373\u5de5\u4f5c\u76ee\u5f55\n      - 2\u3002\u542f\u52a8\u547d\u4ee4\uff1a\uff08\u66f4\u591a\u53c2\u6570\u8bf7\u81ea\u884c\u6307\u5b9a\uff09\n          - \u65b9\u5f0f1\u3002\u76f4\u63a5\u6267\u884c\u811a\u672c: `python runcworker.py -n ping`\n          - \u65b9\u5f0f2\u3002\u4f7f\u7528\u547d\u4ee4\u884c\uff1a`celery -A app_celery.consumer.workers.ping worker --loglevel=info --concurrency=5`\n\n### \u6ce8\u610f\uff1a\n\n- \u6700\u597d\u4e0e`app`\u89e3\u8026\uff0c\u5373\uff1a\n    - \u53ea`app`\u5355\u5411\u8c03\u7528`app_celery`\n    - \u4f46`app_celery`\u4e0d\u8c03\u7528`app`",
    "app_celery/requirements.txt": "# -*- coding: utf-8 -*-\n# Python>=3.11\ntoollib==1.7.8\npython-dotenv==1.1.1\nPyYAML==6.0.2\npydantic==2.11.9\ncelery==5.5.3\nredis==6.4.0\ngevent==25.9.1",
    "app_celery/__init__.py": "\"\"\"\n@author axiner\n@version v0.0.1\n@created 2025/09/20 10:10\n@abstract app-celery\n@description\n@history\n\"\"\"\nfrom celery import Celery\n\nfrom app_celery.conf import config\n\n\ndef make_celery(include: list = None, configs: dict = None):\n    app = Celery(\n        main=\"app_celery\",\n        broker=config.celery_broker_url,\n        backend=config.celery_backend_url,\n        include=include,\n    )\n    app.conf.update(\n        timezone=config.celery_timezone,\n        enable_utc=config.celery_enable_utc,\n        task_serializer=config.celery_task_serializer,\n        result_serializer=config.celery_result_serializer,\n        accept_content=config.celery_accept_content,\n        celery_task_ignore_result=config.celery_task_ignore_result,\n        celery_result_expire=config.celery_result_expire,\n        celery_task_track_started=config.celery_task_track_started,\n        worker_concurrency=config.celery_worker_concurrency,\n        worker_prefetch_multiplier=config.celery_worker_prefetch_multiplier,\n        worker_max_tasks_per_child=config.celery_worker_max_tasks_per_child,\n        broker_connection_retry_on_startup=config.celery_broker_connection_retry_on_startup,\n        task_reject_on_worker_lost=config.celery_task_reject_on_worker_lost,\n    )\n    if configs:\n        app.conf.update(configs)\n    return app\n",
    "app_celery/consumer/__init__.py": "\"\"\"\n\u6d88\u8d39\u8005\n\"\"\"\nimport re\nfrom pathlib import Path\n\nfrom app_celery import make_celery\n\n\ndef autodiscover_task_modules(\n        task_name: str = \"tasks\",\n        task_module: str = \"app_celery.consumer.tasks\",\n) -> list:\n    \"\"\"\n    \u81ea\u52a8\u53d1\u73b0\u4efb\u52a1\u6a21\u5757\n    - \u53ef\u5728\u6a21\u5757\u4e2d\u52a0\u5165`_active = False`\u6765\u53d6\u6d88\u6fc0\u6d3b\n    \"\"\"\n    task_modules = []\n    active_pat = re.compile(r\"^_active\\s*=\\s*False\\s*(?:#.*)?$\", re.MULTILINE)\n    for p in Path(__file__).parent.joinpath(task_name).rglob(\"*.py\"):\n        if p.stem == \"__init__\":\n            continue\n        if active_pat.search(p.read_text(encoding=\"utf-8\")):\n            continue\n        task_modules.append(f\"{task_module}.{p.stem}\")\n    return task_modules\n\n\ncelery_app = make_celery(\n    include=autodiscover_task_modules()\n)\n",
    "app_celery/consumer/tasks/beat_ping.py": "import logging\n\nfrom celery.schedules import crontab\n\nfrom app_celery.consumer import celery_app\n\nlogger = logging.getLogger(__name__)\n\ncelery_app.conf.beat_schedule.setdefault(\n    'beat_ping', {\n        'task': 'app_celery.consumer.tasks.beat_ping.ping',\n        'schedule': crontab(minute='*/2'),  # \u6bcfx\u5206\u949f\u6267\u884c\u4e00\u6b21\n        'options': {'queue': 'beat_ping'}\n    }\n)\n\n\n@celery_app.task(\n    bind=True,\n    autoretry_for=(Exception,),\n    max_retries=3,\n    retry_backoff=True,\n    retry_backoff_max=300,\n    retry_jitter=True,\n    time_limit=360,\n    soft_time_limit=300,\n    acks_late=True,\n)\ndef ping(self, text: str = \"\u8fd9\u662f\u4e00\u4e2a\u5b9a\u65f6\u4efb\u52a1\u6d4b\u8bd5\"):\n    logger.info(f\"pong: {text}\")\n",
    "app_celery/consumer/tasks/ping.py": "import logging\n\nfrom app_celery.consumer import celery_app\n\nlogger = logging.getLogger(__name__)\n\n\n@celery_app.task(\n    bind=True,\n    autoretry_for=(Exception,),\n    max_retries=3,\n    retry_backoff=True,\n    retry_backoff_max=300,\n    retry_jitter=True,\n    time_limit=360,\n    soft_time_limit=300,\n    acks_late=True,\n)\ndef ping(self, text: str = \"\u8fd9\u662f\u4e00\u4e2a\u5f02\u6b65\u4efb\u52a1\u6d4b\u8bd5\"):\n    logger.info(f\"pong: {text}\")\n",
    "app_celery/consumer/tasks/__init__.py": "\"\"\"\n\u4efb\u52a1\uff08\u5b9a\u65f6&\u5f02\u6b65\uff09\n\"\"\"\n",
    "app_celery/consumer/workers/beat_ping.py": "from app_celery.consumer import celery_app\n\ncelery_app.conf.update(\n    task_queues={\n        \"beat_ping\": {\n            \"exchange_type\": \"direct\",\n            \"exchange\": \"beat_ping\",\n            \"routing_key\": \"beat_ping\",\n        },\n    },\n    task_routes={\n        \"app_celery.consumer.tasks.beat_ping.ping\": {\"queue\": \"beat_ping\"},\n    }\n)\n",
    "app_celery/consumer/workers/ping.py": "from app_celery.consumer import celery_app\n\ncelery_app.conf.update(\n    task_queues={\n        \"ping\": {\n            \"exchange_type\": \"direct\",\n            \"exchange\": \"ping\",\n            \"routing_key\": \"ping\",\n        },\n    },\n    task_routes={\n        \"app_celery.consumer.tasks.ping.ping\": {\"queue\": \"ping\"},\n    }\n)\n",
    "app_celery/consumer/workers/__init__.py": "\"\"\"\n\u5de5\u4f5c\u8005\n\"\"\"",
    "app_celery/producer/publisher.py": "import logging\n\nfrom app_celery.producer import celery_app\nfrom app_celery.producer.registry import AllTasks\n\nlogger = logging.getLogger(__name__)\n\n\ndef publish(task_label: str, *args, **kwargs):\n    \"\"\"\u53d1\u5e03\u4efb\u52a1\"\"\"\n    if task_label not in AllTasks:\n        raise ValueError(f\"UNKNOWN TASK: {task_label}\")\n    task_params = AllTasks[task_label]\n    result = celery_app.send_task(\n        name=task_params.name,\n        queue=task_params.queue,\n        args=args,\n        kwargs=kwargs,\n        **task_params.options,\n    )\n    logger.info(f\"PUBLISH TASK: {task_label} | ID={result.id} | QUEUE={task_params.queue}\")\n    return result.id\n",
    "app_celery/producer/registry.py": "from pydantic import BaseModel\n\n\nclass TaskParams(BaseModel):\n    name: str\n    queue: str\n    options: dict = {}\n\n\nAllTasks: dict[str, TaskParams] = {  # label: TaskParams\n    \"ping\": TaskParams(\n        name=\"app_celery.consumer.tasks.ping.ping\",\n        queue=\"ping\"\n    ),\n}\n",
    "app_celery/producer/tests.py": "import unittest\n\nfrom app_celery.producer.publisher import publish\n\n\nclass TestPublisher(unittest.TestCase):\n\n    def test_publish_ping(self):\n        publish(\"ping\")\n",
    "app_celery/producer/__init__.py": "\"\"\"\n\u751f\u4ea7\u8005\n\"\"\"\nfrom app_celery import make_celery\n\ncelery_app = make_celery()\n",
    "config/.env": "# ------- \u5747\u53ef\u76f4\u63a5\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf -------\n# ------- \u5747\u53ef\u76f4\u63a5\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf -------\n# ------- \u5747\u53ef\u76f4\u63a5\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf -------\n# \u5e94\u7528\u73af\u5883\uff08\u5b9a\u4f4dyaml\u914d\u7f6e\uff09\napp_env=dev\n# \u5e94\u7528\u914d\u7f6e\uff08\u6307\u5b9ayaml\u914d\u7f6e\uff0c\u4f18\u4e8e`app_env`\u5b9a\u4f4d\uff09\napp_yaml=\n# ------- Config -------\napi_keys=\n# \u96ea\u82b1\u7b97\u6cd5\u6570\u636e\u4e2d\u5fc3id\uff08\u53d6\u503c\uff1a0-31\uff0c\u5728\u5206\u5e03\u5f0f\u90e8\u7f72\u65f6\u9700\u786e\u4fdd\u6bcf\u4e2a\u8282\u70b9\u7684\u53d6\u503c\u4e0d\u540c\uff09\nsnow_datacenter_id=0\n",
    "config/app_dev.yaml": "# \u8bf7\u6839\u636e\u81ea\u8eab\u9700\u6c42\u4fee\u6539\napp_title: xApp-dev\napp_summary: xxApp-dev\napp_description: xxxApp-dev\napp_version: 1.0.0\napp_debug: true\napp_log_dir: ./logs\napp_disable_docs: false\napp_allow_origins:\n  - '*'\n# #\nredis_host:\nredis_port:\nredis_db:\nredis_password:\nredis_max_connections:\ndb_url: sqlite:///app_dev.sqlite\ndb_async_url: sqlite+aiosqlite:///app_dev.sqlite\n# #\ncelery_broker_url: redis://:<password>@<host>:<port>/<db>\ncelery_backend_url: redis://:<password>@<host>:<port>/<db>\ncelery_timezone: Asia/Shanghai\ncelery_enable_utc: true\ncelery_task_serializer: json\ncelery_result_serializer: json\ncelery_accept_content: [ json ]\ncelery_task_ignore_result: false\ncelery_result_expire: 86400\ncelery_task_track_started: true\ncelery_worker_concurrency: 8\ncelery_worker_prefetch_multiplier: 2\ncelery_worker_max_tasks_per_child: 100\ncelery_broker_connection_retry_on_startup: true\ncelery_task_reject_on_worker_lost: true\n",
    "config/app_prod.yaml": "# \u8bf7\u6839\u636e\u81ea\u8eab\u9700\u6c42\u4fee\u6539\napp_title: xApp-prod\napp_summary: xxApp-prod\napp_description: xxxApp-prod\napp_version: 1.0.0\napp_debug: false\napp_log_dir: ./logs\napp_disable_docs: true\napp_allow_origins:\n  - '*'\n# #\nredis_host:\nredis_port:\nredis_db:\nredis_password:\nredis_max_connections:\ndb_url: sqlite:///app_prod.sqlite\ndb_async_url: sqlite+aiosqlite:///app_prod.sqlite\n# #\ncelery_broker_url: redis://:<password>@<host>:<port>/<db>\ncelery_backend_url: redis://:<password>@<host>:<port>/<db>\ncelery_timezone: Asia/Shanghai\ncelery_enable_utc: true\ncelery_task_serializer: json\ncelery_result_serializer: json\ncelery_accept_content: [ json ]\ncelery_task_ignore_result: false\ncelery_result_expire: 86400\ncelery_task_track_started: true\ncelery_worker_concurrency: 8\ncelery_worker_prefetch_multiplier: 2\ncelery_worker_max_tasks_per_child: 100\ncelery_broker_connection_retry_on_startup: true\ncelery_task_reject_on_worker_lost: true\n",
    "config/app_test.yaml": "# \u8bf7\u6839\u636e\u81ea\u8eab\u9700\u6c42\u4fee\u6539\napp_title: xApp-test\napp_summary: xxApp-test\napp_description: xxxApp-test\napp_version: 1.0.0\napp_debug: true\napp_log_dir: ./logs\napp_disable_docs: false\napp_allow_origins:\n  - '*'\n# #\nredis_host:\nredis_port:\nredis_db:\nredis_password:\nredis_max_connections:\ndb_url: sqlite:///app_test.sqlite\ndb_async_url: sqlite+aiosqlite:///app_test.sqlite\n# #\ncelery_broker_url: redis://:<password>@<host>:<port>/<db>\ncelery_backend_url: redis://:<password>@<host>:<port>/<db>\ncelery_timezone: Asia/Shanghai\ncelery_enable_utc: true\ncelery_task_serializer: json\ncelery_result_serializer: json\ncelery_accept_content: [ json ]\ncelery_task_ignore_result: false\ncelery_result_expire: 86400\ncelery_task_track_started: true\ncelery_worker_concurrency: 8\ncelery_worker_prefetch_multiplier: 2\ncelery_worker_max_tasks_per_child: 100\ncelery_broker_connection_retry_on_startup: true\ncelery_task_reject_on_worker_lost: true\n",
    "deploy/.gitkeep": "",
    "docs/.gitkeep": "",
    "logs/.gitkeep": "",
    "tests/__init__.py": "\"\"\"\n\u6d4b\u8bd5\n\"\"\"\n"
}