# (generated with --quick)

import __future__
import datetime as _datetime
import io
import logging
import os
from typing import Any, Dict, NoReturn, Optional, Tuple, Type, TypeVar, Union, overload

BytesIO: Type[io.BytesIO]
DEFAULT_CHUNK_SIZE: Any
DestinationExists: Any
DirectoryExists: Any
DirectoryExpected: Any
DirectoryNotEmpty: Any
FS: Any
FileExists: Any
FileExpected: Any
HttpError: Any
Info: Any
MediaFileUpload: Any
MediaIoBaseDownload: Any
MediaIoBaseUpload: Any
Mode: Any
NoURL: Any
OperationFailed: Any
RawWrapper: Any
RemoveRootError: Any
ResourceNotFound: Any
ResourceType: Any
SEEK_END: int
SubFS: Any
_ALL_FIELDS: str
_folderMimeType: str
_log: logging.Logger
_rootMetadata: Dict[str, str]
_sharingUrl: str
_shortcutMimeType: str
absolute_import: __future__._Feature
basename: Any
build: Any
datetime: Type[_datetime.datetime]
datetime_to_epoch: Any
dirname: Any
epoch_to_datetime: Any
iteratepath: Any
join: Any
split: Any
timezone: Type[_datetime.timezone]

AnyStr = TypeVar('AnyStr', str, bytes)

class GoogleDriveFS(Any):
    _drive: Any
    _file_kwargs: Dict[str, bool]
    _file_list_kwargs: Dict[str, Any]
    _meta: Dict[str, Optional[Union[bool, str]]]
    driveId: Any
    retryCount: int
    rootId: Any
    subfs_class: Type[SubGoogleDriveFS]
    def __init__(self, credentials, rootId = ..., driveId = ...) -> None: ...
    def __repr__(self) -> str: ...
    def _childByName(self, parentId, childName) -> Any: ...
    def _childrenById(self, parentId) -> Any: ...
    def _createSubdirectory(self, name, path, parents) -> SubGoogleDriveFS: ...
    def _download_request(self, path, request, file_obj, chunk_size) -> NoReturn: ...
    def _download_to_file(self, path, metadata, file_obj, chunk_size) -> None: ...
    def _export_as(self, path, metadata, file_obj, chunk_size, mimeType) -> None: ...
    def _fileQuery(self, query) -> Any: ...
    def _itemFromPath(self, path) -> Any: ...
    def _itemsFromPath(self, path) -> dict: ...
    def add_shortcut(self, shortcut_path, target_path) -> None: ...
    def copy(self, src_path, dst_path, overwrite = ..., preserve_time = ...) -> None: ...
    def download(self, path, file, chunk_size = ..., **options) -> None: ...
    def getinfo(self, path, namespaces = ...) -> Any: ...
    def geturl(self, path, purpose = ...) -> str: ...
    def google_resource(self) -> Any: ...
    def hasurl(self, path, purpose = ...) -> Any: ...
    def listdir(self, path) -> Any: ...
    def makedir(self, path, permissions = ..., recreate = ...) -> Any: ...
    def move(self, src_path, dst_path, overwrite = ..., preserve_time = ...) -> None: ...
    def openbin(self, path, mode = ..., buffering = ..., **options) -> _UploadOnClose: ...
    def remove(self, path) -> None: ...
    def removedir(self, path) -> None: ...
    def scandir(self, path, namespaces = ..., page = ...) -> Any: ...
    def search(self, condition) -> Any: ...
    def setinfo(self, path, info) -> None: ...
    def share(self, path, email = ..., role = ...) -> Any: ...
    def watch(self, path, notificationAddress, expiration = ..., id = ..., token = ...) -> None: ...

class SubGoogleDriveFS(Any):
    def __repr__(self) -> str: ...
    def add_shortcut(self, shortcut_path, target_path) -> None: ...
    def google_resource(self) -> Any: ...
    def watch(self, path, notificationAddress, expiration = ..., id = ..., token = ...) -> None: ...

class _UploadOnClose(Any):
    fs: Any
    localPath: Any
    options: Dict[str, Any]
    parentMetadata: Any
    parsedMode: Any
    path: Any
    thisMetadata: Any
    def __init__(self, fs, path, thisMetadata, parentMetadata, parsedMode, **options) -> None: ...
    def close(self) -> None: ...

def _Escape(name) -> Any: ...
def _GenerateChildren(children, page) -> Any: ...
def _InfoFromMetadata(metadata) -> Any: ...
def close(fd: int) -> None: ...
def getLogger(name: Optional[str] = ...) -> logging.Logger: ...
@overload
def mkstemp() -> Tuple[int, str]: ...
@overload
def mkstemp(suffix: Optional[AnyStr] = ..., prefix: Optional[AnyStr] = ..., dir: Optional[Union[os.PathLike[AnyStr], AnyStr]] = ..., text: bool = ...) -> Tuple[int, AnyStr]: ...
def remove(path: Union[bytes, str, os.PathLike[Union[bytes, str]]], *, dir_fd: Optional[int] = ...) -> None: ...
def splitext(p: Union[os.PathLike[AnyStr], AnyStr]) -> Tuple[AnyStr, AnyStr]: ...
