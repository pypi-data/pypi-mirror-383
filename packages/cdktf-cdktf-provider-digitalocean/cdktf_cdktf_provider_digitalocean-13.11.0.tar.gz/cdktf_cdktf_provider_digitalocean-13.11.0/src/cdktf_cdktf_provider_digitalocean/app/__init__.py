r'''
# `digitalocean_app`

Refer to the Terraform Registry for docs: [`digitalocean_app`](https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app).
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from .._jsii import *

import cdktf as _cdktf_9a9027ec
import constructs as _constructs_77d1e7e8


class App(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.App",
):
    '''Represents a {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app digitalocean_app}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id_: builtins.str,
        *,
        dedicated_ips: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppDedicatedIps", typing.Dict[builtins.str, typing.Any]]]]] = None,
        id: typing.Optional[builtins.str] = None,
        project_id: typing.Optional[builtins.str] = None,
        spec: typing.Optional[typing.Union["AppSpec", typing.Dict[builtins.str, typing.Any]]] = None,
        timeouts: typing.Optional[typing.Union["AppTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app digitalocean_app} Resource.

        :param scope: The scope in which to define this construct.
        :param id_: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param dedicated_ips: dedicated_ips block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dedicated_ips App#dedicated_ips}
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#id App#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param project_id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#project_id App#project_id}.
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#spec App#spec}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#timeouts App#timeouts}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4df3abe7a935384cde4c3257940849f32848e490de2b962e3b1794032ed3c897)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id_", value=id_, expected_type=type_hints["id_"])
        config = AppConfig(
            dedicated_ips=dedicated_ips,
            id=id,
            project_id=project_id,
            spec=spec,
            timeouts=timeouts,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id_, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a App resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the App to import.
        :param import_from_id: The id of the existing App that should be imported. Refer to the {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the App to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71188ffdd22d1c4c7fcdef308a1cf5d8807240f9127c47aea932ecb995652c2a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putDedicatedIps")
    def put_dedicated_ips(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppDedicatedIps", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8ef0ad4a5791352015dc28ed117f961a887a7a291b26aec3bc664416119aa9d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDedicatedIps", [value]))

    @jsii.member(jsii_name="putSpec")
    def put_spec(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecAlert", typing.Dict[builtins.str, typing.Any]]]]] = None,
        database: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecDatabase", typing.Dict[builtins.str, typing.Any]]]]] = None,
        disable_edge_cache: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_email_obfuscation: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        domain: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecDomain", typing.Dict[builtins.str, typing.Any]]]]] = None,
        domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        egress: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecEgress", typing.Dict[builtins.str, typing.Any]]]]] = None,
        enhanced_threat_control_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecEnv", typing.Dict[builtins.str, typing.Any]]]]] = None,
        features: typing.Optional[typing.Sequence[builtins.str]] = None,
        function: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunction", typing.Dict[builtins.str, typing.Any]]]]] = None,
        ingress: typing.Optional[typing.Union["AppSpecIngress", typing.Dict[builtins.str, typing.Any]]] = None,
        job: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJob", typing.Dict[builtins.str, typing.Any]]]]] = None,
        maintenance: typing.Optional[typing.Union["AppSpecMaintenance", typing.Dict[builtins.str, typing.Any]]] = None,
        region: typing.Optional[builtins.str] = None,
        service: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecService", typing.Dict[builtins.str, typing.Any]]]]] = None,
        static_site: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecStaticSite", typing.Dict[builtins.str, typing.Any]]]]] = None,
        vpc: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecVpc", typing.Dict[builtins.str, typing.Any]]]]] = None,
        worker: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorker", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param name: The name of the app. Must be unique across all apps in the same account. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        :param database: database block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#database App#database}
        :param disable_edge_cache: Whether to disable the edge cache for the app. Default is false, which enables the edge cache. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disable_edge_cache App#disable_edge_cache}
        :param disable_email_obfuscation: Email obfuscation configuration for the app. Default is false, which keeps the email obfuscated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disable_email_obfuscation App#disable_email_obfuscation}
        :param domain: domain block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#domain App#domain}
        :param domains: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#domains App#domains}.
        :param egress: egress block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#egress App#egress}
        :param enhanced_threat_control_enabled: Whether to enable enhanced threat control for the app. Default is false. Set to true to enable enhanced threat control, putting additional security measures for Layer 7 DDoS attacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enhanced_threat_control_enabled App#enhanced_threat_control_enabled}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        :param features: List of features which is applied to the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#features App#features}
        :param function: function block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#function App#function}
        :param ingress: ingress block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#ingress App#ingress}
        :param job: job block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#job App#job}
        :param maintenance: maintenance block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#maintenance App#maintenance}
        :param region: The slug for the DigitalOcean data center region hosting the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#region App#region}
        :param service: service block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#service App#service}
        :param static_site: static_site block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#static_site App#static_site}
        :param vpc: vpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#vpc App#vpc}
        :param worker: worker block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#worker App#worker}
        '''
        value = AppSpec(
            name=name,
            alert=alert,
            database=database,
            disable_edge_cache=disable_edge_cache,
            disable_email_obfuscation=disable_email_obfuscation,
            domain=domain,
            domains=domains,
            egress=egress,
            enhanced_threat_control_enabled=enhanced_threat_control_enabled,
            env=env,
            features=features,
            function=function,
            ingress=ingress,
            job=job,
            maintenance=maintenance,
            region=region,
            service=service,
            static_site=static_site,
            vpc=vpc,
            worker=worker,
        )

        return typing.cast(None, jsii.invoke(self, "putSpec", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(self, *, create: typing.Optional[builtins.str] = None) -> None:
        '''
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#create App#create}.
        '''
        value = AppTimeouts(create=create)

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetDedicatedIps")
    def reset_dedicated_ips(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDedicatedIps", []))

    @jsii.member(jsii_name="resetId")
    def reset_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetId", []))

    @jsii.member(jsii_name="resetProjectId")
    def reset_project_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProjectId", []))

    @jsii.member(jsii_name="resetSpec")
    def reset_spec(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSpec", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="activeDeploymentId")
    def active_deployment_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "activeDeploymentId"))

    @builtins.property
    @jsii.member(jsii_name="createdAt")
    def created_at(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "createdAt"))

    @builtins.property
    @jsii.member(jsii_name="dedicatedIps")
    def dedicated_ips(self) -> "AppDedicatedIpsList":
        return typing.cast("AppDedicatedIpsList", jsii.get(self, "dedicatedIps"))

    @builtins.property
    @jsii.member(jsii_name="defaultIngress")
    def default_ingress(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "defaultIngress"))

    @builtins.property
    @jsii.member(jsii_name="liveDomain")
    def live_domain(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "liveDomain"))

    @builtins.property
    @jsii.member(jsii_name="liveUrl")
    def live_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "liveUrl"))

    @builtins.property
    @jsii.member(jsii_name="spec")
    def spec(self) -> "AppSpecOutputReference":
        return typing.cast("AppSpecOutputReference", jsii.get(self, "spec"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "AppTimeoutsOutputReference":
        return typing.cast("AppTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="updatedAt")
    def updated_at(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "updatedAt"))

    @builtins.property
    @jsii.member(jsii_name="urn")
    def urn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "urn"))

    @builtins.property
    @jsii.member(jsii_name="dedicatedIpsInput")
    def dedicated_ips_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppDedicatedIps"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppDedicatedIps"]]], jsii.get(self, "dedicatedIpsInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="projectIdInput")
    def project_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "projectIdInput"))

    @builtins.property
    @jsii.member(jsii_name="specInput")
    def spec_input(self) -> typing.Optional["AppSpec"]:
        return typing.cast(typing.Optional["AppSpec"], jsii.get(self, "specInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "AppTimeouts"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "AppTimeouts"]], jsii.get(self, "timeoutsInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf81a026819d3bb12ef63bfecc21f993f050e5481901d576c3ca0150b6064142)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="projectId")
    def project_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "projectId"))

    @project_id.setter
    def project_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__942fb3c341cfae473eb8784695dbc82fa24d16136d6a182945cb055d00ad8b80)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "projectId", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "dedicated_ips": "dedicatedIps",
        "id": "id",
        "project_id": "projectId",
        "spec": "spec",
        "timeouts": "timeouts",
    },
)
class AppConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        dedicated_ips: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppDedicatedIps", typing.Dict[builtins.str, typing.Any]]]]] = None,
        id: typing.Optional[builtins.str] = None,
        project_id: typing.Optional[builtins.str] = None,
        spec: typing.Optional[typing.Union["AppSpec", typing.Dict[builtins.str, typing.Any]]] = None,
        timeouts: typing.Optional[typing.Union["AppTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param dedicated_ips: dedicated_ips block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dedicated_ips App#dedicated_ips}
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#id App#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param project_id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#project_id App#project_id}.
        :param spec: spec block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#spec App#spec}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#timeouts App#timeouts}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(spec, dict):
            spec = AppSpec(**spec)
        if isinstance(timeouts, dict):
            timeouts = AppTimeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24fd8195dd6c8ea4eee39ab93c4757079afaf80fbe4d1cbd5e7876c8bc7f1b37)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument dedicated_ips", value=dedicated_ips, expected_type=type_hints["dedicated_ips"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument timeouts", value=timeouts, expected_type=type_hints["timeouts"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if dedicated_ips is not None:
            self._values["dedicated_ips"] = dedicated_ips
        if id is not None:
            self._values["id"] = id
        if project_id is not None:
            self._values["project_id"] = project_id
        if spec is not None:
            self._values["spec"] = spec
        if timeouts is not None:
            self._values["timeouts"] = timeouts

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def dedicated_ips(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppDedicatedIps"]]]:
        '''dedicated_ips block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dedicated_ips App#dedicated_ips}
        '''
        result = self._values.get("dedicated_ips")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppDedicatedIps"]]], result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#id App#id}.

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#project_id App#project_id}.'''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def spec(self) -> typing.Optional["AppSpec"]:
        '''spec block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#spec App#spec}
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["AppSpec"], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["AppTimeouts"]:
        '''timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#timeouts App#timeouts}
        '''
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["AppTimeouts"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppDedicatedIps",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "ip": "ip", "status": "status"},
)
class AppDedicatedIps:
    def __init__(
        self,
        *,
        id: typing.Optional[builtins.str] = None,
        ip: typing.Optional[builtins.str] = None,
        status: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id: The ID of the dedicated egress IP. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#id App#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param ip: The IP address of the dedicated egress IP. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#ip App#ip}
        :param status: The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#status App#status}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53b79b81c696f3e24bd6628d8c55688bb5432369361446aa8dc36386e4e0f867)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument ip", value=ip, expected_type=type_hints["ip"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id
        if ip is not None:
            self._values["ip"] = ip
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''The ID of the dedicated egress IP.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#id App#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ip(self) -> typing.Optional[builtins.str]:
        '''The IP address of the dedicated egress IP.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#ip App#ip}
        '''
        result = self._values.get("ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def status(self) -> typing.Optional[builtins.str]:
        '''The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#status App#status}
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppDedicatedIps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppDedicatedIpsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppDedicatedIpsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40c38c49840863aa38955b9e0b4a4fe93525a5c992d7e78270be600abe302049)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppDedicatedIpsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d72693f0080da500304a701c969da82f7c8bd01768be03c57a684c699e081ef)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppDedicatedIpsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec18a339dc7866d1e7901125b1a4c85d2861641b1d88e3ff019591af397bd834)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40fff99cc0d03f34db2db50f61e4e7b8afb2076003853b6aa9b5802877c22b6d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8feea29c701ffba27d00b9f61afa837759234135929dff830221b7a7ed4a39f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppDedicatedIps]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppDedicatedIps]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppDedicatedIps]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4536dfacdaf09f292d804f8e2ffc1fb5dca1dd6a6a61025c9eadad5818b43e5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppDedicatedIpsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppDedicatedIpsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fae65efcbd215df6f1a378a0dca7dd9109cdef8fd1a0712cec0313feba6a80fc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetId")
    def reset_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetId", []))

    @jsii.member(jsii_name="resetIp")
    def reset_ip(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIp", []))

    @jsii.member(jsii_name="resetStatus")
    def reset_status(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStatus", []))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="ipInput")
    def ip_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipInput"))

    @builtins.property
    @jsii.member(jsii_name="statusInput")
    def status_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "statusInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c979d5f707659ccdb76df5a06f08e7b6c71580deb1104e4cb4b59dd8e48f0208)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ip")
    def ip(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "ip"))

    @ip.setter
    def ip(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__382ae912dda34d5c159c90948cca5390b3024b6d18d04e94c29a074405fbae4c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ip", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="status")
    def status(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "status"))

    @status.setter
    def status(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__090d1da745544c23d96ff83c83b4cba8a2f636846cdb1902a6f324e4dfcd0caf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "status", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[AppDedicatedIps, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[AppDedicatedIps, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[AppDedicatedIps, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b661826349a60e8395b8cc48918ce19fb43aeaad660d159d338ea5729f78a20)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpec",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "database": "database",
        "disable_edge_cache": "disableEdgeCache",
        "disable_email_obfuscation": "disableEmailObfuscation",
        "domain": "domain",
        "domains": "domains",
        "egress": "egress",
        "enhanced_threat_control_enabled": "enhancedThreatControlEnabled",
        "env": "env",
        "features": "features",
        "function": "function",
        "ingress": "ingress",
        "job": "job",
        "maintenance": "maintenance",
        "region": "region",
        "service": "service",
        "static_site": "staticSite",
        "vpc": "vpc",
        "worker": "worker",
    },
)
class AppSpec:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecAlert", typing.Dict[builtins.str, typing.Any]]]]] = None,
        database: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecDatabase", typing.Dict[builtins.str, typing.Any]]]]] = None,
        disable_edge_cache: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_email_obfuscation: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        domain: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecDomain", typing.Dict[builtins.str, typing.Any]]]]] = None,
        domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        egress: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecEgress", typing.Dict[builtins.str, typing.Any]]]]] = None,
        enhanced_threat_control_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecEnv", typing.Dict[builtins.str, typing.Any]]]]] = None,
        features: typing.Optional[typing.Sequence[builtins.str]] = None,
        function: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunction", typing.Dict[builtins.str, typing.Any]]]]] = None,
        ingress: typing.Optional[typing.Union["AppSpecIngress", typing.Dict[builtins.str, typing.Any]]] = None,
        job: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJob", typing.Dict[builtins.str, typing.Any]]]]] = None,
        maintenance: typing.Optional[typing.Union["AppSpecMaintenance", typing.Dict[builtins.str, typing.Any]]] = None,
        region: typing.Optional[builtins.str] = None,
        service: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecService", typing.Dict[builtins.str, typing.Any]]]]] = None,
        static_site: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecStaticSite", typing.Dict[builtins.str, typing.Any]]]]] = None,
        vpc: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecVpc", typing.Dict[builtins.str, typing.Any]]]]] = None,
        worker: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorker", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param name: The name of the app. Must be unique across all apps in the same account. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        :param database: database block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#database App#database}
        :param disable_edge_cache: Whether to disable the edge cache for the app. Default is false, which enables the edge cache. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disable_edge_cache App#disable_edge_cache}
        :param disable_email_obfuscation: Email obfuscation configuration for the app. Default is false, which keeps the email obfuscated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disable_email_obfuscation App#disable_email_obfuscation}
        :param domain: domain block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#domain App#domain}
        :param domains: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#domains App#domains}.
        :param egress: egress block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#egress App#egress}
        :param enhanced_threat_control_enabled: Whether to enable enhanced threat control for the app. Default is false. Set to true to enable enhanced threat control, putting additional security measures for Layer 7 DDoS attacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enhanced_threat_control_enabled App#enhanced_threat_control_enabled}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        :param features: List of features which is applied to the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#features App#features}
        :param function: function block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#function App#function}
        :param ingress: ingress block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#ingress App#ingress}
        :param job: job block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#job App#job}
        :param maintenance: maintenance block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#maintenance App#maintenance}
        :param region: The slug for the DigitalOcean data center region hosting the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#region App#region}
        :param service: service block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#service App#service}
        :param static_site: static_site block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#static_site App#static_site}
        :param vpc: vpc block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#vpc App#vpc}
        :param worker: worker block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#worker App#worker}
        '''
        if isinstance(ingress, dict):
            ingress = AppSpecIngress(**ingress)
        if isinstance(maintenance, dict):
            maintenance = AppSpecMaintenance(**maintenance)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b832495a405813c79d95af8699c07578ff52fe1df8b59054fa0d55d72b2809a8)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument alert", value=alert, expected_type=type_hints["alert"])
            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
            check_type(argname="argument disable_edge_cache", value=disable_edge_cache, expected_type=type_hints["disable_edge_cache"])
            check_type(argname="argument disable_email_obfuscation", value=disable_email_obfuscation, expected_type=type_hints["disable_email_obfuscation"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domains", value=domains, expected_type=type_hints["domains"])
            check_type(argname="argument egress", value=egress, expected_type=type_hints["egress"])
            check_type(argname="argument enhanced_threat_control_enabled", value=enhanced_threat_control_enabled, expected_type=type_hints["enhanced_threat_control_enabled"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument features", value=features, expected_type=type_hints["features"])
            check_type(argname="argument function", value=function, expected_type=type_hints["function"])
            check_type(argname="argument ingress", value=ingress, expected_type=type_hints["ingress"])
            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
            check_type(argname="argument maintenance", value=maintenance, expected_type=type_hints["maintenance"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument static_site", value=static_site, expected_type=type_hints["static_site"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument worker", value=worker, expected_type=type_hints["worker"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if database is not None:
            self._values["database"] = database
        if disable_edge_cache is not None:
            self._values["disable_edge_cache"] = disable_edge_cache
        if disable_email_obfuscation is not None:
            self._values["disable_email_obfuscation"] = disable_email_obfuscation
        if domain is not None:
            self._values["domain"] = domain
        if domains is not None:
            self._values["domains"] = domains
        if egress is not None:
            self._values["egress"] = egress
        if enhanced_threat_control_enabled is not None:
            self._values["enhanced_threat_control_enabled"] = enhanced_threat_control_enabled
        if env is not None:
            self._values["env"] = env
        if features is not None:
            self._values["features"] = features
        if function is not None:
            self._values["function"] = function
        if ingress is not None:
            self._values["ingress"] = ingress
        if job is not None:
            self._values["job"] = job
        if maintenance is not None:
            self._values["maintenance"] = maintenance
        if region is not None:
            self._values["region"] = region
        if service is not None:
            self._values["service"] = service
        if static_site is not None:
            self._values["static_site"] = static_site
        if vpc is not None:
            self._values["vpc"] = vpc
        if worker is not None:
            self._values["worker"] = worker

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the app. Must be unique across all apps in the same account.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlert"]]]:
        '''alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        '''
        result = self._values.get("alert")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlert"]]], result)

    @builtins.property
    def database(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecDatabase"]]]:
        '''database block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#database App#database}
        '''
        result = self._values.get("database")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecDatabase"]]], result)

    @builtins.property
    def disable_edge_cache(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to disable the edge cache for the app. Default is false, which enables the edge cache.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disable_edge_cache App#disable_edge_cache}
        '''
        result = self._values.get("disable_edge_cache")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def disable_email_obfuscation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Email obfuscation configuration for the app. Default is false, which keeps the email obfuscated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disable_email_obfuscation App#disable_email_obfuscation}
        '''
        result = self._values.get("disable_email_obfuscation")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def domain(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecDomain"]]]:
        '''domain block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#domain App#domain}
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecDomain"]]], result)

    @builtins.property
    def domains(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#domains App#domains}.'''
        result = self._values.get("domains")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def egress(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecEgress"]]]:
        '''egress block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#egress App#egress}
        '''
        result = self._values.get("egress")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecEgress"]]], result)

    @builtins.property
    def enhanced_threat_control_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to enable enhanced threat control for the app.

        Default is false. Set to true to enable enhanced threat control, putting additional security measures for Layer 7 DDoS attacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enhanced_threat_control_enabled App#enhanced_threat_control_enabled}
        '''
        result = self._values.get("enhanced_threat_control_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecEnv"]]]:
        '''env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecEnv"]]], result)

    @builtins.property
    def features(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of features which is applied to the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#features App#features}
        '''
        result = self._values.get("features")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def function(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunction"]]]:
        '''function block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#function App#function}
        '''
        result = self._values.get("function")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunction"]]], result)

    @builtins.property
    def ingress(self) -> typing.Optional["AppSpecIngress"]:
        '''ingress block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#ingress App#ingress}
        '''
        result = self._values.get("ingress")
        return typing.cast(typing.Optional["AppSpecIngress"], result)

    @builtins.property
    def job(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJob"]]]:
        '''job block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#job App#job}
        '''
        result = self._values.get("job")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJob"]]], result)

    @builtins.property
    def maintenance(self) -> typing.Optional["AppSpecMaintenance"]:
        '''maintenance block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#maintenance App#maintenance}
        '''
        result = self._values.get("maintenance")
        return typing.cast(typing.Optional["AppSpecMaintenance"], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The slug for the DigitalOcean data center region hosting the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#region App#region}
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]]:
        '''service block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#service App#service}
        '''
        result = self._values.get("service")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]], result)

    @builtins.property
    def static_site(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]]]:
        '''static_site block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#static_site App#static_site}
        '''
        result = self._values.get("static_site")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]]], result)

    @builtins.property
    def vpc(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecVpc"]]]:
        '''vpc block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#vpc App#vpc}
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecVpc"]]], result)

    @builtins.property
    def worker(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]]:
        '''worker block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#worker App#worker}
        '''
        result = self._values.get("worker")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlert",
    jsii_struct_bases=[],
    name_mapping={
        "rule": "rule",
        "destinations": "destinations",
        "disabled": "disabled",
    },
)
class AppSpecAlert:
    def __init__(
        self,
        *,
        rule: builtins.str,
        destinations: typing.Optional[typing.Union["AppSpecAlertDestinations", typing.Dict[builtins.str, typing.Any]]] = None,
        disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.
        :param destinations: destinations block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.
        '''
        if isinstance(destinations, dict):
            destinations = AppSpecAlertDestinations(**destinations)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9dd51a26e13bbc241bc7b98a65c620faea5913acbbaf83cd03ddb28bad50907)
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "rule": rule,
        }
        if destinations is not None:
            self._values["destinations"] = destinations
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def rule(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.'''
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destinations(self) -> typing.Optional["AppSpecAlertDestinations"]:
        '''destinations block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        '''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional["AppSpecAlertDestinations"], result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.'''
        result = self._values.get("disabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlertDestinations",
    jsii_struct_bases=[],
    name_mapping={"emails": "emails", "slack_webhooks": "slackWebhooks"},
)
class AppSpecAlertDestinations:
    def __init__(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42e47a84b0b44b92eefed28e787d80c50796b5a7b956905269f2b803c82394a5)
            check_type(argname="argument emails", value=emails, expected_type=type_hints["emails"])
            check_type(argname="argument slack_webhooks", value=slack_webhooks, expected_type=type_hints["slack_webhooks"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if emails is not None:
            self._values["emails"] = emails
        if slack_webhooks is not None:
            self._values["slack_webhooks"] = slack_webhooks

    @builtins.property
    def emails(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.'''
        result = self._values.get("emails")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def slack_webhooks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlertDestinationsSlackWebhooks"]]]:
        '''slack_webhooks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        result = self._values.get("slack_webhooks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlertDestinationsSlackWebhooks"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecAlertDestinations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecAlertDestinationsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlertDestinationsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a57aa4096d44252cb5ff03956d144d9c1d5b9ae05610ae7b310581a92b9b2bd1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSlackWebhooks")
    def put_slack_webhooks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3077474ca50fc9968fe096742b4f4fcd2a0d7fdb1aa0bcffdc615f93da0fee76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSlackWebhooks", [value]))

    @jsii.member(jsii_name="resetEmails")
    def reset_emails(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEmails", []))

    @jsii.member(jsii_name="resetSlackWebhooks")
    def reset_slack_webhooks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSlackWebhooks", []))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooks")
    def slack_webhooks(self) -> "AppSpecAlertDestinationsSlackWebhooksList":
        return typing.cast("AppSpecAlertDestinationsSlackWebhooksList", jsii.get(self, "slackWebhooks"))

    @builtins.property
    @jsii.member(jsii_name="emailsInput")
    def emails_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "emailsInput"))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooksInput")
    def slack_webhooks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlertDestinationsSlackWebhooks"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecAlertDestinationsSlackWebhooks"]]], jsii.get(self, "slackWebhooksInput"))

    @builtins.property
    @jsii.member(jsii_name="emails")
    def emails(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "emails"))

    @emails.setter
    def emails(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b6f2657c761faf7c5abe2c016fced7b1298de420242d4358a9a778a7aa99d00)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "emails", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecAlertDestinations], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecAlertDestinations]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__906b4aa760a318ffadcd63f7e77538c94bb2d8124560c4932a0043e4988de0c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlertDestinationsSlackWebhooks",
    jsii_struct_bases=[],
    name_mapping={"channel": "channel", "url": "url"},
)
class AppSpecAlertDestinationsSlackWebhooks:
    def __init__(self, *, channel: builtins.str, url: builtins.str) -> None:
        '''
        :param channel: The Slack channel to send notifications to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        :param url: The Slack webhook URL. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86e62bff85ce3086135c2fe0db30c3876059973aca8399636a85025883a35c4b)
            check_type(argname="argument channel", value=channel, expected_type=type_hints["channel"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel": channel,
            "url": url,
        }

    @builtins.property
    def channel(self) -> builtins.str:
        '''The Slack channel to send notifications to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        '''
        result = self._values.get("channel")
        assert result is not None, "Required property 'channel' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''The Slack webhook URL.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecAlertDestinationsSlackWebhooks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecAlertDestinationsSlackWebhooksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlertDestinationsSlackWebhooksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__912912e1bb7039daecd0e937566552dd0ca3027cb3acf426f00d740b61219c2a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecAlertDestinationsSlackWebhooksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee25b9f626df04b0080ef5c5ebe3143f72beb49b2b88915c477ec08859779373)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecAlertDestinationsSlackWebhooksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__902c3c2a7e19b22ab69da9daac073167b4e4112deb5eb1d0e4212e56987b2287)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f4074b9e1368c351347c775905a3adfa689b5c9d4eaf3a9f728e7c1ec003a5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f136a115144463cf3e5be19d9cd2a8bcd6cdae728fc194ee862b46d6f133190)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlertDestinationsSlackWebhooks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlertDestinationsSlackWebhooks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlertDestinationsSlackWebhooks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__713902ccec94dfdcbaf8a9a8f987d6f126a29c28e181a25c97379b793ad9a18c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecAlertDestinationsSlackWebhooksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlertDestinationsSlackWebhooksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f62d14682c1a60473b76bd91206aac78dffe39a05705923766624e1d0a4a20a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="channelInput")
    def channel_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "channelInput"))

    @builtins.property
    @jsii.member(jsii_name="urlInput")
    def url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "urlInput"))

    @builtins.property
    @jsii.member(jsii_name="channel")
    def channel(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channel"))

    @channel.setter
    def channel(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__184ee1cb797aea226a95a02046c34847c92318fff2c426848308688f687d0779)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "channel", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @url.setter
    def url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__368bafdc801091815375924c2a9902ccab37dd3df7981eb315e3f54ffe86d58b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "url", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlertDestinationsSlackWebhooks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlertDestinationsSlackWebhooks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlertDestinationsSlackWebhooks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93c5eb07e8f5dd364eb650815d70e7a32857dfe688439907ac6732d2638ab5d5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c532d92806e5fecb31344063b81b8ebdf4b209a9f45adf8d07047d97d42aaa4c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecAlertOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70e60a47c9c520f2147a024609c0414219b3841d0eaa76320e3e117444ae86d5)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecAlertOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87f89f7c4a3b1c4c8c50eb7524593b1463ec579cbf9158a6920e2b1e5171e0e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__665bf5efff0b1be516c78fe671ebeacdcd19a2ddc3006d1614e73f0817285e72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa5b99375a67de9f67cd1a83795b8f74448089112593db9a912850d7cb70172c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a109763459518561b39daadf81bab735656e9ab2be1d0a63272aad4ea51efbc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b71d226fed96eee91b5573862c02cf4f30199afbb6ea833e6a27257d917f07cd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDestinations")
    def put_destinations(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        value = AppSpecAlertDestinations(emails=emails, slack_webhooks=slack_webhooks)

        return typing.cast(None, jsii.invoke(self, "putDestinations", [value]))

    @jsii.member(jsii_name="resetDestinations")
    def reset_destinations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDestinations", []))

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="destinations")
    def destinations(self) -> AppSpecAlertDestinationsOutputReference:
        return typing.cast(AppSpecAlertDestinationsOutputReference, jsii.get(self, "destinations"))

    @builtins.property
    @jsii.member(jsii_name="destinationsInput")
    def destinations_input(self) -> typing.Optional[AppSpecAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecAlertDestinations], jsii.get(self, "destinationsInput"))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e08cdf8cf5742616bac9d897f1004d1193b50e47824a08d67846d741f79b723a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a257331e79440ccbcfd66d60e74916cab5c15d3fd5405dbf18ab7a7a0ef254f2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04860ef4b93dbc3c8b306a7771513b20d0181ceca15d01c22d3e3fc5f235afa7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecDatabase",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_name": "clusterName",
        "db_name": "dbName",
        "db_user": "dbUser",
        "engine": "engine",
        "name": "name",
        "production": "production",
        "version": "version",
    },
)
class AppSpecDatabase:
    def __init__(
        self,
        *,
        cluster_name: typing.Optional[builtins.str] = None,
        db_name: typing.Optional[builtins.str] = None,
        db_user: typing.Optional[builtins.str] = None,
        engine: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        production: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param db_name: The name of the MySQL or PostgreSQL database to configure. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#db_name App#db_name}
        :param db_user: The name of the MySQL or PostgreSQL user to configure. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#db_user App#db_user}
        :param engine: The database engine to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#engine App#engine}
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param production: Whether this is a production or dev database. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#production App#production}
        :param version: The version of the database engine. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#version App#version}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c142f3e93eb01cddd2291ef464e249e246c1ffdd22645cf31ebf218407f73ceb)
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument db_name", value=db_name, expected_type=type_hints["db_name"])
            check_type(argname="argument db_user", value=db_user, expected_type=type_hints["db_user"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument production", value=production, expected_type=type_hints["production"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cluster_name is not None:
            self._values["cluster_name"] = cluster_name
        if db_name is not None:
            self._values["db_name"] = db_name
        if db_user is not None:
            self._values["db_user"] = db_user
        if engine is not None:
            self._values["engine"] = engine
        if name is not None:
            self._values["name"] = name
        if production is not None:
            self._values["production"] = production
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        '''The name of the underlying DigitalOcean DBaaS cluster.

        This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        '''
        result = self._values.get("cluster_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_name(self) -> typing.Optional[builtins.str]:
        '''The name of the MySQL or PostgreSQL database to configure.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#db_name App#db_name}
        '''
        result = self._values.get("db_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_user(self) -> typing.Optional[builtins.str]:
        '''The name of the MySQL or PostgreSQL user to configure.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#db_user App#db_user}
        '''
        result = self._values.get("db_user")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine(self) -> typing.Optional[builtins.str]:
        '''The database engine to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#engine App#engine}
        '''
        result = self._values.get("engine")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def production(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether this is a production or dev database.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#production App#production}
        '''
        result = self._values.get("production")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''The version of the database engine.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#version App#version}
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecDatabase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecDatabaseList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecDatabaseList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5bd379fb5fdf22cef0f2f7ace0eec4b306f5e02a46e4dcefed3c9050a67ec4ba)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecDatabaseOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93ef1336081940305acf36acca33140a9eccbcaf8d53ff569817cd91d2e7695b)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecDatabaseOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe87ca696eb3705a30749f5d6d927646e614e82972b1118fc3b6d5012e7f89c6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__989f3c4466c27377e71960aeda8840bd4bfb27abe36d16bfbd15b6ee5d614227)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a18cacc9014e52b03b2af92197c973b16f2b8e3cf406ba7ee5f7e8056c4602b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9552cb92317fa40cad3af7edc4e9f8a21c260d89b60b784aaddd1ecef72edb43)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecDatabaseOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecDatabaseOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8422334c7c260cd704b8d5450017cba6179e776457072e022895ed0a7331e14e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetClusterName")
    def reset_cluster_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterName", []))

    @jsii.member(jsii_name="resetDbName")
    def reset_db_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDbName", []))

    @jsii.member(jsii_name="resetDbUser")
    def reset_db_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDbUser", []))

    @jsii.member(jsii_name="resetEngine")
    def reset_engine(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEngine", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetProduction")
    def reset_production(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProduction", []))

    @jsii.member(jsii_name="resetVersion")
    def reset_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVersion", []))

    @builtins.property
    @jsii.member(jsii_name="clusterNameInput")
    def cluster_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterNameInput"))

    @builtins.property
    @jsii.member(jsii_name="dbNameInput")
    def db_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbNameInput"))

    @builtins.property
    @jsii.member(jsii_name="dbUserInput")
    def db_user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbUserInput"))

    @builtins.property
    @jsii.member(jsii_name="engineInput")
    def engine_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engineInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="productionInput")
    def production_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "productionInput"))

    @builtins.property
    @jsii.member(jsii_name="versionInput")
    def version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "versionInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterName")
    def cluster_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterName"))

    @cluster_name.setter
    def cluster_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca53c5684726ea98c7d1e4a3852b242eac9d33c96a53bbe3bd3b592fd363815f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="dbName")
    def db_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dbName"))

    @db_name.setter
    def db_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__320b89854abddd00939e8b1369f9de720b0b1e90b44da49ce4fbd6e1c0bb8ea5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="dbUser")
    def db_user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dbUser"))

    @db_user.setter
    def db_user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__236162ae41555a2cf493bfd160c01d86c3e638b38d2e3edf7d9bdf0a7e91c6bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbUser", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "engine"))

    @engine.setter
    def engine(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f293910f3dfefa38741ab9bd5c91702d14ae2484046e509d966a9d27805b96d4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engine", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e68adce4de1a6f2371f6455a406696b025affce9931d5473bdc8b320bf8aefa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="production")
    def production(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "production"))

    @production.setter
    def production(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb32a5b78568332bc06fb8985081c438beda362ffbfe5d46eb7ec74317b41d18)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "production", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="version")
    def version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "version"))

    @version.setter
    def version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1eb7d2c5df9f0006330d46eca3451b9e75fdf4d9051e4e4fc5317075fa3b6ff9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "version", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__226dd4b374f0d6e65d1adce30c288dcfb032b0d047762b78e78844cda81b8c71)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecDomain",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "wildcard": "wildcard",
        "zone": "zone",
    },
)
class AppSpecDomain:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
        wildcard: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        zone: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: The hostname for the domain. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param type: The type of the domain. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        :param wildcard: Indicates whether the domain includes all sub-domains, in addition to the given domain. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#wildcard App#wildcard}
        :param zone: If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#zone App#zone}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dad909028fe4d571c7c75fe3f6158e29b7e6c32aa0d40b6950792b0ada407cdc)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument wildcard", value=wildcard, expected_type=type_hints["wildcard"])
            check_type(argname="argument zone", value=zone, expected_type=type_hints["zone"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type
        if wildcard is not None:
            self._values["wildcard"] = wildcard
        if zone is not None:
            self._values["zone"] = zone

    @builtins.property
    def name(self) -> builtins.str:
        '''The hostname for the domain.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the domain.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def wildcard(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Indicates whether the domain includes all sub-domains, in addition to the given domain.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#wildcard App#wildcard}
        '''
        result = self._values.get("wildcard")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def zone(self) -> typing.Optional[builtins.str]:
        '''If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#zone App#zone}
        '''
        result = self._values.get("zone")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecDomain(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecDomainList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecDomainList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7671f9fa5c31c6a046e0cc06ee5b9e848b481ffb994e66b4c3b229ce1f9cf868)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecDomainOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__185c61c5b3c7ec53ef8a21b6e39bb7c2b57a0cce0c094848cf9ab169b153e1be)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecDomainOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b9455186b22eba56a9c0995f1aa8ddc30a337ea1ae2bf15c5258271b3597f94)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2381e41d961d7cfb1b7378115683e90a063b552fbbd6d919db6018affc67f934)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41ea3d0b15edcca68ab69e69d85a8f2fc6098df5b0150e7461fc65c6e3519973)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aeff35ff813d77f3448f0f52149d0e516ddb7c9e8173c132ab5ec4a2c2896610)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecDomainOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecDomainOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e33db8a027e00c43f23ff039de28b9ef1fdbae4e7bc7c658a03f2a32223379eb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetWildcard")
    def reset_wildcard(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWildcard", []))

    @jsii.member(jsii_name="resetZone")
    def reset_zone(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetZone", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="wildcardInput")
    def wildcard_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "wildcardInput"))

    @builtins.property
    @jsii.member(jsii_name="zoneInput")
    def zone_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "zoneInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56242112a7e05df96ec9ef8c94a7c246ff39d1e2b83cfa0a70362c15c987cacc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d60b763e3bfcc96ae415d3cd196e6507beb397089580753445dbd5cc40668cef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wildcard")
    def wildcard(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "wildcard"))

    @wildcard.setter
    def wildcard(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c958cac3b714beefa23fdee25e9331c834d76e606d709c81d341909ef0014e24)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wildcard", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="zone")
    def zone(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "zone"))

    @zone.setter
    def zone(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9634f8cd18ba8fd971c64de571dea65ebc86aa7b89dd265e6ab2931c55f140dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "zone", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6476bfde3debcf144093c3ede3dbe422b587e565baf8b65b907e55e8c3b25c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecEgress",
    jsii_struct_bases=[],
    name_mapping={"type": "type"},
)
class AppSpecEgress:
    def __init__(self, *, type: typing.Optional[builtins.str] = None) -> None:
        '''
        :param type: The app egress type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecd93ddc2704b728d607ca259967e68ded88c45455d28911dc9ed2ff8d2e256e)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The app egress type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecEgress(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecEgressList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecEgressList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9ed7dbbaa5e37fa3c802129d12a8b76f7ba9c01d41791c6a35d2470cff9ff9a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecEgressOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__150a1785d17194db4abd9ac6b27b6eed675e208a73edc1f8e878f7746e607f94)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecEgressOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ea68c66b7b9388497d3cc98cf12441a8739f447cb9ab36f8fe96551a83a7d66)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c451b591fcf19dbeee42d8577ee8d9b29545c8a193662e9f4c2e493c1f92331b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2641f0e8d8d5ddeeb1d2e8974ca8ec66e1ab2047152c0c6ad03d4ad865b60b66)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEgress]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEgress]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEgress]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aefc166bfd7889ecacd8b3ae8dda25f0445588679c1b96bf44c13cc1e4db3d46)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecEgressOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecEgressOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60f746caf4c8f80dac1ec35945d678993919ca57d119d01cf76a0047ca11a27e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca07f9b0edc97060783865a91490399cf4823307e4c3d1c5915867bba405b5aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEgress]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEgress]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEgress]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0641647e430ab55aaffece81ccc80fbfc01052331fb558ecd76e3bbf841855d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__288d58277af9d9149b574a0b0102e003b234638058363a6442f964901600715b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        '''The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f5b8a2866ce84f77b18ac8b15887af07517cfa5d29b9712de80b4087f6a0a7d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecEnvOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af45b9f5f7ca90ef83a0f1247c87f73a9710fb14bb0519069e982337614c7b2a)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecEnvOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__378c08fe410e2cd1c8636e6e3f9e834832e5f26704aa70fedefeb9fe5b2f9ab6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5df46dd324c22a5909e21bf98f20654077e7f15c0b51b85aa89b8b85da30f38)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84a946b755c3dff6242022ece1a210872e6e6424eac519bfaf0528b3bd6283ed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__974791a0ac7ac4452f3122428cd9f353447ebd4d1f3cfd783ba71dad184c6caa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d1619d7456c9487c18d496d580dbc0bf7458c5045b88b209ad27cdd9b0b79c9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1402c0178ae9d43724b9e07abec63951f1d54b9c9d1aee3f569cca8b2d6776b9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ad27195cc196d1b00eaeeb3c4430d58f0594742e542030eb831169ec3a400f3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86d8b86a8c50ce873aac09ae01c9acb2024b4f7d8cca02476fa6fb97adca518d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8953a668e070b7926e55ebe24a9c8d6019d3522c2bd8b1cc3b9519f90cf74005)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd1d7b5603885c0e3f974c74b75c89cff87f6af012556e71698d8acb13043287)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunction",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "bitbucket": "bitbucket",
        "cors": "cors",
        "env": "env",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "log_destination": "logDestination",
        "routes": "routes",
        "source_dir": "sourceDir",
    },
)
class AppSpecFunction:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunctionAlert", typing.Dict[builtins.str, typing.Any]]]]] = None,
        bitbucket: typing.Optional[typing.Union["AppSpecFunctionBitbucket", typing.Dict[builtins.str, typing.Any]]] = None,
        cors: typing.Optional[typing.Union["AppSpecFunctionCors", typing.Dict[builtins.str, typing.Any]]] = None,
        env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunctionEnv", typing.Dict[builtins.str, typing.Any]]]]] = None,
        git: typing.Optional[typing.Union["AppSpecFunctionGit", typing.Dict[builtins.str, typing.Any]]] = None,
        github: typing.Optional[typing.Union["AppSpecFunctionGithub", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["AppSpecFunctionGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunctionLogDestination", typing.Dict[builtins.str, typing.Any]]]]] = None,
        routes: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunctionRoutes", typing.Dict[builtins.str, typing.Any]]]]] = None,
        source_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        :param bitbucket: bitbucket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        :param cors: cors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        :param routes: routes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#routes App#routes}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        '''
        if isinstance(bitbucket, dict):
            bitbucket = AppSpecFunctionBitbucket(**bitbucket)
        if isinstance(cors, dict):
            cors = AppSpecFunctionCors(**cors)
        if isinstance(git, dict):
            git = AppSpecFunctionGit(**git)
        if isinstance(github, dict):
            github = AppSpecFunctionGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecFunctionGitlab(**gitlab)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b251b874e7a5952a662e222e2472a77f209b886162e10513caf04295d704e2cc)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument alert", value=alert, expected_type=type_hints["alert"])
            check_type(argname="argument bitbucket", value=bitbucket, expected_type=type_hints["bitbucket"])
            check_type(argname="argument cors", value=cors, expected_type=type_hints["cors"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument git", value=git, expected_type=type_hints["git"])
            check_type(argname="argument github", value=github, expected_type=type_hints["github"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument log_destination", value=log_destination, expected_type=type_hints["log_destination"])
            check_type(argname="argument routes", value=routes, expected_type=type_hints["routes"])
            check_type(argname="argument source_dir", value=source_dir, expected_type=type_hints["source_dir"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if bitbucket is not None:
            self._values["bitbucket"] = bitbucket
        if cors is not None:
            self._values["cors"] = cors
        if env is not None:
            self._values["env"] = env
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if routes is not None:
            self._values["routes"] = routes
        if source_dir is not None:
            self._values["source_dir"] = source_dir

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlert"]]]:
        '''alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        '''
        result = self._values.get("alert")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlert"]]], result)

    @builtins.property
    def bitbucket(self) -> typing.Optional["AppSpecFunctionBitbucket"]:
        '''bitbucket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        '''
        result = self._values.get("bitbucket")
        return typing.cast(typing.Optional["AppSpecFunctionBitbucket"], result)

    @builtins.property
    def cors(self) -> typing.Optional["AppSpecFunctionCors"]:
        '''cors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        '''
        result = self._values.get("cors")
        return typing.cast(typing.Optional["AppSpecFunctionCors"], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionEnv"]]]:
        '''env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionEnv"]]], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecFunctionGit"]:
        '''git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        '''
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecFunctionGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecFunctionGithub"]:
        '''github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        '''
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecFunctionGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecFunctionGitlab"]:
        '''gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecFunctionGitlab"], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionLogDestination"]]]:
        '''log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        '''
        result = self._values.get("log_destination")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionLogDestination"]]], result)

    @builtins.property
    def routes(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]]]:
        '''routes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#routes App#routes}
        '''
        result = self._values.get("routes")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]]], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        '''An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        '''
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunction(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "destinations": "destinations",
        "disabled": "disabled",
    },
)
class AppSpecFunctionAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        destinations: typing.Optional[typing.Union["AppSpecFunctionAlertDestinations", typing.Dict[builtins.str, typing.Any]]] = None,
        disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.
        :param destinations: destinations block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.
        '''
        if isinstance(destinations, dict):
            destinations = AppSpecFunctionAlertDestinations(**destinations)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2f6a275dc8925777dc57e3f65262d9a77fbeda5bf66462fe458b19be8f143b1)
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if destinations is not None:
            self._values["destinations"] = destinations
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.'''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.'''
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.'''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.'''
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destinations(self) -> typing.Optional["AppSpecFunctionAlertDestinations"]:
        '''destinations block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        '''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional["AppSpecFunctionAlertDestinations"], result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.'''
        result = self._values.get("disabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlertDestinations",
    jsii_struct_bases=[],
    name_mapping={"emails": "emails", "slack_webhooks": "slackWebhooks"},
)
class AppSpecFunctionAlertDestinations:
    def __init__(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunctionAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11c1ec8fe8520982b9a3a16d61180a83842a04c2278e319037c28ceb4d928ae7)
            check_type(argname="argument emails", value=emails, expected_type=type_hints["emails"])
            check_type(argname="argument slack_webhooks", value=slack_webhooks, expected_type=type_hints["slack_webhooks"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if emails is not None:
            self._values["emails"] = emails
        if slack_webhooks is not None:
            self._values["slack_webhooks"] = slack_webhooks

    @builtins.property
    def emails(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.'''
        result = self._values.get("emails")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def slack_webhooks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlertDestinationsSlackWebhooks"]]]:
        '''slack_webhooks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        result = self._values.get("slack_webhooks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlertDestinationsSlackWebhooks"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionAlertDestinations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionAlertDestinationsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlertDestinationsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c47cecd9e0e806e02d09b23fb03995dc056071a2712b6cf3aa0de827aab7b71c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSlackWebhooks")
    def put_slack_webhooks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunctionAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c8caf59a28702ac49bb63d27e5619e313e9982fe141af1e71d5b7a804ddf179)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSlackWebhooks", [value]))

    @jsii.member(jsii_name="resetEmails")
    def reset_emails(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEmails", []))

    @jsii.member(jsii_name="resetSlackWebhooks")
    def reset_slack_webhooks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSlackWebhooks", []))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooks")
    def slack_webhooks(self) -> "AppSpecFunctionAlertDestinationsSlackWebhooksList":
        return typing.cast("AppSpecFunctionAlertDestinationsSlackWebhooksList", jsii.get(self, "slackWebhooks"))

    @builtins.property
    @jsii.member(jsii_name="emailsInput")
    def emails_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "emailsInput"))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooksInput")
    def slack_webhooks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlertDestinationsSlackWebhooks"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionAlertDestinationsSlackWebhooks"]]], jsii.get(self, "slackWebhooksInput"))

    @builtins.property
    @jsii.member(jsii_name="emails")
    def emails(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "emails"))

    @emails.setter
    def emails(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca98385c64d11c9503af063f896c06bb0530cdbad1181ee69b514036a2afb544)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "emails", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecFunctionAlertDestinations], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionAlertDestinations],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8adbfd1272d29c6ef86575606c7dde1321c2abd0c22ed138c133172cb371e72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlertDestinationsSlackWebhooks",
    jsii_struct_bases=[],
    name_mapping={"channel": "channel", "url": "url"},
)
class AppSpecFunctionAlertDestinationsSlackWebhooks:
    def __init__(self, *, channel: builtins.str, url: builtins.str) -> None:
        '''
        :param channel: The Slack channel to send notifications to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        :param url: The Slack webhook URL. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc9636407e086409574bd10aabdff325ef1dcbfd7fa0e50f6375aad59cc06950)
            check_type(argname="argument channel", value=channel, expected_type=type_hints["channel"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel": channel,
            "url": url,
        }

    @builtins.property
    def channel(self) -> builtins.str:
        '''The Slack channel to send notifications to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        '''
        result = self._values.get("channel")
        assert result is not None, "Required property 'channel' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''The Slack webhook URL.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionAlertDestinationsSlackWebhooks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionAlertDestinationsSlackWebhooksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlertDestinationsSlackWebhooksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__391b8a6c95f389d93f0f27d5eff6f27b9ecc6ae211e7f174c1f7670d2d023e16)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecFunctionAlertDestinationsSlackWebhooksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2ae0bd927dc927912f9ecba5b464174a0ef7153d9a709f56b885296c6a303e2)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecFunctionAlertDestinationsSlackWebhooksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23391299cd21c594f2c8927c85b2270ce781a184d0838131333afef3b7693f3a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3e4bf2471d05df9fbbf0a1d44c2230cac3efc78bb1c18c4d5bff90646f40d00)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba031afff6c2ad066ecb0310d4abcb07ca30e842c332f391705be93d384bbbe7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlertDestinationsSlackWebhooks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlertDestinationsSlackWebhooks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlertDestinationsSlackWebhooks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3aa783f55d4904b6b8d67645568aee5e4cb872e25031bc86d5410069dde9fc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionAlertDestinationsSlackWebhooksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlertDestinationsSlackWebhooksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84f72eb3b539fc83f2f9a7ca2537420be6ca6029759f0c19eb2edd76673ac106)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="channelInput")
    def channel_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "channelInput"))

    @builtins.property
    @jsii.member(jsii_name="urlInput")
    def url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "urlInput"))

    @builtins.property
    @jsii.member(jsii_name="channel")
    def channel(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channel"))

    @channel.setter
    def channel(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ee77fa9478669a942d71e1775a6b7bd5cf7c1ca96a7549e6a5c7adbbec9e178)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "channel", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @url.setter
    def url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00c8767017c761c4e7644b1f61abb52a8d3a7eb0fe0a2ccadbc6082f2e27ba34)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "url", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlertDestinationsSlackWebhooks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlertDestinationsSlackWebhooks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlertDestinationsSlackWebhooks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68e798deb086fe16f52c84dc64ab757fa023bf61f94dbf7a4b4a66c9bfc2a209)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62c8a9db4e98ea7c641d590eea7badb99f2c8e349144b68bb9dec20f41372982)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionAlertOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ee49551763a940460598761ba797f9a955d11b3d7fff70ba476000d98f5b930)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecFunctionAlertOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__756803929bf46fba45a303f0cd575fddf04b3a87c5609dbe61c67c0f2580f661)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd80dcfc5353d0f9b5d78cd46b7298a52e28179ea0bc67007f36a86d84c1b996)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2990f1a026ff7916421de781212c771f46bdba25cf7eb756144fb6444b46dcaa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__700bc14f3cab721255828da6e51466de6d848a1ad28dc0bbbad579927c3252a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb2a6e5049b56d01fecbeb7e659b918b2b3670d33c22d06cf865619ff952ca90)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDestinations")
    def put_destinations(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        value = AppSpecFunctionAlertDestinations(
            emails=emails, slack_webhooks=slack_webhooks
        )

        return typing.cast(None, jsii.invoke(self, "putDestinations", [value]))

    @jsii.member(jsii_name="resetDestinations")
    def reset_destinations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDestinations", []))

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="destinations")
    def destinations(self) -> AppSpecFunctionAlertDestinationsOutputReference:
        return typing.cast(AppSpecFunctionAlertDestinationsOutputReference, jsii.get(self, "destinations"))

    @builtins.property
    @jsii.member(jsii_name="destinationsInput")
    def destinations_input(self) -> typing.Optional[AppSpecFunctionAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecFunctionAlertDestinations], jsii.get(self, "destinationsInput"))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "operatorInput"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85e1e56058e49d7296ccecb643716646619798b9348278e2c19350aebc9122c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dea539486b33118aaa792e65df5ab0217077b98f7d157c49311838843c59ca59)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "operator", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0938a4dee4a136d84a1ce2cc11580c505f3cf775110cf1377b74d37d8daf56b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ce33be5ae2ec90c47b9edcd5eae6003ab36a44adb80d9c3cd9939fe04249b94)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad6f524b7fc466ca59fcc108149016960b974b60d188269fae082ba3d026cbde)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "window", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0730d399c9174b7b27f7830907aec02cd0e7efa5336f6e5a073f42d5c7bb7c02)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionBitbucket",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecFunctionBitbucket:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b0797140786b964ef3dd62cbf8f97b85275c509ef4947de4bdbed8467fc375b)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionBitbucket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionBitbucketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionBitbucketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08118ee77e0b1555daced469eba39fe0583537540e1c1b9e41e1f94121fec667)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0381d1334f6c05840e2a546182a38bd0b578ef607aa74c6f6718b53b880e34b3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e346215dfc13b9ba72f1c54aeff379a30e14fbf964cd43dc22ae77ef30789198)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9879b513f4d9a369e9dd833088e12444cbe0c17bf792889bb395c60b91b3d448)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionBitbucket]:
        return typing.cast(typing.Optional[AppSpecFunctionBitbucket], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionBitbucket]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5b0f43f8e7b3bd6f623cc1921cba7491ec85399ba91a4333dbce398a88a4427)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionCors",
    jsii_struct_bases=[],
    name_mapping={
        "allow_credentials": "allowCredentials",
        "allow_headers": "allowHeaders",
        "allow_methods": "allowMethods",
        "allow_origins": "allowOrigins",
        "expose_headers": "exposeHeaders",
        "max_age": "maxAge",
    },
)
class AppSpecFunctionCors:
    def __init__(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union["AppSpecFunctionCorsAllowOrigins", typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        if isinstance(allow_origins, dict):
            allow_origins = AppSpecFunctionCorsAllowOrigins(**allow_origins)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85344ee719dd4cf905970b2c80f4af5b55db06ad268bdf5bb4c9c73703e47cef)
            check_type(argname="argument allow_credentials", value=allow_credentials, expected_type=type_hints["allow_credentials"])
            check_type(argname="argument allow_headers", value=allow_headers, expected_type=type_hints["allow_headers"])
            check_type(argname="argument allow_methods", value=allow_methods, expected_type=type_hints["allow_methods"])
            check_type(argname="argument allow_origins", value=allow_origins, expected_type=type_hints["allow_origins"])
            check_type(argname="argument expose_headers", value=expose_headers, expected_type=type_hints["expose_headers"])
            check_type(argname="argument max_age", value=max_age, expected_type=type_hints["max_age"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_credentials is not None:
            self._values["allow_credentials"] = allow_credentials
        if allow_headers is not None:
            self._values["allow_headers"] = allow_headers
        if allow_methods is not None:
            self._values["allow_methods"] = allow_methods
        if allow_origins is not None:
            self._values["allow_origins"] = allow_origins
        if expose_headers is not None:
            self._values["expose_headers"] = expose_headers
        if max_age is not None:
            self._values["max_age"] = max_age

    @builtins.property
    def allow_credentials(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``.

        This configures the Access-Control-Allow-Credentials header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        '''
        result = self._values.get("allow_credentials")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def allow_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        '''
        result = self._values.get("allow_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_methods(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        '''
        result = self._values.get("allow_methods")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_origins(self) -> typing.Optional["AppSpecFunctionCorsAllowOrigins"]:
        '''allow_origins block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        '''
        result = self._values.get("allow_origins")
        return typing.cast(typing.Optional["AppSpecFunctionCorsAllowOrigins"], result)

    @builtins.property
    def expose_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        '''
        result = self._values.get("expose_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def max_age(self) -> typing.Optional[builtins.str]:
        '''An optional duration specifying how long browsers can cache the results of a preflight request.

        This configures the Access-Control-Max-Age header. Example: ``5h30m``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        result = self._values.get("max_age")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionCors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionCorsAllowOrigins",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact", "prefix": "prefix", "regex": "regex"},
)
class AppSpecFunctionCorsAllowOrigins:
    def __init__(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__daee1674054a6a6289b81c7892448a6dfd68edf74b4a28ab38d29f30e35e97e5)
            check_type(argname="argument exact", value=exact, expected_type=type_hints["exact"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact
        if prefix is not None:
            self._values["prefix"] = prefix
        if regex is not None:
            self._values["regex"] = regex

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        '''Exact string match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        '''
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''Prefix-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def regex(self) -> typing.Optional[builtins.str]:
        '''RE2 style regex-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        result = self._values.get("regex")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionCorsAllowOrigins(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionCorsAllowOriginsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionCorsAllowOriginsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d571a8302c3f10f5b3b72dcd95d6777338aad41090b5a603a1331222e7425bbd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetRegex")
    def reset_regex(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegex", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regexInput")
    def regex_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94faa26335d0969f935be99c4309dee4c6305cd7a17c7b7581a0055db8f6b8aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exact", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4dd39afe6dc616186ffe01c84217ff4eaadd355881d3f8eb57946125b51e5dc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "prefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="regex")
    def regex(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "regex"))

    @regex.setter
    def regex(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0e75a9c57430c1c96e74e838236ec17d3d8503113903faba95da86f079387d6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "regex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecFunctionCorsAllowOrigins], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionCorsAllowOrigins],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__576a46d6c70b9af454b64330ecb7242128c6ea4c99db3b51ffdd45b400506029)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionCorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionCorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67b17d09dd068459b79946bd1676d72d4819f8c3f17e4dbcada18695a13acd64)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAllowOrigins")
    def put_allow_origins(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        value = AppSpecFunctionCorsAllowOrigins(
            exact=exact, prefix=prefix, regex=regex
        )

        return typing.cast(None, jsii.invoke(self, "putAllowOrigins", [value]))

    @jsii.member(jsii_name="resetAllowCredentials")
    def reset_allow_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowCredentials", []))

    @jsii.member(jsii_name="resetAllowHeaders")
    def reset_allow_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowHeaders", []))

    @jsii.member(jsii_name="resetAllowMethods")
    def reset_allow_methods(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowMethods", []))

    @jsii.member(jsii_name="resetAllowOrigins")
    def reset_allow_origins(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowOrigins", []))

    @jsii.member(jsii_name="resetExposeHeaders")
    def reset_expose_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExposeHeaders", []))

    @jsii.member(jsii_name="resetMaxAge")
    def reset_max_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxAge", []))

    @builtins.property
    @jsii.member(jsii_name="allowOrigins")
    def allow_origins(self) -> AppSpecFunctionCorsAllowOriginsOutputReference:
        return typing.cast(AppSpecFunctionCorsAllowOriginsOutputReference, jsii.get(self, "allowOrigins"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentialsInput")
    def allow_credentials_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "allowCredentialsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowHeadersInput")
    def allow_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="allowMethodsInput")
    def allow_methods_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowMethodsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowOriginsInput")
    def allow_origins_input(self) -> typing.Optional[AppSpecFunctionCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecFunctionCorsAllowOrigins], jsii.get(self, "allowOriginsInput"))

    @builtins.property
    @jsii.member(jsii_name="exposeHeadersInput")
    def expose_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "exposeHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="maxAgeInput")
    def max_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentials")
    def allow_credentials(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "allowCredentials"))

    @allow_credentials.setter
    def allow_credentials(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd1204791ee4b30eed4fa14c91340bc59311e3474c67a1d81a5f6323e39c7767)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowCredentials", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowHeaders")
    def allow_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowHeaders"))

    @allow_headers.setter
    def allow_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2bcea74cc2031182ae31ba8345dc8b780b865cb94798cc9495ce732a13068806)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowMethods")
    def allow_methods(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowMethods"))

    @allow_methods.setter
    def allow_methods(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c8d38bdd66e0bc3ed75d16571dd29d2eb8819fd9dc20ab298321c2596009556)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowMethods", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="exposeHeaders")
    def expose_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "exposeHeaders"))

    @expose_headers.setter
    def expose_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__707e7291b5db7a40b8d035af3e9f3adf5ddf3588555c5965d108ce4065538105)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exposeHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxAge")
    def max_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxAge"))

    @max_age.setter
    def max_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72a3d15f5dd883cc66ff398a56220ca3ddc18df9783ebf7de97e20790010bda5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionCors]:
        return typing.cast(typing.Optional[AppSpecFunctionCors], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionCors]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34a7783f5056cecd84931fed6e04c134cb4dcc8790cd6d56012951c22477b829)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecFunctionEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b6499b37af4c21a61809db40935cb979889a26eb5df5d55ae0c586349305e5d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        '''The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6283003a6864f7dbd42ca12caad20b5bd8904c6e45582be85c514dbc61ee70a0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionEnvOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b52bc03ea4805fb980173bb4faa1b7916e1079d33f5c4f19f2ca199b0ce1f68)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecFunctionEnvOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b2e73c71faa9f72cb39b3f7653b1f4abae90db025819cac811f1062c2e322a2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97499a2f95a0fb1bfb824c3488cec837967d0ca5b355a7b22ba511f8c65d0e6d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6de408e8c9ed2d87b80d9ed88bc31b2ede7624f4542f94c7c44656c07a9a55fc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91f00dcc3a042a4c4910e67e18010d1b0c0335a55f29dbb2ab43f44c972554a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__396c5a7f9acb1dac2a1a6a82755133f77209e888295daefcf538c64a5c14bb0f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a68402a5496f10bc9e42ab76e055acc75a901ce70f523b10bb511b52b920161a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0a5288c9909bf75fe4fcd425eb4d2691bd3be245afbb19f346bda7aecc924c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0f4b91f406667634a91b4e27d8801fe4607aecee2bc7529f897c92b12b6883a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd1c8073be85c1455f5b69a8586b97d653917833f14df954595a8f37a11af235)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__168b88ae5483dffd4d23fcd3fe27544c023997e7f39f6d8360e2889d371d6105)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecFunctionGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f53ecb797f4e04428399385606e273b7ce9913a2a83d0ca080c8c93b5877e4cf)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument repo_clone_url", value=repo_clone_url, expected_type=type_hints["repo_clone_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        '''The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8c5c183c5d8413a182c98b2cc03dc1d5a52362cf0f3e4f4153f0c3155b52820)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5564f24d72e2416daabc35dd59b678edc53ada7c327f8bd8d9d988ac0443083)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9871940bffe7b6243986e8afb0d9e2f6770985c439a27ef58b03317a4d22cd43)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repoCloneUrl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionGit]:
        return typing.cast(typing.Optional[AppSpecFunctionGit], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dc94f911880ceeea6680123e2fccb355f0e0c8f783a3d00daf937a78ae15770)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecFunctionGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c41bd8641ed39cb2029431fc37695bc5775d933ad5efd2457e714c25743da5f)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e08a75a54dfae34b97c7a005f8daa4c9cac70b5c92afe40af6fd8e2e714820c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1213301ea0dea357458df2571ce24ec0b07deac79d839b336da98944c3d63803)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4125ef609bf2a04ab3b9e4c84c24b60157d61925ee72b3e2ff96ac6bde6437be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1523c0bec840acfcad53759e78a81e1949074e92ff95eb26f6d7430f9bdba17c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionGithub]:
        return typing.cast(typing.Optional[AppSpecFunctionGithub], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1efd638b783b3bf5393fc3a843400410072c20e3387b38b0336cabfc84b1f65)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecFunctionGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__321f497bdbee386782dc3dcada93c2464777709822f5eea74167a457ad9fac42)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c46084785bca56d6954a4f7bfbea47a4ffd94e90e0135b7bd19b89815cdd1d28)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aaa014da63d609d77d089ddcec72ee88570c2049c8e5bc62b559eb624081b601)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ca5b9d9173e02cbf6a32dd78d9b7f0b4cb3fb7e40b713fbf395282433fe817d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12b21d006ed43904c18a16d926492f1cb5f0f32c7115683097e21f0a58c58355)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionGitlab]:
        return typing.cast(typing.Optional[AppSpecFunctionGitlab], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecFunctionGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdf8a0e891badef370b2a4ed8aa4d0154c1bf172081b620b086db5032d270e68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30858b953a85f94a58ddcf644ffa3c8df19d979dcfad880e9a4be950cb47a1d7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__923457eff4cf8ff6cc991e33d2059b2d03d4f2964a1ae5c2c3a3a7263ba7f349)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecFunctionOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc39e4fd866adde8ae287738a7596c2ab8828f050a06c1043e1c6f37b0ebfa8c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fc8e05d11172c514183c76e85a194a23d21a8b1b16c5c392be5d1375a8fe716)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__376cd3ea7701d266290c05bf9560de8f8d7847ed95484209a54efa4a8f0240df)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e650427e6003526807b4ae40f3389bbf45356fdcf3adaf8b29b20c62a1772d13)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "open_search": "openSearch",
        "papertrail": "papertrail",
    },
)
class AppSpecFunctionLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[typing.Union["AppSpecFunctionLogDestinationDatadog", typing.Dict[builtins.str, typing.Any]]] = None,
        logtail: typing.Optional[typing.Union["AppSpecFunctionLogDestinationLogtail", typing.Dict[builtins.str, typing.Any]]] = None,
        open_search: typing.Optional[typing.Union["AppSpecFunctionLogDestinationOpenSearch", typing.Dict[builtins.str, typing.Any]]] = None,
        papertrail: typing.Optional[typing.Union["AppSpecFunctionLogDestinationPapertrail", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        :param open_search: open_search block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        if isinstance(datadog, dict):
            datadog = AppSpecFunctionLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecFunctionLogDestinationLogtail(**logtail)
        if isinstance(open_search, dict):
            open_search = AppSpecFunctionLogDestinationOpenSearch(**open_search)
        if isinstance(papertrail, dict):
            papertrail = AppSpecFunctionLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a79dc418c01632fe742e41a23bf7e69114ac1e02f574a6df27bd33ddc82129d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument datadog", value=datadog, expected_type=type_hints["datadog"])
            check_type(argname="argument logtail", value=logtail, expected_type=type_hints["logtail"])
            check_type(argname="argument open_search", value=open_search, expected_type=type_hints["open_search"])
            check_type(argname="argument papertrail", value=papertrail, expected_type=type_hints["papertrail"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if open_search is not None:
            self._values["open_search"] = open_search
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecFunctionLogDestinationDatadog"]:
        '''datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        '''
        result = self._values.get("datadog")
        return typing.cast(typing.Optional["AppSpecFunctionLogDestinationDatadog"], result)

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecFunctionLogDestinationLogtail"]:
        '''logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        '''
        result = self._values.get("logtail")
        return typing.cast(typing.Optional["AppSpecFunctionLogDestinationLogtail"], result)

    @builtins.property
    def open_search(self) -> typing.Optional["AppSpecFunctionLogDestinationOpenSearch"]:
        '''open_search block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        '''
        result = self._values.get("open_search")
        return typing.cast(typing.Optional["AppSpecFunctionLogDestinationOpenSearch"], result)

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecFunctionLogDestinationPapertrail"]:
        '''papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        result = self._values.get("papertrail")
        return typing.cast(typing.Optional["AppSpecFunctionLogDestinationPapertrail"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecFunctionLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6303070b1c668d899ba50f63dc6da0d546d42e7cf6c65d5f1a51163c498fd17)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        '''Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        '''
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a4071e148c4cc11c32e69b21a20d9ace01b9c59c8288b130338127913a0e970)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c444b5d1cbe7c607e9c9f64714d67065674590228dc30476d0137f2eb954c17f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "apiKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b6b30abb4985661f226ccde8880bc1c9587c38c986495562f6669292db71917)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationDatadog], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef4f39365a2a7f3daa88ddf60c596b049ac6730b866b6e35ab00a56eb5604ab9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfc409c4f142afeb1885eccd6f447b99e272f657ad5bdf33d0570217b611d9e2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionLogDestinationOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccb362caf4c2bb787f93865f7e4b1ffc63985cd57663eb54b34f1336cba2dff2)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecFunctionLogDestinationOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9f75a164b8100ed75109f404dcbf5de4de20035a2f559f7095ddba4e7b3d66b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6541e1ff72d5f6b78051aab692e5348c43b875661d9667215b4c5ee54cead98c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e831b6ab00b3395fd2139bb2dcb1d9ad1681246c4808e98ddde0c383583a49cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__140b23b485bc2f061debcb4e3f57ec946902bfe25b43de40d9879748ce591930)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecFunctionLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fa38ca3fc01c1b0d400008e7f4f9c3436dde65f41ad19d7d3e48b34c3663673)
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        '''Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ed9d6d1db3a4070ad78ff8249fb17f525d7bf1d32458f30658d42c73eb890f4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95cfde3a8f9c9a8dc53181dfd71a74fd39b633a89ee6303dbe1ed3d81801e295)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "token", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecFunctionLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationLogtail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4636064ecf34fc8af61b04d52e2e3ed69448ecb3c96a23eb1e89994e28e5cc53)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationOpenSearch",
    jsii_struct_bases=[],
    name_mapping={
        "basic_auth": "basicAuth",
        "cluster_name": "clusterName",
        "endpoint": "endpoint",
        "index_name": "indexName",
    },
)
class AppSpecFunctionLogDestinationOpenSearch:
    def __init__(
        self,
        *,
        basic_auth: typing.Union["AppSpecFunctionLogDestinationOpenSearchBasicAuth", typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        if isinstance(basic_auth, dict):
            basic_auth = AppSpecFunctionLogDestinationOpenSearchBasicAuth(**basic_auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8212194531bac4b1fd7e5afa417c3bd62ab8fb7813e8326fb97d680c5b9516f4)
            check_type(argname="argument basic_auth", value=basic_auth, expected_type=type_hints["basic_auth"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument index_name", value=index_name, expected_type=type_hints["index_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "basic_auth": basic_auth,
        }
        if cluster_name is not None:
            self._values["cluster_name"] = cluster_name
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if index_name is not None:
            self._values["index_name"] = index_name

    @builtins.property
    def basic_auth(self) -> "AppSpecFunctionLogDestinationOpenSearchBasicAuth":
        '''basic_auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        '''
        result = self._values.get("basic_auth")
        assert result is not None, "Required property 'basic_auth' is missing"
        return typing.cast("AppSpecFunctionLogDestinationOpenSearchBasicAuth", result)

    @builtins.property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch cluster name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        '''
        result = self._values.get("cluster_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''OpenSearch endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def index_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch index name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        result = self._values.get("index_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationOpenSearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationOpenSearchBasicAuth",
    jsii_struct_bases=[],
    name_mapping={"password": "password", "user": "user"},
)
class AppSpecFunctionLogDestinationOpenSearchBasicAuth:
    def __init__(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2112ef844b5f0676e404e46859a248ee3fe26a6a50e5eb255b17d5b8694c6bf8)
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if password is not None:
            self._values["password"] = password
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''Password for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''user for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationOpenSearchBasicAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionLogDestinationOpenSearchBasicAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationOpenSearchBasicAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__285bfd1afbf73c52c6abda2a1b2cc4ac12f9b8ea0c48f5e882582cf329a32ba3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPassword")
    def reset_password(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPassword", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="passwordInput")
    def password_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "passwordInput"))

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "password"))

    @password.setter
    def password(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07868f940a5ca9d6ec4c9f77bd8b030c480af7c747e05f737d27265a0638dc26)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "password", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fba63d20ccabb3d45830b8519ffe7ca97842df3ce265fc013c08a379d4d1451)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "user", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[AppSpecFunctionLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationOpenSearchBasicAuth], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationOpenSearchBasicAuth],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b0bbe2544457d334fdd93acf3b84f3c3a4886249dd4805dead63888f0dab4f1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionLogDestinationOpenSearchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationOpenSearchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bed3b2de339d13b027d392db6d2ef9203c072859c166822024bd670fd2ed9f6d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putBasicAuth")
    def put_basic_auth(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        value = AppSpecFunctionLogDestinationOpenSearchBasicAuth(
            password=password, user=user
        )

        return typing.cast(None, jsii.invoke(self, "putBasicAuth", [value]))

    @jsii.member(jsii_name="resetClusterName")
    def reset_cluster_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterName", []))

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @jsii.member(jsii_name="resetIndexName")
    def reset_index_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIndexName", []))

    @builtins.property
    @jsii.member(jsii_name="basicAuth")
    def basic_auth(
        self,
    ) -> AppSpecFunctionLogDestinationOpenSearchBasicAuthOutputReference:
        return typing.cast(AppSpecFunctionLogDestinationOpenSearchBasicAuthOutputReference, jsii.get(self, "basicAuth"))

    @builtins.property
    @jsii.member(jsii_name="basicAuthInput")
    def basic_auth_input(
        self,
    ) -> typing.Optional[AppSpecFunctionLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationOpenSearchBasicAuth], jsii.get(self, "basicAuthInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterNameInput")
    def cluster_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterNameInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="indexNameInput")
    def index_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "indexNameInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterName")
    def cluster_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterName"))

    @cluster_name.setter
    def cluster_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__644755880d3295528b559b0ae7a704e9b1999b48b6c359e5f087fd6eb1b761ac)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db58b1f1f71dba806b8cf4c7c2ae2afa5c69ff210c92234b3134bbf69e83e916)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="indexName")
    def index_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "indexName"))

    @index_name.setter
    def index_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dffb5f0639210280f86d128cd220af4e4f913c6ded0e35825e3b94be831f1dd2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "indexName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[AppSpecFunctionLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationOpenSearch], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationOpenSearch],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3423c447dc8fe1f6adc16b228ad1dad4a16e2e4396433af21833eee15b903f61)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e635bd1b87ec2dc669e174357c7f5dd35457152bfd2c0d45a45fb047f20943d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecFunctionLogDestinationDatadog(
            api_key=api_key, endpoint=endpoint
        )

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        value = AppSpecFunctionLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putOpenSearch")
    def put_open_search(
        self,
        *,
        basic_auth: typing.Union[AppSpecFunctionLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        value = AppSpecFunctionLogDestinationOpenSearch(
            basic_auth=basic_auth,
            cluster_name=cluster_name,
            endpoint=endpoint,
            index_name=index_name,
        )

        return typing.cast(None, jsii.invoke(self, "putOpenSearch", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecFunctionLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetOpenSearch")
    def reset_open_search(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOpenSearch", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecFunctionLogDestinationDatadogOutputReference:
        return typing.cast(AppSpecFunctionLogDestinationDatadogOutputReference, jsii.get(self, "datadog"))

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecFunctionLogDestinationLogtailOutputReference:
        return typing.cast(AppSpecFunctionLogDestinationLogtailOutputReference, jsii.get(self, "logtail"))

    @builtins.property
    @jsii.member(jsii_name="openSearch")
    def open_search(self) -> AppSpecFunctionLogDestinationOpenSearchOutputReference:
        return typing.cast(AppSpecFunctionLogDestinationOpenSearchOutputReference, jsii.get(self, "openSearch"))

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecFunctionLogDestinationPapertrailOutputReference":
        return typing.cast("AppSpecFunctionLogDestinationPapertrailOutputReference", jsii.get(self, "papertrail"))

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecFunctionLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationDatadog], jsii.get(self, "datadogInput"))

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecFunctionLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationLogtail], jsii.get(self, "logtailInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="openSearchInput")
    def open_search_input(
        self,
    ) -> typing.Optional[AppSpecFunctionLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationOpenSearch], jsii.get(self, "openSearchInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(
        self,
    ) -> typing.Optional["AppSpecFunctionLogDestinationPapertrail"]:
        return typing.cast(typing.Optional["AppSpecFunctionLogDestinationPapertrail"], jsii.get(self, "papertrailInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fce8a45f03828296766ad7c7eefb758e36d89b1340f22d445362e742cdf06c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2fc48fb7aab26e8fccefebca1ae70e3c7071c12dce81acdee1199a808b59ab3c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecFunctionLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a9f7d989889a78bc7b35a28a8899ddf8bb65531db068d9d56be5f73c9052c8b)
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        '''Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c7af33e25ea778eee0d4cf01b86392ae402005a54cece16630007f0bf894c4a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d664b72c7bb3cf55dfeb24e03f3c5607019ceeedab3e7708f07f2ec788fd9408)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[AppSpecFunctionLogDestinationPapertrail]:
        return typing.cast(typing.Optional[AppSpecFunctionLogDestinationPapertrail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecFunctionLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34948092c3ad79dfd2b999804f4002b9cdc78a5dfefc874de52773fbeba49cdb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a0639923a619d05beb0823d07cd56b187c03e6ca8f4e8ae75b46a53a914779e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionAlert, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90e7c8e628e0cce6c1a678e955b6c865d80472a0bf877cd798b74a918a3be8a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putBitbucket")
    def put_bitbucket(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecFunctionBitbucket(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putBitbucket", [value]))

    @jsii.member(jsii_name="putCors")
    def put_cors(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union[AppSpecFunctionCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        value = AppSpecFunctionCors(
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )

        return typing.cast(None, jsii.invoke(self, "putCors", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionEnv, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fbf401f813fe199b414c37316262fd97a8abc06a7b41e365221056dcd846b96)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        value = AppSpecFunctionGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecFunctionGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecFunctionGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionLogDestination, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__370e661586949a3ca3c6edd8185dac4fff92e0f1b3c4c6e8107335d5a5a18e7b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="putRoutes")
    def put_routes(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecFunctionRoutes", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93b591fd733cf0ee3fc91a61a127332db2e519a0ff8ecae618e61b881cd85877)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRoutes", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetBitbucket")
    def reset_bitbucket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBitbucket", []))

    @jsii.member(jsii_name="resetCors")
    def reset_cors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCors", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRoutes")
    def reset_routes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoutes", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecFunctionAlertList:
        return typing.cast(AppSpecFunctionAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="bitbucket")
    def bitbucket(self) -> AppSpecFunctionBitbucketOutputReference:
        return typing.cast(AppSpecFunctionBitbucketOutputReference, jsii.get(self, "bitbucket"))

    @builtins.property
    @jsii.member(jsii_name="cors")
    def cors(self) -> AppSpecFunctionCorsOutputReference:
        return typing.cast(AppSpecFunctionCorsOutputReference, jsii.get(self, "cors"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecFunctionEnvList:
        return typing.cast(AppSpecFunctionEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecFunctionGitOutputReference:
        return typing.cast(AppSpecFunctionGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecFunctionGithubOutputReference:
        return typing.cast(AppSpecFunctionGithubOutputReference, jsii.get(self, "github"))

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecFunctionGitlabOutputReference:
        return typing.cast(AppSpecFunctionGitlabOutputReference, jsii.get(self, "gitlab"))

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecFunctionLogDestinationList:
        return typing.cast(AppSpecFunctionLogDestinationList, jsii.get(self, "logDestination"))

    @builtins.property
    @jsii.member(jsii_name="routes")
    def routes(self) -> "AppSpecFunctionRoutesList":
        return typing.cast("AppSpecFunctionRoutesList", jsii.get(self, "routes"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]], jsii.get(self, "alertInput"))

    @builtins.property
    @jsii.member(jsii_name="bitbucketInput")
    def bitbucket_input(self) -> typing.Optional[AppSpecFunctionBitbucket]:
        return typing.cast(typing.Optional[AppSpecFunctionBitbucket], jsii.get(self, "bitbucketInput"))

    @builtins.property
    @jsii.member(jsii_name="corsInput")
    def cors_input(self) -> typing.Optional[AppSpecFunctionCors]:
        return typing.cast(typing.Optional[AppSpecFunctionCors], jsii.get(self, "corsInput"))

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]], jsii.get(self, "envInput"))

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecFunctionGithub]:
        return typing.cast(typing.Optional[AppSpecFunctionGithub], jsii.get(self, "githubInput"))

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecFunctionGit]:
        return typing.cast(typing.Optional[AppSpecFunctionGit], jsii.get(self, "gitInput"))

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecFunctionGitlab]:
        return typing.cast(typing.Optional[AppSpecFunctionGitlab], jsii.get(self, "gitlabInput"))

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]]], jsii.get(self, "logDestinationInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="routesInput")
    def routes_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecFunctionRoutes"]]], jsii.get(self, "routesInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDirInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa6b83b7147eb28068a11b0d4653507d89a68d1e3e0e0fa3b514b619f5a9f09c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c4cb9caa0732ff8a5f17827c852373ac0249eafe80aaf741940be481ec2b7ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDir", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8799b6c752769369988b7c3236b495ebf72baa7d681bb84eadac9f190bb9c8e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionRoutes",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "preserve_path_prefix": "preservePathPrefix"},
)
class AppSpecFunctionRoutes:
    def __init__(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param path: Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        :param preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d342fd7bacfdf2b533292944ce51ae4685ad88ae1417dc16429538f628f6dcd)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument preserve_path_prefix", value=preserve_path_prefix, expected_type=type_hints["preserve_path_prefix"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path
        if preserve_path_prefix is not None:
            self._values["preserve_path_prefix"] = preserve_path_prefix

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path specifies an route by HTTP path prefix.

        Paths must start with / and must be unique within the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_path_prefix(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''An optional flag to preserve the path that is forwarded to the backend service.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        '''
        result = self._values.get("preserve_path_prefix")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecFunctionRoutes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecFunctionRoutesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionRoutesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5873e9d50ae71262d458e74509dcc12ce3993fae9f4b2f7ea1b7eded0e0a667)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecFunctionRoutesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3284c282591edfe8b50229b568bbe16f1d24241fd7be97c597a9ae9b80c9600)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecFunctionRoutesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__101d2d78c456d84af0a872a0897b932a75f12052e747181741678ed8feb3b791)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__380e739d589ddc6be11ef0b87b6fc7811330867cebcdb5ff0063b13ffc55c26b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f34a92e02eaa2d78f25efc6b59960836adcd2ed6742a40723e40812df48fa6b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3af2de4802b34adf467379c68db016c2e50e88eeb3ded2689f3db1dccdada5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecFunctionRoutesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecFunctionRoutesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ccdaa6d147a14d6dd41a9617e96596035de07a02c895f5742ea17f21853e689)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPreservePathPrefix")
    def reset_preserve_path_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreservePathPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefixInput")
    def preserve_path_prefix_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "preservePathPrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b40d4473d4eb9fb31db930656f04d979474497484b2cba4030ee1ba4221b82b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "path", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefix")
    def preserve_path_prefix(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "preservePathPrefix"))

    @preserve_path_prefix.setter
    def preserve_path_prefix(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__677deadb8001bbf513313c3c0c549801b7fa93abffc07c3e931bac83bd033e6d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preservePathPrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46b5c21e2bd5f94231ac2c2780c0ecab219545e3267b85b47ccbbab77066506f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngress",
    jsii_struct_bases=[],
    name_mapping={"rule": "rule"},
)
class AppSpecIngress:
    def __init__(
        self,
        *,
        rule: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecIngressRule", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param rule: rule block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f76a4c002e24ffff3890c2f0f3de44e298b686d2e44075cb82181a7a0a9c524)
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rule is not None:
            self._values["rule"] = rule

    @builtins.property
    def rule(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecIngressRule"]]]:
        '''rule block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}
        '''
        result = self._values.get("rule")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecIngressRule"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngress(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecIngressOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15dda3d3068c9fb71028aec2d366fe813f774c12e288785e0435a8e40c4685a1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putRule")
    def put_rule(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecIngressRule", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05ebbf4f773e313d4fc9470ebb9724fdf9ac8914851efc9967a55ba0d50e4ef8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRule", [value]))

    @jsii.member(jsii_name="resetRule")
    def reset_rule(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRule", []))

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> "AppSpecIngressRuleList":
        return typing.cast("AppSpecIngressRuleList", jsii.get(self, "rule"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecIngressRule"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecIngressRule"]]], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngress]:
        return typing.cast(typing.Optional[AppSpecIngress], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecIngress]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a4f75a9422cbe6ba8ed3430df23e06671d5da4c121ff5014c0130ddce1c3a03)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRule",
    jsii_struct_bases=[],
    name_mapping={
        "component": "component",
        "cors": "cors",
        "match": "match",
        "redirect": "redirect",
    },
)
class AppSpecIngressRule:
    def __init__(
        self,
        *,
        component: typing.Optional[typing.Union["AppSpecIngressRuleComponent", typing.Dict[builtins.str, typing.Any]]] = None,
        cors: typing.Optional[typing.Union["AppSpecIngressRuleCors", typing.Dict[builtins.str, typing.Any]]] = None,
        match: typing.Optional[typing.Union["AppSpecIngressRuleMatch", typing.Dict[builtins.str, typing.Any]]] = None,
        redirect: typing.Optional[typing.Union["AppSpecIngressRuleRedirect", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param component: component block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#component App#component}
        :param cors: cors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        :param match: match block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#match App#match}
        :param redirect: redirect block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#redirect App#redirect}
        '''
        if isinstance(component, dict):
            component = AppSpecIngressRuleComponent(**component)
        if isinstance(cors, dict):
            cors = AppSpecIngressRuleCors(**cors)
        if isinstance(match, dict):
            match = AppSpecIngressRuleMatch(**match)
        if isinstance(redirect, dict):
            redirect = AppSpecIngressRuleRedirect(**redirect)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ff3a8a18d79528fadcc270e382c8bbd1805559a0bf36cc0bd4c2f58df28b9ee)
            check_type(argname="argument component", value=component, expected_type=type_hints["component"])
            check_type(argname="argument cors", value=cors, expected_type=type_hints["cors"])
            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
            check_type(argname="argument redirect", value=redirect, expected_type=type_hints["redirect"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if component is not None:
            self._values["component"] = component
        if cors is not None:
            self._values["cors"] = cors
        if match is not None:
            self._values["match"] = match
        if redirect is not None:
            self._values["redirect"] = redirect

    @builtins.property
    def component(self) -> typing.Optional["AppSpecIngressRuleComponent"]:
        '''component block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#component App#component}
        '''
        result = self._values.get("component")
        return typing.cast(typing.Optional["AppSpecIngressRuleComponent"], result)

    @builtins.property
    def cors(self) -> typing.Optional["AppSpecIngressRuleCors"]:
        '''cors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        '''
        result = self._values.get("cors")
        return typing.cast(typing.Optional["AppSpecIngressRuleCors"], result)

    @builtins.property
    def match(self) -> typing.Optional["AppSpecIngressRuleMatch"]:
        '''match block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#match App#match}
        '''
        result = self._values.get("match")
        return typing.cast(typing.Optional["AppSpecIngressRuleMatch"], result)

    @builtins.property
    def redirect(self) -> typing.Optional["AppSpecIngressRuleRedirect"]:
        '''redirect block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#redirect App#redirect}
        '''
        result = self._values.get("redirect")
        return typing.cast(typing.Optional["AppSpecIngressRuleRedirect"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleComponent",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "preserve_path_prefix": "preservePathPrefix",
        "rewrite": "rewrite",
    },
)
class AppSpecIngressRuleComponent:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        rewrite: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}.
        :param preserve_path_prefix: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}.
        :param rewrite: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rewrite App#rewrite}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d42f444906cfd089cdf46ab2f85df4d05d82a434215919e5f5f4d6b3d29091a6)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument preserve_path_prefix", value=preserve_path_prefix, expected_type=type_hints["preserve_path_prefix"])
            check_type(argname="argument rewrite", value=rewrite, expected_type=type_hints["rewrite"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if preserve_path_prefix is not None:
            self._values["preserve_path_prefix"] = preserve_path_prefix
        if rewrite is not None:
            self._values["rewrite"] = rewrite

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_path_prefix(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}.'''
        result = self._values.get("preserve_path_prefix")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def rewrite(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rewrite App#rewrite}.'''
        result = self._values.get("rewrite")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRuleComponent(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecIngressRuleComponentOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleComponentOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89d6830b49e1559fc4f7a939b3dc9340c098497c2b6584845a712d401715b698)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetPreservePathPrefix")
    def reset_preserve_path_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreservePathPrefix", []))

    @jsii.member(jsii_name="resetRewrite")
    def reset_rewrite(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRewrite", []))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefixInput")
    def preserve_path_prefix_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "preservePathPrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="rewriteInput")
    def rewrite_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "rewriteInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__429e61dfcc6ea42509240322a7d644a942c6073c8c4f360a7baa636f18409c1f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefix")
    def preserve_path_prefix(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "preservePathPrefix"))

    @preserve_path_prefix.setter
    def preserve_path_prefix(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd01923c20690b03b3330b4ea4070b40c420ea29217496e273f7b79883b6b452)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preservePathPrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rewrite")
    def rewrite(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rewrite"))

    @rewrite.setter
    def rewrite(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16af3c867ea4e0395fead54d3670b1dd6f48b1bc93f1b638ccdda2c9035cff34)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rewrite", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngressRuleComponent]:
        return typing.cast(typing.Optional[AppSpecIngressRuleComponent], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecIngressRuleComponent],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23bf3accddbf7bcd85b724edf80e8a833b5561e9a03a38b76f2bb25b0d375d45)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleCors",
    jsii_struct_bases=[],
    name_mapping={
        "allow_credentials": "allowCredentials",
        "allow_headers": "allowHeaders",
        "allow_methods": "allowMethods",
        "allow_origins": "allowOrigins",
        "expose_headers": "exposeHeaders",
        "max_age": "maxAge",
    },
)
class AppSpecIngressRuleCors:
    def __init__(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union["AppSpecIngressRuleCorsAllowOrigins", typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        if isinstance(allow_origins, dict):
            allow_origins = AppSpecIngressRuleCorsAllowOrigins(**allow_origins)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e184ba3cfb46e4010add7cc9f8f4c583326df5326886a7f796e2b9b87367a0b)
            check_type(argname="argument allow_credentials", value=allow_credentials, expected_type=type_hints["allow_credentials"])
            check_type(argname="argument allow_headers", value=allow_headers, expected_type=type_hints["allow_headers"])
            check_type(argname="argument allow_methods", value=allow_methods, expected_type=type_hints["allow_methods"])
            check_type(argname="argument allow_origins", value=allow_origins, expected_type=type_hints["allow_origins"])
            check_type(argname="argument expose_headers", value=expose_headers, expected_type=type_hints["expose_headers"])
            check_type(argname="argument max_age", value=max_age, expected_type=type_hints["max_age"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_credentials is not None:
            self._values["allow_credentials"] = allow_credentials
        if allow_headers is not None:
            self._values["allow_headers"] = allow_headers
        if allow_methods is not None:
            self._values["allow_methods"] = allow_methods
        if allow_origins is not None:
            self._values["allow_origins"] = allow_origins
        if expose_headers is not None:
            self._values["expose_headers"] = expose_headers
        if max_age is not None:
            self._values["max_age"] = max_age

    @builtins.property
    def allow_credentials(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``.

        This configures the Access-Control-Allow-Credentials header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        '''
        result = self._values.get("allow_credentials")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def allow_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        '''
        result = self._values.get("allow_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_methods(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        '''
        result = self._values.get("allow_methods")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_origins(self) -> typing.Optional["AppSpecIngressRuleCorsAllowOrigins"]:
        '''allow_origins block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        '''
        result = self._values.get("allow_origins")
        return typing.cast(typing.Optional["AppSpecIngressRuleCorsAllowOrigins"], result)

    @builtins.property
    def expose_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        '''
        result = self._values.get("expose_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def max_age(self) -> typing.Optional[builtins.str]:
        '''An optional duration specifying how long browsers can cache the results of a preflight request.

        This configures the Access-Control-Max-Age header. Example: ``5h30m``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        result = self._values.get("max_age")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRuleCors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleCorsAllowOrigins",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact", "prefix": "prefix", "regex": "regex"},
)
class AppSpecIngressRuleCorsAllowOrigins:
    def __init__(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae87663880807dfa2828990887c35ad47a65ce57ca4150aa5ecf0f76dd094aa9)
            check_type(argname="argument exact", value=exact, expected_type=type_hints["exact"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact
        if prefix is not None:
            self._values["prefix"] = prefix
        if regex is not None:
            self._values["regex"] = regex

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        '''Exact string match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        '''
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''Prefix-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def regex(self) -> typing.Optional[builtins.str]:
        '''RE2 style regex-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        result = self._values.get("regex")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRuleCorsAllowOrigins(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecIngressRuleCorsAllowOriginsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleCorsAllowOriginsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b980dca3f8d594d30f6a2f169556260e52eee055a052076cbfa87c7689c4b0f3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetRegex")
    def reset_regex(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegex", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regexInput")
    def regex_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b6d504acc84bb5944f43568d864109d652944d0c464703eb1062f7a31dd936a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exact", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__736c70ec6c9b9704bb256ff85879e26db9cbafbd3d93f3fde473a4766ca39f80)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "prefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="regex")
    def regex(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "regex"))

    @regex.setter
    def regex(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a48ab4825bfe51489096dc73c6ac936ecec1f85589d11de0b63c6053a6581956)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "regex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngressRuleCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecIngressRuleCorsAllowOrigins], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecIngressRuleCorsAllowOrigins],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be979a799bd3fdbb9d7e9ac5779b7814bb1803ceafe0f9a11c0f42e0db14c591)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecIngressRuleCorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleCorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c70cfd0cc75a7d826c6eda2a949753ea9425730ee1bc3309aa8667a5c4dd0fe)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAllowOrigins")
    def put_allow_origins(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        value = AppSpecIngressRuleCorsAllowOrigins(
            exact=exact, prefix=prefix, regex=regex
        )

        return typing.cast(None, jsii.invoke(self, "putAllowOrigins", [value]))

    @jsii.member(jsii_name="resetAllowCredentials")
    def reset_allow_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowCredentials", []))

    @jsii.member(jsii_name="resetAllowHeaders")
    def reset_allow_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowHeaders", []))

    @jsii.member(jsii_name="resetAllowMethods")
    def reset_allow_methods(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowMethods", []))

    @jsii.member(jsii_name="resetAllowOrigins")
    def reset_allow_origins(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowOrigins", []))

    @jsii.member(jsii_name="resetExposeHeaders")
    def reset_expose_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExposeHeaders", []))

    @jsii.member(jsii_name="resetMaxAge")
    def reset_max_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxAge", []))

    @builtins.property
    @jsii.member(jsii_name="allowOrigins")
    def allow_origins(self) -> AppSpecIngressRuleCorsAllowOriginsOutputReference:
        return typing.cast(AppSpecIngressRuleCorsAllowOriginsOutputReference, jsii.get(self, "allowOrigins"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentialsInput")
    def allow_credentials_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "allowCredentialsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowHeadersInput")
    def allow_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="allowMethodsInput")
    def allow_methods_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowMethodsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowOriginsInput")
    def allow_origins_input(
        self,
    ) -> typing.Optional[AppSpecIngressRuleCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecIngressRuleCorsAllowOrigins], jsii.get(self, "allowOriginsInput"))

    @builtins.property
    @jsii.member(jsii_name="exposeHeadersInput")
    def expose_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "exposeHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="maxAgeInput")
    def max_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentials")
    def allow_credentials(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "allowCredentials"))

    @allow_credentials.setter
    def allow_credentials(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a21eb8a42b6f9574bbe06eb55ee594236aecc2e615427504855d658aa5189580)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowCredentials", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowHeaders")
    def allow_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowHeaders"))

    @allow_headers.setter
    def allow_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b45009d902392104202748eaee2becc4a2c0972eada4287422b532befc97c5ef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowMethods")
    def allow_methods(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowMethods"))

    @allow_methods.setter
    def allow_methods(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18e5869aa7fb5884c617020d801afb99f01fc03f845378dde886fc1098bfdc56)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowMethods", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="exposeHeaders")
    def expose_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "exposeHeaders"))

    @expose_headers.setter
    def expose_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1885b7906f046c94baa894dc5db0f45a08b198074707a2262e7300b8ef076e1e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exposeHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxAge")
    def max_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxAge"))

    @max_age.setter
    def max_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17f011eaf84084fc5afcb841d3000f5578b164ce71738cad5a1067f6726a1507)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngressRuleCors]:
        return typing.cast(typing.Optional[AppSpecIngressRuleCors], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecIngressRuleCors]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d24b600d8f10dd289ab41281d7d8ead54da2768c9e90f4a91e5418bc7fe78cc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecIngressRuleList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f5dac640b8893fec91f88c8024b7e2cbc1087222fa5a997e4b383e233de3594)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecIngressRuleOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b2d8b47eff3ea217013eb9db7a1ff15fcd50bec56d86cdca6dd424810d99423)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecIngressRuleOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__676f01c4fea80fe511124884ed6de0695f8f6da947003fea1200916005e6e2a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4ee491890dc22b6be6822ae07ea2ead4df9cfeb053710891e40425f9fbd9158)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01e9512df1478db18c08aa067d71e7d90afb8a83341c42e4f6bb5e527a850534)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecIngressRule]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecIngressRule]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecIngressRule]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72cd9f905de85bbd8b2f5144288843b75303b38d5a7481b4301b663798393fed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleMatch",
    jsii_struct_bases=[],
    name_mapping={"authority": "authority", "path": "path"},
)
class AppSpecIngressRuleMatch:
    def __init__(
        self,
        *,
        authority: typing.Optional[typing.Union["AppSpecIngressRuleMatchAuthority", typing.Dict[builtins.str, typing.Any]]] = None,
        path: typing.Optional[typing.Union["AppSpecIngressRuleMatchPath", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param authority: authority block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#authority App#authority}
        :param path: path block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        '''
        if isinstance(authority, dict):
            authority = AppSpecIngressRuleMatchAuthority(**authority)
        if isinstance(path, dict):
            path = AppSpecIngressRuleMatchPath(**path)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa2732c89acdb3de172afea00e7faf4af6cbd79e71027421abce9ec8fe374b33)
            check_type(argname="argument authority", value=authority, expected_type=type_hints["authority"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authority is not None:
            self._values["authority"] = authority
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def authority(self) -> typing.Optional["AppSpecIngressRuleMatchAuthority"]:
        '''authority block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#authority App#authority}
        '''
        result = self._values.get("authority")
        return typing.cast(typing.Optional["AppSpecIngressRuleMatchAuthority"], result)

    @builtins.property
    def path(self) -> typing.Optional["AppSpecIngressRuleMatchPath"]:
        '''path block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional["AppSpecIngressRuleMatchPath"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRuleMatch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleMatchAuthority",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact"},
)
class AppSpecIngressRuleMatchAuthority:
    def __init__(self, *, exact: typing.Optional[builtins.str] = None) -> None:
        '''
        :param exact: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f713c2538195d1f85e8b721b45e79fff0fb28d13f7dee95101d8268375f13800)
            check_type(argname="argument exact", value=exact, expected_type=type_hints["exact"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}.'''
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRuleMatchAuthority(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecIngressRuleMatchAuthorityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleMatchAuthorityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6beb8a82215969765fece613d762b4f7296a1dba8439ed8755a07dffe3459459)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a18e1bd85e442566fe05ba87e00f548ec547b69c5c8912b4c05bd102762081b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exact", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngressRuleMatchAuthority]:
        return typing.cast(typing.Optional[AppSpecIngressRuleMatchAuthority], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecIngressRuleMatchAuthority],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1e3d925cbe2c8765d742535d79ab82c85f894136ecf98ff43e73a600cd15c04)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecIngressRuleMatchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleMatchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c97b36f80223f682a85815bb36633fa88d3545c07b1c8c505ac8ea4cd28ac513)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAuthority")
    def put_authority(self, *, exact: typing.Optional[builtins.str] = None) -> None:
        '''
        :param exact: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}.
        '''
        value = AppSpecIngressRuleMatchAuthority(exact=exact)

        return typing.cast(None, jsii.invoke(self, "putAuthority", [value]))

    @jsii.member(jsii_name="putPath")
    def put_path(self, *, prefix: typing.Optional[builtins.str] = None) -> None:
        '''
        :param prefix: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}.
        '''
        value = AppSpecIngressRuleMatchPath(prefix=prefix)

        return typing.cast(None, jsii.invoke(self, "putPath", [value]))

    @jsii.member(jsii_name="resetAuthority")
    def reset_authority(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuthority", []))

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @builtins.property
    @jsii.member(jsii_name="authority")
    def authority(self) -> AppSpecIngressRuleMatchAuthorityOutputReference:
        return typing.cast(AppSpecIngressRuleMatchAuthorityOutputReference, jsii.get(self, "authority"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> "AppSpecIngressRuleMatchPathOutputReference":
        return typing.cast("AppSpecIngressRuleMatchPathOutputReference", jsii.get(self, "path"))

    @builtins.property
    @jsii.member(jsii_name="authorityInput")
    def authority_input(self) -> typing.Optional[AppSpecIngressRuleMatchAuthority]:
        return typing.cast(typing.Optional[AppSpecIngressRuleMatchAuthority], jsii.get(self, "authorityInput"))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional["AppSpecIngressRuleMatchPath"]:
        return typing.cast(typing.Optional["AppSpecIngressRuleMatchPath"], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngressRuleMatch]:
        return typing.cast(typing.Optional[AppSpecIngressRuleMatch], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecIngressRuleMatch]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a5a8b67dff41aa37e77c381a0f27f1a0f4b4398781efbc9e1bb131c19e72f5a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleMatchPath",
    jsii_struct_bases=[],
    name_mapping={"prefix": "prefix"},
)
class AppSpecIngressRuleMatchPath:
    def __init__(self, *, prefix: typing.Optional[builtins.str] = None) -> None:
        '''
        :param prefix: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdc1808ecb38a5cde8b0618a441734891221b6050f72c2a677381c9ec53fbe49)
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if prefix is not None:
            self._values["prefix"] = prefix

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}.'''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRuleMatchPath(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecIngressRuleMatchPathOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleMatchPathOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7692b4a26f85964de58b8d95b312b264d7de6fc8cd8d987f95df006fd001b63d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__215c9f2c05f8834c78745b5f304414d2c0dc1be86234d034f50269459024f645)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "prefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngressRuleMatchPath]:
        return typing.cast(typing.Optional[AppSpecIngressRuleMatchPath], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecIngressRuleMatchPath],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fbd910a3231fe69b6df3dd3977b1a2c31bf884f19dfe128c27e8be8e54810b6b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecIngressRuleOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e93686ddc263ab595dc45165454e4e005edf41715f57ea4717644883a5aa259)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putComponent")
    def put_component(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        rewrite: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}.
        :param preserve_path_prefix: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}.
        :param rewrite: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rewrite App#rewrite}.
        '''
        value = AppSpecIngressRuleComponent(
            name=name, preserve_path_prefix=preserve_path_prefix, rewrite=rewrite
        )

        return typing.cast(None, jsii.invoke(self, "putComponent", [value]))

    @jsii.member(jsii_name="putCors")
    def put_cors(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union[AppSpecIngressRuleCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        value = AppSpecIngressRuleCors(
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )

        return typing.cast(None, jsii.invoke(self, "putCors", [value]))

    @jsii.member(jsii_name="putMatch")
    def put_match(
        self,
        *,
        authority: typing.Optional[typing.Union[AppSpecIngressRuleMatchAuthority, typing.Dict[builtins.str, typing.Any]]] = None,
        path: typing.Optional[typing.Union[AppSpecIngressRuleMatchPath, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param authority: authority block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#authority App#authority}
        :param path: path block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        '''
        value = AppSpecIngressRuleMatch(authority=authority, path=path)

        return typing.cast(None, jsii.invoke(self, "putMatch", [value]))

    @jsii.member(jsii_name="putRedirect")
    def put_redirect(
        self,
        *,
        authority: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
        redirect_code: typing.Optional[jsii.Number] = None,
        scheme: typing.Optional[builtins.str] = None,
        uri: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param authority: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#authority App#authority}.
        :param port: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#port App#port}.
        :param redirect_code: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#redirect_code App#redirect_code}.
        :param scheme: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scheme App#scheme}.
        :param uri: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#uri App#uri}.
        '''
        value = AppSpecIngressRuleRedirect(
            authority=authority,
            port=port,
            redirect_code=redirect_code,
            scheme=scheme,
            uri=uri,
        )

        return typing.cast(None, jsii.invoke(self, "putRedirect", [value]))

    @jsii.member(jsii_name="resetComponent")
    def reset_component(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetComponent", []))

    @jsii.member(jsii_name="resetCors")
    def reset_cors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCors", []))

    @jsii.member(jsii_name="resetMatch")
    def reset_match(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMatch", []))

    @jsii.member(jsii_name="resetRedirect")
    def reset_redirect(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRedirect", []))

    @builtins.property
    @jsii.member(jsii_name="component")
    def component(self) -> AppSpecIngressRuleComponentOutputReference:
        return typing.cast(AppSpecIngressRuleComponentOutputReference, jsii.get(self, "component"))

    @builtins.property
    @jsii.member(jsii_name="cors")
    def cors(self) -> AppSpecIngressRuleCorsOutputReference:
        return typing.cast(AppSpecIngressRuleCorsOutputReference, jsii.get(self, "cors"))

    @builtins.property
    @jsii.member(jsii_name="match")
    def match(self) -> AppSpecIngressRuleMatchOutputReference:
        return typing.cast(AppSpecIngressRuleMatchOutputReference, jsii.get(self, "match"))

    @builtins.property
    @jsii.member(jsii_name="redirect")
    def redirect(self) -> "AppSpecIngressRuleRedirectOutputReference":
        return typing.cast("AppSpecIngressRuleRedirectOutputReference", jsii.get(self, "redirect"))

    @builtins.property
    @jsii.member(jsii_name="componentInput")
    def component_input(self) -> typing.Optional[AppSpecIngressRuleComponent]:
        return typing.cast(typing.Optional[AppSpecIngressRuleComponent], jsii.get(self, "componentInput"))

    @builtins.property
    @jsii.member(jsii_name="corsInput")
    def cors_input(self) -> typing.Optional[AppSpecIngressRuleCors]:
        return typing.cast(typing.Optional[AppSpecIngressRuleCors], jsii.get(self, "corsInput"))

    @builtins.property
    @jsii.member(jsii_name="matchInput")
    def match_input(self) -> typing.Optional[AppSpecIngressRuleMatch]:
        return typing.cast(typing.Optional[AppSpecIngressRuleMatch], jsii.get(self, "matchInput"))

    @builtins.property
    @jsii.member(jsii_name="redirectInput")
    def redirect_input(self) -> typing.Optional["AppSpecIngressRuleRedirect"]:
        return typing.cast(typing.Optional["AppSpecIngressRuleRedirect"], jsii.get(self, "redirectInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecIngressRule]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecIngressRule]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecIngressRule]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5a201f81bec64a671bed046d3e92343b34979002eff1125f26ffc2a1fd32b24)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleRedirect",
    jsii_struct_bases=[],
    name_mapping={
        "authority": "authority",
        "port": "port",
        "redirect_code": "redirectCode",
        "scheme": "scheme",
        "uri": "uri",
    },
)
class AppSpecIngressRuleRedirect:
    def __init__(
        self,
        *,
        authority: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
        redirect_code: typing.Optional[jsii.Number] = None,
        scheme: typing.Optional[builtins.str] = None,
        uri: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param authority: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#authority App#authority}.
        :param port: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#port App#port}.
        :param redirect_code: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#redirect_code App#redirect_code}.
        :param scheme: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scheme App#scheme}.
        :param uri: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#uri App#uri}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__268ca60f7fcd98af8a1760845d57f5432339d133b7977b2db8f3d7f1b2a61dfb)
            check_type(argname="argument authority", value=authority, expected_type=type_hints["authority"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument redirect_code", value=redirect_code, expected_type=type_hints["redirect_code"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
            check_type(argname="argument uri", value=uri, expected_type=type_hints["uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authority is not None:
            self._values["authority"] = authority
        if port is not None:
            self._values["port"] = port
        if redirect_code is not None:
            self._values["redirect_code"] = redirect_code
        if scheme is not None:
            self._values["scheme"] = scheme
        if uri is not None:
            self._values["uri"] = uri

    @builtins.property
    def authority(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#authority App#authority}.'''
        result = self._values.get("authority")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#port App#port}.'''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def redirect_code(self) -> typing.Optional[jsii.Number]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#redirect_code App#redirect_code}.'''
        result = self._values.get("redirect_code")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scheme App#scheme}.'''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def uri(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#uri App#uri}.'''
        result = self._values.get("uri")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecIngressRuleRedirect(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecIngressRuleRedirectOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecIngressRuleRedirectOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe0d32c3b334fc2fd28fcb4091fa52dfdd0f927bcb978ea8be8fdb0a7169c5b1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAuthority")
    def reset_authority(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuthority", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetRedirectCode")
    def reset_redirect_code(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRedirectCode", []))

    @jsii.member(jsii_name="resetScheme")
    def reset_scheme(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScheme", []))

    @jsii.member(jsii_name="resetUri")
    def reset_uri(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUri", []))

    @builtins.property
    @jsii.member(jsii_name="authorityInput")
    def authority_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "authorityInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="redirectCodeInput")
    def redirect_code_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "redirectCodeInput"))

    @builtins.property
    @jsii.member(jsii_name="schemeInput")
    def scheme_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "schemeInput"))

    @builtins.property
    @jsii.member(jsii_name="uriInput")
    def uri_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "uriInput"))

    @builtins.property
    @jsii.member(jsii_name="authority")
    def authority(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "authority"))

    @authority.setter
    def authority(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78e6ff27d1a8df58476d5e4f881cea6517a4a734380fabc2e5ee1aa878bde7ba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "authority", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__466b9a9223cb13422dd9c1966a2b4302581f1f1c726dfa71cd24fc90986bc2f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "port", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="redirectCode")
    def redirect_code(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "redirectCode"))

    @redirect_code.setter
    def redirect_code(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cec073b8b3eb9598c2e2c39d1818b02d7e20ea13dd99ca966cb2b2010d3362ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "redirectCode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scheme")
    def scheme(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scheme"))

    @scheme.setter
    def scheme(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d24bf161f558f5b403fc2d0089fda5dac99a2310733073ad2c86659820b55cc9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scheme", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="uri")
    def uri(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "uri"))

    @uri.setter
    def uri(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51e21cf72d9ed251b565a507fa4892538e48abfb6fd724327c0b03663f24149f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "uri", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecIngressRuleRedirect]:
        return typing.cast(typing.Optional[AppSpecIngressRuleRedirect], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecIngressRuleRedirect],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5cdf1d4e6a94812772323b8f189d5aca2de8a860385e5ce004b6988a7b73f46d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJob",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "bitbucket": "bitbucket",
        "build_command": "buildCommand",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "image": "image",
        "instance_count": "instanceCount",
        "instance_size_slug": "instanceSizeSlug",
        "kind": "kind",
        "log_destination": "logDestination",
        "run_command": "runCommand",
        "source_dir": "sourceDir",
        "termination": "termination",
    },
)
class AppSpecJob:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJobAlert", typing.Dict[builtins.str, typing.Any]]]]] = None,
        bitbucket: typing.Optional[typing.Union["AppSpecJobBitbucket", typing.Dict[builtins.str, typing.Any]]] = None,
        build_command: typing.Optional[builtins.str] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJobEnv", typing.Dict[builtins.str, typing.Any]]]]] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        git: typing.Optional[typing.Union["AppSpecJobGit", typing.Dict[builtins.str, typing.Any]]] = None,
        github: typing.Optional[typing.Union["AppSpecJobGithub", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["AppSpecJobGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        image: typing.Optional[typing.Union["AppSpecJobImage", typing.Dict[builtins.str, typing.Any]]] = None,
        instance_count: typing.Optional[jsii.Number] = None,
        instance_size_slug: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJobLogDestination", typing.Dict[builtins.str, typing.Any]]]]] = None,
        run_command: typing.Optional[builtins.str] = None,
        source_dir: typing.Optional[builtins.str] = None,
        termination: typing.Optional[typing.Union["AppSpecJobTermination", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        :param bitbucket: bitbucket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        :param image: image block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#image App#image}
        :param instance_count: The amount of instances that this component should be scaled to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_count App#instance_count}
        :param instance_size_slug: The instance size to use for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_size_slug App#instance_size_slug}
        :param kind: The type of job and when it will be run during the deployment process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#kind App#kind}
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        :param run_command: An optional run command to override the component's default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#run_command App#run_command}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        :param termination: termination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#termination App#termination}
        '''
        if isinstance(bitbucket, dict):
            bitbucket = AppSpecJobBitbucket(**bitbucket)
        if isinstance(git, dict):
            git = AppSpecJobGit(**git)
        if isinstance(github, dict):
            github = AppSpecJobGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecJobGitlab(**gitlab)
        if isinstance(image, dict):
            image = AppSpecJobImage(**image)
        if isinstance(termination, dict):
            termination = AppSpecJobTermination(**termination)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcf26b5e573e23cc79b70ddf72d6aa00f01a1cd40f956eef57808531884d0cf5)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument alert", value=alert, expected_type=type_hints["alert"])
            check_type(argname="argument bitbucket", value=bitbucket, expected_type=type_hints["bitbucket"])
            check_type(argname="argument build_command", value=build_command, expected_type=type_hints["build_command"])
            check_type(argname="argument dockerfile_path", value=dockerfile_path, expected_type=type_hints["dockerfile_path"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument environment_slug", value=environment_slug, expected_type=type_hints["environment_slug"])
            check_type(argname="argument git", value=git, expected_type=type_hints["git"])
            check_type(argname="argument github", value=github, expected_type=type_hints["github"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
            check_type(argname="argument instance_size_slug", value=instance_size_slug, expected_type=type_hints["instance_size_slug"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument log_destination", value=log_destination, expected_type=type_hints["log_destination"])
            check_type(argname="argument run_command", value=run_command, expected_type=type_hints["run_command"])
            check_type(argname="argument source_dir", value=source_dir, expected_type=type_hints["source_dir"])
            check_type(argname="argument termination", value=termination, expected_type=type_hints["termination"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if bitbucket is not None:
            self._values["bitbucket"] = bitbucket
        if build_command is not None:
            self._values["build_command"] = build_command
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if image is not None:
            self._values["image"] = image
        if instance_count is not None:
            self._values["instance_count"] = instance_count
        if instance_size_slug is not None:
            self._values["instance_size_slug"] = instance_size_slug
        if kind is not None:
            self._values["kind"] = kind
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if run_command is not None:
            self._values["run_command"] = run_command
        if source_dir is not None:
            self._values["source_dir"] = source_dir
        if termination is not None:
            self._values["termination"] = termination

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlert"]]]:
        '''alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        '''
        result = self._values.get("alert")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlert"]]], result)

    @builtins.property
    def bitbucket(self) -> typing.Optional["AppSpecJobBitbucket"]:
        '''bitbucket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        '''
        result = self._values.get("bitbucket")
        return typing.cast(typing.Optional["AppSpecJobBitbucket"], result)

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        '''An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        '''
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        '''The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        '''
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobEnv"]]]:
        '''env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobEnv"]]], result)

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        '''An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        '''
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecJobGit"]:
        '''git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        '''
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecJobGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecJobGithub"]:
        '''github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        '''
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecJobGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecJobGitlab"]:
        '''gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecJobGitlab"], result)

    @builtins.property
    def image(self) -> typing.Optional["AppSpecJobImage"]:
        '''image block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#image App#image}
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional["AppSpecJobImage"], result)

    @builtins.property
    def instance_count(self) -> typing.Optional[jsii.Number]:
        '''The amount of instances that this component should be scaled to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_count App#instance_count}
        '''
        result = self._values.get("instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_size_slug(self) -> typing.Optional[builtins.str]:
        '''The instance size to use for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_size_slug App#instance_size_slug}
        '''
        result = self._values.get("instance_size_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''The type of job and when it will be run during the deployment process.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#kind App#kind}
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobLogDestination"]]]:
        '''log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        '''
        result = self._values.get("log_destination")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobLogDestination"]]], result)

    @builtins.property
    def run_command(self) -> typing.Optional[builtins.str]:
        '''An optional run command to override the component's default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#run_command App#run_command}
        '''
        result = self._values.get("run_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        '''An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        '''
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination(self) -> typing.Optional["AppSpecJobTermination"]:
        '''termination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#termination App#termination}
        '''
        result = self._values.get("termination")
        return typing.cast(typing.Optional["AppSpecJobTermination"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJob(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "destinations": "destinations",
        "disabled": "disabled",
    },
)
class AppSpecJobAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        destinations: typing.Optional[typing.Union["AppSpecJobAlertDestinations", typing.Dict[builtins.str, typing.Any]]] = None,
        disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.
        :param destinations: destinations block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.
        '''
        if isinstance(destinations, dict):
            destinations = AppSpecJobAlertDestinations(**destinations)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be3acc81c4dec3067f5a0c63cfc670e83fa17c010017471b40714be206136607)
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if destinations is not None:
            self._values["destinations"] = destinations
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.'''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.'''
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.'''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.'''
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destinations(self) -> typing.Optional["AppSpecJobAlertDestinations"]:
        '''destinations block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        '''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional["AppSpecJobAlertDestinations"], result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.'''
        result = self._values.get("disabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlertDestinations",
    jsii_struct_bases=[],
    name_mapping={"emails": "emails", "slack_webhooks": "slackWebhooks"},
)
class AppSpecJobAlertDestinations:
    def __init__(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJobAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8c84222282bd859eb1815e512331798071dd786514ef75f2c0587f4ec631bfc)
            check_type(argname="argument emails", value=emails, expected_type=type_hints["emails"])
            check_type(argname="argument slack_webhooks", value=slack_webhooks, expected_type=type_hints["slack_webhooks"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if emails is not None:
            self._values["emails"] = emails
        if slack_webhooks is not None:
            self._values["slack_webhooks"] = slack_webhooks

    @builtins.property
    def emails(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.'''
        result = self._values.get("emails")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def slack_webhooks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlertDestinationsSlackWebhooks"]]]:
        '''slack_webhooks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        result = self._values.get("slack_webhooks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlertDestinationsSlackWebhooks"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobAlertDestinations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobAlertDestinationsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlertDestinationsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0cc8e9f635b118ab865f194bee73fd9f6112832c30ca82c4a86dbeb12ceada67)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSlackWebhooks")
    def put_slack_webhooks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJobAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ff38bb1bc20e78a7c3b8e0c1405e94c0a159a7703819802bc757895db21e8fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSlackWebhooks", [value]))

    @jsii.member(jsii_name="resetEmails")
    def reset_emails(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEmails", []))

    @jsii.member(jsii_name="resetSlackWebhooks")
    def reset_slack_webhooks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSlackWebhooks", []))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooks")
    def slack_webhooks(self) -> "AppSpecJobAlertDestinationsSlackWebhooksList":
        return typing.cast("AppSpecJobAlertDestinationsSlackWebhooksList", jsii.get(self, "slackWebhooks"))

    @builtins.property
    @jsii.member(jsii_name="emailsInput")
    def emails_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "emailsInput"))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooksInput")
    def slack_webhooks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlertDestinationsSlackWebhooks"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobAlertDestinationsSlackWebhooks"]]], jsii.get(self, "slackWebhooksInput"))

    @builtins.property
    @jsii.member(jsii_name="emails")
    def emails(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "emails"))

    @emails.setter
    def emails(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9291431534337753f5fb8e37b3b5cb6ba325623ee511e9153d74bc8128c6cb24)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "emails", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecJobAlertDestinations], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobAlertDestinations],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cff1a71bdaba3d692ab230ab2a2c66bc8e79816a2acc03118f3ed48a9665b68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlertDestinationsSlackWebhooks",
    jsii_struct_bases=[],
    name_mapping={"channel": "channel", "url": "url"},
)
class AppSpecJobAlertDestinationsSlackWebhooks:
    def __init__(self, *, channel: builtins.str, url: builtins.str) -> None:
        '''
        :param channel: The Slack channel to send notifications to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        :param url: The Slack webhook URL. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d38f58562057b5a448f7b25c935d545ab918be2256c963f5ed110571095b7b2d)
            check_type(argname="argument channel", value=channel, expected_type=type_hints["channel"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel": channel,
            "url": url,
        }

    @builtins.property
    def channel(self) -> builtins.str:
        '''The Slack channel to send notifications to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        '''
        result = self._values.get("channel")
        assert result is not None, "Required property 'channel' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''The Slack webhook URL.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobAlertDestinationsSlackWebhooks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobAlertDestinationsSlackWebhooksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlertDestinationsSlackWebhooksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3ecbb46d8f33ca0fa3f4126739e07722bd0c6368edcb4048d24914b75ae1e5a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecJobAlertDestinationsSlackWebhooksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41195a3bff1e16e9806dc65116e5a26f3e27a046244646e02fc57b7dac0bdfd9)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecJobAlertDestinationsSlackWebhooksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19476c9dd7b1530c0b4be3364f1ebabf703f22893fc1ac78de19c1f2828b2756)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8934f7e28628c3282ac84c49acd80c01792e5193b50d7a2baa78b4e00910490)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c1592e42155d999dc2ce719b45e07028ce285f4889046379c26a5fe4914114c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlertDestinationsSlackWebhooks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlertDestinationsSlackWebhooks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlertDestinationsSlackWebhooks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc0c8bf94c0f4d79d19eb174c23141fc8aebce01039021576c61736cb737e868)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobAlertDestinationsSlackWebhooksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlertDestinationsSlackWebhooksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1dbc1e4a42236493f0efe44d5c2e5044f4a0a2d5e5023efd2df369820ca6f248)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="channelInput")
    def channel_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "channelInput"))

    @builtins.property
    @jsii.member(jsii_name="urlInput")
    def url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "urlInput"))

    @builtins.property
    @jsii.member(jsii_name="channel")
    def channel(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channel"))

    @channel.setter
    def channel(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e062bf2b2324713e50e1b663b547f852b1837b8e65882a41ce9b4f854aa8a5c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "channel", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @url.setter
    def url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b48400837b5898ada9bbbd95072015d500ff9ad7f561ca22905a499c4d5d3df1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "url", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlertDestinationsSlackWebhooks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlertDestinationsSlackWebhooks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlertDestinationsSlackWebhooks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0eab49a58ccf74cc4d17b81b39c6012d78b78dbd7d91d777038b63392a7818bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__683527f4b33d0078b4db9450264d938a3ca68858b2310a843ba127496748181c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobAlertOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__433e45d4d768f6febeb6b64c5d72a1cecba42466442c2620f331bfda6a324785)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecJobAlertOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b099dc833297163d27b0aad75e96e0cb1c5d56d746a140cabca45f2c4cbe04e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0ce00b209040b0991935fc6f9932beeddbcba165c985603480cb4333439463b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20b5783f629c335e4e11aa6f0fd22f4dc3ce782159b251c0b93ff41683ea5e76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb8c1a30748a72a5b109022eac67d9c1f213df28e3f8a1e78705f81666c8e927)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c7ad0a81aa8dd0a82fae1690233a165e1c442f24d8fff575a225afde5896e5c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDestinations")
    def put_destinations(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        value = AppSpecJobAlertDestinations(
            emails=emails, slack_webhooks=slack_webhooks
        )

        return typing.cast(None, jsii.invoke(self, "putDestinations", [value]))

    @jsii.member(jsii_name="resetDestinations")
    def reset_destinations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDestinations", []))

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="destinations")
    def destinations(self) -> AppSpecJobAlertDestinationsOutputReference:
        return typing.cast(AppSpecJobAlertDestinationsOutputReference, jsii.get(self, "destinations"))

    @builtins.property
    @jsii.member(jsii_name="destinationsInput")
    def destinations_input(self) -> typing.Optional[AppSpecJobAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecJobAlertDestinations], jsii.get(self, "destinationsInput"))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "operatorInput"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac7955c0212a7a0e007ae6c34d06cb93012e61d04412d9d60464be6fa457a028)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f8310cce55dcafca6d540786d5e9f7162bfcf1b14ddb180e90e1e3ae81f87e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "operator", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e03861387e31e1b5c5ecf16f2e9ebce6ac3028bb44845d0e992ba0e65dd15595)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a73063b770e871d9d61ca1804bff6a5dbac926abd0434b912452eb72883d255)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9318c492dc14008e041fdbe37c60cc924001f2681effc46f757ba77c97015647)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "window", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e34092ab1dc1ad81bd415ecae02755bb202d4295090fff10147dae9fe081c509)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobBitbucket",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecJobBitbucket:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c52881e13cec22d64276845a1a72272f76b2c59ea94b037659e35d43ddd8eea)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobBitbucket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobBitbucketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobBitbucketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e03c395c1b561b2cbbe102e317eafc5235c0780d83b78468b17330013703cec1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d50d4e7ba2e91391905de7e454929b5937952d367de56a6d4edce3f28e75402)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e27e2ab9a44636bf3101e693dcd3ee9bfd8a6f9e87ab0dffc03ab155cbe918a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05a10c2f6ee57cf7c20415cd8fbb5eae7bdf14cbb734e73258da900998b83e2a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobBitbucket]:
        return typing.cast(typing.Optional[AppSpecJobBitbucket], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobBitbucket]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e87dd064d8a45b515d7dd3b1994b38b265c533cffd9c308804fabcf4a1a9f76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecJobEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7aedade110b6fd4949dcb641193079c54c1774733af6947cc6f0a7e7b403f27f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        '''The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__025f2a702125212b5f3e96bb7296e342ced8379260dccbb2c761e879c3ff3672)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobEnvOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b82e1379dea6e037b4840823c9069b3e162771863bf1e69084d18af143613609)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecJobEnvOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__515670284bec05769c77bff6d5d1fa0fe1d3b8fc04a2080c62be70ba59f09771)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3b3d8cf4e09e9bb280f3f184374fa8d0cf423f76a6c17c095b01c6f3472073e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75d9dfe3b68a9c74938f1f78ce5af6f6fb3166b3de340161284e810af10a8ce7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a861a333194faa5dee3641423fc87458d618681b059c312dd6cc08c1693c42ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f536e8994431e09692984503b99cad665464f63f1aac2d9b9dddd8b6fed6ac2e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__144ae7e83fdeb1c027f078f532dd92481b3c76452c7576a990a2400ae32e16f9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6baf81aae3afbcdeccf5edc14e4d6d90c659b5e8e2e766e946fbea70313b6406)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__777bf3bb9c39c9ea1c095fb80074547b0797b6754e24e059c7ef97ad3af07756)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5403dd0c51a58329b0e945ea452fa3de87004e9d02a2a4d6f151c6a6dc9cce2f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18b3fe5323a39cb8d0270c25173bfff3e09e7306a0f203ea088ce0e14dcb140b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecJobGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08d2c1d7b70088de9900003f6d2297d587d9c9e739ad4c178d73ecf56410a20c)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument repo_clone_url", value=repo_clone_url, expected_type=type_hints["repo_clone_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        '''The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b2634b2e48123aa0c70c221cd1b7371ea6c38c5c0a8d6b599589598ac02bb7b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15f4e39cbb6a07b54461484531dc90792d88124ac99413bf57d50dd17d7db149)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c22b4571fccd4c4940732d52194c01f17d8da1cdeef879575030ff50244965d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repoCloneUrl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobGit]:
        return typing.cast(typing.Optional[AppSpecJobGit], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33fdb84f283c1f34b01bef66fb9b0ecd36af101ee0ada491a9ff95cb562d1279)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecJobGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c04eb7945a7f896fdf4d993531051948a593c18b4ab890e4dbb372b7b52d7a2)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__633158b3aa5e169e137b809bac885fcef4b5eb384bb4a77656c9f0334cd7239d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4344cc2f962299aef6663702955b6876dfe41462a5f55171776c7450a17bd63d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb0953a7912b1344115af56418706f23ccce1210898de4fd87bd78244853ea76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee97e03f3dc94eebb0f37943a502f31d66a38ee3b064ad5939902d31259f2408)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobGithub]:
        return typing.cast(typing.Optional[AppSpecJobGithub], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fdcd28c133407ec21c6b06bf14ad59d6f6e656a145cdbf2299c70ebd0ee7059)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecJobGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61494db0431da4d97abebad512c852521311bae05b819a85f041b305fde6ed93)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3794062fa8fa6fb5f84908514e110e0aa0c8f96f17de8f4c61d36357a8a007e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd7e51358e3ac0a4e2967c304cd414690fe65738fbbadeeddfaabcd74fc053f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__242eb697436c98884b812533820c1426263b5b1957534672506fdc5d61442e20)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__875fb9eba129ca9d7b73f4283047a7b8a3aa5c466ad0003d35a91cb1849bd41c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobGitlab]:
        return typing.cast(typing.Optional[AppSpecJobGitlab], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d00fe80a4a10dfa94cc9284e14fdaf623dd0095bfbdf01f1a0bd45a5234aff8d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobImage",
    jsii_struct_bases=[],
    name_mapping={
        "registry_type": "registryType",
        "repository": "repository",
        "deploy_on_push": "deployOnPush",
        "digest": "digest",
        "registry": "registry",
        "registry_credentials": "registryCredentials",
        "tag": "tag",
    },
)
class AppSpecJobImage:
    def __init__(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecJobImageDeployOnPush", typing.Dict[builtins.str, typing.Any]]]]] = None,
        digest: typing.Optional[builtins.str] = None,
        registry: typing.Optional[builtins.str] = None,
        registry_credentials: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param digest: The image digest. Cannot be specified if tag is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        :param registry_credentials: Access credentials for third-party registries. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        :param tag: The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44dd460b7f7ece75329b21baffe70152a36bce40236dbc74d512c4119dac008e)
            check_type(argname="argument registry_type", value=registry_type, expected_type=type_hints["registry_type"])
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument digest", value=digest, expected_type=type_hints["digest"])
            check_type(argname="argument registry", value=registry, expected_type=type_hints["registry"])
            check_type(argname="argument registry_credentials", value=registry_credentials, expected_type=type_hints["registry_credentials"])
            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "registry_type": registry_type,
            "repository": repository,
        }
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if digest is not None:
            self._values["digest"] = digest
        if registry is not None:
            self._values["registry"] = registry
        if registry_credentials is not None:
            self._values["registry_credentials"] = registry_credentials
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def registry_type(self) -> builtins.str:
        '''The registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        '''
        result = self._values.get("registry_type")
        assert result is not None, "Required property 'registry_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        '''The repository name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        '''
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobImageDeployOnPush"]]]:
        '''deploy_on_push block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecJobImageDeployOnPush"]]], result)

    @builtins.property
    def digest(self) -> typing.Optional[builtins.str]:
        '''The image digest. Cannot be specified if tag is provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        '''
        result = self._values.get("digest")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def registry(self) -> typing.Optional[builtins.str]:
        '''The registry name. Must be left empty for the DOCR registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        '''
        result = self._values.get("registry")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def registry_credentials(self) -> typing.Optional[builtins.str]:
        '''Access credentials for third-party registries.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        '''
        result = self._values.get("registry_credentials")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag(self) -> typing.Optional[builtins.str]:
        '''The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        result = self._values.get("tag")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobImage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobImageDeployOnPush",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AppSpecJobImageDeployOnPush:
    def __init__(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Whether to automatically deploy images pushed to DOCR. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5eeed21080bebcc3d53c42ca866601775f7a32d0de1503da046b5a946091c68a)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy images pushed to DOCR.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobImageDeployOnPush(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobImageDeployOnPushList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobImageDeployOnPushList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14c11d566166be2420cb88c9fe29a7b290dede25dd44aa5ba72c101f4bdf4cc1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobImageDeployOnPushOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb04f6f50e009bac35a8b4bb60430463aeff5d03cebdbe27b268e8ed64367c46)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecJobImageDeployOnPushOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb739a1d1d717a2db9c804168c6fa753cd670222151d1c4912974a2f78f33b11)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5adadc9903540a47218af4b7fe1688d011059f98617fb8e11afd4bdb52324c64)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ef1c52a18c76dfb80adc2024f7610d7d57e02fdb4c0479327c45e00636790b3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc4f8b1f9e918655ffaa97eea16c9822a0346821c98823ab86d23fa44a7a2def)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobImageDeployOnPushOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobImageDeployOnPushOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cd85444be5a67c54256de5338649b0d7a4046c0aec288c2dee02f4893bce331)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9ec17e73190a6d6fd02c1d33a320297ca0b37683beb704085cc19ca1d6844ef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d7fe7a1ec7a76dc0f25f113848f80ee2ce90f6b04ef879df227bcbd9249847e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobImageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobImageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__286e4bf5349c35c6712b71146edd054a932f0d5cbfbe3e3b047a501042cbc02b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDeployOnPush")
    def put_deploy_on_push(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__653c716e3db0c009d35157deee00c0744f6aae54b3cb47c4170db7dbdff9a0b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDeployOnPush", [value]))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetDigest")
    def reset_digest(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDigest", []))

    @jsii.member(jsii_name="resetRegistry")
    def reset_registry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistry", []))

    @jsii.member(jsii_name="resetRegistryCredentials")
    def reset_registry_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistryCredentials", []))

    @jsii.member(jsii_name="resetTag")
    def reset_tag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTag", []))

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(self) -> AppSpecJobImageDeployOnPushList:
        return typing.cast(AppSpecJobImageDeployOnPushList, jsii.get(self, "deployOnPush"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="digestInput")
    def digest_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "digestInput"))

    @builtins.property
    @jsii.member(jsii_name="registryCredentialsInput")
    def registry_credentials_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryCredentialsInput"))

    @builtins.property
    @jsii.member(jsii_name="registryInput")
    def registry_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryInput"))

    @builtins.property
    @jsii.member(jsii_name="registryTypeInput")
    def registry_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="repositoryInput")
    def repository_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repositoryInput"))

    @builtins.property
    @jsii.member(jsii_name="tagInput")
    def tag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagInput"))

    @builtins.property
    @jsii.member(jsii_name="digest")
    def digest(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "digest"))

    @digest.setter
    def digest(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a6d1cacff41d41001a33540ca1d00cbafddc82616f19967df59850670c606d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "digest", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registry")
    def registry(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registry"))

    @registry.setter
    def registry(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44a928b806b2e79622234fae7615f9bc372581804aaccb91d4f3861521adf705)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registry", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registryCredentials")
    def registry_credentials(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryCredentials"))

    @registry_credentials.setter
    def registry_credentials(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24cabaad8f6a9cbb51315101f3e3b22d89a6247df0fcc13087639c4c2bca2d9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registryCredentials", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registryType")
    def registry_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryType"))

    @registry_type.setter
    def registry_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c2541bf4036dac0523136eef2561e638c445c5a06238e2def6236aa53ba5469)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registryType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repository"))

    @repository.setter
    def repository(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__309d6fe324367aff40918dfe79c7b5d7809486ddead845080f63771b728984fd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repository", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tag")
    def tag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tag"))

    @tag.setter
    def tag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__934e545667a613a39845890be41fbdba26b6fb1cd5909396f6bb662ddb066156)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tag", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobImage]:
        return typing.cast(typing.Optional[AppSpecJobImage], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobImage]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b0bb53f23ab5475a7b10a19a9ce3d74c10c2e10b28c875c422c35016edb438a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fcab48dd8148ba73276bc7cf28e43a80c3599bcbf631f1fbeb7b0dd88c5fc0fb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d614a30876ec98aa8f2abbd97ac0529048bb0d1cf877f040f9beb4f7f0ecd39)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecJobOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9db4b79b73feaeb3de3ead74f39421ddb34540e4602797862e909ef2671c2db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c0aaa26e3aca95d7e64dcde1aeecedc744e85315f6d8d36c4db18d15c0cb8e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56a055a5c368fa883f559f651ee80d2449e6e249bd954e0ae476763451067de0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2d7b2536af6ed63dec4d7dc031b3d592344f8f3dd2a8eac6e43e1827b4954bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "open_search": "openSearch",
        "papertrail": "papertrail",
    },
)
class AppSpecJobLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[typing.Union["AppSpecJobLogDestinationDatadog", typing.Dict[builtins.str, typing.Any]]] = None,
        logtail: typing.Optional[typing.Union["AppSpecJobLogDestinationLogtail", typing.Dict[builtins.str, typing.Any]]] = None,
        open_search: typing.Optional[typing.Union["AppSpecJobLogDestinationOpenSearch", typing.Dict[builtins.str, typing.Any]]] = None,
        papertrail: typing.Optional[typing.Union["AppSpecJobLogDestinationPapertrail", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        :param open_search: open_search block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        if isinstance(datadog, dict):
            datadog = AppSpecJobLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecJobLogDestinationLogtail(**logtail)
        if isinstance(open_search, dict):
            open_search = AppSpecJobLogDestinationOpenSearch(**open_search)
        if isinstance(papertrail, dict):
            papertrail = AppSpecJobLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__394c27d42c29c8731fe8ecbcc1f2f5104e7d2b28329a37196fe761cfc249c39c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument datadog", value=datadog, expected_type=type_hints["datadog"])
            check_type(argname="argument logtail", value=logtail, expected_type=type_hints["logtail"])
            check_type(argname="argument open_search", value=open_search, expected_type=type_hints["open_search"])
            check_type(argname="argument papertrail", value=papertrail, expected_type=type_hints["papertrail"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if open_search is not None:
            self._values["open_search"] = open_search
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecJobLogDestinationDatadog"]:
        '''datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        '''
        result = self._values.get("datadog")
        return typing.cast(typing.Optional["AppSpecJobLogDestinationDatadog"], result)

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecJobLogDestinationLogtail"]:
        '''logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        '''
        result = self._values.get("logtail")
        return typing.cast(typing.Optional["AppSpecJobLogDestinationLogtail"], result)

    @builtins.property
    def open_search(self) -> typing.Optional["AppSpecJobLogDestinationOpenSearch"]:
        '''open_search block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        '''
        result = self._values.get("open_search")
        return typing.cast(typing.Optional["AppSpecJobLogDestinationOpenSearch"], result)

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecJobLogDestinationPapertrail"]:
        '''papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        result = self._values.get("papertrail")
        return typing.cast(typing.Optional["AppSpecJobLogDestinationPapertrail"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecJobLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__101b1d73ee96df873cebf135ee73e0d56e034a8d909951fd5116730532ebdc2b)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        '''Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        '''
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff9ce25fb00b6a5c6ec5bbc3ff6302a2818c3db7cd8fa29f8d84c5662e43aa5e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a606f03fefd8b502e5bebdadb5dca2dc5bb5c5af31d95f107d7f16632544592a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "apiKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad8ddfa1a77f12b43abcedc0b90c1dea8d5f2462c1663edd4e72c7f75184ad2d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationDatadog], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__306c169885dea306970d6f0707dea4d5b1a243cc8235cd38b49b88677921f952)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83a83f0de9b87e6b8787de7c3f30b0ad41ec8c5d664f62208c42605112b0f21f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecJobLogDestinationOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46ee5113f2a65afbd0ef773dec10c1bafec7735a9d00bb0f33690801c0541daf)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecJobLogDestinationOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e69fc03f4bf8c67a028d49e1481d9bdf7b318b6a6c6be4ea9789856f0f2e542c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4dc4fed8078d1ba433d860b9542a95f1c859df6d0d3c2ab45bcc871bf02b3e2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b8578d0b8e7bdf97398623e58b91ee613ab34d2a7529331583afd1ff02d4ee9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcd4f7722d4a6f9950bfbade435d98cc065c343a3a63ed9aadbaddf1fde2ac96)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecJobLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f24899d209686731ab7718ccf26782f11d30f542dfd262414fa63f272a74bb5)
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        '''Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__597b2ae08864a8fa0a03aead6d19a4b17428f4dd013d3b13139fa77a7a15ddff)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e096fcb00094ffb2d5a944feac4a56e69810dbc9c3cf4f7dc73e6b9d57b6e400)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "token", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationLogtail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6e3a410dd16eaf7115ff186a2acfa787ee73df688a23591a77ff4be47840717)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationOpenSearch",
    jsii_struct_bases=[],
    name_mapping={
        "basic_auth": "basicAuth",
        "cluster_name": "clusterName",
        "endpoint": "endpoint",
        "index_name": "indexName",
    },
)
class AppSpecJobLogDestinationOpenSearch:
    def __init__(
        self,
        *,
        basic_auth: typing.Union["AppSpecJobLogDestinationOpenSearchBasicAuth", typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        if isinstance(basic_auth, dict):
            basic_auth = AppSpecJobLogDestinationOpenSearchBasicAuth(**basic_auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ee84eb08fa535f20570fe8f0d9746ef7bb06d154bd72a8c52edb9d2f8c4089e)
            check_type(argname="argument basic_auth", value=basic_auth, expected_type=type_hints["basic_auth"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument index_name", value=index_name, expected_type=type_hints["index_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "basic_auth": basic_auth,
        }
        if cluster_name is not None:
            self._values["cluster_name"] = cluster_name
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if index_name is not None:
            self._values["index_name"] = index_name

    @builtins.property
    def basic_auth(self) -> "AppSpecJobLogDestinationOpenSearchBasicAuth":
        '''basic_auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        '''
        result = self._values.get("basic_auth")
        assert result is not None, "Required property 'basic_auth' is missing"
        return typing.cast("AppSpecJobLogDestinationOpenSearchBasicAuth", result)

    @builtins.property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch cluster name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        '''
        result = self._values.get("cluster_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''OpenSearch endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def index_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch index name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        result = self._values.get("index_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationOpenSearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationOpenSearchBasicAuth",
    jsii_struct_bases=[],
    name_mapping={"password": "password", "user": "user"},
)
class AppSpecJobLogDestinationOpenSearchBasicAuth:
    def __init__(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b5f8bdf0d8194818f9b0441404e52f1f0007707df2be8b723e1c06a74495656)
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if password is not None:
            self._values["password"] = password
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''Password for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''user for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationOpenSearchBasicAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobLogDestinationOpenSearchBasicAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationOpenSearchBasicAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d55a07390f2758fb189aad92630d380e4153a6bfea5ef441e45a826cf3809388)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPassword")
    def reset_password(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPassword", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="passwordInput")
    def password_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "passwordInput"))

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "password"))

    @password.setter
    def password(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cd628054bbb99339a26fd90f49fa0242ec256ce1676082ffe2be186851dd875)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "password", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b3836505b7e350e2b621b7997c08921aab443d51b4a084bfd06ea7cd9961af5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "user", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[AppSpecJobLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationOpenSearchBasicAuth], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationOpenSearchBasicAuth],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e064dca62d8de626b5b0bc62d86dda7369f75a1f0dd85a4523c5baf5e633aac6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobLogDestinationOpenSearchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationOpenSearchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83e273109b65e0a3aa1fa900bfb9c4d036524e9a374566c952c222d0b633b0e0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putBasicAuth")
    def put_basic_auth(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        value = AppSpecJobLogDestinationOpenSearchBasicAuth(
            password=password, user=user
        )

        return typing.cast(None, jsii.invoke(self, "putBasicAuth", [value]))

    @jsii.member(jsii_name="resetClusterName")
    def reset_cluster_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterName", []))

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @jsii.member(jsii_name="resetIndexName")
    def reset_index_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIndexName", []))

    @builtins.property
    @jsii.member(jsii_name="basicAuth")
    def basic_auth(self) -> AppSpecJobLogDestinationOpenSearchBasicAuthOutputReference:
        return typing.cast(AppSpecJobLogDestinationOpenSearchBasicAuthOutputReference, jsii.get(self, "basicAuth"))

    @builtins.property
    @jsii.member(jsii_name="basicAuthInput")
    def basic_auth_input(
        self,
    ) -> typing.Optional[AppSpecJobLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationOpenSearchBasicAuth], jsii.get(self, "basicAuthInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterNameInput")
    def cluster_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterNameInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="indexNameInput")
    def index_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "indexNameInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterName")
    def cluster_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterName"))

    @cluster_name.setter
    def cluster_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d97812cdc74cfafb6d14bf563483e23b8e6c53e57516161fb2406cbcc44227ea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9d86fea83f3006b3a3b07787aeef812b60c1f709a6c19a0e5b59d6f89762669)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="indexName")
    def index_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "indexName"))

    @index_name.setter
    def index_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__224afa9c81c048abd5527af33f0024b11e426b8ee8e2b54a84125a4cd5600e9c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "indexName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationOpenSearch], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationOpenSearch],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3d8ea6de3b050ad7c53f18c6cbd6f1d31b064e2efea42feeced22acf750c3c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c54c6302a955add499770ad0d79dc5f3413214a394503a474c44ceaa1050cb7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecJobLogDestinationDatadog(api_key=api_key, endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        value = AppSpecJobLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putOpenSearch")
    def put_open_search(
        self,
        *,
        basic_auth: typing.Union[AppSpecJobLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        value = AppSpecJobLogDestinationOpenSearch(
            basic_auth=basic_auth,
            cluster_name=cluster_name,
            endpoint=endpoint,
            index_name=index_name,
        )

        return typing.cast(None, jsii.invoke(self, "putOpenSearch", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecJobLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetOpenSearch")
    def reset_open_search(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOpenSearch", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecJobLogDestinationDatadogOutputReference:
        return typing.cast(AppSpecJobLogDestinationDatadogOutputReference, jsii.get(self, "datadog"))

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecJobLogDestinationLogtailOutputReference:
        return typing.cast(AppSpecJobLogDestinationLogtailOutputReference, jsii.get(self, "logtail"))

    @builtins.property
    @jsii.member(jsii_name="openSearch")
    def open_search(self) -> AppSpecJobLogDestinationOpenSearchOutputReference:
        return typing.cast(AppSpecJobLogDestinationOpenSearchOutputReference, jsii.get(self, "openSearch"))

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecJobLogDestinationPapertrailOutputReference":
        return typing.cast("AppSpecJobLogDestinationPapertrailOutputReference", jsii.get(self, "papertrail"))

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecJobLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationDatadog], jsii.get(self, "datadogInput"))

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecJobLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationLogtail], jsii.get(self, "logtailInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="openSearchInput")
    def open_search_input(self) -> typing.Optional[AppSpecJobLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationOpenSearch], jsii.get(self, "openSearchInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(self) -> typing.Optional["AppSpecJobLogDestinationPapertrail"]:
        return typing.cast(typing.Optional["AppSpecJobLogDestinationPapertrail"], jsii.get(self, "papertrailInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__224f80cb3500186b16570ef51a87716f88707e8fcf58e62bdfc57f01b625e627)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c8be2635576aa2fc08c276ccaa1528542ba0978504f2ca3ad9774d995549522)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecJobLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1393d74439e71eb445bd00e802e99ebfe0008c710e4372897abd910662c3f67)
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        '''Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f212e4b20635771509c548b3bee48bea1e2ce7cbc13729347efe29e8af5cdff)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95d446055a38a1abcc588a8279dc0bfd1deaa62f6a9aa209c62355feb241e36d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobLogDestinationPapertrail]:
        return typing.cast(typing.Optional[AppSpecJobLogDestinationPapertrail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecJobLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6412d999330b443f1c69f0e6346d192e6caf2d6dcc0cdcdb73d0303be6a5183)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecJobOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__927916c8a5b60022fded4a29d6df7a2fcecdd35a3cde3a50ae967ac15083d62e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobAlert, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6336c3d655aa6f99d17127e5736b3e92b689063bfc170fbd7623822f1f12e2e6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putBitbucket")
    def put_bitbucket(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecJobBitbucket(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putBitbucket", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobEnv, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7557e04810f1997f0d93eb7c0ac38b56e3f32308596214e3039920ca5d81c906)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        value = AppSpecJobGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecJobGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecJobGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putImage")
    def put_image(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]]] = None,
        digest: typing.Optional[builtins.str] = None,
        registry: typing.Optional[builtins.str] = None,
        registry_credentials: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param digest: The image digest. Cannot be specified if tag is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        :param registry_credentials: Access credentials for third-party registries. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        :param tag: The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        value = AppSpecJobImage(
            registry_type=registry_type,
            repository=repository,
            deploy_on_push=deploy_on_push,
            digest=digest,
            registry=registry,
            registry_credentials=registry_credentials,
            tag=tag,
        )

        return typing.cast(None, jsii.invoke(self, "putImage", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobLogDestination, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5624d7ad0afd565fbdba1f8adc46c0f2a190938b2c3490a6d3839ea434b4ec2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="putTermination")
    def put_termination(
        self,
        *,
        grace_period_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        value = AppSpecJobTermination(grace_period_seconds=grace_period_seconds)

        return typing.cast(None, jsii.invoke(self, "putTermination", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetBitbucket")
    def reset_bitbucket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBitbucket", []))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetInstanceCount")
    def reset_instance_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceCount", []))

    @jsii.member(jsii_name="resetInstanceSizeSlug")
    def reset_instance_size_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceSizeSlug", []))

    @jsii.member(jsii_name="resetKind")
    def reset_kind(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKind", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRunCommand")
    def reset_run_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunCommand", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @jsii.member(jsii_name="resetTermination")
    def reset_termination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTermination", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecJobAlertList:
        return typing.cast(AppSpecJobAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="bitbucket")
    def bitbucket(self) -> AppSpecJobBitbucketOutputReference:
        return typing.cast(AppSpecJobBitbucketOutputReference, jsii.get(self, "bitbucket"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecJobEnvList:
        return typing.cast(AppSpecJobEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecJobGitOutputReference:
        return typing.cast(AppSpecJobGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecJobGithubOutputReference:
        return typing.cast(AppSpecJobGithubOutputReference, jsii.get(self, "github"))

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecJobGitlabOutputReference:
        return typing.cast(AppSpecJobGitlabOutputReference, jsii.get(self, "gitlab"))

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> AppSpecJobImageOutputReference:
        return typing.cast(AppSpecJobImageOutputReference, jsii.get(self, "image"))

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecJobLogDestinationList:
        return typing.cast(AppSpecJobLogDestinationList, jsii.get(self, "logDestination"))

    @builtins.property
    @jsii.member(jsii_name="termination")
    def termination(self) -> "AppSpecJobTerminationOutputReference":
        return typing.cast("AppSpecJobTerminationOutputReference", jsii.get(self, "termination"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]], jsii.get(self, "alertInput"))

    @builtins.property
    @jsii.member(jsii_name="bitbucketInput")
    def bitbucket_input(self) -> typing.Optional[AppSpecJobBitbucket]:
        return typing.cast(typing.Optional[AppSpecJobBitbucket], jsii.get(self, "bitbucketInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "buildCommandInput"))

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput"))

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]], jsii.get(self, "envInput"))

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput"))

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecJobGithub]:
        return typing.cast(typing.Optional[AppSpecJobGithub], jsii.get(self, "githubInput"))

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecJobGit]:
        return typing.cast(typing.Optional[AppSpecJobGit], jsii.get(self, "gitInput"))

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecJobGitlab]:
        return typing.cast(typing.Optional[AppSpecJobGitlab], jsii.get(self, "gitlabInput"))

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[AppSpecJobImage]:
        return typing.cast(typing.Optional[AppSpecJobImage], jsii.get(self, "imageInput"))

    @builtins.property
    @jsii.member(jsii_name="instanceCountInput")
    def instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "instanceCountInput"))

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlugInput")
    def instance_size_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceSizeSlugInput"))

    @builtins.property
    @jsii.member(jsii_name="kindInput")
    def kind_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kindInput"))

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]], jsii.get(self, "logDestinationInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="runCommandInput")
    def run_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "runCommandInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDirInput"))

    @builtins.property
    @jsii.member(jsii_name="terminationInput")
    def termination_input(self) -> typing.Optional["AppSpecJobTermination"]:
        return typing.cast(typing.Optional["AppSpecJobTermination"], jsii.get(self, "terminationInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eac2642fcf284e0bdcdf5330b173d53a4246212a28764e801fa252faf4a475da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "buildCommand", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51e7ae88791f9e07f0c139ff7d98d63dc311ec640e19602cf5f71dd3a3b3a687)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dockerfilePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e5d9da277f56cd490220afafddf56df19c570af7e3e98447365ab9781ea9676)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "environmentSlug", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="instanceCount")
    def instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "instanceCount"))

    @instance_count.setter
    def instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__538856a7762973bb974e279c687fc7f4d6db184fdd5c32c7d8b8b8a834cba654)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlug")
    def instance_size_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "instanceSizeSlug"))

    @instance_size_slug.setter
    def instance_size_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02a7a572c932498e6a4aa2fc043db56f53cd9fc22d55231808e7c0a74bca7203)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceSizeSlug", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="kind")
    def kind(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "kind"))

    @kind.setter
    def kind(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__821c8bd094b69a4f523542c9a5a3f63ed0965ea7b2c2c2ab3bd65a6a4fb77746)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "kind", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__328e634de23bfe5811755ed029b8945a332cb884272980a2e61e71cad99489e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runCommand"))

    @run_command.setter
    def run_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51843a8c1e8bd6866691ec29e4231b373a87973c5078ecff4a4671ebc7ff3204)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "runCommand", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f62d07e36d0275d95d5e90ec8e63e38ec300705f60a3f7d76e3896a743c28c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDir", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__845898d6101a73a56d73bdfbeed921744c4d5bf175e1c442d16930d6961b8126)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobTermination",
    jsii_struct_bases=[],
    name_mapping={"grace_period_seconds": "gracePeriodSeconds"},
)
class AppSpecJobTermination:
    def __init__(
        self,
        *,
        grace_period_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f80cb57838b4966dcc391dddd77729fa17881cfba97b3d5460254ef944c7a4cf)
            check_type(argname="argument grace_period_seconds", value=grace_period_seconds, expected_type=type_hints["grace_period_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if grace_period_seconds is not None:
            self._values["grace_period_seconds"] = grace_period_seconds

    @builtins.property
    def grace_period_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown.

        Default: 120, Minimum 1, Maximum 600.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        result = self._values.get("grace_period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecJobTermination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecJobTerminationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecJobTerminationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__684469dd0f8280a6c99614d2ddbfe7f4a15d61ece3f04a163a553bdb604e0fcc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetGracePeriodSeconds")
    def reset_grace_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGracePeriodSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="gracePeriodSecondsInput")
    def grace_period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "gracePeriodSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="gracePeriodSeconds")
    def grace_period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "gracePeriodSeconds"))

    @grace_period_seconds.setter
    def grace_period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d2a1a638d13b8d04fb7fc54ba34b5868b53dca6f0193ae044e438eccd345a01)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gracePeriodSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecJobTermination]:
        return typing.cast(typing.Optional[AppSpecJobTermination], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecJobTermination]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ce3d8c8c0e6f31b4b0786a5230e3f0eddb34e474b09681f8528a6c0bba67308)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecMaintenance",
    jsii_struct_bases=[],
    name_mapping={
        "archive": "archive",
        "enabled": "enabled",
        "offline_page_url": "offlinePageUrl",
    },
)
class AppSpecMaintenance:
    def __init__(
        self,
        *,
        archive: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        offline_page_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param archive: Indicates whether the app should be archived. Setting this to true implies that enabled is set to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#archive App#archive}
        :param enabled: Indicates whether maintenance mode should be enabled for the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        :param offline_page_url: A custom offline page to display when maintenance mode is enabled or the app is archived. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#offline_page_url App#offline_page_url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cced29cc874c69f6ae69068913551d4930752c2e41e214fe5eae83b5a53b2055)
            check_type(argname="argument archive", value=archive, expected_type=type_hints["archive"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument offline_page_url", value=offline_page_url, expected_type=type_hints["offline_page_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if archive is not None:
            self._values["archive"] = archive
        if enabled is not None:
            self._values["enabled"] = enabled
        if offline_page_url is not None:
            self._values["offline_page_url"] = offline_page_url

    @builtins.property
    def archive(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#archive App#archive}
        '''
        result = self._values.get("archive")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Indicates whether maintenance mode should be enabled for the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def offline_page_url(self) -> typing.Optional[builtins.str]:
        '''A custom offline page to display when maintenance mode is enabled or the app is archived.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#offline_page_url App#offline_page_url}
        '''
        result = self._values.get("offline_page_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecMaintenance(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecMaintenanceOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecMaintenanceOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b83459b2c4f659b26dd75433f21eb96e20ed59db96c00407bc7aaf90bfd28391)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetArchive")
    def reset_archive(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetArchive", []))

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @jsii.member(jsii_name="resetOfflinePageUrl")
    def reset_offline_page_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOfflinePageUrl", []))

    @builtins.property
    @jsii.member(jsii_name="archiveInput")
    def archive_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "archiveInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="offlinePageUrlInput")
    def offline_page_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "offlinePageUrlInput"))

    @builtins.property
    @jsii.member(jsii_name="archive")
    def archive(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "archive"))

    @archive.setter
    def archive(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dcf31c7733d50b4e082323b402a843ce7b1ea8270deb26d704299865e7f2b09)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "archive", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a90babe3fd0f553b7314c8963196234fa3a18c1614c137e050f2051887ecd05b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="offlinePageUrl")
    def offline_page_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "offlinePageUrl"))

    @offline_page_url.setter
    def offline_page_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce6886bc915f099183f6a2c8b595bee758cd033969f40484efc6ba5e13d9545e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "offlinePageUrl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecMaintenance]:
        return typing.cast(typing.Optional[AppSpecMaintenance], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecMaintenance]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbb4859728d0c04caa95d162b2b73fcad26942570bc1af82ff133a90eddef5a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e52978efe4b2396ab96a4f0f1c4f07a8f6b366ddd702b6f073fc21a4c8bb8a6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecAlert, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ac17a09c84cfef40d965e613ec763cff31189f1d28c67e10e09fe7bf16f9f1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putDatabase")
    def put_database(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecDatabase, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88c174e62e79a0d27a962c395ff22ef66b131c78e54820bf2011e032144a2b45)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDatabase", [value]))

    @jsii.member(jsii_name="putDomain")
    def put_domain(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecDomain, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bed8f38599577acab1e383d5d6b058ec7df2898b518b92501daed3abc00cf1e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDomain", [value]))

    @jsii.member(jsii_name="putEgress")
    def put_egress(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecEgress, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f394c20a297073ae77916263c17fc04a7043446f4fe9feaf7dd68c67f591ea87)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEgress", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecEnv, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b271275838996e60237f4875497b9d9be245426093b713c81d0f51f56cb2414)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putFunction")
    def put_function(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunction, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e129cac45cb7f39eb2bdc92b5c7cd7b703abd8241b6234155cbad296c9bc8330)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putFunction", [value]))

    @jsii.member(jsii_name="putIngress")
    def put_ingress(
        self,
        *,
        rule: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecIngressRule, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param rule: rule block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}
        '''
        value = AppSpecIngress(rule=rule)

        return typing.cast(None, jsii.invoke(self, "putIngress", [value]))

    @jsii.member(jsii_name="putJob")
    def put_job(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJob, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__451e0a243239d94819cdc19aa11202bd6125f1b3c0ee90b2846456ba5c264182)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putJob", [value]))

    @jsii.member(jsii_name="putMaintenance")
    def put_maintenance(
        self,
        *,
        archive: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        offline_page_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param archive: Indicates whether the app should be archived. Setting this to true implies that enabled is set to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#archive App#archive}
        :param enabled: Indicates whether maintenance mode should be enabled for the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        :param offline_page_url: A custom offline page to display when maintenance mode is enabled or the app is archived. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#offline_page_url App#offline_page_url}
        '''
        value = AppSpecMaintenance(
            archive=archive, enabled=enabled, offline_page_url=offline_page_url
        )

        return typing.cast(None, jsii.invoke(self, "putMaintenance", [value]))

    @jsii.member(jsii_name="putService")
    def put_service(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecService", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a575f19e9aeeb36d6f4e20ce859f9b272b89974b31b4433b612fd29bf99e1d9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putService", [value]))

    @jsii.member(jsii_name="putStaticSite")
    def put_static_site(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecStaticSite", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7a3f99dae64b041b907069b883620ca7c421a9e1ccbb28ccc992ca5307b4b9b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putStaticSite", [value]))

    @jsii.member(jsii_name="putVpc")
    def put_vpc(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecVpc", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7aeb55ae46c35e7953665ca8d2f53d39db0f792de286744f953fd5b956aafada)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putVpc", [value]))

    @jsii.member(jsii_name="putWorker")
    def put_worker(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorker", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b7d7b21b1ef833279447b25a47e32c4542cc522d6205324662700b193670cfb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putWorker", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetDatabase")
    def reset_database(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatabase", []))

    @jsii.member(jsii_name="resetDisableEdgeCache")
    def reset_disable_edge_cache(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableEdgeCache", []))

    @jsii.member(jsii_name="resetDisableEmailObfuscation")
    def reset_disable_email_obfuscation(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableEmailObfuscation", []))

    @jsii.member(jsii_name="resetDomain")
    def reset_domain(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDomain", []))

    @jsii.member(jsii_name="resetDomains")
    def reset_domains(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDomains", []))

    @jsii.member(jsii_name="resetEgress")
    def reset_egress(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEgress", []))

    @jsii.member(jsii_name="resetEnhancedThreatControlEnabled")
    def reset_enhanced_threat_control_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnhancedThreatControlEnabled", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetFeatures")
    def reset_features(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFeatures", []))

    @jsii.member(jsii_name="resetFunction")
    def reset_function(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFunction", []))

    @jsii.member(jsii_name="resetIngress")
    def reset_ingress(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIngress", []))

    @jsii.member(jsii_name="resetJob")
    def reset_job(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetJob", []))

    @jsii.member(jsii_name="resetMaintenance")
    def reset_maintenance(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaintenance", []))

    @jsii.member(jsii_name="resetRegion")
    def reset_region(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegion", []))

    @jsii.member(jsii_name="resetService")
    def reset_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetService", []))

    @jsii.member(jsii_name="resetStaticSite")
    def reset_static_site(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStaticSite", []))

    @jsii.member(jsii_name="resetVpc")
    def reset_vpc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVpc", []))

    @jsii.member(jsii_name="resetWorker")
    def reset_worker(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorker", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecAlertList:
        return typing.cast(AppSpecAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="database")
    def database(self) -> AppSpecDatabaseList:
        return typing.cast(AppSpecDatabaseList, jsii.get(self, "database"))

    @builtins.property
    @jsii.member(jsii_name="domain")
    def domain(self) -> AppSpecDomainList:
        return typing.cast(AppSpecDomainList, jsii.get(self, "domain"))

    @builtins.property
    @jsii.member(jsii_name="egress")
    def egress(self) -> AppSpecEgressList:
        return typing.cast(AppSpecEgressList, jsii.get(self, "egress"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecEnvList:
        return typing.cast(AppSpecEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="function")
    def function(self) -> AppSpecFunctionList:
        return typing.cast(AppSpecFunctionList, jsii.get(self, "function"))

    @builtins.property
    @jsii.member(jsii_name="ingress")
    def ingress(self) -> AppSpecIngressOutputReference:
        return typing.cast(AppSpecIngressOutputReference, jsii.get(self, "ingress"))

    @builtins.property
    @jsii.member(jsii_name="job")
    def job(self) -> AppSpecJobList:
        return typing.cast(AppSpecJobList, jsii.get(self, "job"))

    @builtins.property
    @jsii.member(jsii_name="maintenance")
    def maintenance(self) -> AppSpecMaintenanceOutputReference:
        return typing.cast(AppSpecMaintenanceOutputReference, jsii.get(self, "maintenance"))

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> "AppSpecServiceList":
        return typing.cast("AppSpecServiceList", jsii.get(self, "service"))

    @builtins.property
    @jsii.member(jsii_name="staticSite")
    def static_site(self) -> "AppSpecStaticSiteList":
        return typing.cast("AppSpecStaticSiteList", jsii.get(self, "staticSite"))

    @builtins.property
    @jsii.member(jsii_name="vpc")
    def vpc(self) -> "AppSpecVpcList":
        return typing.cast("AppSpecVpcList", jsii.get(self, "vpc"))

    @builtins.property
    @jsii.member(jsii_name="worker")
    def worker(self) -> "AppSpecWorkerList":
        return typing.cast("AppSpecWorkerList", jsii.get(self, "worker"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]], jsii.get(self, "alertInput"))

    @builtins.property
    @jsii.member(jsii_name="databaseInput")
    def database_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]], jsii.get(self, "databaseInput"))

    @builtins.property
    @jsii.member(jsii_name="disableEdgeCacheInput")
    def disable_edge_cache_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableEdgeCacheInput"))

    @builtins.property
    @jsii.member(jsii_name="disableEmailObfuscationInput")
    def disable_email_obfuscation_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableEmailObfuscationInput"))

    @builtins.property
    @jsii.member(jsii_name="domainInput")
    def domain_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]], jsii.get(self, "domainInput"))

    @builtins.property
    @jsii.member(jsii_name="domainsInput")
    def domains_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "domainsInput"))

    @builtins.property
    @jsii.member(jsii_name="egressInput")
    def egress_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEgress]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEgress]]], jsii.get(self, "egressInput"))

    @builtins.property
    @jsii.member(jsii_name="enhancedThreatControlEnabledInput")
    def enhanced_threat_control_enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enhancedThreatControlEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]], jsii.get(self, "envInput"))

    @builtins.property
    @jsii.member(jsii_name="featuresInput")
    def features_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "featuresInput"))

    @builtins.property
    @jsii.member(jsii_name="functionInput")
    def function_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]], jsii.get(self, "functionInput"))

    @builtins.property
    @jsii.member(jsii_name="ingressInput")
    def ingress_input(self) -> typing.Optional[AppSpecIngress]:
        return typing.cast(typing.Optional[AppSpecIngress], jsii.get(self, "ingressInput"))

    @builtins.property
    @jsii.member(jsii_name="jobInput")
    def job_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]], jsii.get(self, "jobInput"))

    @builtins.property
    @jsii.member(jsii_name="maintenanceInput")
    def maintenance_input(self) -> typing.Optional[AppSpecMaintenance]:
        return typing.cast(typing.Optional[AppSpecMaintenance], jsii.get(self, "maintenanceInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="regionInput")
    def region_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regionInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceInput")
    def service_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecService"]]], jsii.get(self, "serviceInput"))

    @builtins.property
    @jsii.member(jsii_name="staticSiteInput")
    def static_site_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSite"]]], jsii.get(self, "staticSiteInput"))

    @builtins.property
    @jsii.member(jsii_name="vpcInput")
    def vpc_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecVpc"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecVpc"]]], jsii.get(self, "vpcInput"))

    @builtins.property
    @jsii.member(jsii_name="workerInput")
    def worker_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorker"]]], jsii.get(self, "workerInput"))

    @builtins.property
    @jsii.member(jsii_name="disableEdgeCache")
    def disable_edge_cache(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disableEdgeCache"))

    @disable_edge_cache.setter
    def disable_edge_cache(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08f0d3dae87a499a7228f0c5fb4a26f5d2af425090eea5e34484ce889a35a9b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableEdgeCache", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="disableEmailObfuscation")
    def disable_email_obfuscation(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disableEmailObfuscation"))

    @disable_email_obfuscation.setter
    def disable_email_obfuscation(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e63d31298a251d40e17b4a3ad17a8691064eb295664a2f69738de482164edc81)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableEmailObfuscation", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="domains")
    def domains(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "domains"))

    @domains.setter
    def domains(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__500e3758f60a3b420025cc85c355eb1932b9ec463a0716d5f3479cc5c2ca57af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "domains", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enhancedThreatControlEnabled")
    def enhanced_threat_control_enabled(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enhancedThreatControlEnabled"))

    @enhanced_threat_control_enabled.setter
    def enhanced_threat_control_enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8877f34f9dcf53e59d3b09245390ced72395e77254856699c1bb7d83e9a181c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enhancedThreatControlEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="features")
    def features(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "features"))

    @features.setter
    def features(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33d86794683989d331be49302725dc1e55e87c5e42d1571816211e979d050e08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "features", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82b0f9cbc8018fb6fc1aaa6f721c5f37f4dce020bf7ace10b229fcf7a210a0f2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @region.setter
    def region(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3ff3602c572c287f4c84e53c7346e84152e850bf366a068dafbb80bd52bf38b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "region", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpec]:
        return typing.cast(typing.Optional[AppSpec], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpec]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b88fdf8f6ae6e302739d5cd89a8ee11d44200bc8d0086d3a22bc7983f658cdaa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecService",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "autoscaling": "autoscaling",
        "bitbucket": "bitbucket",
        "build_command": "buildCommand",
        "cors": "cors",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "health_check": "healthCheck",
        "http_port": "httpPort",
        "image": "image",
        "instance_count": "instanceCount",
        "instance_size_slug": "instanceSizeSlug",
        "internal_ports": "internalPorts",
        "log_destination": "logDestination",
        "routes": "routes",
        "run_command": "runCommand",
        "source_dir": "sourceDir",
        "termination": "termination",
    },
)
class AppSpecService:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceAlert", typing.Dict[builtins.str, typing.Any]]]]] = None,
        autoscaling: typing.Optional[typing.Union["AppSpecServiceAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        bitbucket: typing.Optional[typing.Union["AppSpecServiceBitbucket", typing.Dict[builtins.str, typing.Any]]] = None,
        build_command: typing.Optional[builtins.str] = None,
        cors: typing.Optional[typing.Union["AppSpecServiceCors", typing.Dict[builtins.str, typing.Any]]] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceEnv", typing.Dict[builtins.str, typing.Any]]]]] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        git: typing.Optional[typing.Union["AppSpecServiceGit", typing.Dict[builtins.str, typing.Any]]] = None,
        github: typing.Optional[typing.Union["AppSpecServiceGithub", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["AppSpecServiceGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        health_check: typing.Optional[typing.Union["AppSpecServiceHealthCheck", typing.Dict[builtins.str, typing.Any]]] = None,
        http_port: typing.Optional[jsii.Number] = None,
        image: typing.Optional[typing.Union["AppSpecServiceImage", typing.Dict[builtins.str, typing.Any]]] = None,
        instance_count: typing.Optional[jsii.Number] = None,
        instance_size_slug: typing.Optional[builtins.str] = None,
        internal_ports: typing.Optional[typing.Sequence[jsii.Number]] = None,
        log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceLogDestination", typing.Dict[builtins.str, typing.Any]]]]] = None,
        routes: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceRoutes", typing.Dict[builtins.str, typing.Any]]]]] = None,
        run_command: typing.Optional[builtins.str] = None,
        source_dir: typing.Optional[builtins.str] = None,
        termination: typing.Optional[typing.Union["AppSpecServiceTermination", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        :param autoscaling: autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#autoscaling App#autoscaling}
        :param bitbucket: bitbucket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        :param cors: cors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        :param health_check: health_check block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#health_check App#health_check}
        :param http_port: The internal port on which this service's run command will listen. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#http_port App#http_port}
        :param image: image block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#image App#image}
        :param instance_count: The amount of instances that this component should be scaled to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_count App#instance_count}
        :param instance_size_slug: The instance size to use for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_size_slug App#instance_size_slug}
        :param internal_ports: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#internal_ports App#internal_ports}.
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        :param routes: routes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#routes App#routes}
        :param run_command: An optional run command to override the component's default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#run_command App#run_command}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        :param termination: termination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#termination App#termination}
        '''
        if isinstance(autoscaling, dict):
            autoscaling = AppSpecServiceAutoscaling(**autoscaling)
        if isinstance(bitbucket, dict):
            bitbucket = AppSpecServiceBitbucket(**bitbucket)
        if isinstance(cors, dict):
            cors = AppSpecServiceCors(**cors)
        if isinstance(git, dict):
            git = AppSpecServiceGit(**git)
        if isinstance(github, dict):
            github = AppSpecServiceGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecServiceGitlab(**gitlab)
        if isinstance(health_check, dict):
            health_check = AppSpecServiceHealthCheck(**health_check)
        if isinstance(image, dict):
            image = AppSpecServiceImage(**image)
        if isinstance(termination, dict):
            termination = AppSpecServiceTermination(**termination)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e83db37d611925e081fef563955859bf2fbe6d4c53a69f725614b73196cc8632)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument alert", value=alert, expected_type=type_hints["alert"])
            check_type(argname="argument autoscaling", value=autoscaling, expected_type=type_hints["autoscaling"])
            check_type(argname="argument bitbucket", value=bitbucket, expected_type=type_hints["bitbucket"])
            check_type(argname="argument build_command", value=build_command, expected_type=type_hints["build_command"])
            check_type(argname="argument cors", value=cors, expected_type=type_hints["cors"])
            check_type(argname="argument dockerfile_path", value=dockerfile_path, expected_type=type_hints["dockerfile_path"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument environment_slug", value=environment_slug, expected_type=type_hints["environment_slug"])
            check_type(argname="argument git", value=git, expected_type=type_hints["git"])
            check_type(argname="argument github", value=github, expected_type=type_hints["github"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument health_check", value=health_check, expected_type=type_hints["health_check"])
            check_type(argname="argument http_port", value=http_port, expected_type=type_hints["http_port"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
            check_type(argname="argument instance_size_slug", value=instance_size_slug, expected_type=type_hints["instance_size_slug"])
            check_type(argname="argument internal_ports", value=internal_ports, expected_type=type_hints["internal_ports"])
            check_type(argname="argument log_destination", value=log_destination, expected_type=type_hints["log_destination"])
            check_type(argname="argument routes", value=routes, expected_type=type_hints["routes"])
            check_type(argname="argument run_command", value=run_command, expected_type=type_hints["run_command"])
            check_type(argname="argument source_dir", value=source_dir, expected_type=type_hints["source_dir"])
            check_type(argname="argument termination", value=termination, expected_type=type_hints["termination"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if autoscaling is not None:
            self._values["autoscaling"] = autoscaling
        if bitbucket is not None:
            self._values["bitbucket"] = bitbucket
        if build_command is not None:
            self._values["build_command"] = build_command
        if cors is not None:
            self._values["cors"] = cors
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if health_check is not None:
            self._values["health_check"] = health_check
        if http_port is not None:
            self._values["http_port"] = http_port
        if image is not None:
            self._values["image"] = image
        if instance_count is not None:
            self._values["instance_count"] = instance_count
        if instance_size_slug is not None:
            self._values["instance_size_slug"] = instance_size_slug
        if internal_ports is not None:
            self._values["internal_ports"] = internal_ports
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if routes is not None:
            self._values["routes"] = routes
        if run_command is not None:
            self._values["run_command"] = run_command
        if source_dir is not None:
            self._values["source_dir"] = source_dir
        if termination is not None:
            self._values["termination"] = termination

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlert"]]]:
        '''alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        '''
        result = self._values.get("alert")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlert"]]], result)

    @builtins.property
    def autoscaling(self) -> typing.Optional["AppSpecServiceAutoscaling"]:
        '''autoscaling block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#autoscaling App#autoscaling}
        '''
        result = self._values.get("autoscaling")
        return typing.cast(typing.Optional["AppSpecServiceAutoscaling"], result)

    @builtins.property
    def bitbucket(self) -> typing.Optional["AppSpecServiceBitbucket"]:
        '''bitbucket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        '''
        result = self._values.get("bitbucket")
        return typing.cast(typing.Optional["AppSpecServiceBitbucket"], result)

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        '''An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        '''
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cors(self) -> typing.Optional["AppSpecServiceCors"]:
        '''cors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        '''
        result = self._values.get("cors")
        return typing.cast(typing.Optional["AppSpecServiceCors"], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        '''The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        '''
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceEnv"]]]:
        '''env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceEnv"]]], result)

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        '''An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        '''
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecServiceGit"]:
        '''git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        '''
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecServiceGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecServiceGithub"]:
        '''github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        '''
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecServiceGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecServiceGitlab"]:
        '''gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecServiceGitlab"], result)

    @builtins.property
    def health_check(self) -> typing.Optional["AppSpecServiceHealthCheck"]:
        '''health_check block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#health_check App#health_check}
        '''
        result = self._values.get("health_check")
        return typing.cast(typing.Optional["AppSpecServiceHealthCheck"], result)

    @builtins.property
    def http_port(self) -> typing.Optional[jsii.Number]:
        '''The internal port on which this service's run command will listen.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#http_port App#http_port}
        '''
        result = self._values.get("http_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image(self) -> typing.Optional["AppSpecServiceImage"]:
        '''image block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#image App#image}
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional["AppSpecServiceImage"], result)

    @builtins.property
    def instance_count(self) -> typing.Optional[jsii.Number]:
        '''The amount of instances that this component should be scaled to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_count App#instance_count}
        '''
        result = self._values.get("instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_size_slug(self) -> typing.Optional[builtins.str]:
        '''The instance size to use for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_size_slug App#instance_size_slug}
        '''
        result = self._values.get("instance_size_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def internal_ports(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#internal_ports App#internal_ports}.'''
        result = self._values.get("internal_ports")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceLogDestination"]]]:
        '''log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        '''
        result = self._values.get("log_destination")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceLogDestination"]]], result)

    @builtins.property
    def routes(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]]]:
        '''routes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#routes App#routes}
        '''
        result = self._values.get("routes")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]]], result)

    @builtins.property
    def run_command(self) -> typing.Optional[builtins.str]:
        '''An optional run command to override the component's default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#run_command App#run_command}
        '''
        result = self._values.get("run_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        '''An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        '''
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination(self) -> typing.Optional["AppSpecServiceTermination"]:
        '''termination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#termination App#termination}
        '''
        result = self._values.get("termination")
        return typing.cast(typing.Optional["AppSpecServiceTermination"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecService(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "destinations": "destinations",
        "disabled": "disabled",
    },
)
class AppSpecServiceAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        destinations: typing.Optional[typing.Union["AppSpecServiceAlertDestinations", typing.Dict[builtins.str, typing.Any]]] = None,
        disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.
        :param destinations: destinations block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.
        '''
        if isinstance(destinations, dict):
            destinations = AppSpecServiceAlertDestinations(**destinations)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__677a7d3e4066d253fb60aa58610734af078eb569f15cbcc21f8d36a8d2b10d37)
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if destinations is not None:
            self._values["destinations"] = destinations
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.'''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.'''
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.'''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.'''
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destinations(self) -> typing.Optional["AppSpecServiceAlertDestinations"]:
        '''destinations block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        '''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional["AppSpecServiceAlertDestinations"], result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.'''
        result = self._values.get("disabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlertDestinations",
    jsii_struct_bases=[],
    name_mapping={"emails": "emails", "slack_webhooks": "slackWebhooks"},
)
class AppSpecServiceAlertDestinations:
    def __init__(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__691d93ff411bb93f8b66db08ce06984caee747ba17f3558220f96d648c44de60)
            check_type(argname="argument emails", value=emails, expected_type=type_hints["emails"])
            check_type(argname="argument slack_webhooks", value=slack_webhooks, expected_type=type_hints["slack_webhooks"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if emails is not None:
            self._values["emails"] = emails
        if slack_webhooks is not None:
            self._values["slack_webhooks"] = slack_webhooks

    @builtins.property
    def emails(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.'''
        result = self._values.get("emails")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def slack_webhooks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlertDestinationsSlackWebhooks"]]]:
        '''slack_webhooks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        result = self._values.get("slack_webhooks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlertDestinationsSlackWebhooks"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceAlertDestinations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceAlertDestinationsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlertDestinationsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47773438cbaa86368070337f2e67e36b1e0687ba89569b4d91aa07c72dfbc4e2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSlackWebhooks")
    def put_slack_webhooks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e12c18b2a110bc35fd9de9761d22a7ded55f05b58800c1e5790e40b7e1570279)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSlackWebhooks", [value]))

    @jsii.member(jsii_name="resetEmails")
    def reset_emails(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEmails", []))

    @jsii.member(jsii_name="resetSlackWebhooks")
    def reset_slack_webhooks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSlackWebhooks", []))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooks")
    def slack_webhooks(self) -> "AppSpecServiceAlertDestinationsSlackWebhooksList":
        return typing.cast("AppSpecServiceAlertDestinationsSlackWebhooksList", jsii.get(self, "slackWebhooks"))

    @builtins.property
    @jsii.member(jsii_name="emailsInput")
    def emails_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "emailsInput"))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooksInput")
    def slack_webhooks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlertDestinationsSlackWebhooks"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceAlertDestinationsSlackWebhooks"]]], jsii.get(self, "slackWebhooksInput"))

    @builtins.property
    @jsii.member(jsii_name="emails")
    def emails(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "emails"))

    @emails.setter
    def emails(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3688a5d797eba65c08d235be8aa3b7fa129293f8130765f4c3d4b165395502a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "emails", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecServiceAlertDestinations], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceAlertDestinations],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__210cac7d23afda1458727082b73c036c12c7de9afeed431b4a3076b6ffc7016c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlertDestinationsSlackWebhooks",
    jsii_struct_bases=[],
    name_mapping={"channel": "channel", "url": "url"},
)
class AppSpecServiceAlertDestinationsSlackWebhooks:
    def __init__(self, *, channel: builtins.str, url: builtins.str) -> None:
        '''
        :param channel: The Slack channel to send notifications to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        :param url: The Slack webhook URL. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dac18fbb27bc9c9ffafef0546b3130ee7d01b2030e75643f1e3194acfe3f6324)
            check_type(argname="argument channel", value=channel, expected_type=type_hints["channel"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel": channel,
            "url": url,
        }

    @builtins.property
    def channel(self) -> builtins.str:
        '''The Slack channel to send notifications to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        '''
        result = self._values.get("channel")
        assert result is not None, "Required property 'channel' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''The Slack webhook URL.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceAlertDestinationsSlackWebhooks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceAlertDestinationsSlackWebhooksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlertDestinationsSlackWebhooksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__297c3ce6c3e70e7f2f423e5e93d93c94d0a52b568764c14e829b64ccfdd39ea7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecServiceAlertDestinationsSlackWebhooksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a69e796cc779849817588d6ff2c0641e197c1be48f25ca83ac9c35fce2edd3f4)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecServiceAlertDestinationsSlackWebhooksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a38f51d4eb4b5582bc50ae4e0c8887f3b34343d5c006e31f4f3705221e6e813)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edb3ee558d90338d306bf0e00cd18e1d6a257ed87a18bcedf30519b63bb59cd3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__607206e81b49a930709ea31649c56b6137f1dca2feb2db32c591f17eed4d0ae3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlertDestinationsSlackWebhooks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlertDestinationsSlackWebhooks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlertDestinationsSlackWebhooks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d7884eb362d4bc7a0fe52df60247bbc90297ad7a3ab14d76696502c856f0aec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceAlertDestinationsSlackWebhooksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlertDestinationsSlackWebhooksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7275af08599a17442be98e90eb0948a7e24f4ea112f702c2d6aaacea3a5aa58e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="channelInput")
    def channel_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "channelInput"))

    @builtins.property
    @jsii.member(jsii_name="urlInput")
    def url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "urlInput"))

    @builtins.property
    @jsii.member(jsii_name="channel")
    def channel(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channel"))

    @channel.setter
    def channel(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f3369e13bd756fbc960979734680766e2e89bc4b3ae95e7b3faa93e764b076a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "channel", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @url.setter
    def url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18533f6f8fecd6b198769d58464981d3c80b2e0bf88b62c77e88008aeb75a9d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "url", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlertDestinationsSlackWebhooks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlertDestinationsSlackWebhooks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlertDestinationsSlackWebhooks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72a90bcc0278b0a145b870d586057d666526f36f6554ad57210969fe51e3ce4e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__960cf37f6de07dfd1473cd9fe30222ac81b7dfcf25b79ce3e4687f67ce0a9dd8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceAlertOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88174e08d2f617e7070e5fc2084f47e44702b6fdc49ca72849fd8d151f5a9936)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecServiceAlertOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fa798b69266197fc2dc33856cb045a5d36f2052c8adf75e2d02861991fa49a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc83bd6bb9af7156e9441adca62f2f38792e6a0546742543a1a6d038e67c7dee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6693c7e9ade61c977b35a6d66686eb94efc776797bbb5ce3893a08e2f8a6ec4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f33b16cfd72bbc3d3a684a8f1847c8a9d79c19594de88c07c7516cc8389215f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f0b2220f47e72e5653a3a5e59321a6a0d4bdc0d48b2588f8442b6f631c7c5e2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDestinations")
    def put_destinations(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        value = AppSpecServiceAlertDestinations(
            emails=emails, slack_webhooks=slack_webhooks
        )

        return typing.cast(None, jsii.invoke(self, "putDestinations", [value]))

    @jsii.member(jsii_name="resetDestinations")
    def reset_destinations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDestinations", []))

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="destinations")
    def destinations(self) -> AppSpecServiceAlertDestinationsOutputReference:
        return typing.cast(AppSpecServiceAlertDestinationsOutputReference, jsii.get(self, "destinations"))

    @builtins.property
    @jsii.member(jsii_name="destinationsInput")
    def destinations_input(self) -> typing.Optional[AppSpecServiceAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecServiceAlertDestinations], jsii.get(self, "destinationsInput"))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "operatorInput"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67b677f2d6680aff68e2ad7a1326af5bb50a85c1dec01ce1554d151d8b41249e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6014802f5c8b24ed014a699fdf15f82a0a8e7d733eadfae3a5708c73fed1976)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "operator", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f39101af717b2d8617820ec1c586b1fb8824c492df8d5fb945a4fbe26089fdbe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9098a9eae739062c0a3d36666b94c0879b7faf6cd3251a3a609af20ceb1edeb0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63ea55e84ee7069a98d0d05f0f85386581f6809b123832e39376d1abdb6c9a81)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "window", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef61d0d55b9ffd77c52f078c8af9a29fe9cac6bcdfb42c39d9138b5ea2bbb5e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAutoscaling",
    jsii_struct_bases=[],
    name_mapping={
        "max_instance_count": "maxInstanceCount",
        "metrics": "metrics",
        "min_instance_count": "minInstanceCount",
    },
)
class AppSpecServiceAutoscaling:
    def __init__(
        self,
        *,
        max_instance_count: jsii.Number,
        metrics: typing.Union["AppSpecServiceAutoscalingMetrics", typing.Dict[builtins.str, typing.Any]],
        min_instance_count: jsii.Number,
    ) -> None:
        '''
        :param max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_instance_count App#max_instance_count}
        :param metrics: metrics block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#metrics App#metrics}
        :param min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#min_instance_count App#min_instance_count}
        '''
        if isinstance(metrics, dict):
            metrics = AppSpecServiceAutoscalingMetrics(**metrics)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__985ce244e4360c106ea6d02de443bc3b636d88ef63b1cf0253b2b5eb856b0749)
            check_type(argname="argument max_instance_count", value=max_instance_count, expected_type=type_hints["max_instance_count"])
            check_type(argname="argument metrics", value=metrics, expected_type=type_hints["metrics"])
            check_type(argname="argument min_instance_count", value=min_instance_count, expected_type=type_hints["min_instance_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "max_instance_count": max_instance_count,
            "metrics": metrics,
            "min_instance_count": min_instance_count,
        }

    @builtins.property
    def max_instance_count(self) -> jsii.Number:
        '''The maximum amount of instances for this component. Must be more than min_instance_count.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_instance_count App#max_instance_count}
        '''
        result = self._values.get("max_instance_count")
        assert result is not None, "Required property 'max_instance_count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def metrics(self) -> "AppSpecServiceAutoscalingMetrics":
        '''metrics block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#metrics App#metrics}
        '''
        result = self._values.get("metrics")
        assert result is not None, "Required property 'metrics' is missing"
        return typing.cast("AppSpecServiceAutoscalingMetrics", result)

    @builtins.property
    def min_instance_count(self) -> jsii.Number:
        '''The minimum amount of instances for this component. Must be less than max_instance_count.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#min_instance_count App#min_instance_count}
        '''
        result = self._values.get("min_instance_count")
        assert result is not None, "Required property 'min_instance_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceAutoscaling(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAutoscalingMetrics",
    jsii_struct_bases=[],
    name_mapping={"cpu": "cpu"},
)
class AppSpecServiceAutoscalingMetrics:
    def __init__(
        self,
        *,
        cpu: typing.Optional[typing.Union["AppSpecServiceAutoscalingMetricsCpu", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param cpu: cpu block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cpu App#cpu}
        '''
        if isinstance(cpu, dict):
            cpu = AppSpecServiceAutoscalingMetricsCpu(**cpu)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74f50d01f9710b430c966a97ffc12be19d94c7d700ec23d9c4035f70584bec26)
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cpu is not None:
            self._values["cpu"] = cpu

    @builtins.property
    def cpu(self) -> typing.Optional["AppSpecServiceAutoscalingMetricsCpu"]:
        '''cpu block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cpu App#cpu}
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional["AppSpecServiceAutoscalingMetricsCpu"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceAutoscalingMetrics(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAutoscalingMetricsCpu",
    jsii_struct_bases=[],
    name_mapping={"percent": "percent"},
)
class AppSpecServiceAutoscalingMetricsCpu:
    def __init__(self, *, percent: jsii.Number) -> None:
        '''
        :param percent: The average target CPU utilization for the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#percent App#percent}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aab0535f77ef524951e46cf11884f1e3c763c512bca9192dde4614c153790b2f)
            check_type(argname="argument percent", value=percent, expected_type=type_hints["percent"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "percent": percent,
        }

    @builtins.property
    def percent(self) -> jsii.Number:
        '''The average target CPU utilization for the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#percent App#percent}
        '''
        result = self._values.get("percent")
        assert result is not None, "Required property 'percent' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceAutoscalingMetricsCpu(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceAutoscalingMetricsCpuOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAutoscalingMetricsCpuOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__164049787e40f73a826c938b477f9f07065cae0a3c017c25ca8eb21e8584f094)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="percentInput")
    def percent_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "percentInput"))

    @builtins.property
    @jsii.member(jsii_name="percent")
    def percent(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "percent"))

    @percent.setter
    def percent(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c407dd076d3ed203f244cce51292b0512ca5bce954d31b5d6338abe401aed4e2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "percent", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceAutoscalingMetricsCpu]:
        return typing.cast(typing.Optional[AppSpecServiceAutoscalingMetricsCpu], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceAutoscalingMetricsCpu],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0915e38b9b5a17177ebc57ab6d766be0ccbb06526af4266353c7bee0f89153c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceAutoscalingMetricsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAutoscalingMetricsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f90707fe671d922ae3d2b92b1ac8f6ddbe7fb92515e122baf9d2dae96d05d169)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCpu")
    def put_cpu(self, *, percent: jsii.Number) -> None:
        '''
        :param percent: The average target CPU utilization for the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#percent App#percent}
        '''
        value = AppSpecServiceAutoscalingMetricsCpu(percent=percent)

        return typing.cast(None, jsii.invoke(self, "putCpu", [value]))

    @jsii.member(jsii_name="resetCpu")
    def reset_cpu(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpu", []))

    @builtins.property
    @jsii.member(jsii_name="cpu")
    def cpu(self) -> AppSpecServiceAutoscalingMetricsCpuOutputReference:
        return typing.cast(AppSpecServiceAutoscalingMetricsCpuOutputReference, jsii.get(self, "cpu"))

    @builtins.property
    @jsii.member(jsii_name="cpuInput")
    def cpu_input(self) -> typing.Optional[AppSpecServiceAutoscalingMetricsCpu]:
        return typing.cast(typing.Optional[AppSpecServiceAutoscalingMetricsCpu], jsii.get(self, "cpuInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceAutoscalingMetrics]:
        return typing.cast(typing.Optional[AppSpecServiceAutoscalingMetrics], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceAutoscalingMetrics],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d0a0a10797cc2d91483f08eed91f9d402c4ed9ed75c691108abbd80e341c31b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceAutoscalingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceAutoscalingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f371fe720622a4381e0567ccef81a0cf999d128071d52ddc2ab0931e81bf101b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putMetrics")
    def put_metrics(
        self,
        *,
        cpu: typing.Optional[typing.Union[AppSpecServiceAutoscalingMetricsCpu, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param cpu: cpu block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cpu App#cpu}
        '''
        value = AppSpecServiceAutoscalingMetrics(cpu=cpu)

        return typing.cast(None, jsii.invoke(self, "putMetrics", [value]))

    @builtins.property
    @jsii.member(jsii_name="metrics")
    def metrics(self) -> AppSpecServiceAutoscalingMetricsOutputReference:
        return typing.cast(AppSpecServiceAutoscalingMetricsOutputReference, jsii.get(self, "metrics"))

    @builtins.property
    @jsii.member(jsii_name="maxInstanceCountInput")
    def max_instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxInstanceCountInput"))

    @builtins.property
    @jsii.member(jsii_name="metricsInput")
    def metrics_input(self) -> typing.Optional[AppSpecServiceAutoscalingMetrics]:
        return typing.cast(typing.Optional[AppSpecServiceAutoscalingMetrics], jsii.get(self, "metricsInput"))

    @builtins.property
    @jsii.member(jsii_name="minInstanceCountInput")
    def min_instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minInstanceCountInput"))

    @builtins.property
    @jsii.member(jsii_name="maxInstanceCount")
    def max_instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxInstanceCount"))

    @max_instance_count.setter
    def max_instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1c16200d13cc78f0a53f8db0925d9a7cd8e6321930515d79e28164b96ff1862)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxInstanceCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minInstanceCount")
    def min_instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "minInstanceCount"))

    @min_instance_count.setter
    def min_instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85789d7dcbe95a5e3129f40d34d060fbe9c972abbcf58180a3a9fa9c6b58eb3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minInstanceCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceAutoscaling]:
        return typing.cast(typing.Optional[AppSpecServiceAutoscaling], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceAutoscaling]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc6603128470624b5d67332b1b63c729b711ef042b11caafb8c6f03cb86fdb1c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceBitbucket",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecServiceBitbucket:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__979ada8363c70095e484e9093c20bc2c0b70df675024a85d77292d62c1f3cb92)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceBitbucket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceBitbucketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceBitbucketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcfee9085b9749e8ad0ad6241e2e9d4c826e3dfcce865d051aa6e184fc043065)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__203f0cdb05bea53e0b29a3a635fc8cd147f91d3d0acc8df93cf1c2bde9cfcbed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41a427b1f6f6ae21f8e7af0474ae1121f3c9b4184e7d7bcb8e2a9dcb2c7b2b14)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10575f32e51e420650af38993498126f27987a7f51233fc3123d15e6b1463766)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceBitbucket]:
        return typing.cast(typing.Optional[AppSpecServiceBitbucket], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceBitbucket]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5487d1c2ebbf1f73b6e0ab27c37c6454e4d842ef852c75e4730092da615ea70)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceCors",
    jsii_struct_bases=[],
    name_mapping={
        "allow_credentials": "allowCredentials",
        "allow_headers": "allowHeaders",
        "allow_methods": "allowMethods",
        "allow_origins": "allowOrigins",
        "expose_headers": "exposeHeaders",
        "max_age": "maxAge",
    },
)
class AppSpecServiceCors:
    def __init__(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union["AppSpecServiceCorsAllowOrigins", typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        if isinstance(allow_origins, dict):
            allow_origins = AppSpecServiceCorsAllowOrigins(**allow_origins)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44a8072b4f5b7b5dea4c7147709c903c1b3b863ac8789be82496e9148f96cee8)
            check_type(argname="argument allow_credentials", value=allow_credentials, expected_type=type_hints["allow_credentials"])
            check_type(argname="argument allow_headers", value=allow_headers, expected_type=type_hints["allow_headers"])
            check_type(argname="argument allow_methods", value=allow_methods, expected_type=type_hints["allow_methods"])
            check_type(argname="argument allow_origins", value=allow_origins, expected_type=type_hints["allow_origins"])
            check_type(argname="argument expose_headers", value=expose_headers, expected_type=type_hints["expose_headers"])
            check_type(argname="argument max_age", value=max_age, expected_type=type_hints["max_age"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_credentials is not None:
            self._values["allow_credentials"] = allow_credentials
        if allow_headers is not None:
            self._values["allow_headers"] = allow_headers
        if allow_methods is not None:
            self._values["allow_methods"] = allow_methods
        if allow_origins is not None:
            self._values["allow_origins"] = allow_origins
        if expose_headers is not None:
            self._values["expose_headers"] = expose_headers
        if max_age is not None:
            self._values["max_age"] = max_age

    @builtins.property
    def allow_credentials(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``.

        This configures the Access-Control-Allow-Credentials header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        '''
        result = self._values.get("allow_credentials")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def allow_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        '''
        result = self._values.get("allow_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_methods(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        '''
        result = self._values.get("allow_methods")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_origins(self) -> typing.Optional["AppSpecServiceCorsAllowOrigins"]:
        '''allow_origins block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        '''
        result = self._values.get("allow_origins")
        return typing.cast(typing.Optional["AppSpecServiceCorsAllowOrigins"], result)

    @builtins.property
    def expose_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        '''
        result = self._values.get("expose_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def max_age(self) -> typing.Optional[builtins.str]:
        '''An optional duration specifying how long browsers can cache the results of a preflight request.

        This configures the Access-Control-Max-Age header. Example: ``5h30m``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        result = self._values.get("max_age")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceCors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceCorsAllowOrigins",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact", "prefix": "prefix", "regex": "regex"},
)
class AppSpecServiceCorsAllowOrigins:
    def __init__(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66971ba5963e19841f72dcd605329522e7e610142b248336f443a9bd0330fa24)
            check_type(argname="argument exact", value=exact, expected_type=type_hints["exact"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact
        if prefix is not None:
            self._values["prefix"] = prefix
        if regex is not None:
            self._values["regex"] = regex

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        '''Exact string match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        '''
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''Prefix-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def regex(self) -> typing.Optional[builtins.str]:
        '''RE2 style regex-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        result = self._values.get("regex")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceCorsAllowOrigins(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceCorsAllowOriginsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceCorsAllowOriginsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9d396894537c1edb3a13eba0a74effffebb7f352419631bd5680a90c62719e2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetRegex")
    def reset_regex(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegex", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regexInput")
    def regex_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c06a24fc9d935c37ad6b32edfafd8aa04fb92d93126e8d725a59b3f2b9200a3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exact", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1dee837843229df9d7af7f9029ebbe7c489b8e64a7c40d44274c0e95d10b220d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "prefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="regex")
    def regex(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "regex"))

    @regex.setter
    def regex(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f47bf5fe03152a7658b7d4fd0fbfe0a0064ed2e9d75026a6bc8b42014c9b2f1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "regex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecServiceCorsAllowOrigins], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceCorsAllowOrigins],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21ba1011a9b5a1321c765ff92d574d8a2059d2a36c483d665ca092d0becb7f4b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceCorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceCorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5da3effddfe810bbff1026140ed7a4d6036aa7584c29bdcbd26fd214cbe2d081)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAllowOrigins")
    def put_allow_origins(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        value = AppSpecServiceCorsAllowOrigins(exact=exact, prefix=prefix, regex=regex)

        return typing.cast(None, jsii.invoke(self, "putAllowOrigins", [value]))

    @jsii.member(jsii_name="resetAllowCredentials")
    def reset_allow_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowCredentials", []))

    @jsii.member(jsii_name="resetAllowHeaders")
    def reset_allow_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowHeaders", []))

    @jsii.member(jsii_name="resetAllowMethods")
    def reset_allow_methods(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowMethods", []))

    @jsii.member(jsii_name="resetAllowOrigins")
    def reset_allow_origins(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowOrigins", []))

    @jsii.member(jsii_name="resetExposeHeaders")
    def reset_expose_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExposeHeaders", []))

    @jsii.member(jsii_name="resetMaxAge")
    def reset_max_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxAge", []))

    @builtins.property
    @jsii.member(jsii_name="allowOrigins")
    def allow_origins(self) -> AppSpecServiceCorsAllowOriginsOutputReference:
        return typing.cast(AppSpecServiceCorsAllowOriginsOutputReference, jsii.get(self, "allowOrigins"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentialsInput")
    def allow_credentials_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "allowCredentialsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowHeadersInput")
    def allow_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="allowMethodsInput")
    def allow_methods_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowMethodsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowOriginsInput")
    def allow_origins_input(self) -> typing.Optional[AppSpecServiceCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecServiceCorsAllowOrigins], jsii.get(self, "allowOriginsInput"))

    @builtins.property
    @jsii.member(jsii_name="exposeHeadersInput")
    def expose_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "exposeHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="maxAgeInput")
    def max_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentials")
    def allow_credentials(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "allowCredentials"))

    @allow_credentials.setter
    def allow_credentials(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f560d96810493434eb1022b2065b68c8951990a7bebc2caf92b6590b93a5ecd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowCredentials", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowHeaders")
    def allow_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowHeaders"))

    @allow_headers.setter
    def allow_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9588d738a914581d8fa98df7c73809a3a8fdcf2d586cb58261a04fa2b863708)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowMethods")
    def allow_methods(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowMethods"))

    @allow_methods.setter
    def allow_methods(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b9958fd4ab30c1c7d968ba912f566dbe676bb8ddc7ad4bc68eb0ff0639f32e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowMethods", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="exposeHeaders")
    def expose_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "exposeHeaders"))

    @expose_headers.setter
    def expose_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56d88d2c1bba219e74b4d04e4ef62aa55846cb6644359b9c1132bffeba55e65c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exposeHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxAge")
    def max_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxAge"))

    @max_age.setter
    def max_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa12b9d722511b226b70bc8885360a4e90705733d93eaee93c11b8d832cdee13)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceCors]:
        return typing.cast(typing.Optional[AppSpecServiceCors], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceCors]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__acb44bb902446b4c76f0a1e8d479b0a5730c77aaa135c0577410b2ffc614ebf1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecServiceEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2062de1d2b698b443d4444fa2921a0f7eb724d5398f99b6c88c955bdaa2e143e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        '''The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f21714640e6ee67f2540a212cc48eacd1e68b60c5dff1946e643c2c62cebdca)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceEnvOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e71578c99d0771ead5008a2c779293fd44088609d791e5cfca5b86e5c12161f)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecServiceEnvOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6db1010770862110676220956dd867a966fae87a56b6a2b5b3a61bfaf69eee1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83eb2d8643729159a4bb86bc1caf0ffee681eb01ad510926a809d21990a112bb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d77042d46422c784b5416c4532553a68dc618bdf8a497040983ed250b101ffc5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c592fd2cdb98f5890aa8756a9bc05e4b0e9dd35be6bbc6809ccc5dd0f1c087e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4d1554cabac46661cfcebca4044b584176d136fcce02a14e1ae09ab16fcb012)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05b58f5d64b5920bb33534a830c687c1e845739d1842e2eb395e35da17458780)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0a0022a59cbdeecd60f0a2bb55bb6e1700a1605a7485d790c301173f079171c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c89b9191190dfa5552894ed2d0fd902e2e133cedaa1ed740336f29a57c1cf5e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f975bc1987ebe974c9e03837bf4756bb1592a381c9e992cc9915047425fabe45)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5068c6f1e485700ba665f6f02bd5499b7a2df3865f13baef15f904c2fa9a20f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecServiceGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c8bc5542ebad7a14da6f43f476178e579580b8c79a12cbd7add5ce085390f65)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument repo_clone_url", value=repo_clone_url, expected_type=type_hints["repo_clone_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        '''The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27a947e28e5d753d3882b918704cbd26a52fabb2531148d70a8d4f7f28719ee2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aad5a0a507b3b8c8a8ab682cf0699912418cd6a085cf1edb92931a5e78ad467a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c06473ce62c9e10484b7b18bd97cb6a5a625bf6154a7fc551221413326beabd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repoCloneUrl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceGit]:
        return typing.cast(typing.Optional[AppSpecServiceGit], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c3298ba17fb92782ea19062244d6f78351edf71425652e3df20320477a44427)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecServiceGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bb40ede89a0b544b35976bf83a9990fe4b59b16144321d450444ca0804b9af0)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a1a2c5175b58e98493783d619fba05581022f57433cc524fe3a3f8ddeebe2de)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd0673d66763d63fdacb048654cf338f93a22c6a17ff2db7b31131eb0683f5ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cceece8490fdb3c7336df036f4386fa4ceb07eab5e6aa02eaa4bd24fb1698abf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f86bc8e30abf7223850c5cebf8b6b609968f588a08ca0049d826df04f8b9eb4a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceGithub]:
        return typing.cast(typing.Optional[AppSpecServiceGithub], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0556e7f7c0061b941c14147ae1755186d46ed55386ee6c711bf985534f93884)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecServiceGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f920f7f33b412724fc2312afb93c239eb8746cf118ba9ef0e84eeeff26231d4)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5a0a404995add9c111faf3df97ad9b92892bdd7777236089b325d098d8124c1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__469b3df6e7298c0e4832dc36217f4baeb47f58f5ec80b307222b20427dcb6955)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c6d900f7eff27605882ad9b0b0994a2e21c5cd098b6c8399bc6f021665b082a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d8ab840145a69fbcd72f381cbec34a1fa18ab90c6079aa9c3072138f806302c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceGitlab]:
        return typing.cast(typing.Optional[AppSpecServiceGitlab], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05c32ee459338868aa4efd6358692abf66bc50c07d136ed2f3f8d683831b4942)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceHealthCheck",
    jsii_struct_bases=[],
    name_mapping={
        "failure_threshold": "failureThreshold",
        "http_path": "httpPath",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "port": "port",
        "success_threshold": "successThreshold",
        "timeout_seconds": "timeoutSeconds",
    },
)
class AppSpecServiceHealthCheck:
    def __init__(
        self,
        *,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_path: typing.Optional[builtins.str] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        port: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param failure_threshold: The number of failed health checks before considered unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#failure_threshold App#failure_threshold}
        :param http_path: The route path used for the HTTP health check ping. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#http_path App#http_path}
        :param initial_delay_seconds: The number of seconds to wait before beginning health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#initial_delay_seconds App#initial_delay_seconds}
        :param period_seconds: The number of seconds to wait between health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#period_seconds App#period_seconds}
        :param port: The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#port App#port}
        :param success_threshold: The number of successful health checks before considered healthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#success_threshold App#success_threshold}
        :param timeout_seconds: The number of seconds after which the check times out. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#timeout_seconds App#timeout_seconds}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dff3423822fbbe36d24554c3a6951943c9099232cae4e55a4c7d0bcc93d4f095)
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_path", value=http_path, expected_type=type_hints["http_path"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_path is not None:
            self._values["http_path"] = http_path
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if port is not None:
            self._values["port"] = port
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''The number of failed health checks before considered unhealthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#failure_threshold App#failure_threshold}
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_path(self) -> typing.Optional[builtins.str]:
        '''The route path used for the HTTP health check ping.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#http_path App#http_path}
        '''
        result = self._values.get("http_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds to wait before beginning health checks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#initial_delay_seconds App#initial_delay_seconds}
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds to wait between health checks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#period_seconds App#period_seconds}
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''The port on which the health check will be performed.

        If not set, the health check will be performed on the component's http_port.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#port App#port}
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''The number of successful health checks before considered healthy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#success_threshold App#success_threshold}
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds after which the check times out.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#timeout_seconds App#timeout_seconds}
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceHealthCheck(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceHealthCheckOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceHealthCheckOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0489b99797eeddb6e549d8ec7664f6e1a0dfe50ef3c30797501845ccb1eb99ab)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetFailureThreshold")
    def reset_failure_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFailureThreshold", []))

    @jsii.member(jsii_name="resetHttpPath")
    def reset_http_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpPath", []))

    @jsii.member(jsii_name="resetInitialDelaySeconds")
    def reset_initial_delay_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialDelaySeconds", []))

    @jsii.member(jsii_name="resetPeriodSeconds")
    def reset_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPeriodSeconds", []))

    @jsii.member(jsii_name="resetPort")
    def reset_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPort", []))

    @jsii.member(jsii_name="resetSuccessThreshold")
    def reset_success_threshold(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSuccessThreshold", []))

    @jsii.member(jsii_name="resetTimeoutSeconds")
    def reset_timeout_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="failureThresholdInput")
    def failure_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "failureThresholdInput"))

    @builtins.property
    @jsii.member(jsii_name="httpPathInput")
    def http_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpPathInput"))

    @builtins.property
    @jsii.member(jsii_name="initialDelaySecondsInput")
    def initial_delay_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "initialDelaySecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="periodSecondsInput")
    def period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "periodSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="portInput")
    def port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "portInput"))

    @builtins.property
    @jsii.member(jsii_name="successThresholdInput")
    def success_threshold_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "successThresholdInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutSecondsInput")
    def timeout_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "timeoutSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="failureThreshold")
    def failure_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "failureThreshold"))

    @failure_threshold.setter
    def failure_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60c6f75ba43197f83949a8c2f008775abc671213fa8ecf7e1c77b23059edcc28)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "failureThreshold", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="httpPath")
    def http_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "httpPath"))

    @http_path.setter
    def http_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98d43a2c5a032ae49e30e2563742d2d13dac437c55ef3da0c16d84650596e97e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "httpPath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="initialDelaySeconds")
    def initial_delay_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialDelaySeconds"))

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c84403d2326719eee3bc096bda0e963c64008753dba95100c1c14f871d9baf46)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "initialDelaySeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="periodSeconds")
    def period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "periodSeconds"))

    @period_seconds.setter
    def period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91fb9d1918a7f20dc73f6869c8fe64ce47d9ad9318c6aa15ffc36635e785df33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "periodSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @port.setter
    def port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6268b69e46b069733163cf76f6fd8071994d6117e61976f7776f0e4e5b3c747b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "port", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="successThreshold")
    def success_threshold(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "successThreshold"))

    @success_threshold.setter
    def success_threshold(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5f0bfa6b1c4acfbfb617cf2065b3335550ab18ec5f0281b8eb969fa998bb668)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "successThreshold", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @timeout_seconds.setter
    def timeout_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6ec7d882c9ef2bc44ec65b52ce693da01f27cba0e855dc423cd3db02509ebd0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "timeoutSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceHealthCheck]:
        return typing.cast(typing.Optional[AppSpecServiceHealthCheck], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceHealthCheck]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__633e9c4d7fd79f1b533da7dfb5fb36a1696dad86d1d9018040f075f6f276fcb4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceImage",
    jsii_struct_bases=[],
    name_mapping={
        "registry_type": "registryType",
        "repository": "repository",
        "deploy_on_push": "deployOnPush",
        "digest": "digest",
        "registry": "registry",
        "registry_credentials": "registryCredentials",
        "tag": "tag",
    },
)
class AppSpecServiceImage:
    def __init__(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceImageDeployOnPush", typing.Dict[builtins.str, typing.Any]]]]] = None,
        digest: typing.Optional[builtins.str] = None,
        registry: typing.Optional[builtins.str] = None,
        registry_credentials: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param digest: The image digest. Cannot be specified if tag is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        :param registry_credentials: Access credentials for third-party registries. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        :param tag: The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__feac39c18ca7b3aeb4ed686400f0e4c560705d0cea003d17cc16cebe1ac1611e)
            check_type(argname="argument registry_type", value=registry_type, expected_type=type_hints["registry_type"])
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument digest", value=digest, expected_type=type_hints["digest"])
            check_type(argname="argument registry", value=registry, expected_type=type_hints["registry"])
            check_type(argname="argument registry_credentials", value=registry_credentials, expected_type=type_hints["registry_credentials"])
            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "registry_type": registry_type,
            "repository": repository,
        }
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if digest is not None:
            self._values["digest"] = digest
        if registry is not None:
            self._values["registry"] = registry
        if registry_credentials is not None:
            self._values["registry_credentials"] = registry_credentials
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def registry_type(self) -> builtins.str:
        '''The registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        '''
        result = self._values.get("registry_type")
        assert result is not None, "Required property 'registry_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        '''The repository name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        '''
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceImageDeployOnPush"]]]:
        '''deploy_on_push block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceImageDeployOnPush"]]], result)

    @builtins.property
    def digest(self) -> typing.Optional[builtins.str]:
        '''The image digest. Cannot be specified if tag is provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        '''
        result = self._values.get("digest")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def registry(self) -> typing.Optional[builtins.str]:
        '''The registry name. Must be left empty for the DOCR registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        '''
        result = self._values.get("registry")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def registry_credentials(self) -> typing.Optional[builtins.str]:
        '''Access credentials for third-party registries.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        '''
        result = self._values.get("registry_credentials")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag(self) -> typing.Optional[builtins.str]:
        '''The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        result = self._values.get("tag")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceImage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceImageDeployOnPush",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AppSpecServiceImageDeployOnPush:
    def __init__(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Whether to automatically deploy images pushed to DOCR. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a0b5e6adb65742638796bcc9a918e4584e0f7b94a8cfe560b5b0d9b07c8dee8)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy images pushed to DOCR.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceImageDeployOnPush(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceImageDeployOnPushList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceImageDeployOnPushList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d28db1a1f7e55f307a856c2d01e60ca8fba7ec0337e18735fa1205c5976b57a1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecServiceImageDeployOnPushOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3449baf02b642322b725a7fdab49353eadcd87d4b2681832a17a493333ec927a)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecServiceImageDeployOnPushOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a0006cc6e9c227fe6602da28fbffe94c89b8eb2e4f86388fc01774e744bdd60)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04c760a8877d63b4bafc9e3407c240c2333d7b58eee1a4b88240e36d5f3bb9e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fbc862e4189921d05f33fd1effa33d037eafe548a1918385a00210a710a39aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4c61d393f93dccb6338413b5534916afd1e8f2958029bb2990d08bf2cedb1a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceImageDeployOnPushOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceImageDeployOnPushOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44c8b9b00ea987cf04fc58682d0fe19f3641e782a8f567bbcb2cee15aa7180dc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45d9f3dcb924fba617fba1288142ed227673a0c2e9b3fcdf34d8e64a676ca34d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7712ff516ad55d75b92fb2dd4203d1a7bc4a8d2126dc738ceef3fbd9dd8e3456)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceImageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceImageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38a74141e06ec96ea520ff83e4cabe33d46c20c2ccaa59696abe7e09cf948898)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDeployOnPush")
    def put_deploy_on_push(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c89cf67b70355d2d2e049f174b46044b00b96908cf4edf4007aee26579f3d596)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDeployOnPush", [value]))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetDigest")
    def reset_digest(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDigest", []))

    @jsii.member(jsii_name="resetRegistry")
    def reset_registry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistry", []))

    @jsii.member(jsii_name="resetRegistryCredentials")
    def reset_registry_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistryCredentials", []))

    @jsii.member(jsii_name="resetTag")
    def reset_tag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTag", []))

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(self) -> AppSpecServiceImageDeployOnPushList:
        return typing.cast(AppSpecServiceImageDeployOnPushList, jsii.get(self, "deployOnPush"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="digestInput")
    def digest_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "digestInput"))

    @builtins.property
    @jsii.member(jsii_name="registryCredentialsInput")
    def registry_credentials_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryCredentialsInput"))

    @builtins.property
    @jsii.member(jsii_name="registryInput")
    def registry_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryInput"))

    @builtins.property
    @jsii.member(jsii_name="registryTypeInput")
    def registry_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="repositoryInput")
    def repository_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repositoryInput"))

    @builtins.property
    @jsii.member(jsii_name="tagInput")
    def tag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagInput"))

    @builtins.property
    @jsii.member(jsii_name="digest")
    def digest(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "digest"))

    @digest.setter
    def digest(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fbc2e1117fdfe3c01aec349db19f074e0a48ccd3843f26cb044de8870fc84c3c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "digest", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registry")
    def registry(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registry"))

    @registry.setter
    def registry(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2500bddd31e7a4f55cdc4a5eeddf2ff26eb5359b8b99de01ecdb4f6bedc8f6cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registry", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registryCredentials")
    def registry_credentials(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryCredentials"))

    @registry_credentials.setter
    def registry_credentials(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9108994d87726ae737ecaff374b93f50eaa4ed7405803fdff52645ed2838553)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registryCredentials", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registryType")
    def registry_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryType"))

    @registry_type.setter
    def registry_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1586ec17ece3d7b17bae6f4a87b97bda400d904e7f3965423b55e54da438a8e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registryType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repository"))

    @repository.setter
    def repository(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcf39b6ab499a21d2eeac1cc535ccf754e03784378cde8d642d65f589e0fa915)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repository", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tag")
    def tag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tag"))

    @tag.setter
    def tag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6be2c222f7fd4cb2e6d6eb607b24062a43673a859610ed9878cec1559e4c3411)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tag", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceImage]:
        return typing.cast(typing.Optional[AppSpecServiceImage], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceImage]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f69e4b7f489d5ce3054131d8963116c53e5f14e742d9d39a8e00d2adb9155480)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__445ea9eb916f3004869ab1b9f691434f7a6ac1e6bd775637c8384e1f2a7024e6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__acfb012c04b87928ea0caa121e1c921ed56290b5a81d182f951b717441e1ccca)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecServiceOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a04a77beeaaa74543a78742871de41fbd16b3ec2a6b50939f71f1c70b88e799)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b9fb25b78ae70a781d45e4b828480e5d938fdb433676d9a033e18a94b5244a7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23cbe2f66c1994c55fb7ebc52508f6d3070f8985ca474b618a2425a3a5dca5a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16da2f02b850b4517800466438359cc29170fcf67650902c1afe8bc4d97f6217)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "open_search": "openSearch",
        "papertrail": "papertrail",
    },
)
class AppSpecServiceLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[typing.Union["AppSpecServiceLogDestinationDatadog", typing.Dict[builtins.str, typing.Any]]] = None,
        logtail: typing.Optional[typing.Union["AppSpecServiceLogDestinationLogtail", typing.Dict[builtins.str, typing.Any]]] = None,
        open_search: typing.Optional[typing.Union["AppSpecServiceLogDestinationOpenSearch", typing.Dict[builtins.str, typing.Any]]] = None,
        papertrail: typing.Optional[typing.Union["AppSpecServiceLogDestinationPapertrail", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        :param open_search: open_search block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        if isinstance(datadog, dict):
            datadog = AppSpecServiceLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecServiceLogDestinationLogtail(**logtail)
        if isinstance(open_search, dict):
            open_search = AppSpecServiceLogDestinationOpenSearch(**open_search)
        if isinstance(papertrail, dict):
            papertrail = AppSpecServiceLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b80100048f682471fa81c84ce23a19ea5157a464bd81414a87e495f1b46f33e1)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument datadog", value=datadog, expected_type=type_hints["datadog"])
            check_type(argname="argument logtail", value=logtail, expected_type=type_hints["logtail"])
            check_type(argname="argument open_search", value=open_search, expected_type=type_hints["open_search"])
            check_type(argname="argument papertrail", value=papertrail, expected_type=type_hints["papertrail"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if open_search is not None:
            self._values["open_search"] = open_search
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecServiceLogDestinationDatadog"]:
        '''datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        '''
        result = self._values.get("datadog")
        return typing.cast(typing.Optional["AppSpecServiceLogDestinationDatadog"], result)

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecServiceLogDestinationLogtail"]:
        '''logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        '''
        result = self._values.get("logtail")
        return typing.cast(typing.Optional["AppSpecServiceLogDestinationLogtail"], result)

    @builtins.property
    def open_search(self) -> typing.Optional["AppSpecServiceLogDestinationOpenSearch"]:
        '''open_search block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        '''
        result = self._values.get("open_search")
        return typing.cast(typing.Optional["AppSpecServiceLogDestinationOpenSearch"], result)

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecServiceLogDestinationPapertrail"]:
        '''papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        result = self._values.get("papertrail")
        return typing.cast(typing.Optional["AppSpecServiceLogDestinationPapertrail"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecServiceLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30f3012bb9a93e0351da6111238992c4562d3a46a61e77f3d3d81b759545fd9e)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        '''Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        '''
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de43b364c482db7a39d7b4bcf48da7f3f658e4c883e4b303ad37a496b4fb5ffc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97dfd6b3e83f8a2ebeb446d5123d4ea12ebe0efb8eaca94363604bbf50624a52)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "apiKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64d066f4a6ce478537df7b7d6a86bacb18aec1b4b37b61de18c0fea9ab0afff9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationDatadog], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b998c8446bd5425d72b2197e9badd18791723d63669c81b550fdf0e1ba89322)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__070ed101274adcc79b311c77a040da407025af7fcd0608b618b72e0fdac290d1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceLogDestinationOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d37306e457b8a3ec9cb4539b0b5bdf39bbaf711a4f7495a82dcf82f61a65fad5)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecServiceLogDestinationOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4ed999da459735860eb7c3ae30f4353cd0aa344db31d2f1fda4475eac13b1e1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12baf602c5f8168beb36464828161bda7cc6797f646387db87d4f5d0415c491e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad34dc7807e796bd1fd0093c95f322067eba8b30428700e9dae733e031b1d31b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96522fd3f507b940b016b043f83bde39ba281199bda99e7c20be85a24a5221f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecServiceLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b5845d97c85d1db5d72d04d07931aa3ffa0d1dd0496199587478cc02254dbdb)
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        '''Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__731bc80aa1861304f499ab77d10d2f66a394a446c4bd52ed04479fa70f3ec0f0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bade63bcf466906fb7ae33f0c80a96aa7261c3a91818844bb2d48f4e2a71967d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "token", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationLogtail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__448eba8fe53b0487a63b908533f6a5f4b66120ceca7d2cb67524e93de7e3256b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationOpenSearch",
    jsii_struct_bases=[],
    name_mapping={
        "basic_auth": "basicAuth",
        "cluster_name": "clusterName",
        "endpoint": "endpoint",
        "index_name": "indexName",
    },
)
class AppSpecServiceLogDestinationOpenSearch:
    def __init__(
        self,
        *,
        basic_auth: typing.Union["AppSpecServiceLogDestinationOpenSearchBasicAuth", typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        if isinstance(basic_auth, dict):
            basic_auth = AppSpecServiceLogDestinationOpenSearchBasicAuth(**basic_auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4c7c3b53d86c30504630be3654ef9326cf80a36212ce70a105c4e7186611890)
            check_type(argname="argument basic_auth", value=basic_auth, expected_type=type_hints["basic_auth"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument index_name", value=index_name, expected_type=type_hints["index_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "basic_auth": basic_auth,
        }
        if cluster_name is not None:
            self._values["cluster_name"] = cluster_name
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if index_name is not None:
            self._values["index_name"] = index_name

    @builtins.property
    def basic_auth(self) -> "AppSpecServiceLogDestinationOpenSearchBasicAuth":
        '''basic_auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        '''
        result = self._values.get("basic_auth")
        assert result is not None, "Required property 'basic_auth' is missing"
        return typing.cast("AppSpecServiceLogDestinationOpenSearchBasicAuth", result)

    @builtins.property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch cluster name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        '''
        result = self._values.get("cluster_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''OpenSearch endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def index_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch index name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        result = self._values.get("index_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationOpenSearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationOpenSearchBasicAuth",
    jsii_struct_bases=[],
    name_mapping={"password": "password", "user": "user"},
)
class AppSpecServiceLogDestinationOpenSearchBasicAuth:
    def __init__(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ea2414b015234933f55bffc1bdb0030961fed80a5acc38815d98164ef5b81c8)
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if password is not None:
            self._values["password"] = password
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''Password for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''user for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationOpenSearchBasicAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceLogDestinationOpenSearchBasicAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationOpenSearchBasicAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b92ab4a89f541fecf8330df163b0ad7770e86a9b3571cbde893901331c8a3f3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPassword")
    def reset_password(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPassword", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="passwordInput")
    def password_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "passwordInput"))

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "password"))

    @password.setter
    def password(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c529dae0330747806f1ed2ecbcfd4ab088670d8508d9098dd5436600a392dc7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "password", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__849bcac58547576f593c971bfc8066804483d82551cfa7dc5ba81efc92699304)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "user", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[AppSpecServiceLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationOpenSearchBasicAuth], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationOpenSearchBasicAuth],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21a56d3ab27e5a458755a41fb91530091a34c3efabb97900b5b98e84d2a77723)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceLogDestinationOpenSearchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationOpenSearchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3340c81661cafe8bcfc0538ebcb9068f54658f151c5c38e9281b94e2d4560542)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putBasicAuth")
    def put_basic_auth(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        value = AppSpecServiceLogDestinationOpenSearchBasicAuth(
            password=password, user=user
        )

        return typing.cast(None, jsii.invoke(self, "putBasicAuth", [value]))

    @jsii.member(jsii_name="resetClusterName")
    def reset_cluster_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterName", []))

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @jsii.member(jsii_name="resetIndexName")
    def reset_index_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIndexName", []))

    @builtins.property
    @jsii.member(jsii_name="basicAuth")
    def basic_auth(
        self,
    ) -> AppSpecServiceLogDestinationOpenSearchBasicAuthOutputReference:
        return typing.cast(AppSpecServiceLogDestinationOpenSearchBasicAuthOutputReference, jsii.get(self, "basicAuth"))

    @builtins.property
    @jsii.member(jsii_name="basicAuthInput")
    def basic_auth_input(
        self,
    ) -> typing.Optional[AppSpecServiceLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationOpenSearchBasicAuth], jsii.get(self, "basicAuthInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterNameInput")
    def cluster_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterNameInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="indexNameInput")
    def index_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "indexNameInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterName")
    def cluster_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterName"))

    @cluster_name.setter
    def cluster_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b50829cb8953c9113909b34a649d6d1d331190ab8566b68c1f12f33673b4c031)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1600c6ba7da5e88a156f61d69fa5a972a0ccb54e2cc1acfa3d18c43c350466c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="indexName")
    def index_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "indexName"))

    @index_name.setter
    def index_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95ac9938f9074e220bcf3db5bc5104011a87452021ee2537c8c3a95c0c68b83d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "indexName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationOpenSearch], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationOpenSearch],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1d865810bf395438a570b505feb2ea45c1ffe5aca15460ce997996dca856c3e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9a25f6710918fcdca18f773afbae505dbbfb14abb789d76339b58cf103a1c2b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecServiceLogDestinationDatadog(api_key=api_key, endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        value = AppSpecServiceLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putOpenSearch")
    def put_open_search(
        self,
        *,
        basic_auth: typing.Union[AppSpecServiceLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        value = AppSpecServiceLogDestinationOpenSearch(
            basic_auth=basic_auth,
            cluster_name=cluster_name,
            endpoint=endpoint,
            index_name=index_name,
        )

        return typing.cast(None, jsii.invoke(self, "putOpenSearch", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecServiceLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetOpenSearch")
    def reset_open_search(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOpenSearch", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecServiceLogDestinationDatadogOutputReference:
        return typing.cast(AppSpecServiceLogDestinationDatadogOutputReference, jsii.get(self, "datadog"))

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecServiceLogDestinationLogtailOutputReference:
        return typing.cast(AppSpecServiceLogDestinationLogtailOutputReference, jsii.get(self, "logtail"))

    @builtins.property
    @jsii.member(jsii_name="openSearch")
    def open_search(self) -> AppSpecServiceLogDestinationOpenSearchOutputReference:
        return typing.cast(AppSpecServiceLogDestinationOpenSearchOutputReference, jsii.get(self, "openSearch"))

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecServiceLogDestinationPapertrailOutputReference":
        return typing.cast("AppSpecServiceLogDestinationPapertrailOutputReference", jsii.get(self, "papertrail"))

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecServiceLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationDatadog], jsii.get(self, "datadogInput"))

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecServiceLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationLogtail], jsii.get(self, "logtailInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="openSearchInput")
    def open_search_input(
        self,
    ) -> typing.Optional[AppSpecServiceLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationOpenSearch], jsii.get(self, "openSearchInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(
        self,
    ) -> typing.Optional["AppSpecServiceLogDestinationPapertrail"]:
        return typing.cast(typing.Optional["AppSpecServiceLogDestinationPapertrail"], jsii.get(self, "papertrailInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__860e2dbeb0497178fa94de043a7b491f1c22d8af74789fbcd162a50543a8e196)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__302263cfd6845503cdbd10fe1b7908e4c846f744ca9e5e9837916a8756b5e3f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecServiceLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70ff15103afa3ea4a06ba7124b375fd02fc3cb8c19c14f6bbc8dd1b0287a6fd8)
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        '''Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c20222d974b7a759a352b2663695bc2e42d41ce4068bffeac5e2a10c1ffc993c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__857013c964c3ecdf1a518573019ff2fd5bf7d1908308aa0d056ebc68f9ff043d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceLogDestinationPapertrail]:
        return typing.cast(typing.Optional[AppSpecServiceLogDestinationPapertrail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecServiceLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__027b9d58a39d2b78fbda6a9ac08b88b501e5a9d8e296be52ac094c572121b917)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__393346795f5654fd9c842eaa1dff869b28c5663d0a93fb54815a0104d9821696)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceAlert, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db838f8cbb88ce4682de1ea160bfece2841e8508a308159376a66dd92cad412d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putAutoscaling")
    def put_autoscaling(
        self,
        *,
        max_instance_count: jsii.Number,
        metrics: typing.Union[AppSpecServiceAutoscalingMetrics, typing.Dict[builtins.str, typing.Any]],
        min_instance_count: jsii.Number,
    ) -> None:
        '''
        :param max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_instance_count App#max_instance_count}
        :param metrics: metrics block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#metrics App#metrics}
        :param min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#min_instance_count App#min_instance_count}
        '''
        value = AppSpecServiceAutoscaling(
            max_instance_count=max_instance_count,
            metrics=metrics,
            min_instance_count=min_instance_count,
        )

        return typing.cast(None, jsii.invoke(self, "putAutoscaling", [value]))

    @jsii.member(jsii_name="putBitbucket")
    def put_bitbucket(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecServiceBitbucket(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putBitbucket", [value]))

    @jsii.member(jsii_name="putCors")
    def put_cors(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union[AppSpecServiceCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        value = AppSpecServiceCors(
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )

        return typing.cast(None, jsii.invoke(self, "putCors", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceEnv, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e52dbabd7d90bfd4d06ca601c0ee51835388ed2086d89be87ee94a5bf487ef7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        value = AppSpecServiceGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecServiceGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecServiceGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putHealthCheck")
    def put_health_check(
        self,
        *,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_path: typing.Optional[builtins.str] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        port: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param failure_threshold: The number of failed health checks before considered unhealthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#failure_threshold App#failure_threshold}
        :param http_path: The route path used for the HTTP health check ping. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#http_path App#http_path}
        :param initial_delay_seconds: The number of seconds to wait before beginning health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#initial_delay_seconds App#initial_delay_seconds}
        :param period_seconds: The number of seconds to wait between health checks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#period_seconds App#period_seconds}
        :param port: The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#port App#port}
        :param success_threshold: The number of successful health checks before considered healthy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#success_threshold App#success_threshold}
        :param timeout_seconds: The number of seconds after which the check times out. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#timeout_seconds App#timeout_seconds}
        '''
        value = AppSpecServiceHealthCheck(
            failure_threshold=failure_threshold,
            http_path=http_path,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            port=port,
            success_threshold=success_threshold,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(None, jsii.invoke(self, "putHealthCheck", [value]))

    @jsii.member(jsii_name="putImage")
    def put_image(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]]] = None,
        digest: typing.Optional[builtins.str] = None,
        registry: typing.Optional[builtins.str] = None,
        registry_credentials: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param digest: The image digest. Cannot be specified if tag is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        :param registry_credentials: Access credentials for third-party registries. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        :param tag: The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        value = AppSpecServiceImage(
            registry_type=registry_type,
            repository=repository,
            deploy_on_push=deploy_on_push,
            digest=digest,
            registry=registry,
            registry_credentials=registry_credentials,
            tag=tag,
        )

        return typing.cast(None, jsii.invoke(self, "putImage", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceLogDestination, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71830b1e8004c3e118883545bca6cf49fff9dcd6308acaaa5c1ccc4470283828)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="putRoutes")
    def put_routes(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecServiceRoutes", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26341a8e39fc1352d621bf71436ed417587c837d97d4708487fd8bae11d1af17)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRoutes", [value]))

    @jsii.member(jsii_name="putTermination")
    def put_termination(
        self,
        *,
        drain_seconds: typing.Optional[jsii.Number] = None,
        grace_period_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param drain_seconds: The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#drain_seconds App#drain_seconds}
        :param grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        value = AppSpecServiceTermination(
            drain_seconds=drain_seconds, grace_period_seconds=grace_period_seconds
        )

        return typing.cast(None, jsii.invoke(self, "putTermination", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetAutoscaling")
    def reset_autoscaling(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoscaling", []))

    @jsii.member(jsii_name="resetBitbucket")
    def reset_bitbucket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBitbucket", []))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetCors")
    def reset_cors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCors", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetHealthCheck")
    def reset_health_check(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHealthCheck", []))

    @jsii.member(jsii_name="resetHttpPort")
    def reset_http_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpPort", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetInstanceCount")
    def reset_instance_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceCount", []))

    @jsii.member(jsii_name="resetInstanceSizeSlug")
    def reset_instance_size_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceSizeSlug", []))

    @jsii.member(jsii_name="resetInternalPorts")
    def reset_internal_ports(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInternalPorts", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRoutes")
    def reset_routes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoutes", []))

    @jsii.member(jsii_name="resetRunCommand")
    def reset_run_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunCommand", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @jsii.member(jsii_name="resetTermination")
    def reset_termination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTermination", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecServiceAlertList:
        return typing.cast(AppSpecServiceAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="autoscaling")
    def autoscaling(self) -> AppSpecServiceAutoscalingOutputReference:
        return typing.cast(AppSpecServiceAutoscalingOutputReference, jsii.get(self, "autoscaling"))

    @builtins.property
    @jsii.member(jsii_name="bitbucket")
    def bitbucket(self) -> AppSpecServiceBitbucketOutputReference:
        return typing.cast(AppSpecServiceBitbucketOutputReference, jsii.get(self, "bitbucket"))

    @builtins.property
    @jsii.member(jsii_name="cors")
    def cors(self) -> AppSpecServiceCorsOutputReference:
        return typing.cast(AppSpecServiceCorsOutputReference, jsii.get(self, "cors"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecServiceEnvList:
        return typing.cast(AppSpecServiceEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecServiceGitOutputReference:
        return typing.cast(AppSpecServiceGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecServiceGithubOutputReference:
        return typing.cast(AppSpecServiceGithubOutputReference, jsii.get(self, "github"))

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecServiceGitlabOutputReference:
        return typing.cast(AppSpecServiceGitlabOutputReference, jsii.get(self, "gitlab"))

    @builtins.property
    @jsii.member(jsii_name="healthCheck")
    def health_check(self) -> AppSpecServiceHealthCheckOutputReference:
        return typing.cast(AppSpecServiceHealthCheckOutputReference, jsii.get(self, "healthCheck"))

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> AppSpecServiceImageOutputReference:
        return typing.cast(AppSpecServiceImageOutputReference, jsii.get(self, "image"))

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecServiceLogDestinationList:
        return typing.cast(AppSpecServiceLogDestinationList, jsii.get(self, "logDestination"))

    @builtins.property
    @jsii.member(jsii_name="routes")
    def routes(self) -> "AppSpecServiceRoutesList":
        return typing.cast("AppSpecServiceRoutesList", jsii.get(self, "routes"))

    @builtins.property
    @jsii.member(jsii_name="termination")
    def termination(self) -> "AppSpecServiceTerminationOutputReference":
        return typing.cast("AppSpecServiceTerminationOutputReference", jsii.get(self, "termination"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]], jsii.get(self, "alertInput"))

    @builtins.property
    @jsii.member(jsii_name="autoscalingInput")
    def autoscaling_input(self) -> typing.Optional[AppSpecServiceAutoscaling]:
        return typing.cast(typing.Optional[AppSpecServiceAutoscaling], jsii.get(self, "autoscalingInput"))

    @builtins.property
    @jsii.member(jsii_name="bitbucketInput")
    def bitbucket_input(self) -> typing.Optional[AppSpecServiceBitbucket]:
        return typing.cast(typing.Optional[AppSpecServiceBitbucket], jsii.get(self, "bitbucketInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "buildCommandInput"))

    @builtins.property
    @jsii.member(jsii_name="corsInput")
    def cors_input(self) -> typing.Optional[AppSpecServiceCors]:
        return typing.cast(typing.Optional[AppSpecServiceCors], jsii.get(self, "corsInput"))

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput"))

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]], jsii.get(self, "envInput"))

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput"))

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecServiceGithub]:
        return typing.cast(typing.Optional[AppSpecServiceGithub], jsii.get(self, "githubInput"))

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecServiceGit]:
        return typing.cast(typing.Optional[AppSpecServiceGit], jsii.get(self, "gitInput"))

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecServiceGitlab]:
        return typing.cast(typing.Optional[AppSpecServiceGitlab], jsii.get(self, "gitlabInput"))

    @builtins.property
    @jsii.member(jsii_name="healthCheckInput")
    def health_check_input(self) -> typing.Optional[AppSpecServiceHealthCheck]:
        return typing.cast(typing.Optional[AppSpecServiceHealthCheck], jsii.get(self, "healthCheckInput"))

    @builtins.property
    @jsii.member(jsii_name="httpPortInput")
    def http_port_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "httpPortInput"))

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[AppSpecServiceImage]:
        return typing.cast(typing.Optional[AppSpecServiceImage], jsii.get(self, "imageInput"))

    @builtins.property
    @jsii.member(jsii_name="instanceCountInput")
    def instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "instanceCountInput"))

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlugInput")
    def instance_size_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceSizeSlugInput"))

    @builtins.property
    @jsii.member(jsii_name="internalPortsInput")
    def internal_ports_input(self) -> typing.Optional[typing.List[jsii.Number]]:
        return typing.cast(typing.Optional[typing.List[jsii.Number]], jsii.get(self, "internalPortsInput"))

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]]], jsii.get(self, "logDestinationInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="routesInput")
    def routes_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecServiceRoutes"]]], jsii.get(self, "routesInput"))

    @builtins.property
    @jsii.member(jsii_name="runCommandInput")
    def run_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "runCommandInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDirInput"))

    @builtins.property
    @jsii.member(jsii_name="terminationInput")
    def termination_input(self) -> typing.Optional["AppSpecServiceTermination"]:
        return typing.cast(typing.Optional["AppSpecServiceTermination"], jsii.get(self, "terminationInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a22022548574b09cabca7b53ff2382e2ce8ca7c9aeac82929b724c8706559a03)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "buildCommand", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be21ae0329568ef97c7948e15592c794b124ea85024f2d5ce68e6072f4d0138d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dockerfilePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd243b6c4ebeda316bfe2b97c54799aa90990f9b82bc9b0fb578de973fbf94e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "environmentSlug", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="httpPort")
    def http_port(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "httpPort"))

    @http_port.setter
    def http_port(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2fecd46ea4ece4b65b850d04a42efaf54dd99cae5aca5681222f3c1feac9526)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "httpPort", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="instanceCount")
    def instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "instanceCount"))

    @instance_count.setter
    def instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bafe4b9882c0f91e5f564d1a4f57f652bcc13ac25ea9766236493df39fb0ef3a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlug")
    def instance_size_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "instanceSizeSlug"))

    @instance_size_slug.setter
    def instance_size_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__549847ad9240922f62d1087459c2d70c5e13d620febbd5751a663d7e5afcac01)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceSizeSlug", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalPorts")
    def internal_ports(self) -> typing.List[jsii.Number]:
        return typing.cast(typing.List[jsii.Number], jsii.get(self, "internalPorts"))

    @internal_ports.setter
    def internal_ports(self, value: typing.List[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f89a581c4a4a6334058bf7f39e59220c716c6a6ea89938770e5105ccafaab1aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalPorts", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1283900c8e2f3650701c6b219075a8da2965b7c26c98aff2270cec1911fa080e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runCommand"))

    @run_command.setter
    def run_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5658493ab295515daacb2d7832ed966506a4752b93c0048bccfa40c4d0bd73e7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "runCommand", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__077500d09e4bd85dcf27f14afc389ab9b4ed1c5a6dec10f9f58e8161695223d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDir", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b31251e1c68ef137e911f2c53451afdcede567d7dab77e466bad94f93269b795)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceRoutes",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "preserve_path_prefix": "preservePathPrefix"},
)
class AppSpecServiceRoutes:
    def __init__(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param path: Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        :param preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64db7eef5fe9f8912e7540b1905b641473a17d6620a7b2d0b3157e7cf7d7bc7f)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument preserve_path_prefix", value=preserve_path_prefix, expected_type=type_hints["preserve_path_prefix"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path
        if preserve_path_prefix is not None:
            self._values["preserve_path_prefix"] = preserve_path_prefix

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path specifies an route by HTTP path prefix.

        Paths must start with / and must be unique within the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_path_prefix(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''An optional flag to preserve the path that is forwarded to the backend service.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        '''
        result = self._values.get("preserve_path_prefix")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceRoutes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceRoutesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceRoutesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12bc039b16370d4fb2e2d84924e284b3304c6061f0984e22c10028a2c8d6ec48)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecServiceRoutesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5982bde928cd7b9be589c713c33bd9ef111cbc759f3944dd94138bee680d8fc)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecServiceRoutesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42b34f0941d6b4a19cc2b1a9b1369700b1334a7fab210ac212c516bca7ba4ba6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3dff9220ad75b5d449ef9b649d223884bbe237e7cea45e68d9275fc774f3faf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__036535286d6d6eee484ae8aa495d24e91342b3a882621cb2fadc1155f08d0f85)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df9573640dcc848c4cb06db3d6ef6d67c494608dfe8edd77002eb7396261afd2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecServiceRoutesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceRoutesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03f86950289200649e2b9f76162a3e7831a363d359e1cc71205335d85e39c4de)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPreservePathPrefix")
    def reset_preserve_path_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreservePathPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefixInput")
    def preserve_path_prefix_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "preservePathPrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45fea86e78e8bfd0fd350b264e4b0843bd779258cbc8c54f1fcfde533b3676be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "path", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefix")
    def preserve_path_prefix(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "preservePathPrefix"))

    @preserve_path_prefix.setter
    def preserve_path_prefix(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2efd4968610b0da3704214906464f4adb0c3bb42738d69cdb9e033a2896e34e8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preservePathPrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0e32ef60d22349a36a948dad7bbb3d0bc860ca5fd267ab99d951f39144a4508)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceTermination",
    jsii_struct_bases=[],
    name_mapping={
        "drain_seconds": "drainSeconds",
        "grace_period_seconds": "gracePeriodSeconds",
    },
)
class AppSpecServiceTermination:
    def __init__(
        self,
        *,
        drain_seconds: typing.Optional[jsii.Number] = None,
        grace_period_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param drain_seconds: The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#drain_seconds App#drain_seconds}
        :param grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__636713d0315d2fbfc70225f167516f0be663be910fbab2a53a19b5886fb98212)
            check_type(argname="argument drain_seconds", value=drain_seconds, expected_type=type_hints["drain_seconds"])
            check_type(argname="argument grace_period_seconds", value=grace_period_seconds, expected_type=type_hints["grace_period_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if drain_seconds is not None:
            self._values["drain_seconds"] = drain_seconds
        if grace_period_seconds is not None:
            self._values["grace_period_seconds"] = grace_period_seconds

    @builtins.property
    def drain_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal.

        Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#drain_seconds App#drain_seconds}
        '''
        result = self._values.get("drain_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def grace_period_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown.

        Default: 120, Minimum 1, Maximum 600.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        result = self._values.get("grace_period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecServiceTermination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecServiceTerminationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecServiceTerminationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad5c51f0ea650bc4255646ef612885f69baee104c4d9d95e47f4fdcfb1e68e99)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDrainSeconds")
    def reset_drain_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDrainSeconds", []))

    @jsii.member(jsii_name="resetGracePeriodSeconds")
    def reset_grace_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGracePeriodSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="drainSecondsInput")
    def drain_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "drainSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="gracePeriodSecondsInput")
    def grace_period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "gracePeriodSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="drainSeconds")
    def drain_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "drainSeconds"))

    @drain_seconds.setter
    def drain_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1f50e0d38ea88871be886f6d2bffce0cff4a4b5799dbdebcc12145eca9e3858)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "drainSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="gracePeriodSeconds")
    def grace_period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "gracePeriodSeconds"))

    @grace_period_seconds.setter
    def grace_period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__753741d3d758decbc7c0898e1b92da5ac31b4bb896605306c17c5ec84e0a8281)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gracePeriodSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecServiceTermination]:
        return typing.cast(typing.Optional[AppSpecServiceTermination], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecServiceTermination]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe09068b1b8890b603ee4f3b912c6184860d7a6327eec6bb4aea7858994c3343)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSite",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "bitbucket": "bitbucket",
        "build_command": "buildCommand",
        "catchall_document": "catchallDocument",
        "cors": "cors",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "error_document": "errorDocument",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "index_document": "indexDocument",
        "output_dir": "outputDir",
        "routes": "routes",
        "source_dir": "sourceDir",
    },
)
class AppSpecStaticSite:
    def __init__(
        self,
        *,
        name: builtins.str,
        bitbucket: typing.Optional[typing.Union["AppSpecStaticSiteBitbucket", typing.Dict[builtins.str, typing.Any]]] = None,
        build_command: typing.Optional[builtins.str] = None,
        catchall_document: typing.Optional[builtins.str] = None,
        cors: typing.Optional[typing.Union["AppSpecStaticSiteCors", typing.Dict[builtins.str, typing.Any]]] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecStaticSiteEnv", typing.Dict[builtins.str, typing.Any]]]]] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        error_document: typing.Optional[builtins.str] = None,
        git: typing.Optional[typing.Union["AppSpecStaticSiteGit", typing.Dict[builtins.str, typing.Any]]] = None,
        github: typing.Optional[typing.Union["AppSpecStaticSiteGithub", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["AppSpecStaticSiteGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        index_document: typing.Optional[builtins.str] = None,
        output_dir: typing.Optional[builtins.str] = None,
        routes: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecStaticSiteRoutes", typing.Dict[builtins.str, typing.Any]]]]] = None,
        source_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param bitbucket: bitbucket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        :param catchall_document: The name of the document to use as the fallback for any requests to documents that are not found when serving this static site. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#catchall_document App#catchall_document}
        :param cors: cors block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        :param error_document: The name of the error document to use when serving this static site. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#error_document App#error_document}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        :param index_document: The name of the index document to use when serving this static site. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_document App#index_document}
        :param output_dir: An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: ``_static``, ``dist``, ``public``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#output_dir App#output_dir}
        :param routes: routes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#routes App#routes}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        '''
        if isinstance(bitbucket, dict):
            bitbucket = AppSpecStaticSiteBitbucket(**bitbucket)
        if isinstance(cors, dict):
            cors = AppSpecStaticSiteCors(**cors)
        if isinstance(git, dict):
            git = AppSpecStaticSiteGit(**git)
        if isinstance(github, dict):
            github = AppSpecStaticSiteGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecStaticSiteGitlab(**gitlab)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5551bf6d6d5ce7022a35a629879384ff9cf9d5f9f56e0af2b1a0798c2f58cf73)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument bitbucket", value=bitbucket, expected_type=type_hints["bitbucket"])
            check_type(argname="argument build_command", value=build_command, expected_type=type_hints["build_command"])
            check_type(argname="argument catchall_document", value=catchall_document, expected_type=type_hints["catchall_document"])
            check_type(argname="argument cors", value=cors, expected_type=type_hints["cors"])
            check_type(argname="argument dockerfile_path", value=dockerfile_path, expected_type=type_hints["dockerfile_path"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument environment_slug", value=environment_slug, expected_type=type_hints["environment_slug"])
            check_type(argname="argument error_document", value=error_document, expected_type=type_hints["error_document"])
            check_type(argname="argument git", value=git, expected_type=type_hints["git"])
            check_type(argname="argument github", value=github, expected_type=type_hints["github"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument index_document", value=index_document, expected_type=type_hints["index_document"])
            check_type(argname="argument output_dir", value=output_dir, expected_type=type_hints["output_dir"])
            check_type(argname="argument routes", value=routes, expected_type=type_hints["routes"])
            check_type(argname="argument source_dir", value=source_dir, expected_type=type_hints["source_dir"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if bitbucket is not None:
            self._values["bitbucket"] = bitbucket
        if build_command is not None:
            self._values["build_command"] = build_command
        if catchall_document is not None:
            self._values["catchall_document"] = catchall_document
        if cors is not None:
            self._values["cors"] = cors
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if error_document is not None:
            self._values["error_document"] = error_document
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if index_document is not None:
            self._values["index_document"] = index_document
        if output_dir is not None:
            self._values["output_dir"] = output_dir
        if routes is not None:
            self._values["routes"] = routes
        if source_dir is not None:
            self._values["source_dir"] = source_dir

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def bitbucket(self) -> typing.Optional["AppSpecStaticSiteBitbucket"]:
        '''bitbucket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        '''
        result = self._values.get("bitbucket")
        return typing.cast(typing.Optional["AppSpecStaticSiteBitbucket"], result)

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        '''An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        '''
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def catchall_document(self) -> typing.Optional[builtins.str]:
        '''The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#catchall_document App#catchall_document}
        '''
        result = self._values.get("catchall_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cors(self) -> typing.Optional["AppSpecStaticSiteCors"]:
        '''cors block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cors App#cors}
        '''
        result = self._values.get("cors")
        return typing.cast(typing.Optional["AppSpecStaticSiteCors"], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        '''The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        '''
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteEnv"]]]:
        '''env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteEnv"]]], result)

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        '''An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        '''
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def error_document(self) -> typing.Optional[builtins.str]:
        '''The name of the error document to use when serving this static site.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#error_document App#error_document}
        '''
        result = self._values.get("error_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecStaticSiteGit"]:
        '''git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        '''
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecStaticSiteGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecStaticSiteGithub"]:
        '''github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        '''
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecStaticSiteGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecStaticSiteGitlab"]:
        '''gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecStaticSiteGitlab"], result)

    @builtins.property
    def index_document(self) -> typing.Optional[builtins.str]:
        '''The name of the index document to use when serving this static site.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_document App#index_document}
        '''
        result = self._values.get("index_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_dir(self) -> typing.Optional[builtins.str]:
        '''An optional path to where the built assets will be located, relative to the build context.

        If not set, App Platform will automatically scan for these directory names: ``_static``, ``dist``, ``public``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#output_dir App#output_dir}
        '''
        result = self._values.get("output_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def routes(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]]]:
        '''routes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#routes App#routes}
        '''
        result = self._values.get("routes")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]]], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        '''An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        '''
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSite(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteBitbucket",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecStaticSiteBitbucket:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__944ba0a525de008439090ebe0170dbf1ac048a1300cdeee8bd86e31ebe4aa95d)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteBitbucket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteBitbucketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteBitbucketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5872c251ea7f422d6ad5cfd194b3363928664f3d10e45a9db91a9a5ad5e0826f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ee592dbd804fde382d61b1b1d5ab4d40bffbb50ec658cc2284ec83e5c293ed4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89b6164db7e12896f24d16300d505dbc5a3f28b1b515426ea29e3d32cb4187eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e0b8c5cdb4f76b2a8b9ba295776d140dfea005fcde2a4f38ad0f4830fc509b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteBitbucket]:
        return typing.cast(typing.Optional[AppSpecStaticSiteBitbucket], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecStaticSiteBitbucket],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a32041b270ca8e3236d20e73a600e88712708aac4576ed90442e15f5f6b0dd6e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteCors",
    jsii_struct_bases=[],
    name_mapping={
        "allow_credentials": "allowCredentials",
        "allow_headers": "allowHeaders",
        "allow_methods": "allowMethods",
        "allow_origins": "allowOrigins",
        "expose_headers": "exposeHeaders",
        "max_age": "maxAge",
    },
)
class AppSpecStaticSiteCors:
    def __init__(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union["AppSpecStaticSiteCorsAllowOrigins", typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        if isinstance(allow_origins, dict):
            allow_origins = AppSpecStaticSiteCorsAllowOrigins(**allow_origins)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2c435c2bc38ec7882c884c873e8320d2de481ed96d542f74bb62d3a00a838f3)
            check_type(argname="argument allow_credentials", value=allow_credentials, expected_type=type_hints["allow_credentials"])
            check_type(argname="argument allow_headers", value=allow_headers, expected_type=type_hints["allow_headers"])
            check_type(argname="argument allow_methods", value=allow_methods, expected_type=type_hints["allow_methods"])
            check_type(argname="argument allow_origins", value=allow_origins, expected_type=type_hints["allow_origins"])
            check_type(argname="argument expose_headers", value=expose_headers, expected_type=type_hints["expose_headers"])
            check_type(argname="argument max_age", value=max_age, expected_type=type_hints["max_age"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_credentials is not None:
            self._values["allow_credentials"] = allow_credentials
        if allow_headers is not None:
            self._values["allow_headers"] = allow_headers
        if allow_methods is not None:
            self._values["allow_methods"] = allow_methods
        if allow_origins is not None:
            self._values["allow_origins"] = allow_origins
        if expose_headers is not None:
            self._values["expose_headers"] = expose_headers
        if max_age is not None:
            self._values["max_age"] = max_age

    @builtins.property
    def allow_credentials(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``.

        This configures the Access-Control-Allow-Credentials header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        '''
        result = self._values.get("allow_credentials")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def allow_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        '''
        result = self._values.get("allow_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_methods(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        '''
        result = self._values.get("allow_methods")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def allow_origins(self) -> typing.Optional["AppSpecStaticSiteCorsAllowOrigins"]:
        '''allow_origins block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        '''
        result = self._values.get("allow_origins")
        return typing.cast(typing.Optional["AppSpecStaticSiteCorsAllowOrigins"], result)

    @builtins.property
    def expose_headers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        '''
        result = self._values.get("expose_headers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def max_age(self) -> typing.Optional[builtins.str]:
        '''An optional duration specifying how long browsers can cache the results of a preflight request.

        This configures the Access-Control-Max-Age header. Example: ``5h30m``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        result = self._values.get("max_age")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteCors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteCorsAllowOrigins",
    jsii_struct_bases=[],
    name_mapping={"exact": "exact", "prefix": "prefix", "regex": "regex"},
)
class AppSpecStaticSiteCorsAllowOrigins:
    def __init__(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea24cc1f815e13d7f696ae2393ad71eb998aa65b0f2dcf8e7a7efa7b91364c7d)
            check_type(argname="argument exact", value=exact, expected_type=type_hints["exact"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exact is not None:
            self._values["exact"] = exact
        if prefix is not None:
            self._values["prefix"] = prefix
        if regex is not None:
            self._values["regex"] = regex

    @builtins.property
    def exact(self) -> typing.Optional[builtins.str]:
        '''Exact string match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        '''
        result = self._values.get("exact")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''Prefix-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def regex(self) -> typing.Optional[builtins.str]:
        '''RE2 style regex-based match.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        result = self._values.get("regex")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteCorsAllowOrigins(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteCorsAllowOriginsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteCorsAllowOriginsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d245315a1bec694d20208a281f9cda80fffa80c394c25858356bf7e2630b6dd2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetExact")
    def reset_exact(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExact", []))

    @jsii.member(jsii_name="resetPrefix")
    def reset_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrefix", []))

    @jsii.member(jsii_name="resetRegex")
    def reset_regex(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegex", []))

    @builtins.property
    @jsii.member(jsii_name="exactInput")
    def exact_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exactInput"))

    @builtins.property
    @jsii.member(jsii_name="prefixInput")
    def prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefixInput"))

    @builtins.property
    @jsii.member(jsii_name="regexInput")
    def regex_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexInput"))

    @builtins.property
    @jsii.member(jsii_name="exact")
    def exact(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exact"))

    @exact.setter
    def exact(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96c8f0ddad503aa99bef127165ca3f64c8a51cab11732b4f08e81de96a02d6aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exact", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="prefix")
    def prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prefix"))

    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6a67a9cd7bef88c8c3725990b40de634a1c058ce2b20b9dc236c2bbe9c9160d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "prefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="regex")
    def regex(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "regex"))

    @regex.setter
    def regex(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f088dc5ee29077898a58de2adcb94c4a3e27e450952780931f3e36167fc845c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "regex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecStaticSiteCorsAllowOrigins], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecStaticSiteCorsAllowOrigins],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da65095e2126e1af5d96908bc4089c6123ea146c356d074796dec56c068ea5a7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecStaticSiteCorsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteCorsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ea2e3b7c25cd5d5a2f8eb067564838ae3e3864d15cd5edd07a43253e2948f72)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAllowOrigins")
    def put_allow_origins(
        self,
        *,
        exact: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        regex: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param exact: Exact string match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#exact App#exact}
        :param prefix: Prefix-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#prefix App#prefix}
        :param regex: RE2 style regex-based match. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#regex App#regex}
        '''
        value = AppSpecStaticSiteCorsAllowOrigins(
            exact=exact, prefix=prefix, regex=regex
        )

        return typing.cast(None, jsii.invoke(self, "putAllowOrigins", [value]))

    @jsii.member(jsii_name="resetAllowCredentials")
    def reset_allow_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowCredentials", []))

    @jsii.member(jsii_name="resetAllowHeaders")
    def reset_allow_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowHeaders", []))

    @jsii.member(jsii_name="resetAllowMethods")
    def reset_allow_methods(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowMethods", []))

    @jsii.member(jsii_name="resetAllowOrigins")
    def reset_allow_origins(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowOrigins", []))

    @jsii.member(jsii_name="resetExposeHeaders")
    def reset_expose_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExposeHeaders", []))

    @jsii.member(jsii_name="resetMaxAge")
    def reset_max_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxAge", []))

    @builtins.property
    @jsii.member(jsii_name="allowOrigins")
    def allow_origins(self) -> AppSpecStaticSiteCorsAllowOriginsOutputReference:
        return typing.cast(AppSpecStaticSiteCorsAllowOriginsOutputReference, jsii.get(self, "allowOrigins"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentialsInput")
    def allow_credentials_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "allowCredentialsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowHeadersInput")
    def allow_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="allowMethodsInput")
    def allow_methods_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowMethodsInput"))

    @builtins.property
    @jsii.member(jsii_name="allowOriginsInput")
    def allow_origins_input(self) -> typing.Optional[AppSpecStaticSiteCorsAllowOrigins]:
        return typing.cast(typing.Optional[AppSpecStaticSiteCorsAllowOrigins], jsii.get(self, "allowOriginsInput"))

    @builtins.property
    @jsii.member(jsii_name="exposeHeadersInput")
    def expose_headers_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "exposeHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="maxAgeInput")
    def max_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="allowCredentials")
    def allow_credentials(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "allowCredentials"))

    @allow_credentials.setter
    def allow_credentials(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7045fd4b3494d283cdfa9138cd560c0a215487a5841c19fed56af46b8ab27c31)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowCredentials", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowHeaders")
    def allow_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowHeaders"))

    @allow_headers.setter
    def allow_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5dcd312027caf3982da9c5b57bc9e2fd2ce5b3c2d6e0514b1437d26a0d3f526)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="allowMethods")
    def allow_methods(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowMethods"))

    @allow_methods.setter
    def allow_methods(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bb2c8f7097b240d0c026e7bbeddfa500bb5040d2a5c7713bf795bd46e528c7b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowMethods", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="exposeHeaders")
    def expose_headers(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "exposeHeaders"))

    @expose_headers.setter
    def expose_headers(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12c4dcab8af7427da5f800af2d220692332c207889f45b239c7a324d5f89a191)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exposeHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxAge")
    def max_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxAge"))

    @max_age.setter
    def max_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f16e2eab11651f6fba7df613f825e04db7fed2d836b065a01ab38e82035dd00)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteCors]:
        return typing.cast(typing.Optional[AppSpecStaticSiteCors], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteCors]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f33bf47babd05d6f713d9785878457c136bd7a8766f6bb98d32d12a6b0a8fb8c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecStaticSiteEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f45000e7a35ce6e8d139a667ac15f2f56bc0020f55176006d3fb006bf38513b0)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        '''The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af2a4303a7736cb67b4f4228e2df9442f60cd80e2c9971d25e917f1ed0a5133f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecStaticSiteEnvOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf5c06d860ddfcf2d7e36de7f7b0e65e23d4058a6783802060725d2745671c47)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecStaticSiteEnvOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b1c179e6282dcec6ea3ce64284ae94939247954eb28f678662f70740b65d742)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69ba5bab19fc628584e2163944c7ac7a7f4fd2236c9c27aed2f7b88d4a28bbf9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__070d78774e25f7f045a626383bc2577e9676356ede9dc3918bef6668e44640d1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3b34a8c542ef9f52042255f2fa004eedea65f0aab979d1943f0f27569aacc61)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecStaticSiteEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04ed76ac66f72d48df19437e0a0d95f1619fae4686162dc83cb5be5dbb4c8e27)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f024651eebd14dd1640b1a9f650bd78dbeef29e46610f4e9e1f5ea7087cdb387)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26460338b515bade8258741960a6bc7064766b993615a01619928aed8fb9c0e8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aff978eb8403c59d2472aa17e1a77f0b4032f2925838321033f614af9615e02c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7932556afa563ab839eb79692d115ede4260485020304c02b176ba6a6672ce4d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e73cef212292755b2364e5699ba7f1333adac04d85ea64bd37ff06499dbeb08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecStaticSiteGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f0c19f8040084d5f2463df575e378bd476e88a6a802f79715502e545888ef9f)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument repo_clone_url", value=repo_clone_url, expected_type=type_hints["repo_clone_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        '''The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b183eee85d1cd1c3c6f53cdb827dbdb7da335f20ad2da510864e992db1cf8289)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a64f311ca22f77e0cb8e896ba7487cc71c02b4e79a525b6968d515b7eca6353)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__138aae0b67eced9d0a6c61045600eff7948c0f181fef741717836d0048eb2f2d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repoCloneUrl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteGit]:
        return typing.cast(typing.Optional[AppSpecStaticSiteGit], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67ce6dfc762229b9da172952b8e160f85fb5cb5d0626a60908f6dd8fb2352176)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecStaticSiteGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f360f7167e0493bf054353beec9c25c7861a353545df29731ac0ed6ee25fe60)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c551ecdc66db01a4f1b8eae075b0fe2d83ba76cd60e02ebad35f8d1e4741044a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45a648045b24886faf8e2630149956f89b31b325764ac4519b4892302cd7cae5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f8674d8532321ccce9fd670d5c357dacd61f991676896fb506741453db1b01a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59e219a785a6420c8ccf9fa87ae2332f53dcb6a42fae0ccae0a2c92ad49b01a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteGithub]:
        return typing.cast(typing.Optional[AppSpecStaticSiteGithub], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__262f9c9aa577fd3844608728738694260deb151343a9dd761f3c8a0097e51826)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecStaticSiteGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2cb2cab7156878640c59de80c896ff6ace68228d6147175b8c3bf248588fcdf)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1bad7b75b7f423e7400b2f7bdd55a3c1e6a721ede308169834a65abb5bc5db7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52141c456f03f0f429f9bbbb253d1f157606dc99fecb1bd4c63b8cc3299c1662)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a687df483936e5f9d47a8a7c1119951ea9b9721239ffd4fae9012c86ea408ea0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0e7b0ae29f5440fc048571369875aa6f476efc957f2a8fc35e12032e3ac47e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecStaticSiteGitlab]:
        return typing.cast(typing.Optional[AppSpecStaticSiteGitlab], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecStaticSiteGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c86318c4e268de2549dbd0cf810c1039913846833b96dc5dd47e0b40709dbd39)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecStaticSiteList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a9458ac06fb58d06853571911cb5d1085f61b3c218c84c3bfdf4a65267805d8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecStaticSiteOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f0c986033fcc2ec1230981a69c011f277a611a7579d8e4e37ee0b9c9948c669)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecStaticSiteOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0cfb21c39bf23b8367a3f9428aa0c5ba2429b0190883fbf71b3d5650c4b93984)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__470e8aedd8ea67969401565048420f4ca0242a380b9f4a77c26fb6faf411f7f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__274142c06b5dc0b894c58d362c12daa2d5bdff26627109742a3ac389f9026677)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11c7e8003b6d0a45b81b4da51115592bebc6ec0eaf39cd83b2f4b3a108c3a160)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecStaticSiteOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da734de3d059bf11215a7155c0710a98a220a3a1527d170173d5941e01b5245a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putBitbucket")
    def put_bitbucket(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecStaticSiteBitbucket(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putBitbucket", [value]))

    @jsii.member(jsii_name="putCors")
    def put_cors(
        self,
        *,
        allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
        allow_origins: typing.Optional[typing.Union[AppSpecStaticSiteCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
        expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
        max_age: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is ``include``. This configures the Access-Control-Allow-Credentials header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_credentials App#allow_credentials}
        :param allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_headers App#allow_headers}
        :param allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_methods App#allow_methods}
        :param allow_origins: allow_origins block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#allow_origins App#allow_origins}
        :param expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#expose_headers App#expose_headers}
        :param max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: ``5h30m``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_age App#max_age}
        '''
        value = AppSpecStaticSiteCors(
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )

        return typing.cast(None, jsii.invoke(self, "putCors", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecStaticSiteEnv, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f90ed4cee0034e8739d0d8e107f4dec4620f56cfa1cef0fd611e98c7eb456215)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        value = AppSpecStaticSiteGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecStaticSiteGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecStaticSiteGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putRoutes")
    def put_routes(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecStaticSiteRoutes", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__928af6c90848a5ada99b5f5a7c4a82b40dae2533dfef398572b2436419c39b49)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRoutes", [value]))

    @jsii.member(jsii_name="resetBitbucket")
    def reset_bitbucket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBitbucket", []))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetCatchallDocument")
    def reset_catchall_document(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCatchallDocument", []))

    @jsii.member(jsii_name="resetCors")
    def reset_cors(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCors", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetErrorDocument")
    def reset_error_document(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetErrorDocument", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetIndexDocument")
    def reset_index_document(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIndexDocument", []))

    @jsii.member(jsii_name="resetOutputDir")
    def reset_output_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOutputDir", []))

    @jsii.member(jsii_name="resetRoutes")
    def reset_routes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoutes", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @builtins.property
    @jsii.member(jsii_name="bitbucket")
    def bitbucket(self) -> AppSpecStaticSiteBitbucketOutputReference:
        return typing.cast(AppSpecStaticSiteBitbucketOutputReference, jsii.get(self, "bitbucket"))

    @builtins.property
    @jsii.member(jsii_name="cors")
    def cors(self) -> AppSpecStaticSiteCorsOutputReference:
        return typing.cast(AppSpecStaticSiteCorsOutputReference, jsii.get(self, "cors"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecStaticSiteEnvList:
        return typing.cast(AppSpecStaticSiteEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecStaticSiteGitOutputReference:
        return typing.cast(AppSpecStaticSiteGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecStaticSiteGithubOutputReference:
        return typing.cast(AppSpecStaticSiteGithubOutputReference, jsii.get(self, "github"))

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecStaticSiteGitlabOutputReference:
        return typing.cast(AppSpecStaticSiteGitlabOutputReference, jsii.get(self, "gitlab"))

    @builtins.property
    @jsii.member(jsii_name="routes")
    def routes(self) -> "AppSpecStaticSiteRoutesList":
        return typing.cast("AppSpecStaticSiteRoutesList", jsii.get(self, "routes"))

    @builtins.property
    @jsii.member(jsii_name="bitbucketInput")
    def bitbucket_input(self) -> typing.Optional[AppSpecStaticSiteBitbucket]:
        return typing.cast(typing.Optional[AppSpecStaticSiteBitbucket], jsii.get(self, "bitbucketInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "buildCommandInput"))

    @builtins.property
    @jsii.member(jsii_name="catchallDocumentInput")
    def catchall_document_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "catchallDocumentInput"))

    @builtins.property
    @jsii.member(jsii_name="corsInput")
    def cors_input(self) -> typing.Optional[AppSpecStaticSiteCors]:
        return typing.cast(typing.Optional[AppSpecStaticSiteCors], jsii.get(self, "corsInput"))

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput"))

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]], jsii.get(self, "envInput"))

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput"))

    @builtins.property
    @jsii.member(jsii_name="errorDocumentInput")
    def error_document_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "errorDocumentInput"))

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecStaticSiteGithub]:
        return typing.cast(typing.Optional[AppSpecStaticSiteGithub], jsii.get(self, "githubInput"))

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecStaticSiteGit]:
        return typing.cast(typing.Optional[AppSpecStaticSiteGit], jsii.get(self, "gitInput"))

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecStaticSiteGitlab]:
        return typing.cast(typing.Optional[AppSpecStaticSiteGitlab], jsii.get(self, "gitlabInput"))

    @builtins.property
    @jsii.member(jsii_name="indexDocumentInput")
    def index_document_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "indexDocumentInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="outputDirInput")
    def output_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "outputDirInput"))

    @builtins.property
    @jsii.member(jsii_name="routesInput")
    def routes_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecStaticSiteRoutes"]]], jsii.get(self, "routesInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDirInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80ad1ff221dac9d398380575148dca7d93f2648ab60bafa42ad64400ce6c3226)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "buildCommand", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="catchallDocument")
    def catchall_document(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "catchallDocument"))

    @catchall_document.setter
    def catchall_document(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1617ae633d14d46537e10a723f04b59c9beb087a1b10a94f515f7239f233241e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "catchallDocument", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2264e1ee92b34580706baffe288c78b1be576a2c29f46ed9e5c97c6d371bf8f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dockerfilePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d60a835f9087ab51b76204d357d6b665905469f97749d3ddd7c74c11f473471)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "environmentSlug", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="errorDocument")
    def error_document(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "errorDocument"))

    @error_document.setter
    def error_document(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b09b9909039122c4339dbcd9444d9125937c0f464d91e847aa7fde4b74eeff7c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "errorDocument", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="indexDocument")
    def index_document(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "indexDocument"))

    @index_document.setter
    def index_document(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1dc1a83249c3ddc70f2f1c43315810840f6f4348d4839e4b344e106a6354c476)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "indexDocument", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3301161621a8dfe114066a7a9e9b28d1f7a25b3ac818058d4571d2a6e669f4c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="outputDir")
    def output_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "outputDir"))

    @output_dir.setter
    def output_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be9739c40dc58c6ceb10500b0ffa4b9bd4f92d814c633905e1d47ce349ce08e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "outputDir", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8c8eaaebe921f186e6955b3558614f34f60a53fd90d285f6357f488a4fcf178)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDir", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e953cb972dc771773b70ef906d667937a36fb9f78804b6706c96eb08a4c9348a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteRoutes",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "preserve_path_prefix": "preservePathPrefix"},
)
class AppSpecStaticSiteRoutes:
    def __init__(
        self,
        *,
        path: typing.Optional[builtins.str] = None,
        preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param path: Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        :param preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33c26ecb74dd361707f483f5b2e547f46c542d733e86a63316cee58fa919f653)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument preserve_path_prefix", value=preserve_path_prefix, expected_type=type_hints["preserve_path_prefix"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if path is not None:
            self._values["path"] = path
        if preserve_path_prefix is not None:
            self._values["preserve_path_prefix"] = preserve_path_prefix

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path specifies an route by HTTP path prefix.

        Paths must start with / and must be unique within the app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#path App#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_path_prefix(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''An optional flag to preserve the path that is forwarded to the backend service.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#preserve_path_prefix App#preserve_path_prefix}
        '''
        result = self._values.get("preserve_path_prefix")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecStaticSiteRoutes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecStaticSiteRoutesList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteRoutesList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__105d9af8e5ef0350d15135c60fc2acf343fa9c0f1a559c8cc2a88e5eb57f4091)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecStaticSiteRoutesOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0faf44e4eb81eaa387e86d2da9f6b608616109fe9a6bc92895b3d5c718a8aa91)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecStaticSiteRoutesOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1cceb97685b49818719184b805a4f7b443bfa70207383dacf8d95a5e24a58d61)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2fd756ac8d40003a1715fd44d989a324749730d3007b6ccb399bf80068f7162c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ef31e80d13de1e4b91310e5cc4656da39710eebb9512a3f27accd069df4a475)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff5833b24dff9a20ceee73ef0d952ce905af3f77e6e9236c057f71a32a2087f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecStaticSiteRoutesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecStaticSiteRoutesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23555342944237d869aaf29ca06d3ed30659d42e52966e7f300f034e4e2811ab)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetPath")
    def reset_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPath", []))

    @jsii.member(jsii_name="resetPreservePathPrefix")
    def reset_preserve_path_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreservePathPrefix", []))

    @builtins.property
    @jsii.member(jsii_name="pathInput")
    def path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pathInput"))

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefixInput")
    def preserve_path_prefix_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "preservePathPrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "path"))

    @path.setter
    def path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f74866adb4e77dc12f82f3611ab27cf47e69597b795cac7a952cf97565e95f08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "path", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="preservePathPrefix")
    def preserve_path_prefix(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "preservePathPrefix"))

    @preserve_path_prefix.setter
    def preserve_path_prefix(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2a4b871e4a6b63b260b742c0a9602d70c4211b153bacd2807814b99c258b460)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preservePathPrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24a9543cf24c9110eedbd4e191d1d651be72f42c6f599b0c26417da02c46e186)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecVpc",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class AppSpecVpc:
    def __init__(self, *, id: builtins.str) -> None:
        '''
        :param id: The ID of the VPC. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#id App#id} Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df239cf271283d9b54eec6a4d76c8da7becd54971c1266449009f5415fbacd63)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''The ID of the VPC.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#id App#id}

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecVpc(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecVpcList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecVpcList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16b57a4060ff4ee91d85653e44263dcccbb8e09cae27622b10d5a6fb7f112a25)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecVpcOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38f1a44c80a824b4841148cbbcae47494ab9f7f1756ccb4d8956b04493c7c789)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecVpcOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b352033b222f3d4593be3225501af36422908befb529abdfcbde0ba56f0b84b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2020a7e49393c175cae70374ed5a40242d094b595fe86bfc070fc9d763e71b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abc133f1e0b7e51162a228aa6a380821c12ca5af2c184173dbddd8a8bd09492f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecVpc]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecVpc]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecVpc]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5319262490e384b15ef3b1644fd3be3cba89d70fb277c83783f1ea83c18fe0ef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecVpcOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecVpcOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8d9a506a498950d608249d8af3b5e8e14b78f7b7fee75d84dd7c4bf3ffb8279)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__621ac5ba4a2b2a90c69708eda36598e76b302b5e4b1871a427f5d985e1c2c825)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecVpc]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecVpc]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecVpc]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b754f78574e0b5358f46a4643d60fc85dc519d9303a7539075548fe8e53679c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorker",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alert": "alert",
        "autoscaling": "autoscaling",
        "bitbucket": "bitbucket",
        "build_command": "buildCommand",
        "dockerfile_path": "dockerfilePath",
        "env": "env",
        "environment_slug": "environmentSlug",
        "git": "git",
        "github": "github",
        "gitlab": "gitlab",
        "image": "image",
        "instance_count": "instanceCount",
        "instance_size_slug": "instanceSizeSlug",
        "log_destination": "logDestination",
        "run_command": "runCommand",
        "source_dir": "sourceDir",
        "termination": "termination",
    },
)
class AppSpecWorker:
    def __init__(
        self,
        *,
        name: builtins.str,
        alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorkerAlert", typing.Dict[builtins.str, typing.Any]]]]] = None,
        autoscaling: typing.Optional[typing.Union["AppSpecWorkerAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        bitbucket: typing.Optional[typing.Union["AppSpecWorkerBitbucket", typing.Dict[builtins.str, typing.Any]]] = None,
        build_command: typing.Optional[builtins.str] = None,
        dockerfile_path: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorkerEnv", typing.Dict[builtins.str, typing.Any]]]]] = None,
        environment_slug: typing.Optional[builtins.str] = None,
        git: typing.Optional[typing.Union["AppSpecWorkerGit", typing.Dict[builtins.str, typing.Any]]] = None,
        github: typing.Optional[typing.Union["AppSpecWorkerGithub", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["AppSpecWorkerGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        image: typing.Optional[typing.Union["AppSpecWorkerImage", typing.Dict[builtins.str, typing.Any]]] = None,
        instance_count: typing.Optional[jsii.Number] = None,
        instance_size_slug: typing.Optional[builtins.str] = None,
        log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorkerLogDestination", typing.Dict[builtins.str, typing.Any]]]]] = None,
        run_command: typing.Optional[builtins.str] = None,
        source_dir: typing.Optional[builtins.str] = None,
        termination: typing.Optional[typing.Union["AppSpecWorkerTermination", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: The name of the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param alert: alert block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        :param autoscaling: autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#autoscaling App#autoscaling}
        :param bitbucket: bitbucket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        :param build_command: An optional build command to run while building this component from source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        :param dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        :param env: env block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        :param environment_slug: An environment slug describing the type of this app. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        :param git: git block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        :param github: github block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        :param gitlab: gitlab block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        :param image: image block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#image App#image}
        :param instance_count: The amount of instances that this component should be scaled to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_count App#instance_count}
        :param instance_size_slug: The instance size to use for this component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_size_slug App#instance_size_slug}
        :param log_destination: log_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        :param run_command: An optional run command to override the component's default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#run_command App#run_command}
        :param source_dir: An optional path to the working directory to use for the build. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        :param termination: termination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#termination App#termination}
        '''
        if isinstance(autoscaling, dict):
            autoscaling = AppSpecWorkerAutoscaling(**autoscaling)
        if isinstance(bitbucket, dict):
            bitbucket = AppSpecWorkerBitbucket(**bitbucket)
        if isinstance(git, dict):
            git = AppSpecWorkerGit(**git)
        if isinstance(github, dict):
            github = AppSpecWorkerGithub(**github)
        if isinstance(gitlab, dict):
            gitlab = AppSpecWorkerGitlab(**gitlab)
        if isinstance(image, dict):
            image = AppSpecWorkerImage(**image)
        if isinstance(termination, dict):
            termination = AppSpecWorkerTermination(**termination)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea128fc4f2fa5198b5ab50797ccae8c31cc710116a663d6f8cc2a754e7650ccc)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument alert", value=alert, expected_type=type_hints["alert"])
            check_type(argname="argument autoscaling", value=autoscaling, expected_type=type_hints["autoscaling"])
            check_type(argname="argument bitbucket", value=bitbucket, expected_type=type_hints["bitbucket"])
            check_type(argname="argument build_command", value=build_command, expected_type=type_hints["build_command"])
            check_type(argname="argument dockerfile_path", value=dockerfile_path, expected_type=type_hints["dockerfile_path"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument environment_slug", value=environment_slug, expected_type=type_hints["environment_slug"])
            check_type(argname="argument git", value=git, expected_type=type_hints["git"])
            check_type(argname="argument github", value=github, expected_type=type_hints["github"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
            check_type(argname="argument instance_size_slug", value=instance_size_slug, expected_type=type_hints["instance_size_slug"])
            check_type(argname="argument log_destination", value=log_destination, expected_type=type_hints["log_destination"])
            check_type(argname="argument run_command", value=run_command, expected_type=type_hints["run_command"])
            check_type(argname="argument source_dir", value=source_dir, expected_type=type_hints["source_dir"])
            check_type(argname="argument termination", value=termination, expected_type=type_hints["termination"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if alert is not None:
            self._values["alert"] = alert
        if autoscaling is not None:
            self._values["autoscaling"] = autoscaling
        if bitbucket is not None:
            self._values["bitbucket"] = bitbucket
        if build_command is not None:
            self._values["build_command"] = build_command
        if dockerfile_path is not None:
            self._values["dockerfile_path"] = dockerfile_path
        if env is not None:
            self._values["env"] = env
        if environment_slug is not None:
            self._values["environment_slug"] = environment_slug
        if git is not None:
            self._values["git"] = git
        if github is not None:
            self._values["github"] = github
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if image is not None:
            self._values["image"] = image
        if instance_count is not None:
            self._values["instance_count"] = instance_count
        if instance_size_slug is not None:
            self._values["instance_size_slug"] = instance_size_slug
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if run_command is not None:
            self._values["run_command"] = run_command
        if source_dir is not None:
            self._values["source_dir"] = source_dir
        if termination is not None:
            self._values["termination"] = termination

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alert(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlert"]]]:
        '''alert block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#alert App#alert}
        '''
        result = self._values.get("alert")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlert"]]], result)

    @builtins.property
    def autoscaling(self) -> typing.Optional["AppSpecWorkerAutoscaling"]:
        '''autoscaling block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#autoscaling App#autoscaling}
        '''
        result = self._values.get("autoscaling")
        return typing.cast(typing.Optional["AppSpecWorkerAutoscaling"], result)

    @builtins.property
    def bitbucket(self) -> typing.Optional["AppSpecWorkerBitbucket"]:
        '''bitbucket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#bitbucket App#bitbucket}
        '''
        result = self._values.get("bitbucket")
        return typing.cast(typing.Optional["AppSpecWorkerBitbucket"], result)

    @builtins.property
    def build_command(self) -> typing.Optional[builtins.str]:
        '''An optional build command to run while building this component from source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#build_command App#build_command}
        '''
        result = self._values.get("build_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dockerfile_path(self) -> typing.Optional[builtins.str]:
        '''The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#dockerfile_path App#dockerfile_path}
        '''
        result = self._values.get("dockerfile_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerEnv"]]]:
        '''env block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#env App#env}
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerEnv"]]], result)

    @builtins.property
    def environment_slug(self) -> typing.Optional[builtins.str]:
        '''An environment slug describing the type of this app.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#environment_slug App#environment_slug}
        '''
        result = self._values.get("environment_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def git(self) -> typing.Optional["AppSpecWorkerGit"]:
        '''git block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#git App#git}
        '''
        result = self._values.get("git")
        return typing.cast(typing.Optional["AppSpecWorkerGit"], result)

    @builtins.property
    def github(self) -> typing.Optional["AppSpecWorkerGithub"]:
        '''github block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#github App#github}
        '''
        result = self._values.get("github")
        return typing.cast(typing.Optional["AppSpecWorkerGithub"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["AppSpecWorkerGitlab"]:
        '''gitlab block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#gitlab App#gitlab}
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["AppSpecWorkerGitlab"], result)

    @builtins.property
    def image(self) -> typing.Optional["AppSpecWorkerImage"]:
        '''image block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#image App#image}
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional["AppSpecWorkerImage"], result)

    @builtins.property
    def instance_count(self) -> typing.Optional[jsii.Number]:
        '''The amount of instances that this component should be scaled to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_count App#instance_count}
        '''
        result = self._values.get("instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_size_slug(self) -> typing.Optional[builtins.str]:
        '''The instance size to use for this component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#instance_size_slug App#instance_size_slug}
        '''
        result = self._values.get("instance_size_slug")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_destination(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerLogDestination"]]]:
        '''log_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#log_destination App#log_destination}
        '''
        result = self._values.get("log_destination")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerLogDestination"]]], result)

    @builtins.property
    def run_command(self) -> typing.Optional[builtins.str]:
        '''An optional run command to override the component's default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#run_command App#run_command}
        '''
        result = self._values.get("run_command")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_dir(self) -> typing.Optional[builtins.str]:
        '''An optional path to the working directory to use for the build.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#source_dir App#source_dir}
        '''
        result = self._values.get("source_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination(self) -> typing.Optional["AppSpecWorkerTermination"]:
        '''termination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#termination App#termination}
        '''
        result = self._values.get("termination")
        return typing.cast(typing.Optional["AppSpecWorkerTermination"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorker(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlert",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "rule": "rule",
        "value": "value",
        "window": "window",
        "destinations": "destinations",
        "disabled": "disabled",
    },
)
class AppSpecWorkerAlert:
    def __init__(
        self,
        *,
        operator: builtins.str,
        rule: builtins.str,
        value: jsii.Number,
        window: builtins.str,
        destinations: typing.Optional[typing.Union["AppSpecWorkerAlertDestinations", typing.Dict[builtins.str, typing.Any]]] = None,
        disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param operator: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.
        :param rule: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.
        :param value: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.
        :param window: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.
        :param destinations: destinations block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.
        '''
        if isinstance(destinations, dict):
            destinations = AppSpecWorkerAlertDestinations(**destinations)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15d4f2d67b531897b0da50d601c2afb4db7d8bc46f225685ac05d43253b86407)
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument rule", value=rule, expected_type=type_hints["rule"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operator": operator,
            "rule": rule,
            "value": value,
            "window": window,
        }
        if destinations is not None:
            self._values["destinations"] = destinations
        if disabled is not None:
            self._values["disabled"] = disabled

    @builtins.property
    def operator(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#operator App#operator}.'''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#rule App#rule}.'''
        result = self._values.get("rule")
        assert result is not None, "Required property 'rule' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}.'''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#window App#window}.'''
        result = self._values.get("window")
        assert result is not None, "Required property 'window' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destinations(self) -> typing.Optional["AppSpecWorkerAlertDestinations"]:
        '''destinations block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#destinations App#destinations}
        '''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional["AppSpecWorkerAlertDestinations"], result)

    @builtins.property
    def disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#disabled App#disabled}.'''
        result = self._values.get("disabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerAlert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlertDestinations",
    jsii_struct_bases=[],
    name_mapping={"emails": "emails", "slack_webhooks": "slackWebhooks"},
)
class AppSpecWorkerAlertDestinations:
    def __init__(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorkerAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e2a480076379fdc57dfa3393ab8019ffc50898129e53bda54b5ffc352f3eef3)
            check_type(argname="argument emails", value=emails, expected_type=type_hints["emails"])
            check_type(argname="argument slack_webhooks", value=slack_webhooks, expected_type=type_hints["slack_webhooks"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if emails is not None:
            self._values["emails"] = emails
        if slack_webhooks is not None:
            self._values["slack_webhooks"] = slack_webhooks

    @builtins.property
    def emails(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.'''
        result = self._values.get("emails")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def slack_webhooks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlertDestinationsSlackWebhooks"]]]:
        '''slack_webhooks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        result = self._values.get("slack_webhooks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlertDestinationsSlackWebhooks"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerAlertDestinations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerAlertDestinationsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlertDestinationsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1520c55dca5b521613f49c32e1885a67797958f7f7dbfe5995d7af36f83d4c72)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putSlackWebhooks")
    def put_slack_webhooks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorkerAlertDestinationsSlackWebhooks", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0758b457cd7b0379242a7d637178f4006ab9eab2012b75dd3e871572e5930c10)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSlackWebhooks", [value]))

    @jsii.member(jsii_name="resetEmails")
    def reset_emails(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEmails", []))

    @jsii.member(jsii_name="resetSlackWebhooks")
    def reset_slack_webhooks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSlackWebhooks", []))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooks")
    def slack_webhooks(self) -> "AppSpecWorkerAlertDestinationsSlackWebhooksList":
        return typing.cast("AppSpecWorkerAlertDestinationsSlackWebhooksList", jsii.get(self, "slackWebhooks"))

    @builtins.property
    @jsii.member(jsii_name="emailsInput")
    def emails_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "emailsInput"))

    @builtins.property
    @jsii.member(jsii_name="slackWebhooksInput")
    def slack_webhooks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlertDestinationsSlackWebhooks"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerAlertDestinationsSlackWebhooks"]]], jsii.get(self, "slackWebhooksInput"))

    @builtins.property
    @jsii.member(jsii_name="emails")
    def emails(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "emails"))

    @emails.setter
    def emails(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c785b34beabc10bd2cfb1beb17fb76b8276e47075aa043b15e0502a3cbba0bce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "emails", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecWorkerAlertDestinations], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerAlertDestinations],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__011b2e2d18904064ad91186dcb4d3ad0b9a9122045936acf84a442b46674340c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlertDestinationsSlackWebhooks",
    jsii_struct_bases=[],
    name_mapping={"channel": "channel", "url": "url"},
)
class AppSpecWorkerAlertDestinationsSlackWebhooks:
    def __init__(self, *, channel: builtins.str, url: builtins.str) -> None:
        '''
        :param channel: The Slack channel to send notifications to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        :param url: The Slack webhook URL. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f792ffa843e6eebc83cb98bd351d612eb9f4c7ce90eaef8633ec514e6c727fd3)
            check_type(argname="argument channel", value=channel, expected_type=type_hints["channel"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel": channel,
            "url": url,
        }

    @builtins.property
    def channel(self) -> builtins.str:
        '''The Slack channel to send notifications to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#channel App#channel}
        '''
        result = self._values.get("channel")
        assert result is not None, "Required property 'channel' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''The Slack webhook URL.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#url App#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerAlertDestinationsSlackWebhooks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerAlertDestinationsSlackWebhooksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlertDestinationsSlackWebhooksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ae3af94f21c1d43a96c35f60ecb1eb1a6426bf45b736021256ca5321e9a7941)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecWorkerAlertDestinationsSlackWebhooksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__075852cc774a1341839a7d44b89088dc870aa2875a1d2916b89524cce1b5a72b)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecWorkerAlertDestinationsSlackWebhooksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1707c8a39db7be0bb0afd9f17aad55e4fb714c14d414115671320ad1d37fa2b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69450bd583247520b64b11144cf2a43fdf3f74deb14e3c332d210959d683e200)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d78cf03c8a912c95166d2c34ce76fad33273a02d52c395dd912705468bcecf5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlertDestinationsSlackWebhooks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlertDestinationsSlackWebhooks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlertDestinationsSlackWebhooks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eeb0bb931cc4bb1a99e2d147c14c3f661033dd6552689216077f7d3c61592b77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerAlertDestinationsSlackWebhooksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlertDestinationsSlackWebhooksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9bb6fe7f43a1797129e2f1115cf7223651859aec1d3f8c7ca4fb267bcd79d4f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="channelInput")
    def channel_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "channelInput"))

    @builtins.property
    @jsii.member(jsii_name="urlInput")
    def url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "urlInput"))

    @builtins.property
    @jsii.member(jsii_name="channel")
    def channel(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channel"))

    @channel.setter
    def channel(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__589a2ac5b617a4b585edb52a7beaccaca63569196529718c69c4ba9d424e1a03)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "channel", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @url.setter
    def url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6610487ef3422a5bdced643cbad87c24beef32ab8855b8be406fceab7bd73d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "url", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlertDestinationsSlackWebhooks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlertDestinationsSlackWebhooks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlertDestinationsSlackWebhooks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b5818e0c0a55759306fbd31a696b166860eb786ab8eed3c0f5bc80f3b528262)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerAlertList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlertList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d779aeaf15f9fe7f513b7fa2feac5225dac9eb2f2f37ed3c927b6da1705d897)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerAlertOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0486fa072d1863977fb5a960db7a753158ae782d79cea7cb51c5375e55aca09c)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecWorkerAlertOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99ba398ac4fdc394bfc9aa073ff10ff6e27dc0916e3d7f97af50d6030263e811)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a57f859c4926a74b9c6b5580f9aabf0c53748d7fa0c7a78f6844d4a4b89c35f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__466bc79889cae3662156e3772f6e741e934764b2cf181fcd00e87635296f86cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36c98090d390bc1f5d8f2c41116cf72880bfff1721e42e61913074f579729763)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerAlertOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAlertOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84adee9817df423ea2b687521b30a7d86b5e2ce2940c63988a312d313200e5f4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDestinations")
    def put_destinations(
        self,
        *,
        emails: typing.Optional[typing.Sequence[builtins.str]] = None,
        slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param emails: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#emails App#emails}.
        :param slack_webhooks: slack_webhooks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#slack_webhooks App#slack_webhooks}
        '''
        value = AppSpecWorkerAlertDestinations(
            emails=emails, slack_webhooks=slack_webhooks
        )

        return typing.cast(None, jsii.invoke(self, "putDestinations", [value]))

    @jsii.member(jsii_name="resetDestinations")
    def reset_destinations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDestinations", []))

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @builtins.property
    @jsii.member(jsii_name="destinations")
    def destinations(self) -> AppSpecWorkerAlertDestinationsOutputReference:
        return typing.cast(AppSpecWorkerAlertDestinationsOutputReference, jsii.get(self, "destinations"))

    @builtins.property
    @jsii.member(jsii_name="destinationsInput")
    def destinations_input(self) -> typing.Optional[AppSpecWorkerAlertDestinations]:
        return typing.cast(typing.Optional[AppSpecWorkerAlertDestinations], jsii.get(self, "destinationsInput"))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "operatorInput"))

    @builtins.property
    @jsii.member(jsii_name="ruleInput")
    def rule_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ruleInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="windowInput")
    def window_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "windowInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf9d230f4e1c9208f158c7a990c225323b160074e5d21cad637f20df9f23d04a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c77f12a00d0d23ef5ea29b4c3fd37698f0e0dd6d6a5f61c86b011ff265eb407a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "operator", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="rule")
    def rule(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "rule"))

    @rule.setter
    def rule(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4fbac76a1369a25079c77a7a112f3fc2426203297ec9099f8f5e511f84aae91)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rule", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @value.setter
    def value(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__358effd1904febcb01aec98fd5761f41b53e28a4e302f33455fdfa944409d58d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="window")
    def window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "window"))

    @window.setter
    def window(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3a5ff044af7bbc90c29273ee7905c7dcfb132aad8b9dc6c47f5ab2ddb4311f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "window", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d30dac253aa611726cdefdeda969a66ef410615252ae5a9f55947719d9e6706d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAutoscaling",
    jsii_struct_bases=[],
    name_mapping={
        "max_instance_count": "maxInstanceCount",
        "metrics": "metrics",
        "min_instance_count": "minInstanceCount",
    },
)
class AppSpecWorkerAutoscaling:
    def __init__(
        self,
        *,
        max_instance_count: jsii.Number,
        metrics: typing.Union["AppSpecWorkerAutoscalingMetrics", typing.Dict[builtins.str, typing.Any]],
        min_instance_count: jsii.Number,
    ) -> None:
        '''
        :param max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_instance_count App#max_instance_count}
        :param metrics: metrics block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#metrics App#metrics}
        :param min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#min_instance_count App#min_instance_count}
        '''
        if isinstance(metrics, dict):
            metrics = AppSpecWorkerAutoscalingMetrics(**metrics)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f16d0f4c43fa29d267ea3ab19edde901e8f6c65ffa662e13e44b146a57a766a)
            check_type(argname="argument max_instance_count", value=max_instance_count, expected_type=type_hints["max_instance_count"])
            check_type(argname="argument metrics", value=metrics, expected_type=type_hints["metrics"])
            check_type(argname="argument min_instance_count", value=min_instance_count, expected_type=type_hints["min_instance_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "max_instance_count": max_instance_count,
            "metrics": metrics,
            "min_instance_count": min_instance_count,
        }

    @builtins.property
    def max_instance_count(self) -> jsii.Number:
        '''The maximum amount of instances for this component. Must be more than min_instance_count.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_instance_count App#max_instance_count}
        '''
        result = self._values.get("max_instance_count")
        assert result is not None, "Required property 'max_instance_count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def metrics(self) -> "AppSpecWorkerAutoscalingMetrics":
        '''metrics block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#metrics App#metrics}
        '''
        result = self._values.get("metrics")
        assert result is not None, "Required property 'metrics' is missing"
        return typing.cast("AppSpecWorkerAutoscalingMetrics", result)

    @builtins.property
    def min_instance_count(self) -> jsii.Number:
        '''The minimum amount of instances for this component. Must be less than max_instance_count.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#min_instance_count App#min_instance_count}
        '''
        result = self._values.get("min_instance_count")
        assert result is not None, "Required property 'min_instance_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerAutoscaling(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAutoscalingMetrics",
    jsii_struct_bases=[],
    name_mapping={"cpu": "cpu"},
)
class AppSpecWorkerAutoscalingMetrics:
    def __init__(
        self,
        *,
        cpu: typing.Optional[typing.Union["AppSpecWorkerAutoscalingMetricsCpu", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param cpu: cpu block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cpu App#cpu}
        '''
        if isinstance(cpu, dict):
            cpu = AppSpecWorkerAutoscalingMetricsCpu(**cpu)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d891a2e8680a289d5e06dc7778bc1e95145f7cbf76ac71deb5a72369cb87460e)
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cpu is not None:
            self._values["cpu"] = cpu

    @builtins.property
    def cpu(self) -> typing.Optional["AppSpecWorkerAutoscalingMetricsCpu"]:
        '''cpu block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cpu App#cpu}
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional["AppSpecWorkerAutoscalingMetricsCpu"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerAutoscalingMetrics(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAutoscalingMetricsCpu",
    jsii_struct_bases=[],
    name_mapping={"percent": "percent"},
)
class AppSpecWorkerAutoscalingMetricsCpu:
    def __init__(self, *, percent: jsii.Number) -> None:
        '''
        :param percent: The average target CPU utilization for the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#percent App#percent}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e27dc7a67350c82ef67aa83a61638fa61aaedde2946a654e4154ecdee47ae559)
            check_type(argname="argument percent", value=percent, expected_type=type_hints["percent"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "percent": percent,
        }

    @builtins.property
    def percent(self) -> jsii.Number:
        '''The average target CPU utilization for the component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#percent App#percent}
        '''
        result = self._values.get("percent")
        assert result is not None, "Required property 'percent' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerAutoscalingMetricsCpu(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerAutoscalingMetricsCpuOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAutoscalingMetricsCpuOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d158cd8d8d6ed19fe20946ac41a9c1872dce59e9468aa292e955f48f963848d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="percentInput")
    def percent_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "percentInput"))

    @builtins.property
    @jsii.member(jsii_name="percent")
    def percent(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "percent"))

    @percent.setter
    def percent(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b5b47c22887da7a15d2aa5693d97b1b77470a2b01cdea0ed956975cfab8c945)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "percent", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerAutoscalingMetricsCpu]:
        return typing.cast(typing.Optional[AppSpecWorkerAutoscalingMetricsCpu], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerAutoscalingMetricsCpu],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdee6c3868e72e86fb304e343b5af4a773112e29ca06b796eeab2a5a2e37fe2b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerAutoscalingMetricsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAutoscalingMetricsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a245093746d2f76c6aa7d9d14e8f20206f85533c153b67a7c47a9a2fa5c7c23)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCpu")
    def put_cpu(self, *, percent: jsii.Number) -> None:
        '''
        :param percent: The average target CPU utilization for the component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#percent App#percent}
        '''
        value = AppSpecWorkerAutoscalingMetricsCpu(percent=percent)

        return typing.cast(None, jsii.invoke(self, "putCpu", [value]))

    @jsii.member(jsii_name="resetCpu")
    def reset_cpu(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpu", []))

    @builtins.property
    @jsii.member(jsii_name="cpu")
    def cpu(self) -> AppSpecWorkerAutoscalingMetricsCpuOutputReference:
        return typing.cast(AppSpecWorkerAutoscalingMetricsCpuOutputReference, jsii.get(self, "cpu"))

    @builtins.property
    @jsii.member(jsii_name="cpuInput")
    def cpu_input(self) -> typing.Optional[AppSpecWorkerAutoscalingMetricsCpu]:
        return typing.cast(typing.Optional[AppSpecWorkerAutoscalingMetricsCpu], jsii.get(self, "cpuInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerAutoscalingMetrics]:
        return typing.cast(typing.Optional[AppSpecWorkerAutoscalingMetrics], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerAutoscalingMetrics],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70d90a7183088a7c6dd5ff55ea5ba10c946b075a67fe7b1aae0469c41c59d0a0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerAutoscalingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerAutoscalingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__059d6cfea2bda3272f9219569c415ddcbc9c9cfc45c554715381758dcc7d93a8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putMetrics")
    def put_metrics(
        self,
        *,
        cpu: typing.Optional[typing.Union[AppSpecWorkerAutoscalingMetricsCpu, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param cpu: cpu block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cpu App#cpu}
        '''
        value = AppSpecWorkerAutoscalingMetrics(cpu=cpu)

        return typing.cast(None, jsii.invoke(self, "putMetrics", [value]))

    @builtins.property
    @jsii.member(jsii_name="metrics")
    def metrics(self) -> AppSpecWorkerAutoscalingMetricsOutputReference:
        return typing.cast(AppSpecWorkerAutoscalingMetricsOutputReference, jsii.get(self, "metrics"))

    @builtins.property
    @jsii.member(jsii_name="maxInstanceCountInput")
    def max_instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxInstanceCountInput"))

    @builtins.property
    @jsii.member(jsii_name="metricsInput")
    def metrics_input(self) -> typing.Optional[AppSpecWorkerAutoscalingMetrics]:
        return typing.cast(typing.Optional[AppSpecWorkerAutoscalingMetrics], jsii.get(self, "metricsInput"))

    @builtins.property
    @jsii.member(jsii_name="minInstanceCountInput")
    def min_instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minInstanceCountInput"))

    @builtins.property
    @jsii.member(jsii_name="maxInstanceCount")
    def max_instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxInstanceCount"))

    @max_instance_count.setter
    def max_instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d813d41015660b1f5165f5ba238641abf2bcd36d33a0e65598711f78b3219e76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxInstanceCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minInstanceCount")
    def min_instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "minInstanceCount"))

    @min_instance_count.setter
    def min_instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__582b5b167f7a3968317f1c2580354ebafbcb4209a0d18b96aa899754e2017f21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minInstanceCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerAutoscaling]:
        return typing.cast(typing.Optional[AppSpecWorkerAutoscaling], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerAutoscaling]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69d9017062d74f57008e31c4c9f5cb76c3a3ce7e2de0e2ba05e18342f33a7eea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerBitbucket",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecWorkerBitbucket:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e22012c3f13c0c0f29ea62a47e9f2bbd152135a4c4e428b4cf4209183c6c246c)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerBitbucket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerBitbucketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerBitbucketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d473b53bdfcac9e83c8610c82d7c7e2e48b817e655deb94d2fa1451a6a3689c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f77db2658ee78dc571c67128d295d0a818d00b5ce3c3f6a3b019de2dfc9f902)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13342b7c889a09e2f54ae26d58d26b9b6a7dc23610d10bab13a8ba4714a265ef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15511791028d18dd16f85e7aac167781bd18d0726da4d9355566327734442418)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerBitbucket]:
        return typing.cast(typing.Optional[AppSpecWorkerBitbucket], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerBitbucket]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb9ca1443f62baa039f0707396f2423d205257aef24494ab91c5b4f5e726fc32)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerEnv",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "scope": "scope", "type": "type", "value": "value"},
)
class AppSpecWorkerEnv:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        scope: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: The name of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        :param scope: The visibility scope of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        :param type: The type of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        :param value: The value of the environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8aec839d8ad1906433521153e7e6116312082bc9a052d3ccef5cd9d90ebda586)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if scope is not None:
            self._values["scope"] = scope
        if type is not None:
            self._values["type"] = type
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The name of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#key App#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scope(self) -> typing.Optional[builtins.str]:
        '''The visibility scope of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#scope App#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#type App#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The value of the environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#value App#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerEnvList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerEnvList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b0db79150e821627f5dca2bffe0728214f4386b9d0dd797d9370021dd72ec0e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerEnvOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1cea1d3bcd159a1b369472e72b868709fa66ce4f05302050bdb789a094ac3cc3)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecWorkerEnvOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d7159bbec15ca2ddb459689cc409f71727b13899f3adb35789f3529a1da6a16)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90e96495bcd7f7e66551f83da7fdf1bc21c21b812129cbdce6324a7be99b11a6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26d169c8ead89ae12659cfec811cc5fba8b3c9dc948137d33d54420470c03572)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0f97db69017474f015f676e54731b7c612191523a07eb0e884ed1ba5d0805ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerEnvOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerEnvOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b242b4a7f1b2a697b2093cd897d46c820d78224afc5f06b81a045b31e31c661d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetScope")
    def reset_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetScope", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetValue")
    def reset_value(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValue", []))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__377a2ee6e16bde6dc2a699717c7c79204b42480dbb6701ee3700deb1f25136ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a222587f6826105ab59c75368494a706d7290e54003ee8d7ea0cb6dd2cf7606)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82849edda798b34fa6432b984b567cc6c1b7b68861c7f09c35baf6c9462420ea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82d164001992b24424628038c8f4a4515a4794f56851f49e30a486c87eea06f2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5846819f648f2c7867282d9d2d39b935d49ff62de6733505b794e14c7477d84)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerGit",
    jsii_struct_bases=[],
    name_mapping={"branch": "branch", "repo_clone_url": "repoCloneUrl"},
)
class AppSpecWorkerGit:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08c25376637cb623208ef05f45345a5e67230425d7a41c481b98d5076657c418)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument repo_clone_url", value=repo_clone_url, expected_type=type_hints["repo_clone_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if repo_clone_url is not None:
            self._values["repo_clone_url"] = repo_clone_url

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repo_clone_url(self) -> typing.Optional[builtins.str]:
        '''The clone URL of the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        result = self._values.get("repo_clone_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerGit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerGitOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerGitOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92696592aebb78cbe225dbfd48e4fd6de0a6713d59186174ba2ba3a193c18887)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetRepoCloneUrl")
    def reset_repo_clone_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepoCloneUrl", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrlInput")
    def repo_clone_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoCloneUrlInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__562ca3ff92ff4480f0a58eaaedf002906844c401ab36a04a6846f5e4a5163ae0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repoCloneUrl")
    def repo_clone_url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repoCloneUrl"))

    @repo_clone_url.setter
    def repo_clone_url(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da95fed8fc19e719c537f30777518e3fc1c246c1eb5fc1ba4b0b2941f9d7afd9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repoCloneUrl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerGit]:
        return typing.cast(typing.Optional[AppSpecWorkerGit], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerGit]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94a6fd0eece6433c48cf732fd55ada0e02a585f861b9f353985c50af6a4b6aa9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerGithub",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecWorkerGithub:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6941b892e3c58bcd3b98407324a6dc3b122f57cdc7a69347ee24c4181ec1aee)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerGithub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerGithubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerGithubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e4f982996bff76d1cb10e80dfd4c7c69b241210661c2761d2408d2316bca019)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3c19ff97a06f6f9b4c48676c850b64b599a11062d260b7fb76262012c6cdf84)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8af69bdae5bb427f8a9c19a9f0c0c67790d9c72bb9e7cb531f6295228d19c3fb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c712d5f8c71680feb08ca5f9de33ed92e6d20ab47a1ad48a2aacec88b6541fba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerGithub]:
        return typing.cast(typing.Optional[AppSpecWorkerGithub], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerGithub]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cf2bb0254fea671cf27b14c18c5c84944575b54721576022c2871bbab97eb52)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "branch": "branch",
        "deploy_on_push": "deployOnPush",
        "repo": "repo",
    },
)
class AppSpecWorkerGitlab:
    def __init__(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b13077619be40abb9f155c2f918dfca129c766da0fafc57d3a0bc3271a6d4a7)
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument repo", value=repo, expected_type=type_hints["repo"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if branch is not None:
            self._values["branch"] = branch
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if repo is not None:
            self._values["repo"] = repo

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The name of the branch to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy new commits made to the repo.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def repo(self) -> typing.Optional[builtins.str]:
        '''The name of the repo in the format ``owner/repo``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        result = self._values.get("repo")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerGitlabOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerGitlabOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__608f8dd69ed0a5180d167820848e3a72c62b8049598a21dc94e7c3a99aec1e08)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBranch")
    def reset_branch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBranch", []))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetRepo")
    def reset_repo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRepo", []))

    @builtins.property
    @jsii.member(jsii_name="branchInput")
    def branch_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branchInput"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="repoInput")
    def repo_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repoInput"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "branch"))

    @branch.setter
    def branch(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__177bfd90e21cdb025945d23e92d6b90e76155137886b16465e1f7b85f941399b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "branch", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deployOnPush"))

    @deploy_on_push.setter
    def deploy_on_push(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e1ffab56ca581815bb2873b3553ed097795f53a67997c2e07e07f7204e9ebd4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deployOnPush", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repo")
    def repo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repo"))

    @repo.setter
    def repo(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c6075ba94cf89cc34a2e43545eb9f7145e28aef7835317b2f4075e96d712340)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repo", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerGitlab]:
        return typing.cast(typing.Optional[AppSpecWorkerGitlab], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerGitlab]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8dda533d9ed7114c273141445bd57be0826e3d31b07b077a0a06d178d8b8091)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerImage",
    jsii_struct_bases=[],
    name_mapping={
        "registry_type": "registryType",
        "repository": "repository",
        "deploy_on_push": "deployOnPush",
        "digest": "digest",
        "registry": "registry",
        "registry_credentials": "registryCredentials",
        "tag": "tag",
    },
)
class AppSpecWorkerImage:
    def __init__(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AppSpecWorkerImageDeployOnPush", typing.Dict[builtins.str, typing.Any]]]]] = None,
        digest: typing.Optional[builtins.str] = None,
        registry: typing.Optional[builtins.str] = None,
        registry_credentials: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param digest: The image digest. Cannot be specified if tag is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        :param registry_credentials: Access credentials for third-party registries. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        :param tag: The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bc4f97e7b08294a09aa7c64759c248417a8ea2cf7f893b56f0e35936abd4a1d)
            check_type(argname="argument registry_type", value=registry_type, expected_type=type_hints["registry_type"])
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument deploy_on_push", value=deploy_on_push, expected_type=type_hints["deploy_on_push"])
            check_type(argname="argument digest", value=digest, expected_type=type_hints["digest"])
            check_type(argname="argument registry", value=registry, expected_type=type_hints["registry"])
            check_type(argname="argument registry_credentials", value=registry_credentials, expected_type=type_hints["registry_credentials"])
            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "registry_type": registry_type,
            "repository": repository,
        }
        if deploy_on_push is not None:
            self._values["deploy_on_push"] = deploy_on_push
        if digest is not None:
            self._values["digest"] = digest
        if registry is not None:
            self._values["registry"] = registry
        if registry_credentials is not None:
            self._values["registry_credentials"] = registry_credentials
        if tag is not None:
            self._values["tag"] = tag

    @builtins.property
    def registry_type(self) -> builtins.str:
        '''The registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        '''
        result = self._values.get("registry_type")
        assert result is not None, "Required property 'registry_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        '''The repository name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        '''
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deploy_on_push(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerImageDeployOnPush"]]]:
        '''deploy_on_push block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        '''
        result = self._values.get("deploy_on_push")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AppSpecWorkerImageDeployOnPush"]]], result)

    @builtins.property
    def digest(self) -> typing.Optional[builtins.str]:
        '''The image digest. Cannot be specified if tag is provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        '''
        result = self._values.get("digest")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def registry(self) -> typing.Optional[builtins.str]:
        '''The registry name. Must be left empty for the DOCR registry type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        '''
        result = self._values.get("registry")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def registry_credentials(self) -> typing.Optional[builtins.str]:
        '''Access credentials for third-party registries.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        '''
        result = self._values.get("registry_credentials")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag(self) -> typing.Optional[builtins.str]:
        '''The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        result = self._values.get("tag")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerImage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerImageDeployOnPush",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AppSpecWorkerImageDeployOnPush:
    def __init__(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Whether to automatically deploy images pushed to DOCR. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f5085ada8ff64572db545c1e33e258c50bc32a96a70ae3ec476b048416dc8de)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to automatically deploy images pushed to DOCR.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#enabled App#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerImageDeployOnPush(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerImageDeployOnPushList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerImageDeployOnPushList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5473048aec4f7bb903b7f899ed43680cf8bcb4ccce6068b056dd4a5c34eb101)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "AppSpecWorkerImageDeployOnPushOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__786ffcb0628388e44ccad7551933543ebdf4ce6515a8621f0e70ed10f39624bc)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecWorkerImageDeployOnPushOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bacccfcc501ff60b7116a6148cf892f7e7586c26169b381d116071b07e7dfe49)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e295b606bdf2f0be6585334cd8f3ea3990d1489e02bb418eb1e8c5ffd221ea70)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff9e0ab6b3499f856b6493f80dea31814b09ba305b8961802c5e913e7e02f163)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c95e8d2bed8f2fa38b766faa045e0ce930babf7f7c3176b7f980ba9dd0c9b4a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerImageDeployOnPushOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerImageDeployOnPushOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cd9e383caa06720da4c1da497fdd92176239d669e8a5b77d5b7ab6fbd3cf857)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2fc146bcdb5dada026090a15762337495b4a3bde99ccc65526c0b6b7640ec9a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab4ad0e43f784840a97313755f8812fc618af6a2248e9e95b7436355a711d638)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerImageOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerImageOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b3570cf4fa595bd498bbe420294cd612098dc4e80082e3337c29aa165631516)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDeployOnPush")
    def put_deploy_on_push(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eda6fa520ce02c19f993a60c9620b53905df479b670fcb27a80cd59b4f0a04f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putDeployOnPush", [value]))

    @jsii.member(jsii_name="resetDeployOnPush")
    def reset_deploy_on_push(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeployOnPush", []))

    @jsii.member(jsii_name="resetDigest")
    def reset_digest(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDigest", []))

    @jsii.member(jsii_name="resetRegistry")
    def reset_registry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistry", []))

    @jsii.member(jsii_name="resetRegistryCredentials")
    def reset_registry_credentials(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRegistryCredentials", []))

    @jsii.member(jsii_name="resetTag")
    def reset_tag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTag", []))

    @builtins.property
    @jsii.member(jsii_name="deployOnPush")
    def deploy_on_push(self) -> AppSpecWorkerImageDeployOnPushList:
        return typing.cast(AppSpecWorkerImageDeployOnPushList, jsii.get(self, "deployOnPush"))

    @builtins.property
    @jsii.member(jsii_name="deployOnPushInput")
    def deploy_on_push_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]]], jsii.get(self, "deployOnPushInput"))

    @builtins.property
    @jsii.member(jsii_name="digestInput")
    def digest_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "digestInput"))

    @builtins.property
    @jsii.member(jsii_name="registryCredentialsInput")
    def registry_credentials_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryCredentialsInput"))

    @builtins.property
    @jsii.member(jsii_name="registryInput")
    def registry_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryInput"))

    @builtins.property
    @jsii.member(jsii_name="registryTypeInput")
    def registry_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "registryTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="repositoryInput")
    def repository_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "repositoryInput"))

    @builtins.property
    @jsii.member(jsii_name="tagInput")
    def tag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagInput"))

    @builtins.property
    @jsii.member(jsii_name="digest")
    def digest(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "digest"))

    @digest.setter
    def digest(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3645230b75cdfbd3e93d36f6de7136ced46e86943c503f0437d59acc66b0ea7a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "digest", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registry")
    def registry(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registry"))

    @registry.setter
    def registry(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7116a6be8b747981168a96a680391f5e6f9527e11600ba3e096f318e52f62a49)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registry", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registryCredentials")
    def registry_credentials(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryCredentials"))

    @registry_credentials.setter
    def registry_credentials(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4539e4727ba8e686cc42c6d37e5c1d7907a52cc31ff07cbae6151d45d154dcb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registryCredentials", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="registryType")
    def registry_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "registryType"))

    @registry_type.setter
    def registry_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32f212dd3b6e32a0f9e1c2f87de7af399ccac5f5490884ef834ae5db43dc75ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "registryType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "repository"))

    @repository.setter
    def repository(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d5560abd368a9516080ff7b21c89dfcb60ac7b4161545b942f530bafea14b5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "repository", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tag")
    def tag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tag"))

    @tag.setter
    def tag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30b7dc96ae4a1aa76a11debebe567f8ac3bfa15fdcee7554798158872f66a9f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tag", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerImage]:
        return typing.cast(typing.Optional[AppSpecWorkerImage], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerImage]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52b04bb12883cc9e79aff3a7bc6f342f4af99451fb04395a25df3268e475ca8e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f58f461d9d1f567e3e1ff18798d7f4612b5743e63397c3f18340421026a1452a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00504ee9700705205342db70339571cfea6968cd076982a1957a6da399245eee)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecWorkerOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d71da69f23d508de6ec9d997a0197bae36a6ce582329fff0f45001677839c95d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__387b56728382af9d7f8ed5842416bde5773bda1eaa926237aadc3baec7e9282a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21a89a7aec909ffeaf324550093685f164fc47700865bfa9050ed41f1758ec4b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d3c3c1fa445633a8fe6787616b99526cc905dbe5bbfbda47bb360b5fc8e8afb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestination",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "datadog": "datadog",
        "logtail": "logtail",
        "open_search": "openSearch",
        "papertrail": "papertrail",
    },
)
class AppSpecWorkerLogDestination:
    def __init__(
        self,
        *,
        name: builtins.str,
        datadog: typing.Optional[typing.Union["AppSpecWorkerLogDestinationDatadog", typing.Dict[builtins.str, typing.Any]]] = None,
        logtail: typing.Optional[typing.Union["AppSpecWorkerLogDestinationLogtail", typing.Dict[builtins.str, typing.Any]]] = None,
        open_search: typing.Optional[typing.Union["AppSpecWorkerLogDestinationOpenSearch", typing.Dict[builtins.str, typing.Any]]] = None,
        papertrail: typing.Optional[typing.Union["AppSpecWorkerLogDestinationPapertrail", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: Name of the log destination. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        :param datadog: datadog block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        :param logtail: logtail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        :param open_search: open_search block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        :param papertrail: papertrail block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        if isinstance(datadog, dict):
            datadog = AppSpecWorkerLogDestinationDatadog(**datadog)
        if isinstance(logtail, dict):
            logtail = AppSpecWorkerLogDestinationLogtail(**logtail)
        if isinstance(open_search, dict):
            open_search = AppSpecWorkerLogDestinationOpenSearch(**open_search)
        if isinstance(papertrail, dict):
            papertrail = AppSpecWorkerLogDestinationPapertrail(**papertrail)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0bc88ef84a90b462a47619a4dfacaccdf79201e11d6e6a6e3751b7bd8629cc5)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument datadog", value=datadog, expected_type=type_hints["datadog"])
            check_type(argname="argument logtail", value=logtail, expected_type=type_hints["logtail"])
            check_type(argname="argument open_search", value=open_search, expected_type=type_hints["open_search"])
            check_type(argname="argument papertrail", value=papertrail, expected_type=type_hints["papertrail"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if datadog is not None:
            self._values["datadog"] = datadog
        if logtail is not None:
            self._values["logtail"] = logtail
        if open_search is not None:
            self._values["open_search"] = open_search
        if papertrail is not None:
            self._values["papertrail"] = papertrail

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the log destination.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#name App#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def datadog(self) -> typing.Optional["AppSpecWorkerLogDestinationDatadog"]:
        '''datadog block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#datadog App#datadog}
        '''
        result = self._values.get("datadog")
        return typing.cast(typing.Optional["AppSpecWorkerLogDestinationDatadog"], result)

    @builtins.property
    def logtail(self) -> typing.Optional["AppSpecWorkerLogDestinationLogtail"]:
        '''logtail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#logtail App#logtail}
        '''
        result = self._values.get("logtail")
        return typing.cast(typing.Optional["AppSpecWorkerLogDestinationLogtail"], result)

    @builtins.property
    def open_search(self) -> typing.Optional["AppSpecWorkerLogDestinationOpenSearch"]:
        '''open_search block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#open_search App#open_search}
        '''
        result = self._values.get("open_search")
        return typing.cast(typing.Optional["AppSpecWorkerLogDestinationOpenSearch"], result)

    @builtins.property
    def papertrail(self) -> typing.Optional["AppSpecWorkerLogDestinationPapertrail"]:
        '''papertrail block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#papertrail App#papertrail}
        '''
        result = self._values.get("papertrail")
        return typing.cast(typing.Optional["AppSpecWorkerLogDestinationPapertrail"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationDatadog",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "endpoint": "endpoint"},
)
class AppSpecWorkerLogDestinationDatadog:
    def __init__(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__054045d663727fb4dc9fd343ae4ffed5556e6f2732d28e242c6d6bdcac6d6ad4)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key": api_key,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def api_key(self) -> builtins.str:
        '''Datadog API key.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        '''
        result = self._values.get("api_key")
        assert result is not None, "Required property 'api_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''Datadog HTTP log intake endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationDatadog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerLogDestinationDatadogOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationDatadogOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e457ef71844eab09fe26e6910b68eb8e979009bea23a01a281b01dc0df0b64d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b976b5b3273bf57fa81932a2d380319285d24dd57d73341396dcee1a1b24306)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "apiKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8483ed09fbcc4a88270746545b5709c3383d14a9f92ac4c6e3a700e93d60c89e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationDatadog], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationDatadog],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d31239101bb70626afbbf8bd56a4bed7fc29ca16f0d0eba8aa29a189683e506)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerLogDestinationList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e56ea8d41e6ad406b45fb6389781c160d2fdac4ad7234f652f4367d5227fbc36)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "AppSpecWorkerLogDestinationOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d00ea0f2d291819b2e0df390be040af100b08856d7428e5e7d818705da196f0)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("AppSpecWorkerLogDestinationOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a97f49d65f11feb32ccb76eced07343ba750ca4becc6c419ce16103a42dc94f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98242b3343acf7ac52c87bfbe15e73443453d00ba7fd697fba8f449d32366bab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26d91e7167929d434c8c96644ee9e6bbbbea1a62386067a45e0e7f5cf790a7a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21ec745936e8f04a31dc219e356b365161ca93373c4eeffcc62cdde4ae52565f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationLogtail",
    jsii_struct_bases=[],
    name_mapping={"token": "token"},
)
class AppSpecWorkerLogDestinationLogtail:
    def __init__(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0589d4bb65438c850cf5d7513bccfdfe0d52110026ed044a6857039cf04e5615)
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token": token,
        }

    @builtins.property
    def token(self) -> builtins.str:
        '''Logtail token.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        result = self._values.get("token")
        assert result is not None, "Required property 'token' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationLogtail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerLogDestinationLogtailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationLogtailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f09e230ac5e41a02169b338c465ea2cc39d7689b35d3310c17316097d9617e04)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="tokenInput")
    def token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tokenInput"))

    @builtins.property
    @jsii.member(jsii_name="token")
    def token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "token"))

    @token.setter
    def token(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ff0d9b5a73fc910f536f0e717ba6e417cc0a2544786d053bfa2a17166eeede6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "token", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationLogtail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationLogtail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__200e656c57b49d200a5bfa09383e60f7a7d4bb0230b3ee3929fa30059afb2471)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationOpenSearch",
    jsii_struct_bases=[],
    name_mapping={
        "basic_auth": "basicAuth",
        "cluster_name": "clusterName",
        "endpoint": "endpoint",
        "index_name": "indexName",
    },
)
class AppSpecWorkerLogDestinationOpenSearch:
    def __init__(
        self,
        *,
        basic_auth: typing.Union["AppSpecWorkerLogDestinationOpenSearchBasicAuth", typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        if isinstance(basic_auth, dict):
            basic_auth = AppSpecWorkerLogDestinationOpenSearchBasicAuth(**basic_auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91e295c130c366ba206a5dcdc7aa141dffde54c4983e42a8620b73405279becc)
            check_type(argname="argument basic_auth", value=basic_auth, expected_type=type_hints["basic_auth"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument index_name", value=index_name, expected_type=type_hints["index_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "basic_auth": basic_auth,
        }
        if cluster_name is not None:
            self._values["cluster_name"] = cluster_name
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if index_name is not None:
            self._values["index_name"] = index_name

    @builtins.property
    def basic_auth(self) -> "AppSpecWorkerLogDestinationOpenSearchBasicAuth":
        '''basic_auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        '''
        result = self._values.get("basic_auth")
        assert result is not None, "Required property 'basic_auth' is missing"
        return typing.cast("AppSpecWorkerLogDestinationOpenSearchBasicAuth", result)

    @builtins.property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch cluster name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        '''
        result = self._values.get("cluster_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''OpenSearch endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def index_name(self) -> typing.Optional[builtins.str]:
        '''OpenSearch index name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        result = self._values.get("index_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationOpenSearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationOpenSearchBasicAuth",
    jsii_struct_bases=[],
    name_mapping={"password": "password", "user": "user"},
)
class AppSpecWorkerLogDestinationOpenSearchBasicAuth:
    def __init__(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47248e56135b4bc18874db7862da6e6dcd35591d64f6023d3c84c2f64cddc1dc)
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if password is not None:
            self._values["password"] = password
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''Password for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''user for basic authentication.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationOpenSearchBasicAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerLogDestinationOpenSearchBasicAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationOpenSearchBasicAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0ef4d07817e7ed507af308e2f53da70b4cae6e351b1c6252fe8bbed8f326e21)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPassword")
    def reset_password(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPassword", []))

    @jsii.member(jsii_name="resetUser")
    def reset_user(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUser", []))

    @builtins.property
    @jsii.member(jsii_name="passwordInput")
    def password_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "passwordInput"))

    @builtins.property
    @jsii.member(jsii_name="userInput")
    def user_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userInput"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "password"))

    @password.setter
    def password(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b60a6caf8a3e2ea43052e0fe51f42c6c67713bd8ada1aa9b687d9fac41e9b35)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "password", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "user"))

    @user.setter
    def user(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d25581ef6e96d7c5a52521249b188d1d14a668e15303c628586f1b00fea7b07f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "user", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[AppSpecWorkerLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationOpenSearchBasicAuth], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationOpenSearchBasicAuth],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf71bb541402313c6a41c6856f7c3203ce60233dc794b7773fe787b244c28367)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerLogDestinationOpenSearchOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationOpenSearchOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f87e2fc21a66f3278e9a8cbbdc414a00cb415d5aeab5db7ef3d112052132c857)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putBasicAuth")
    def put_basic_auth(
        self,
        *,
        password: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: Password for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#password App#password}
        :param user: user for basic authentication. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#user App#user}
        '''
        value = AppSpecWorkerLogDestinationOpenSearchBasicAuth(
            password=password, user=user
        )

        return typing.cast(None, jsii.invoke(self, "putBasicAuth", [value]))

    @jsii.member(jsii_name="resetClusterName")
    def reset_cluster_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterName", []))

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @jsii.member(jsii_name="resetIndexName")
    def reset_index_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIndexName", []))

    @builtins.property
    @jsii.member(jsii_name="basicAuth")
    def basic_auth(
        self,
    ) -> AppSpecWorkerLogDestinationOpenSearchBasicAuthOutputReference:
        return typing.cast(AppSpecWorkerLogDestinationOpenSearchBasicAuthOutputReference, jsii.get(self, "basicAuth"))

    @builtins.property
    @jsii.member(jsii_name="basicAuthInput")
    def basic_auth_input(
        self,
    ) -> typing.Optional[AppSpecWorkerLogDestinationOpenSearchBasicAuth]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationOpenSearchBasicAuth], jsii.get(self, "basicAuthInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterNameInput")
    def cluster_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterNameInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="indexNameInput")
    def index_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "indexNameInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterName")
    def cluster_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterName"))

    @cluster_name.setter
    def cluster_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a02e75bbc88eb9dca9f90e11a4a3a4b5986c68a4e3d012abbc8f06a898351cd6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__789bd8cfc359655191602381db5245ceb3d7f2c3f47d81c416573b7b1ff3eedd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="indexName")
    def index_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "indexName"))

    @index_name.setter
    def index_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4ecb08516b17f0b8071b350050fed46a19a4fbdb134158755eab55a3e764ef5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "indexName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationOpenSearch], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationOpenSearch],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f2935075e1dec0b21242e7fcfd55667b492664c3c89038b32a6d211d5b452ef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerLogDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0c32b916f7d49f0748fcf8adb84860acf8394c983962c41129c53d843d86180)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putDatadog")
    def put_datadog(
        self,
        *,
        api_key: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param api_key: Datadog API key. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#api_key App#api_key}
        :param endpoint: Datadog HTTP log intake endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecWorkerLogDestinationDatadog(api_key=api_key, endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putDatadog", [value]))

    @jsii.member(jsii_name="putLogtail")
    def put_logtail(self, *, token: builtins.str) -> None:
        '''
        :param token: Logtail token. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#token App#token}
        '''
        value = AppSpecWorkerLogDestinationLogtail(token=token)

        return typing.cast(None, jsii.invoke(self, "putLogtail", [value]))

    @jsii.member(jsii_name="putOpenSearch")
    def put_open_search(
        self,
        *,
        basic_auth: typing.Union[AppSpecWorkerLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
        cluster_name: typing.Optional[builtins.str] = None,
        endpoint: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param basic_auth: basic_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#basic_auth App#basic_auth}
        :param cluster_name: OpenSearch cluster name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#cluster_name App#cluster_name}
        :param endpoint: OpenSearch endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        :param index_name: OpenSearch index name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#index_name App#index_name}
        '''
        value = AppSpecWorkerLogDestinationOpenSearch(
            basic_auth=basic_auth,
            cluster_name=cluster_name,
            endpoint=endpoint,
            index_name=index_name,
        )

        return typing.cast(None, jsii.invoke(self, "putOpenSearch", [value]))

    @jsii.member(jsii_name="putPapertrail")
    def put_papertrail(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        value = AppSpecWorkerLogDestinationPapertrail(endpoint=endpoint)

        return typing.cast(None, jsii.invoke(self, "putPapertrail", [value]))

    @jsii.member(jsii_name="resetDatadog")
    def reset_datadog(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatadog", []))

    @jsii.member(jsii_name="resetLogtail")
    def reset_logtail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogtail", []))

    @jsii.member(jsii_name="resetOpenSearch")
    def reset_open_search(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOpenSearch", []))

    @jsii.member(jsii_name="resetPapertrail")
    def reset_papertrail(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPapertrail", []))

    @builtins.property
    @jsii.member(jsii_name="datadog")
    def datadog(self) -> AppSpecWorkerLogDestinationDatadogOutputReference:
        return typing.cast(AppSpecWorkerLogDestinationDatadogOutputReference, jsii.get(self, "datadog"))

    @builtins.property
    @jsii.member(jsii_name="logtail")
    def logtail(self) -> AppSpecWorkerLogDestinationLogtailOutputReference:
        return typing.cast(AppSpecWorkerLogDestinationLogtailOutputReference, jsii.get(self, "logtail"))

    @builtins.property
    @jsii.member(jsii_name="openSearch")
    def open_search(self) -> AppSpecWorkerLogDestinationOpenSearchOutputReference:
        return typing.cast(AppSpecWorkerLogDestinationOpenSearchOutputReference, jsii.get(self, "openSearch"))

    @builtins.property
    @jsii.member(jsii_name="papertrail")
    def papertrail(self) -> "AppSpecWorkerLogDestinationPapertrailOutputReference":
        return typing.cast("AppSpecWorkerLogDestinationPapertrailOutputReference", jsii.get(self, "papertrail"))

    @builtins.property
    @jsii.member(jsii_name="datadogInput")
    def datadog_input(self) -> typing.Optional[AppSpecWorkerLogDestinationDatadog]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationDatadog], jsii.get(self, "datadogInput"))

    @builtins.property
    @jsii.member(jsii_name="logtailInput")
    def logtail_input(self) -> typing.Optional[AppSpecWorkerLogDestinationLogtail]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationLogtail], jsii.get(self, "logtailInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="openSearchInput")
    def open_search_input(
        self,
    ) -> typing.Optional[AppSpecWorkerLogDestinationOpenSearch]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationOpenSearch], jsii.get(self, "openSearchInput"))

    @builtins.property
    @jsii.member(jsii_name="papertrailInput")
    def papertrail_input(
        self,
    ) -> typing.Optional["AppSpecWorkerLogDestinationPapertrail"]:
        return typing.cast(typing.Optional["AppSpecWorkerLogDestinationPapertrail"], jsii.get(self, "papertrailInput"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50279ba169661c6cf71dd926831204e0663312321574f7be257c709af978ffb8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39306f5e2645d64307a21c6ee153a21268a580900214b5872715eae79cacfcca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationPapertrail",
    jsii_struct_bases=[],
    name_mapping={"endpoint": "endpoint"},
)
class AppSpecWorkerLogDestinationPapertrail:
    def __init__(self, *, endpoint: builtins.str) -> None:
        '''
        :param endpoint: Papertrail syslog endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3dbbeb5a6e5d8703ff31ec8876ad51b604c7ffff4767d95758feb2fd4caff494)
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
        }

    @builtins.property
    def endpoint(self) -> builtins.str:
        '''Papertrail syslog endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#endpoint App#endpoint}
        '''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerLogDestinationPapertrail(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerLogDestinationPapertrailOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerLogDestinationPapertrailOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d246295cef3d56d2ec1174937da0e79b4d40407f21fad4c643832747336c0115)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b6242759d7c7ee90b21574bf09dd5d8c4189e67d44ee6af053ac72a5f56d777)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerLogDestinationPapertrail]:
        return typing.cast(typing.Optional[AppSpecWorkerLogDestinationPapertrail], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[AppSpecWorkerLogDestinationPapertrail],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__563b69b969e237fdd117a7fbfd567ee39db4a8f476eb63aa2f3fc059fa7d89ae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class AppSpecWorkerOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__312b7de52a955d810df21a3fc69e9314c94ed984c7760e2ea6fb3207b9dca68f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAlert")
    def put_alert(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerAlert, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9cd0ee7ce0d45120221bfa9bfd626aa5e6aa9fbd10d9bb8caae90ecc556453d5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAlert", [value]))

    @jsii.member(jsii_name="putAutoscaling")
    def put_autoscaling(
        self,
        *,
        max_instance_count: jsii.Number,
        metrics: typing.Union[AppSpecWorkerAutoscalingMetrics, typing.Dict[builtins.str, typing.Any]],
        min_instance_count: jsii.Number,
    ) -> None:
        '''
        :param max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#max_instance_count App#max_instance_count}
        :param metrics: metrics block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#metrics App#metrics}
        :param min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#min_instance_count App#min_instance_count}
        '''
        value = AppSpecWorkerAutoscaling(
            max_instance_count=max_instance_count,
            metrics=metrics,
            min_instance_count=min_instance_count,
        )

        return typing.cast(None, jsii.invoke(self, "putAutoscaling", [value]))

    @jsii.member(jsii_name="putBitbucket")
    def put_bitbucket(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecWorkerBitbucket(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putBitbucket", [value]))

    @jsii.member(jsii_name="putEnv")
    def put_env(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerEnv, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08de3b47c3c90c7165b42e03962437225e946fbe7faf4703df24b61f08485169)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putEnv", [value]))

    @jsii.member(jsii_name="putGit")
    def put_git(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        repo_clone_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param repo_clone_url: The clone URL of the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo_clone_url App#repo_clone_url}
        '''
        value = AppSpecWorkerGit(branch=branch, repo_clone_url=repo_clone_url)

        return typing.cast(None, jsii.invoke(self, "putGit", [value]))

    @jsii.member(jsii_name="putGithub")
    def put_github(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecWorkerGithub(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGithub", [value]))

    @jsii.member(jsii_name="putGitlab")
    def put_gitlab(
        self,
        *,
        branch: typing.Optional[builtins.str] = None,
        deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        repo: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param branch: The name of the branch to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#branch App#branch}
        :param deploy_on_push: Whether to automatically deploy new commits made to the repo. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param repo: The name of the repo in the format ``owner/repo``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repo App#repo}
        '''
        value = AppSpecWorkerGitlab(
            branch=branch, deploy_on_push=deploy_on_push, repo=repo
        )

        return typing.cast(None, jsii.invoke(self, "putGitlab", [value]))

    @jsii.member(jsii_name="putImage")
    def put_image(
        self,
        *,
        registry_type: builtins.str,
        repository: builtins.str,
        deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]]] = None,
        digest: typing.Optional[builtins.str] = None,
        registry: typing.Optional[builtins.str] = None,
        registry_credentials: typing.Optional[builtins.str] = None,
        tag: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry_type: The registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_type App#registry_type}
        :param repository: The repository name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#repository App#repository}
        :param deploy_on_push: deploy_on_push block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#deploy_on_push App#deploy_on_push}
        :param digest: The image digest. Cannot be specified if tag is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#digest App#digest}
        :param registry: The registry name. Must be left empty for the DOCR registry type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry App#registry}
        :param registry_credentials: Access credentials for third-party registries. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#registry_credentials App#registry_credentials}
        :param tag: The repository tag. Defaults to latest if not provided. Cannot be specified if digest is provided. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#tag App#tag}
        '''
        value = AppSpecWorkerImage(
            registry_type=registry_type,
            repository=repository,
            deploy_on_push=deploy_on_push,
            digest=digest,
            registry=registry,
            registry_credentials=registry_credentials,
            tag=tag,
        )

        return typing.cast(None, jsii.invoke(self, "putImage", [value]))

    @jsii.member(jsii_name="putLogDestination")
    def put_log_destination(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerLogDestination, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0dab23b186d39bec5473c60d8b615ca561d2ac00247e7420f106bd51a6ce6b69)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putLogDestination", [value]))

    @jsii.member(jsii_name="putTermination")
    def put_termination(
        self,
        *,
        grace_period_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        value = AppSpecWorkerTermination(grace_period_seconds=grace_period_seconds)

        return typing.cast(None, jsii.invoke(self, "putTermination", [value]))

    @jsii.member(jsii_name="resetAlert")
    def reset_alert(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlert", []))

    @jsii.member(jsii_name="resetAutoscaling")
    def reset_autoscaling(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoscaling", []))

    @jsii.member(jsii_name="resetBitbucket")
    def reset_bitbucket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBitbucket", []))

    @jsii.member(jsii_name="resetBuildCommand")
    def reset_build_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBuildCommand", []))

    @jsii.member(jsii_name="resetDockerfilePath")
    def reset_dockerfile_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDockerfilePath", []))

    @jsii.member(jsii_name="resetEnv")
    def reset_env(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnv", []))

    @jsii.member(jsii_name="resetEnvironmentSlug")
    def reset_environment_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironmentSlug", []))

    @jsii.member(jsii_name="resetGit")
    def reset_git(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGit", []))

    @jsii.member(jsii_name="resetGithub")
    def reset_github(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGithub", []))

    @jsii.member(jsii_name="resetGitlab")
    def reset_gitlab(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGitlab", []))

    @jsii.member(jsii_name="resetImage")
    def reset_image(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImage", []))

    @jsii.member(jsii_name="resetInstanceCount")
    def reset_instance_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceCount", []))

    @jsii.member(jsii_name="resetInstanceSizeSlug")
    def reset_instance_size_slug(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInstanceSizeSlug", []))

    @jsii.member(jsii_name="resetLogDestination")
    def reset_log_destination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLogDestination", []))

    @jsii.member(jsii_name="resetRunCommand")
    def reset_run_command(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRunCommand", []))

    @jsii.member(jsii_name="resetSourceDir")
    def reset_source_dir(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSourceDir", []))

    @jsii.member(jsii_name="resetTermination")
    def reset_termination(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTermination", []))

    @builtins.property
    @jsii.member(jsii_name="alert")
    def alert(self) -> AppSpecWorkerAlertList:
        return typing.cast(AppSpecWorkerAlertList, jsii.get(self, "alert"))

    @builtins.property
    @jsii.member(jsii_name="autoscaling")
    def autoscaling(self) -> AppSpecWorkerAutoscalingOutputReference:
        return typing.cast(AppSpecWorkerAutoscalingOutputReference, jsii.get(self, "autoscaling"))

    @builtins.property
    @jsii.member(jsii_name="bitbucket")
    def bitbucket(self) -> AppSpecWorkerBitbucketOutputReference:
        return typing.cast(AppSpecWorkerBitbucketOutputReference, jsii.get(self, "bitbucket"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> AppSpecWorkerEnvList:
        return typing.cast(AppSpecWorkerEnvList, jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="git")
    def git(self) -> AppSpecWorkerGitOutputReference:
        return typing.cast(AppSpecWorkerGitOutputReference, jsii.get(self, "git"))

    @builtins.property
    @jsii.member(jsii_name="github")
    def github(self) -> AppSpecWorkerGithubOutputReference:
        return typing.cast(AppSpecWorkerGithubOutputReference, jsii.get(self, "github"))

    @builtins.property
    @jsii.member(jsii_name="gitlab")
    def gitlab(self) -> AppSpecWorkerGitlabOutputReference:
        return typing.cast(AppSpecWorkerGitlabOutputReference, jsii.get(self, "gitlab"))

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> AppSpecWorkerImageOutputReference:
        return typing.cast(AppSpecWorkerImageOutputReference, jsii.get(self, "image"))

    @builtins.property
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> AppSpecWorkerLogDestinationList:
        return typing.cast(AppSpecWorkerLogDestinationList, jsii.get(self, "logDestination"))

    @builtins.property
    @jsii.member(jsii_name="termination")
    def termination(self) -> "AppSpecWorkerTerminationOutputReference":
        return typing.cast("AppSpecWorkerTerminationOutputReference", jsii.get(self, "termination"))

    @builtins.property
    @jsii.member(jsii_name="alertInput")
    def alert_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]], jsii.get(self, "alertInput"))

    @builtins.property
    @jsii.member(jsii_name="autoscalingInput")
    def autoscaling_input(self) -> typing.Optional[AppSpecWorkerAutoscaling]:
        return typing.cast(typing.Optional[AppSpecWorkerAutoscaling], jsii.get(self, "autoscalingInput"))

    @builtins.property
    @jsii.member(jsii_name="bitbucketInput")
    def bitbucket_input(self) -> typing.Optional[AppSpecWorkerBitbucket]:
        return typing.cast(typing.Optional[AppSpecWorkerBitbucket], jsii.get(self, "bitbucketInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommandInput")
    def build_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "buildCommandInput"))

    @builtins.property
    @jsii.member(jsii_name="dockerfilePathInput")
    def dockerfile_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dockerfilePathInput"))

    @builtins.property
    @jsii.member(jsii_name="envInput")
    def env_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]], jsii.get(self, "envInput"))

    @builtins.property
    @jsii.member(jsii_name="environmentSlugInput")
    def environment_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "environmentSlugInput"))

    @builtins.property
    @jsii.member(jsii_name="githubInput")
    def github_input(self) -> typing.Optional[AppSpecWorkerGithub]:
        return typing.cast(typing.Optional[AppSpecWorkerGithub], jsii.get(self, "githubInput"))

    @builtins.property
    @jsii.member(jsii_name="gitInput")
    def git_input(self) -> typing.Optional[AppSpecWorkerGit]:
        return typing.cast(typing.Optional[AppSpecWorkerGit], jsii.get(self, "gitInput"))

    @builtins.property
    @jsii.member(jsii_name="gitlabInput")
    def gitlab_input(self) -> typing.Optional[AppSpecWorkerGitlab]:
        return typing.cast(typing.Optional[AppSpecWorkerGitlab], jsii.get(self, "gitlabInput"))

    @builtins.property
    @jsii.member(jsii_name="imageInput")
    def image_input(self) -> typing.Optional[AppSpecWorkerImage]:
        return typing.cast(typing.Optional[AppSpecWorkerImage], jsii.get(self, "imageInput"))

    @builtins.property
    @jsii.member(jsii_name="instanceCountInput")
    def instance_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "instanceCountInput"))

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlugInput")
    def instance_size_slug_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceSizeSlugInput"))

    @builtins.property
    @jsii.member(jsii_name="logDestinationInput")
    def log_destination_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]]], jsii.get(self, "logDestinationInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="runCommandInput")
    def run_command_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "runCommandInput"))

    @builtins.property
    @jsii.member(jsii_name="sourceDirInput")
    def source_dir_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDirInput"))

    @builtins.property
    @jsii.member(jsii_name="terminationInput")
    def termination_input(self) -> typing.Optional["AppSpecWorkerTermination"]:
        return typing.cast(typing.Optional["AppSpecWorkerTermination"], jsii.get(self, "terminationInput"))

    @builtins.property
    @jsii.member(jsii_name="buildCommand")
    def build_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "buildCommand"))

    @build_command.setter
    def build_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e87d43963494e8bddff17dcf55030f19fb3aef47973aaa68e0176ab28e91c163)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "buildCommand", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="dockerfilePath")
    def dockerfile_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dockerfilePath"))

    @dockerfile_path.setter
    def dockerfile_path(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ded5884b8809373c6b9e22ec2d4010674a60117fea2353cbe114619a34992413)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dockerfilePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="environmentSlug")
    def environment_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "environmentSlug"))

    @environment_slug.setter
    def environment_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c082085aa2fca0c669ac79ef6cc74b713609fbc91a7e24669f5a1379a4bc2ad9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "environmentSlug", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="instanceCount")
    def instance_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "instanceCount"))

    @instance_count.setter
    def instance_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf1f3255007fe3ce0c568653953d92405669cd54bebf2185add1370976e98fe3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="instanceSizeSlug")
    def instance_size_slug(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "instanceSizeSlug"))

    @instance_size_slug.setter
    def instance_size_slug(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0bbb61f0f58d1061906be30ff3a99355a5cdeecc64e194be4e31bc348223bd2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "instanceSizeSlug", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab8d9b3c1ac0001c1f23a628153d554f3ed357ea2e10bf9ccf9b7e684f81cd35)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "runCommand"))

    @run_command.setter
    def run_command(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__447970bf71a278c711c281eec2ad7335afd5cf1553a4be3736a5902a74f0ec88)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "runCommand", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sourceDir")
    def source_dir(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceDir"))

    @source_dir.setter
    def source_dir(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b588071b616dca70aa3de26a59b0109ac9d6cf5882f16d2cca8732e7822b8ef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDir", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1cb594eebe78865d4411dd225612d1706b790a9ab7abfa090a5bd2fc6ba332e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerTermination",
    jsii_struct_bases=[],
    name_mapping={"grace_period_seconds": "gracePeriodSeconds"},
)
class AppSpecWorkerTermination:
    def __init__(
        self,
        *,
        grace_period_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1fc024fd89f790e34b9cb092aa90984994e4ce8240ca4abc5c80c6331e644b6)
            check_type(argname="argument grace_period_seconds", value=grace_period_seconds, expected_type=type_hints["grace_period_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if grace_period_seconds is not None:
            self._values["grace_period_seconds"] = grace_period_seconds

    @builtins.property
    def grace_period_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown.

        Default: 120, Minimum 1, Maximum 600.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#grace_period_seconds App#grace_period_seconds}
        '''
        result = self._values.get("grace_period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSpecWorkerTermination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSpecWorkerTerminationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppSpecWorkerTerminationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c36610f2783f2158aed47e06827edb15c527b1e208fedfed9906e9cda2dfd3a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetGracePeriodSeconds")
    def reset_grace_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGracePeriodSeconds", []))

    @builtins.property
    @jsii.member(jsii_name="gracePeriodSecondsInput")
    def grace_period_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "gracePeriodSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="gracePeriodSeconds")
    def grace_period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "gracePeriodSeconds"))

    @grace_period_seconds.setter
    def grace_period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5799da0b2f4efa53082879d72aa9ff2e2c9e606254bbab69f379848e4c41dbaf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gracePeriodSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[AppSpecWorkerTermination]:
        return typing.cast(typing.Optional[AppSpecWorkerTermination], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[AppSpecWorkerTermination]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c7fa13e45834c723dce947174ebd4001cc734ef1af40aede3e7c5f197e30c33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-digitalocean.app.AppTimeouts",
    jsii_struct_bases=[],
    name_mapping={"create": "create"},
)
class AppTimeouts:
    def __init__(self, *, create: typing.Optional[builtins.str] = None) -> None:
        '''
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#create App#create}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44ca5eac160d8cef10922e6197498ff5fbec42de3a6c18a740c5248d25c6c648)
            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if create is not None:
            self._values["create"] = create

    @builtins.property
    def create(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/digitalocean/digitalocean/2.68.0/docs/resources/app#create App#create}.'''
        result = self._values.get("create")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-digitalocean.app.AppTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__147693d99a0c606ca92c57643a713083f48fe911fda23535da8d55712dae1820)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCreate")
    def reset_create(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreate", []))

    @builtins.property
    @jsii.member(jsii_name="createInput")
    def create_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "createInput"))

    @builtins.property
    @jsii.member(jsii_name="create")
    def create(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "create"))

    @create.setter
    def create(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__778262ed6f7c1f2512d123073b0d3f21b12ac5e7345754c702643b1763426fd7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "create", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1526192fb2cb9e7adca145d0f95f28c33199ec7366ff4860c026fd58cca6f331)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


__all__ = [
    "App",
    "AppConfig",
    "AppDedicatedIps",
    "AppDedicatedIpsList",
    "AppDedicatedIpsOutputReference",
    "AppSpec",
    "AppSpecAlert",
    "AppSpecAlertDestinations",
    "AppSpecAlertDestinationsOutputReference",
    "AppSpecAlertDestinationsSlackWebhooks",
    "AppSpecAlertDestinationsSlackWebhooksList",
    "AppSpecAlertDestinationsSlackWebhooksOutputReference",
    "AppSpecAlertList",
    "AppSpecAlertOutputReference",
    "AppSpecDatabase",
    "AppSpecDatabaseList",
    "AppSpecDatabaseOutputReference",
    "AppSpecDomain",
    "AppSpecDomainList",
    "AppSpecDomainOutputReference",
    "AppSpecEgress",
    "AppSpecEgressList",
    "AppSpecEgressOutputReference",
    "AppSpecEnv",
    "AppSpecEnvList",
    "AppSpecEnvOutputReference",
    "AppSpecFunction",
    "AppSpecFunctionAlert",
    "AppSpecFunctionAlertDestinations",
    "AppSpecFunctionAlertDestinationsOutputReference",
    "AppSpecFunctionAlertDestinationsSlackWebhooks",
    "AppSpecFunctionAlertDestinationsSlackWebhooksList",
    "AppSpecFunctionAlertDestinationsSlackWebhooksOutputReference",
    "AppSpecFunctionAlertList",
    "AppSpecFunctionAlertOutputReference",
    "AppSpecFunctionBitbucket",
    "AppSpecFunctionBitbucketOutputReference",
    "AppSpecFunctionCors",
    "AppSpecFunctionCorsAllowOrigins",
    "AppSpecFunctionCorsAllowOriginsOutputReference",
    "AppSpecFunctionCorsOutputReference",
    "AppSpecFunctionEnv",
    "AppSpecFunctionEnvList",
    "AppSpecFunctionEnvOutputReference",
    "AppSpecFunctionGit",
    "AppSpecFunctionGitOutputReference",
    "AppSpecFunctionGithub",
    "AppSpecFunctionGithubOutputReference",
    "AppSpecFunctionGitlab",
    "AppSpecFunctionGitlabOutputReference",
    "AppSpecFunctionList",
    "AppSpecFunctionLogDestination",
    "AppSpecFunctionLogDestinationDatadog",
    "AppSpecFunctionLogDestinationDatadogOutputReference",
    "AppSpecFunctionLogDestinationList",
    "AppSpecFunctionLogDestinationLogtail",
    "AppSpecFunctionLogDestinationLogtailOutputReference",
    "AppSpecFunctionLogDestinationOpenSearch",
    "AppSpecFunctionLogDestinationOpenSearchBasicAuth",
    "AppSpecFunctionLogDestinationOpenSearchBasicAuthOutputReference",
    "AppSpecFunctionLogDestinationOpenSearchOutputReference",
    "AppSpecFunctionLogDestinationOutputReference",
    "AppSpecFunctionLogDestinationPapertrail",
    "AppSpecFunctionLogDestinationPapertrailOutputReference",
    "AppSpecFunctionOutputReference",
    "AppSpecFunctionRoutes",
    "AppSpecFunctionRoutesList",
    "AppSpecFunctionRoutesOutputReference",
    "AppSpecIngress",
    "AppSpecIngressOutputReference",
    "AppSpecIngressRule",
    "AppSpecIngressRuleComponent",
    "AppSpecIngressRuleComponentOutputReference",
    "AppSpecIngressRuleCors",
    "AppSpecIngressRuleCorsAllowOrigins",
    "AppSpecIngressRuleCorsAllowOriginsOutputReference",
    "AppSpecIngressRuleCorsOutputReference",
    "AppSpecIngressRuleList",
    "AppSpecIngressRuleMatch",
    "AppSpecIngressRuleMatchAuthority",
    "AppSpecIngressRuleMatchAuthorityOutputReference",
    "AppSpecIngressRuleMatchOutputReference",
    "AppSpecIngressRuleMatchPath",
    "AppSpecIngressRuleMatchPathOutputReference",
    "AppSpecIngressRuleOutputReference",
    "AppSpecIngressRuleRedirect",
    "AppSpecIngressRuleRedirectOutputReference",
    "AppSpecJob",
    "AppSpecJobAlert",
    "AppSpecJobAlertDestinations",
    "AppSpecJobAlertDestinationsOutputReference",
    "AppSpecJobAlertDestinationsSlackWebhooks",
    "AppSpecJobAlertDestinationsSlackWebhooksList",
    "AppSpecJobAlertDestinationsSlackWebhooksOutputReference",
    "AppSpecJobAlertList",
    "AppSpecJobAlertOutputReference",
    "AppSpecJobBitbucket",
    "AppSpecJobBitbucketOutputReference",
    "AppSpecJobEnv",
    "AppSpecJobEnvList",
    "AppSpecJobEnvOutputReference",
    "AppSpecJobGit",
    "AppSpecJobGitOutputReference",
    "AppSpecJobGithub",
    "AppSpecJobGithubOutputReference",
    "AppSpecJobGitlab",
    "AppSpecJobGitlabOutputReference",
    "AppSpecJobImage",
    "AppSpecJobImageDeployOnPush",
    "AppSpecJobImageDeployOnPushList",
    "AppSpecJobImageDeployOnPushOutputReference",
    "AppSpecJobImageOutputReference",
    "AppSpecJobList",
    "AppSpecJobLogDestination",
    "AppSpecJobLogDestinationDatadog",
    "AppSpecJobLogDestinationDatadogOutputReference",
    "AppSpecJobLogDestinationList",
    "AppSpecJobLogDestinationLogtail",
    "AppSpecJobLogDestinationLogtailOutputReference",
    "AppSpecJobLogDestinationOpenSearch",
    "AppSpecJobLogDestinationOpenSearchBasicAuth",
    "AppSpecJobLogDestinationOpenSearchBasicAuthOutputReference",
    "AppSpecJobLogDestinationOpenSearchOutputReference",
    "AppSpecJobLogDestinationOutputReference",
    "AppSpecJobLogDestinationPapertrail",
    "AppSpecJobLogDestinationPapertrailOutputReference",
    "AppSpecJobOutputReference",
    "AppSpecJobTermination",
    "AppSpecJobTerminationOutputReference",
    "AppSpecMaintenance",
    "AppSpecMaintenanceOutputReference",
    "AppSpecOutputReference",
    "AppSpecService",
    "AppSpecServiceAlert",
    "AppSpecServiceAlertDestinations",
    "AppSpecServiceAlertDestinationsOutputReference",
    "AppSpecServiceAlertDestinationsSlackWebhooks",
    "AppSpecServiceAlertDestinationsSlackWebhooksList",
    "AppSpecServiceAlertDestinationsSlackWebhooksOutputReference",
    "AppSpecServiceAlertList",
    "AppSpecServiceAlertOutputReference",
    "AppSpecServiceAutoscaling",
    "AppSpecServiceAutoscalingMetrics",
    "AppSpecServiceAutoscalingMetricsCpu",
    "AppSpecServiceAutoscalingMetricsCpuOutputReference",
    "AppSpecServiceAutoscalingMetricsOutputReference",
    "AppSpecServiceAutoscalingOutputReference",
    "AppSpecServiceBitbucket",
    "AppSpecServiceBitbucketOutputReference",
    "AppSpecServiceCors",
    "AppSpecServiceCorsAllowOrigins",
    "AppSpecServiceCorsAllowOriginsOutputReference",
    "AppSpecServiceCorsOutputReference",
    "AppSpecServiceEnv",
    "AppSpecServiceEnvList",
    "AppSpecServiceEnvOutputReference",
    "AppSpecServiceGit",
    "AppSpecServiceGitOutputReference",
    "AppSpecServiceGithub",
    "AppSpecServiceGithubOutputReference",
    "AppSpecServiceGitlab",
    "AppSpecServiceGitlabOutputReference",
    "AppSpecServiceHealthCheck",
    "AppSpecServiceHealthCheckOutputReference",
    "AppSpecServiceImage",
    "AppSpecServiceImageDeployOnPush",
    "AppSpecServiceImageDeployOnPushList",
    "AppSpecServiceImageDeployOnPushOutputReference",
    "AppSpecServiceImageOutputReference",
    "AppSpecServiceList",
    "AppSpecServiceLogDestination",
    "AppSpecServiceLogDestinationDatadog",
    "AppSpecServiceLogDestinationDatadogOutputReference",
    "AppSpecServiceLogDestinationList",
    "AppSpecServiceLogDestinationLogtail",
    "AppSpecServiceLogDestinationLogtailOutputReference",
    "AppSpecServiceLogDestinationOpenSearch",
    "AppSpecServiceLogDestinationOpenSearchBasicAuth",
    "AppSpecServiceLogDestinationOpenSearchBasicAuthOutputReference",
    "AppSpecServiceLogDestinationOpenSearchOutputReference",
    "AppSpecServiceLogDestinationOutputReference",
    "AppSpecServiceLogDestinationPapertrail",
    "AppSpecServiceLogDestinationPapertrailOutputReference",
    "AppSpecServiceOutputReference",
    "AppSpecServiceRoutes",
    "AppSpecServiceRoutesList",
    "AppSpecServiceRoutesOutputReference",
    "AppSpecServiceTermination",
    "AppSpecServiceTerminationOutputReference",
    "AppSpecStaticSite",
    "AppSpecStaticSiteBitbucket",
    "AppSpecStaticSiteBitbucketOutputReference",
    "AppSpecStaticSiteCors",
    "AppSpecStaticSiteCorsAllowOrigins",
    "AppSpecStaticSiteCorsAllowOriginsOutputReference",
    "AppSpecStaticSiteCorsOutputReference",
    "AppSpecStaticSiteEnv",
    "AppSpecStaticSiteEnvList",
    "AppSpecStaticSiteEnvOutputReference",
    "AppSpecStaticSiteGit",
    "AppSpecStaticSiteGitOutputReference",
    "AppSpecStaticSiteGithub",
    "AppSpecStaticSiteGithubOutputReference",
    "AppSpecStaticSiteGitlab",
    "AppSpecStaticSiteGitlabOutputReference",
    "AppSpecStaticSiteList",
    "AppSpecStaticSiteOutputReference",
    "AppSpecStaticSiteRoutes",
    "AppSpecStaticSiteRoutesList",
    "AppSpecStaticSiteRoutesOutputReference",
    "AppSpecVpc",
    "AppSpecVpcList",
    "AppSpecVpcOutputReference",
    "AppSpecWorker",
    "AppSpecWorkerAlert",
    "AppSpecWorkerAlertDestinations",
    "AppSpecWorkerAlertDestinationsOutputReference",
    "AppSpecWorkerAlertDestinationsSlackWebhooks",
    "AppSpecWorkerAlertDestinationsSlackWebhooksList",
    "AppSpecWorkerAlertDestinationsSlackWebhooksOutputReference",
    "AppSpecWorkerAlertList",
    "AppSpecWorkerAlertOutputReference",
    "AppSpecWorkerAutoscaling",
    "AppSpecWorkerAutoscalingMetrics",
    "AppSpecWorkerAutoscalingMetricsCpu",
    "AppSpecWorkerAutoscalingMetricsCpuOutputReference",
    "AppSpecWorkerAutoscalingMetricsOutputReference",
    "AppSpecWorkerAutoscalingOutputReference",
    "AppSpecWorkerBitbucket",
    "AppSpecWorkerBitbucketOutputReference",
    "AppSpecWorkerEnv",
    "AppSpecWorkerEnvList",
    "AppSpecWorkerEnvOutputReference",
    "AppSpecWorkerGit",
    "AppSpecWorkerGitOutputReference",
    "AppSpecWorkerGithub",
    "AppSpecWorkerGithubOutputReference",
    "AppSpecWorkerGitlab",
    "AppSpecWorkerGitlabOutputReference",
    "AppSpecWorkerImage",
    "AppSpecWorkerImageDeployOnPush",
    "AppSpecWorkerImageDeployOnPushList",
    "AppSpecWorkerImageDeployOnPushOutputReference",
    "AppSpecWorkerImageOutputReference",
    "AppSpecWorkerList",
    "AppSpecWorkerLogDestination",
    "AppSpecWorkerLogDestinationDatadog",
    "AppSpecWorkerLogDestinationDatadogOutputReference",
    "AppSpecWorkerLogDestinationList",
    "AppSpecWorkerLogDestinationLogtail",
    "AppSpecWorkerLogDestinationLogtailOutputReference",
    "AppSpecWorkerLogDestinationOpenSearch",
    "AppSpecWorkerLogDestinationOpenSearchBasicAuth",
    "AppSpecWorkerLogDestinationOpenSearchBasicAuthOutputReference",
    "AppSpecWorkerLogDestinationOpenSearchOutputReference",
    "AppSpecWorkerLogDestinationOutputReference",
    "AppSpecWorkerLogDestinationPapertrail",
    "AppSpecWorkerLogDestinationPapertrailOutputReference",
    "AppSpecWorkerOutputReference",
    "AppSpecWorkerTermination",
    "AppSpecWorkerTerminationOutputReference",
    "AppTimeouts",
    "AppTimeoutsOutputReference",
]

publication.publish()

def _typecheckingstub__4df3abe7a935384cde4c3257940849f32848e490de2b962e3b1794032ed3c897(
    scope: _constructs_77d1e7e8.Construct,
    id_: builtins.str,
    *,
    dedicated_ips: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppDedicatedIps, typing.Dict[builtins.str, typing.Any]]]]] = None,
    id: typing.Optional[builtins.str] = None,
    project_id: typing.Optional[builtins.str] = None,
    spec: typing.Optional[typing.Union[AppSpec, typing.Dict[builtins.str, typing.Any]]] = None,
    timeouts: typing.Optional[typing.Union[AppTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71188ffdd22d1c4c7fcdef308a1cf5d8807240f9127c47aea932ecb995652c2a(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8ef0ad4a5791352015dc28ed117f961a887a7a291b26aec3bc664416119aa9d(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppDedicatedIps, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf81a026819d3bb12ef63bfecc21f993f050e5481901d576c3ca0150b6064142(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__942fb3c341cfae473eb8784695dbc82fa24d16136d6a182945cb055d00ad8b80(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24fd8195dd6c8ea4eee39ab93c4757079afaf80fbe4d1cbd5e7876c8bc7f1b37(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    dedicated_ips: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppDedicatedIps, typing.Dict[builtins.str, typing.Any]]]]] = None,
    id: typing.Optional[builtins.str] = None,
    project_id: typing.Optional[builtins.str] = None,
    spec: typing.Optional[typing.Union[AppSpec, typing.Dict[builtins.str, typing.Any]]] = None,
    timeouts: typing.Optional[typing.Union[AppTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53b79b81c696f3e24bd6628d8c55688bb5432369361446aa8dc36386e4e0f867(
    *,
    id: typing.Optional[builtins.str] = None,
    ip: typing.Optional[builtins.str] = None,
    status: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40c38c49840863aa38955b9e0b4a4fe93525a5c992d7e78270be600abe302049(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d72693f0080da500304a701c969da82f7c8bd01768be03c57a684c699e081ef(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec18a339dc7866d1e7901125b1a4c85d2861641b1d88e3ff019591af397bd834(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40fff99cc0d03f34db2db50f61e4e7b8afb2076003853b6aa9b5802877c22b6d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8feea29c701ffba27d00b9f61afa837759234135929dff830221b7a7ed4a39f8(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4536dfacdaf09f292d804f8e2ffc1fb5dca1dd6a6a61025c9eadad5818b43e5e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppDedicatedIps]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fae65efcbd215df6f1a378a0dca7dd9109cdef8fd1a0712cec0313feba6a80fc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c979d5f707659ccdb76df5a06f08e7b6c71580deb1104e4cb4b59dd8e48f0208(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__382ae912dda34d5c159c90948cca5390b3024b6d18d04e94c29a074405fbae4c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__090d1da745544c23d96ff83c83b4cba8a2f636846cdb1902a6f324e4dfcd0caf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b661826349a60e8395b8cc48918ce19fb43aeaad660d159d338ea5729f78a20(
    value: typing.Optional[typing.Union[AppDedicatedIps, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b832495a405813c79d95af8699c07578ff52fe1df8b59054fa0d55d72b2809a8(
    *,
    name: builtins.str,
    alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecAlert, typing.Dict[builtins.str, typing.Any]]]]] = None,
    database: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecDatabase, typing.Dict[builtins.str, typing.Any]]]]] = None,
    disable_edge_cache: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    disable_email_obfuscation: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    domain: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecDomain, typing.Dict[builtins.str, typing.Any]]]]] = None,
    domains: typing.Optional[typing.Sequence[builtins.str]] = None,
    egress: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecEgress, typing.Dict[builtins.str, typing.Any]]]]] = None,
    enhanced_threat_control_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecEnv, typing.Dict[builtins.str, typing.Any]]]]] = None,
    features: typing.Optional[typing.Sequence[builtins.str]] = None,
    function: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunction, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ingress: typing.Optional[typing.Union[AppSpecIngress, typing.Dict[builtins.str, typing.Any]]] = None,
    job: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJob, typing.Dict[builtins.str, typing.Any]]]]] = None,
    maintenance: typing.Optional[typing.Union[AppSpecMaintenance, typing.Dict[builtins.str, typing.Any]]] = None,
    region: typing.Optional[builtins.str] = None,
    service: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecService, typing.Dict[builtins.str, typing.Any]]]]] = None,
    static_site: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecStaticSite, typing.Dict[builtins.str, typing.Any]]]]] = None,
    vpc: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecVpc, typing.Dict[builtins.str, typing.Any]]]]] = None,
    worker: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorker, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9dd51a26e13bbc241bc7b98a65c620faea5913acbbaf83cd03ddb28bad50907(
    *,
    rule: builtins.str,
    destinations: typing.Optional[typing.Union[AppSpecAlertDestinations, typing.Dict[builtins.str, typing.Any]]] = None,
    disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42e47a84b0b44b92eefed28e787d80c50796b5a7b956905269f2b803c82394a5(
    *,
    emails: typing.Optional[typing.Sequence[builtins.str]] = None,
    slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a57aa4096d44252cb5ff03956d144d9c1d5b9ae05610ae7b310581a92b9b2bd1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3077474ca50fc9968fe096742b4f4fcd2a0d7fdb1aa0bcffdc615f93da0fee76(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b6f2657c761faf7c5abe2c016fced7b1298de420242d4358a9a778a7aa99d00(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__906b4aa760a318ffadcd63f7e77538c94bb2d8124560c4932a0043e4988de0c3(
    value: typing.Optional[AppSpecAlertDestinations],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86e62bff85ce3086135c2fe0db30c3876059973aca8399636a85025883a35c4b(
    *,
    channel: builtins.str,
    url: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__912912e1bb7039daecd0e937566552dd0ca3027cb3acf426f00d740b61219c2a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee25b9f626df04b0080ef5c5ebe3143f72beb49b2b88915c477ec08859779373(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__902c3c2a7e19b22ab69da9daac073167b4e4112deb5eb1d0e4212e56987b2287(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f4074b9e1368c351347c775905a3adfa689b5c9d4eaf3a9f728e7c1ec003a5e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f136a115144463cf3e5be19d9cd2a8bcd6cdae728fc194ee862b46d6f133190(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__713902ccec94dfdcbaf8a9a8f987d6f126a29c28e181a25c97379b793ad9a18c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlertDestinationsSlackWebhooks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f62d14682c1a60473b76bd91206aac78dffe39a05705923766624e1d0a4a20a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__184ee1cb797aea226a95a02046c34847c92318fff2c426848308688f687d0779(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__368bafdc801091815375924c2a9902ccab37dd3df7981eb315e3f54ffe86d58b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93c5eb07e8f5dd364eb650815d70e7a32857dfe688439907ac6732d2638ab5d5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlertDestinationsSlackWebhooks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c532d92806e5fecb31344063b81b8ebdf4b209a9f45adf8d07047d97d42aaa4c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70e60a47c9c520f2147a024609c0414219b3841d0eaa76320e3e117444ae86d5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87f89f7c4a3b1c4c8c50eb7524593b1463ec579cbf9158a6920e2b1e5171e0e0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__665bf5efff0b1be516c78fe671ebeacdcd19a2ddc3006d1614e73f0817285e72(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa5b99375a67de9f67cd1a83795b8f74448089112593db9a912850d7cb70172c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a109763459518561b39daadf81bab735656e9ab2be1d0a63272aad4ea51efbc(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecAlert]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b71d226fed96eee91b5573862c02cf4f30199afbb6ea833e6a27257d917f07cd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e08cdf8cf5742616bac9d897f1004d1193b50e47824a08d67846d741f79b723a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a257331e79440ccbcfd66d60e74916cab5c15d3fd5405dbf18ab7a7a0ef254f2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04860ef4b93dbc3c8b306a7771513b20d0181ceca15d01c22d3e3fc5f235afa7(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecAlert]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c142f3e93eb01cddd2291ef464e249e246c1ffdd22645cf31ebf218407f73ceb(
    *,
    cluster_name: typing.Optional[builtins.str] = None,
    db_name: typing.Optional[builtins.str] = None,
    db_user: typing.Optional[builtins.str] = None,
    engine: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    production: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bd379fb5fdf22cef0f2f7ace0eec4b306f5e02a46e4dcefed3c9050a67ec4ba(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93ef1336081940305acf36acca33140a9eccbcaf8d53ff569817cd91d2e7695b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe87ca696eb3705a30749f5d6d927646e614e82972b1118fc3b6d5012e7f89c6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__989f3c4466c27377e71960aeda8840bd4bfb27abe36d16bfbd15b6ee5d614227(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a18cacc9014e52b03b2af92197c973b16f2b8e3cf406ba7ee5f7e8056c4602b2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9552cb92317fa40cad3af7edc4e9f8a21c260d89b60b784aaddd1ecef72edb43(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDatabase]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8422334c7c260cd704b8d5450017cba6179e776457072e022895ed0a7331e14e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca53c5684726ea98c7d1e4a3852b242eac9d33c96a53bbe3bd3b592fd363815f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__320b89854abddd00939e8b1369f9de720b0b1e90b44da49ce4fbd6e1c0bb8ea5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__236162ae41555a2cf493bfd160c01d86c3e638b38d2e3edf7d9bdf0a7e91c6bc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f293910f3dfefa38741ab9bd5c91702d14ae2484046e509d966a9d27805b96d4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e68adce4de1a6f2371f6455a406696b025affce9931d5473bdc8b320bf8aefa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb32a5b78568332bc06fb8985081c438beda362ffbfe5d46eb7ec74317b41d18(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1eb7d2c5df9f0006330d46eca3451b9e75fdf4d9051e4e4fc5317075fa3b6ff9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__226dd4b374f0d6e65d1adce30c288dcfb032b0d047762b78e78844cda81b8c71(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDatabase]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dad909028fe4d571c7c75fe3f6158e29b7e6c32aa0d40b6950792b0ada407cdc(
    *,
    name: builtins.str,
    type: typing.Optional[builtins.str] = None,
    wildcard: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    zone: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7671f9fa5c31c6a046e0cc06ee5b9e848b481ffb994e66b4c3b229ce1f9cf868(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__185c61c5b3c7ec53ef8a21b6e39bb7c2b57a0cce0c094848cf9ab169b153e1be(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b9455186b22eba56a9c0995f1aa8ddc30a337ea1ae2bf15c5258271b3597f94(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2381e41d961d7cfb1b7378115683e90a063b552fbbd6d919db6018affc67f934(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41ea3d0b15edcca68ab69e69d85a8f2fc6098df5b0150e7461fc65c6e3519973(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aeff35ff813d77f3448f0f52149d0e516ddb7c9e8173c132ab5ec4a2c2896610(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecDomain]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e33db8a027e00c43f23ff039de28b9ef1fdbae4e7bc7c658a03f2a32223379eb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56242112a7e05df96ec9ef8c94a7c246ff39d1e2b83cfa0a70362c15c987cacc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d60b763e3bfcc96ae415d3cd196e6507beb397089580753445dbd5cc40668cef(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c958cac3b714beefa23fdee25e9331c834d76e606d709c81d341909ef0014e24(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9634f8cd18ba8fd971c64de571dea65ebc86aa7b89dd265e6ab2931c55f140dc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6476bfde3debcf144093c3ede3dbe422b587e565baf8b65b907e55e8c3b25c9(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecDomain]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecd93ddc2704b728d607ca259967e68ded88c45455d28911dc9ed2ff8d2e256e(
    *,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9ed7dbbaa5e37fa3c802129d12a8b76f7ba9c01d41791c6a35d2470cff9ff9a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__150a1785d17194db4abd9ac6b27b6eed675e208a73edc1f8e878f7746e607f94(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ea68c66b7b9388497d3cc98cf12441a8739f447cb9ab36f8fe96551a83a7d66(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c451b591fcf19dbeee42d8577ee8d9b29545c8a193662e9f4c2e493c1f92331b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2641f0e8d8d5ddeeb1d2e8974ca8ec66e1ab2047152c0c6ad03d4ad865b60b66(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aefc166bfd7889ecacd8b3ae8dda25f0445588679c1b96bf44c13cc1e4db3d46(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEgress]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60f746caf4c8f80dac1ec35945d678993919ca57d119d01cf76a0047ca11a27e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca07f9b0edc97060783865a91490399cf4823307e4c3d1c5915867bba405b5aa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0641647e430ab55aaffece81ccc80fbfc01052331fb558ecd76e3bbf841855d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEgress]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__288d58277af9d9149b574a0b0102e003b234638058363a6442f964901600715b(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f5b8a2866ce84f77b18ac8b15887af07517cfa5d29b9712de80b4087f6a0a7d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af45b9f5f7ca90ef83a0f1247c87f73a9710fb14bb0519069e982337614c7b2a(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__378c08fe410e2cd1c8636e6e3f9e834832e5f26704aa70fedefeb9fe5b2f9ab6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5df46dd324c22a5909e21bf98f20654077e7f15c0b51b85aa89b8b85da30f38(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84a946b755c3dff6242022ece1a210872e6e6424eac519bfaf0528b3bd6283ed(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__974791a0ac7ac4452f3122428cd9f353447ebd4d1f3cfd783ba71dad184c6caa(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecEnv]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d1619d7456c9487c18d496d580dbc0bf7458c5045b88b209ad27cdd9b0b79c9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1402c0178ae9d43724b9e07abec63951f1d54b9c9d1aee3f569cca8b2d6776b9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ad27195cc196d1b00eaeeb3c4430d58f0594742e542030eb831169ec3a400f3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86d8b86a8c50ce873aac09ae01c9acb2024b4f7d8cca02476fa6fb97adca518d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8953a668e070b7926e55ebe24a9c8d6019d3522c2bd8b1cc3b9519f90cf74005(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd1d7b5603885c0e3f974c74b75c89cff87f6af012556e71698d8acb13043287(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecEnv]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b251b874e7a5952a662e222e2472a77f209b886162e10513caf04295d704e2cc(
    *,
    name: builtins.str,
    alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionAlert, typing.Dict[builtins.str, typing.Any]]]]] = None,
    bitbucket: typing.Optional[typing.Union[AppSpecFunctionBitbucket, typing.Dict[builtins.str, typing.Any]]] = None,
    cors: typing.Optional[typing.Union[AppSpecFunctionCors, typing.Dict[builtins.str, typing.Any]]] = None,
    env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionEnv, typing.Dict[builtins.str, typing.Any]]]]] = None,
    git: typing.Optional[typing.Union[AppSpecFunctionGit, typing.Dict[builtins.str, typing.Any]]] = None,
    github: typing.Optional[typing.Union[AppSpecFunctionGithub, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[AppSpecFunctionGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionLogDestination, typing.Dict[builtins.str, typing.Any]]]]] = None,
    routes: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionRoutes, typing.Dict[builtins.str, typing.Any]]]]] = None,
    source_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2f6a275dc8925777dc57e3f65262d9a77fbeda5bf66462fe458b19be8f143b1(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    destinations: typing.Optional[typing.Union[AppSpecFunctionAlertDestinations, typing.Dict[builtins.str, typing.Any]]] = None,
    disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11c1ec8fe8520982b9a3a16d61180a83842a04c2278e319037c28ceb4d928ae7(
    *,
    emails: typing.Optional[typing.Sequence[builtins.str]] = None,
    slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c47cecd9e0e806e02d09b23fb03995dc056071a2712b6cf3aa0de827aab7b71c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c8caf59a28702ac49bb63d27e5619e313e9982fe141af1e71d5b7a804ddf179(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca98385c64d11c9503af063f896c06bb0530cdbad1181ee69b514036a2afb544(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8adbfd1272d29c6ef86575606c7dde1321c2abd0c22ed138c133172cb371e72(
    value: typing.Optional[AppSpecFunctionAlertDestinations],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc9636407e086409574bd10aabdff325ef1dcbfd7fa0e50f6375aad59cc06950(
    *,
    channel: builtins.str,
    url: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__391b8a6c95f389d93f0f27d5eff6f27b9ecc6ae211e7f174c1f7670d2d023e16(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2ae0bd927dc927912f9ecba5b464174a0ef7153d9a709f56b885296c6a303e2(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23391299cd21c594f2c8927c85b2270ce781a184d0838131333afef3b7693f3a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3e4bf2471d05df9fbbf0a1d44c2230cac3efc78bb1c18c4d5bff90646f40d00(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba031afff6c2ad066ecb0310d4abcb07ca30e842c332f391705be93d384bbbe7(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3aa783f55d4904b6b8d67645568aee5e4cb872e25031bc86d5410069dde9fc2(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlertDestinationsSlackWebhooks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84f72eb3b539fc83f2f9a7ca2537420be6ca6029759f0c19eb2edd76673ac106(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ee77fa9478669a942d71e1775a6b7bd5cf7c1ca96a7549e6a5c7adbbec9e178(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00c8767017c761c4e7644b1f61abb52a8d3a7eb0fe0a2ccadbc6082f2e27ba34(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68e798deb086fe16f52c84dc64ab757fa023bf61f94dbf7a4b4a66c9bfc2a209(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlertDestinationsSlackWebhooks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62c8a9db4e98ea7c641d590eea7badb99f2c8e349144b68bb9dec20f41372982(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ee49551763a940460598761ba797f9a955d11b3d7fff70ba476000d98f5b930(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__756803929bf46fba45a303f0cd575fddf04b3a87c5609dbe61c67c0f2580f661(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd80dcfc5353d0f9b5d78cd46b7298a52e28179ea0bc67007f36a86d84c1b996(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2990f1a026ff7916421de781212c771f46bdba25cf7eb756144fb6444b46dcaa(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__700bc14f3cab721255828da6e51466de6d848a1ad28dc0bbbad579927c3252a5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionAlert]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb2a6e5049b56d01fecbeb7e659b918b2b3670d33c22d06cf865619ff952ca90(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85e1e56058e49d7296ccecb643716646619798b9348278e2c19350aebc9122c9(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dea539486b33118aaa792e65df5ab0217077b98f7d157c49311838843c59ca59(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0938a4dee4a136d84a1ce2cc11580c505f3cf775110cf1377b74d37d8daf56b0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ce33be5ae2ec90c47b9edcd5eae6003ab36a44adb80d9c3cd9939fe04249b94(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad6f524b7fc466ca59fcc108149016960b974b60d188269fae082ba3d026cbde(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0730d399c9174b7b27f7830907aec02cd0e7efa5336f6e5a073f42d5c7bb7c02(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionAlert]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b0797140786b964ef3dd62cbf8f97b85275c509ef4947de4bdbed8467fc375b(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08118ee77e0b1555daced469eba39fe0583537540e1c1b9e41e1f94121fec667(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0381d1334f6c05840e2a546182a38bd0b578ef607aa74c6f6718b53b880e34b3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e346215dfc13b9ba72f1c54aeff379a30e14fbf964cd43dc22ae77ef30789198(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9879b513f4d9a369e9dd833088e12444cbe0c17bf792889bb395c60b91b3d448(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5b0f43f8e7b3bd6f623cc1921cba7491ec85399ba91a4333dbce398a88a4427(
    value: typing.Optional[AppSpecFunctionBitbucket],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85344ee719dd4cf905970b2c80f4af5b55db06ad268bdf5bb4c9c73703e47cef(
    *,
    allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_origins: typing.Optional[typing.Union[AppSpecFunctionCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
    expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_age: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__daee1674054a6a6289b81c7892448a6dfd68edf74b4a28ab38d29f30e35e97e5(
    *,
    exact: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    regex: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d571a8302c3f10f5b3b72dcd95d6777338aad41090b5a603a1331222e7425bbd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94faa26335d0969f935be99c4309dee4c6305cd7a17c7b7581a0055db8f6b8aa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4dd39afe6dc616186ffe01c84217ff4eaadd355881d3f8eb57946125b51e5dc2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0e75a9c57430c1c96e74e838236ec17d3d8503113903faba95da86f079387d6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__576a46d6c70b9af454b64330ecb7242128c6ea4c99db3b51ffdd45b400506029(
    value: typing.Optional[AppSpecFunctionCorsAllowOrigins],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67b17d09dd068459b79946bd1676d72d4819f8c3f17e4dbcada18695a13acd64(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd1204791ee4b30eed4fa14c91340bc59311e3474c67a1d81a5f6323e39c7767(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bcea74cc2031182ae31ba8345dc8b780b865cb94798cc9495ce732a13068806(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c8d38bdd66e0bc3ed75d16571dd29d2eb8819fd9dc20ab298321c2596009556(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__707e7291b5db7a40b8d035af3e9f3adf5ddf3588555c5965d108ce4065538105(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72a3d15f5dd883cc66ff398a56220ca3ddc18df9783ebf7de97e20790010bda5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34a7783f5056cecd84931fed6e04c134cb4dcc8790cd6d56012951c22477b829(
    value: typing.Optional[AppSpecFunctionCors],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b6499b37af4c21a61809db40935cb979889a26eb5df5d55ae0c586349305e5d(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6283003a6864f7dbd42ca12caad20b5bd8904c6e45582be85c514dbc61ee70a0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b52bc03ea4805fb980173bb4faa1b7916e1079d33f5c4f19f2ca199b0ce1f68(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b2e73c71faa9f72cb39b3f7653b1f4abae90db025819cac811f1062c2e322a2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97499a2f95a0fb1bfb824c3488cec837967d0ca5b355a7b22ba511f8c65d0e6d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6de408e8c9ed2d87b80d9ed88bc31b2ede7624f4542f94c7c44656c07a9a55fc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91f00dcc3a042a4c4910e67e18010d1b0c0335a55f29dbb2ab43f44c972554a4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionEnv]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__396c5a7f9acb1dac2a1a6a82755133f77209e888295daefcf538c64a5c14bb0f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a68402a5496f10bc9e42ab76e055acc75a901ce70f523b10bb511b52b920161a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0a5288c9909bf75fe4fcd425eb4d2691bd3be245afbb19f346bda7aecc924c3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0f4b91f406667634a91b4e27d8801fe4607aecee2bc7529f897c92b12b6883a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd1c8073be85c1455f5b69a8586b97d653917833f14df954595a8f37a11af235(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__168b88ae5483dffd4d23fcd3fe27544c023997e7f39f6d8360e2889d371d6105(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionEnv]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f53ecb797f4e04428399385606e273b7ce9913a2a83d0ca080c8c93b5877e4cf(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8c5c183c5d8413a182c98b2cc03dc1d5a52362cf0f3e4f4153f0c3155b52820(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5564f24d72e2416daabc35dd59b678edc53ada7c327f8bd8d9d988ac0443083(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9871940bffe7b6243986e8afb0d9e2f6770985c439a27ef58b03317a4d22cd43(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dc94f911880ceeea6680123e2fccb355f0e0c8f783a3d00daf937a78ae15770(
    value: typing.Optional[AppSpecFunctionGit],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c41bd8641ed39cb2029431fc37695bc5775d933ad5efd2457e714c25743da5f(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e08a75a54dfae34b97c7a005f8daa4c9cac70b5c92afe40af6fd8e2e714820c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1213301ea0dea357458df2571ce24ec0b07deac79d839b336da98944c3d63803(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4125ef609bf2a04ab3b9e4c84c24b60157d61925ee72b3e2ff96ac6bde6437be(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1523c0bec840acfcad53759e78a81e1949074e92ff95eb26f6d7430f9bdba17c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1efd638b783b3bf5393fc3a843400410072c20e3387b38b0336cabfc84b1f65(
    value: typing.Optional[AppSpecFunctionGithub],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__321f497bdbee386782dc3dcada93c2464777709822f5eea74167a457ad9fac42(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c46084785bca56d6954a4f7bfbea47a4ffd94e90e0135b7bd19b89815cdd1d28(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aaa014da63d609d77d089ddcec72ee88570c2049c8e5bc62b559eb624081b601(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ca5b9d9173e02cbf6a32dd78d9b7f0b4cb3fb7e40b713fbf395282433fe817d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12b21d006ed43904c18a16d926492f1cb5f0f32c7115683097e21f0a58c58355(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdf8a0e891badef370b2a4ed8aa4d0154c1bf172081b620b086db5032d270e68(
    value: typing.Optional[AppSpecFunctionGitlab],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30858b953a85f94a58ddcf644ffa3c8df19d979dcfad880e9a4be950cb47a1d7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__923457eff4cf8ff6cc991e33d2059b2d03d4f2964a1ae5c2c3a3a7263ba7f349(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc39e4fd866adde8ae287738a7596c2ab8828f050a06c1043e1c6f37b0ebfa8c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fc8e05d11172c514183c76e85a194a23d21a8b1b16c5c392be5d1375a8fe716(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__376cd3ea7701d266290c05bf9560de8f8d7847ed95484209a54efa4a8f0240df(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e650427e6003526807b4ae40f3389bbf45356fdcf3adaf8b29b20c62a1772d13(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunction]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a79dc418c01632fe742e41a23bf7e69114ac1e02f574a6df27bd33ddc82129d(
    *,
    name: builtins.str,
    datadog: typing.Optional[typing.Union[AppSpecFunctionLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]]] = None,
    logtail: typing.Optional[typing.Union[AppSpecFunctionLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]]] = None,
    open_search: typing.Optional[typing.Union[AppSpecFunctionLogDestinationOpenSearch, typing.Dict[builtins.str, typing.Any]]] = None,
    papertrail: typing.Optional[typing.Union[AppSpecFunctionLogDestinationPapertrail, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6303070b1c668d899ba50f63dc6da0d546d42e7cf6c65d5f1a51163c498fd17(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a4071e148c4cc11c32e69b21a20d9ace01b9c59c8288b130338127913a0e970(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c444b5d1cbe7c607e9c9f64714d67065674590228dc30476d0137f2eb954c17f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b6b30abb4985661f226ccde8880bc1c9587c38c986495562f6669292db71917(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef4f39365a2a7f3daa88ddf60c596b049ac6730b866b6e35ab00a56eb5604ab9(
    value: typing.Optional[AppSpecFunctionLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfc409c4f142afeb1885eccd6f447b99e272f657ad5bdf33d0570217b611d9e2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccb362caf4c2bb787f93865f7e4b1ffc63985cd57663eb54b34f1336cba2dff2(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9f75a164b8100ed75109f404dcbf5de4de20035a2f559f7095ddba4e7b3d66b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6541e1ff72d5f6b78051aab692e5348c43b875661d9667215b4c5ee54cead98c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e831b6ab00b3395fd2139bb2dcb1d9ad1681246c4808e98ddde0c383583a49cb(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__140b23b485bc2f061debcb4e3f57ec946902bfe25b43de40d9879748ce591930(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionLogDestination]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fa38ca3fc01c1b0d400008e7f4f9c3436dde65f41ad19d7d3e48b34c3663673(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ed9d6d1db3a4070ad78ff8249fb17f525d7bf1d32458f30658d42c73eb890f4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95cfde3a8f9c9a8dc53181dfd71a74fd39b633a89ee6303dbe1ed3d81801e295(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4636064ecf34fc8af61b04d52e2e3ed69448ecb3c96a23eb1e89994e28e5cc53(
    value: typing.Optional[AppSpecFunctionLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8212194531bac4b1fd7e5afa417c3bd62ab8fb7813e8326fb97d680c5b9516f4(
    *,
    basic_auth: typing.Union[AppSpecFunctionLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
    cluster_name: typing.Optional[builtins.str] = None,
    endpoint: typing.Optional[builtins.str] = None,
    index_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2112ef844b5f0676e404e46859a248ee3fe26a6a50e5eb255b17d5b8694c6bf8(
    *,
    password: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__285bfd1afbf73c52c6abda2a1b2cc4ac12f9b8ea0c48f5e882582cf329a32ba3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07868f940a5ca9d6ec4c9f77bd8b030c480af7c747e05f737d27265a0638dc26(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fba63d20ccabb3d45830b8519ffe7ca97842df3ce265fc013c08a379d4d1451(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b0bbe2544457d334fdd93acf3b84f3c3a4886249dd4805dead63888f0dab4f1(
    value: typing.Optional[AppSpecFunctionLogDestinationOpenSearchBasicAuth],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bed3b2de339d13b027d392db6d2ef9203c072859c166822024bd670fd2ed9f6d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__644755880d3295528b559b0ae7a704e9b1999b48b6c359e5f087fd6eb1b761ac(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db58b1f1f71dba806b8cf4c7c2ae2afa5c69ff210c92234b3134bbf69e83e916(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dffb5f0639210280f86d128cd220af4e4f913c6ded0e35825e3b94be831f1dd2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3423c447dc8fe1f6adc16b228ad1dad4a16e2e4396433af21833eee15b903f61(
    value: typing.Optional[AppSpecFunctionLogDestinationOpenSearch],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e635bd1b87ec2dc669e174357c7f5dd35457152bfd2c0d45a45fb047f20943d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fce8a45f03828296766ad7c7eefb758e36d89b1340f22d445362e742cdf06c9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2fc48fb7aab26e8fccefebca1ae70e3c7071c12dce81acdee1199a808b59ab3c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionLogDestination]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a9f7d989889a78bc7b35a28a8899ddf8bb65531db068d9d56be5f73c9052c8b(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c7af33e25ea778eee0d4cf01b86392ae402005a54cece16630007f0bf894c4a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d664b72c7bb3cf55dfeb24e03f3c5607019ceeedab3e7708f07f2ec788fd9408(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34948092c3ad79dfd2b999804f4002b9cdc78a5dfefc874de52773fbeba49cdb(
    value: typing.Optional[AppSpecFunctionLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a0639923a619d05beb0823d07cd56b187c03e6ca8f4e8ae75b46a53a914779e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90e7c8e628e0cce6c1a678e955b6c865d80472a0bf877cd798b74a918a3be8a5(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionAlert, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fbf401f813fe199b414c37316262fd97a8abc06a7b41e365221056dcd846b96(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionEnv, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__370e661586949a3ca3c6edd8185dac4fff92e0f1b3c4c6e8107335d5a5a18e7b(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionLogDestination, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93b591fd733cf0ee3fc91a61a127332db2e519a0ff8ecae618e61b881cd85877(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunctionRoutes, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa6b83b7147eb28068a11b0d4653507d89a68d1e3e0e0fa3b514b619f5a9f09c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c4cb9caa0732ff8a5f17827c852373ac0249eafe80aaf741940be481ec2b7ca(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8799b6c752769369988b7c3236b495ebf72baa7d681bb84eadac9f190bb9c8e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunction]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d342fd7bacfdf2b533292944ce51ae4685ad88ae1417dc16429538f628f6dcd(
    *,
    path: typing.Optional[builtins.str] = None,
    preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5873e9d50ae71262d458e74509dcc12ce3993fae9f4b2f7ea1b7eded0e0a667(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3284c282591edfe8b50229b568bbe16f1d24241fd7be97c597a9ae9b80c9600(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__101d2d78c456d84af0a872a0897b932a75f12052e747181741678ed8feb3b791(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__380e739d589ddc6be11ef0b87b6fc7811330867cebcdb5ff0063b13ffc55c26b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f34a92e02eaa2d78f25efc6b59960836adcd2ed6742a40723e40812df48fa6b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3af2de4802b34adf467379c68db016c2e50e88eeb3ded2689f3db1dccdada5e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecFunctionRoutes]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ccdaa6d147a14d6dd41a9617e96596035de07a02c895f5742ea17f21853e689(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b40d4473d4eb9fb31db930656f04d979474497484b2cba4030ee1ba4221b82b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__677deadb8001bbf513313c3c0c549801b7fa93abffc07c3e931bac83bd033e6d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46b5c21e2bd5f94231ac2c2780c0ecab219545e3267b85b47ccbbab77066506f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecFunctionRoutes]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f76a4c002e24ffff3890c2f0f3de44e298b686d2e44075cb82181a7a0a9c524(
    *,
    rule: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecIngressRule, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15dda3d3068c9fb71028aec2d366fe813f774c12e288785e0435a8e40c4685a1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05ebbf4f773e313d4fc9470ebb9724fdf9ac8914851efc9967a55ba0d50e4ef8(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecIngressRule, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a4f75a9422cbe6ba8ed3430df23e06671d5da4c121ff5014c0130ddce1c3a03(
    value: typing.Optional[AppSpecIngress],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ff3a8a18d79528fadcc270e382c8bbd1805559a0bf36cc0bd4c2f58df28b9ee(
    *,
    component: typing.Optional[typing.Union[AppSpecIngressRuleComponent, typing.Dict[builtins.str, typing.Any]]] = None,
    cors: typing.Optional[typing.Union[AppSpecIngressRuleCors, typing.Dict[builtins.str, typing.Any]]] = None,
    match: typing.Optional[typing.Union[AppSpecIngressRuleMatch, typing.Dict[builtins.str, typing.Any]]] = None,
    redirect: typing.Optional[typing.Union[AppSpecIngressRuleRedirect, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d42f444906cfd089cdf46ab2f85df4d05d82a434215919e5f5f4d6b3d29091a6(
    *,
    name: typing.Optional[builtins.str] = None,
    preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    rewrite: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89d6830b49e1559fc4f7a939b3dc9340c098497c2b6584845a712d401715b698(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__429e61dfcc6ea42509240322a7d644a942c6073c8c4f360a7baa636f18409c1f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd01923c20690b03b3330b4ea4070b40c420ea29217496e273f7b79883b6b452(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16af3c867ea4e0395fead54d3670b1dd6f48b1bc93f1b638ccdda2c9035cff34(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23bf3accddbf7bcd85b724edf80e8a833b5561e9a03a38b76f2bb25b0d375d45(
    value: typing.Optional[AppSpecIngressRuleComponent],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e184ba3cfb46e4010add7cc9f8f4c583326df5326886a7f796e2b9b87367a0b(
    *,
    allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_origins: typing.Optional[typing.Union[AppSpecIngressRuleCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
    expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_age: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae87663880807dfa2828990887c35ad47a65ce57ca4150aa5ecf0f76dd094aa9(
    *,
    exact: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    regex: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b980dca3f8d594d30f6a2f169556260e52eee055a052076cbfa87c7689c4b0f3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b6d504acc84bb5944f43568d864109d652944d0c464703eb1062f7a31dd936a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__736c70ec6c9b9704bb256ff85879e26db9cbafbd3d93f3fde473a4766ca39f80(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a48ab4825bfe51489096dc73c6ac936ecec1f85589d11de0b63c6053a6581956(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be979a799bd3fdbb9d7e9ac5779b7814bb1803ceafe0f9a11c0f42e0db14c591(
    value: typing.Optional[AppSpecIngressRuleCorsAllowOrigins],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c70cfd0cc75a7d826c6eda2a949753ea9425730ee1bc3309aa8667a5c4dd0fe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a21eb8a42b6f9574bbe06eb55ee594236aecc2e615427504855d658aa5189580(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b45009d902392104202748eaee2becc4a2c0972eada4287422b532befc97c5ef(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18e5869aa7fb5884c617020d801afb99f01fc03f845378dde886fc1098bfdc56(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1885b7906f046c94baa894dc5db0f45a08b198074707a2262e7300b8ef076e1e(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17f011eaf84084fc5afcb841d3000f5578b164ce71738cad5a1067f6726a1507(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d24b600d8f10dd289ab41281d7d8ead54da2768c9e90f4a91e5418bc7fe78cc2(
    value: typing.Optional[AppSpecIngressRuleCors],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f5dac640b8893fec91f88c8024b7e2cbc1087222fa5a997e4b383e233de3594(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b2d8b47eff3ea217013eb9db7a1ff15fcd50bec56d86cdca6dd424810d99423(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__676f01c4fea80fe511124884ed6de0695f8f6da947003fea1200916005e6e2a5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4ee491890dc22b6be6822ae07ea2ead4df9cfeb053710891e40425f9fbd9158(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01e9512df1478db18c08aa067d71e7d90afb8a83341c42e4f6bb5e527a850534(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72cd9f905de85bbd8b2f5144288843b75303b38d5a7481b4301b663798393fed(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecIngressRule]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa2732c89acdb3de172afea00e7faf4af6cbd79e71027421abce9ec8fe374b33(
    *,
    authority: typing.Optional[typing.Union[AppSpecIngressRuleMatchAuthority, typing.Dict[builtins.str, typing.Any]]] = None,
    path: typing.Optional[typing.Union[AppSpecIngressRuleMatchPath, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f713c2538195d1f85e8b721b45e79fff0fb28d13f7dee95101d8268375f13800(
    *,
    exact: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6beb8a82215969765fece613d762b4f7296a1dba8439ed8755a07dffe3459459(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a18e1bd85e442566fe05ba87e00f548ec547b69c5c8912b4c05bd102762081b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1e3d925cbe2c8765d742535d79ab82c85f894136ecf98ff43e73a600cd15c04(
    value: typing.Optional[AppSpecIngressRuleMatchAuthority],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c97b36f80223f682a85815bb36633fa88d3545c07b1c8c505ac8ea4cd28ac513(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a5a8b67dff41aa37e77c381a0f27f1a0f4b4398781efbc9e1bb131c19e72f5a(
    value: typing.Optional[AppSpecIngressRuleMatch],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdc1808ecb38a5cde8b0618a441734891221b6050f72c2a677381c9ec53fbe49(
    *,
    prefix: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7692b4a26f85964de58b8d95b312b264d7de6fc8cd8d987f95df006fd001b63d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__215c9f2c05f8834c78745b5f304414d2c0dc1be86234d034f50269459024f645(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fbd910a3231fe69b6df3dd3977b1a2c31bf884f19dfe128c27e8be8e54810b6b(
    value: typing.Optional[AppSpecIngressRuleMatchPath],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e93686ddc263ab595dc45165454e4e005edf41715f57ea4717644883a5aa259(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5a201f81bec64a671bed046d3e92343b34979002eff1125f26ffc2a1fd32b24(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecIngressRule]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__268ca60f7fcd98af8a1760845d57f5432339d133b7977b2db8f3d7f1b2a61dfb(
    *,
    authority: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    redirect_code: typing.Optional[jsii.Number] = None,
    scheme: typing.Optional[builtins.str] = None,
    uri: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe0d32c3b334fc2fd28fcb4091fa52dfdd0f927bcb978ea8be8fdb0a7169c5b1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78e6ff27d1a8df58476d5e4f881cea6517a4a734380fabc2e5ee1aa878bde7ba(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__466b9a9223cb13422dd9c1966a2b4302581f1f1c726dfa71cd24fc90986bc2f4(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cec073b8b3eb9598c2e2c39d1818b02d7e20ea13dd99ca966cb2b2010d3362ca(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d24bf161f558f5b403fc2d0089fda5dac99a2310733073ad2c86659820b55cc9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51e21cf72d9ed251b565a507fa4892538e48abfb6fd724327c0b03663f24149f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5cdf1d4e6a94812772323b8f189d5aca2de8a860385e5ce004b6988a7b73f46d(
    value: typing.Optional[AppSpecIngressRuleRedirect],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcf26b5e573e23cc79b70ddf72d6aa00f01a1cd40f956eef57808531884d0cf5(
    *,
    name: builtins.str,
    alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobAlert, typing.Dict[builtins.str, typing.Any]]]]] = None,
    bitbucket: typing.Optional[typing.Union[AppSpecJobBitbucket, typing.Dict[builtins.str, typing.Any]]] = None,
    build_command: typing.Optional[builtins.str] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobEnv, typing.Dict[builtins.str, typing.Any]]]]] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    git: typing.Optional[typing.Union[AppSpecJobGit, typing.Dict[builtins.str, typing.Any]]] = None,
    github: typing.Optional[typing.Union[AppSpecJobGithub, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[AppSpecJobGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    image: typing.Optional[typing.Union[AppSpecJobImage, typing.Dict[builtins.str, typing.Any]]] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_size_slug: typing.Optional[builtins.str] = None,
    kind: typing.Optional[builtins.str] = None,
    log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobLogDestination, typing.Dict[builtins.str, typing.Any]]]]] = None,
    run_command: typing.Optional[builtins.str] = None,
    source_dir: typing.Optional[builtins.str] = None,
    termination: typing.Optional[typing.Union[AppSpecJobTermination, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be3acc81c4dec3067f5a0c63cfc670e83fa17c010017471b40714be206136607(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    destinations: typing.Optional[typing.Union[AppSpecJobAlertDestinations, typing.Dict[builtins.str, typing.Any]]] = None,
    disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8c84222282bd859eb1815e512331798071dd786514ef75f2c0587f4ec631bfc(
    *,
    emails: typing.Optional[typing.Sequence[builtins.str]] = None,
    slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0cc8e9f635b118ab865f194bee73fd9f6112832c30ca82c4a86dbeb12ceada67(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ff38bb1bc20e78a7c3b8e0c1405e94c0a159a7703819802bc757895db21e8fe(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9291431534337753f5fb8e37b3b5cb6ba325623ee511e9153d74bc8128c6cb24(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cff1a71bdaba3d692ab230ab2a2c66bc8e79816a2acc03118f3ed48a9665b68(
    value: typing.Optional[AppSpecJobAlertDestinations],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d38f58562057b5a448f7b25c935d545ab918be2256c963f5ed110571095b7b2d(
    *,
    channel: builtins.str,
    url: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3ecbb46d8f33ca0fa3f4126739e07722bd0c6368edcb4048d24914b75ae1e5a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41195a3bff1e16e9806dc65116e5a26f3e27a046244646e02fc57b7dac0bdfd9(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19476c9dd7b1530c0b4be3364f1ebabf703f22893fc1ac78de19c1f2828b2756(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8934f7e28628c3282ac84c49acd80c01792e5193b50d7a2baa78b4e00910490(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c1592e42155d999dc2ce719b45e07028ce285f4889046379c26a5fe4914114c(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc0c8bf94c0f4d79d19eb174c23141fc8aebce01039021576c61736cb737e868(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlertDestinationsSlackWebhooks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1dbc1e4a42236493f0efe44d5c2e5044f4a0a2d5e5023efd2df369820ca6f248(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e062bf2b2324713e50e1b663b547f852b1837b8e65882a41ce9b4f854aa8a5c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b48400837b5898ada9bbbd95072015d500ff9ad7f561ca22905a499c4d5d3df1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0eab49a58ccf74cc4d17b81b39c6012d78b78dbd7d91d777038b63392a7818bd(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlertDestinationsSlackWebhooks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__683527f4b33d0078b4db9450264d938a3ca68858b2310a843ba127496748181c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__433e45d4d768f6febeb6b64c5d72a1cecba42466442c2620f331bfda6a324785(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b099dc833297163d27b0aad75e96e0cb1c5d56d746a140cabca45f2c4cbe04e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0ce00b209040b0991935fc6f9932beeddbcba165c985603480cb4333439463b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20b5783f629c335e4e11aa6f0fd22f4dc3ce782159b251c0b93ff41683ea5e76(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb8c1a30748a72a5b109022eac67d9c1f213df28e3f8a1e78705f81666c8e927(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobAlert]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c7ad0a81aa8dd0a82fae1690233a165e1c442f24d8fff575a225afde5896e5c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac7955c0212a7a0e007ae6c34d06cb93012e61d04412d9d60464be6fa457a028(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f8310cce55dcafca6d540786d5e9f7162bfcf1b14ddb180e90e1e3ae81f87e9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e03861387e31e1b5c5ecf16f2e9ebce6ac3028bb44845d0e992ba0e65dd15595(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a73063b770e871d9d61ca1804bff6a5dbac926abd0434b912452eb72883d255(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9318c492dc14008e041fdbe37c60cc924001f2681effc46f757ba77c97015647(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e34092ab1dc1ad81bd415ecae02755bb202d4295090fff10147dae9fe081c509(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobAlert]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c52881e13cec22d64276845a1a72272f76b2c59ea94b037659e35d43ddd8eea(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e03c395c1b561b2cbbe102e317eafc5235c0780d83b78468b17330013703cec1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d50d4e7ba2e91391905de7e454929b5937952d367de56a6d4edce3f28e75402(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e27e2ab9a44636bf3101e693dcd3ee9bfd8a6f9e87ab0dffc03ab155cbe918a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05a10c2f6ee57cf7c20415cd8fbb5eae7bdf14cbb734e73258da900998b83e2a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e87dd064d8a45b515d7dd3b1994b38b265c533cffd9c308804fabcf4a1a9f76(
    value: typing.Optional[AppSpecJobBitbucket],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7aedade110b6fd4949dcb641193079c54c1774733af6947cc6f0a7e7b403f27f(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__025f2a702125212b5f3e96bb7296e342ced8379260dccbb2c761e879c3ff3672(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b82e1379dea6e037b4840823c9069b3e162771863bf1e69084d18af143613609(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__515670284bec05769c77bff6d5d1fa0fe1d3b8fc04a2080c62be70ba59f09771(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3b3d8cf4e09e9bb280f3f184374fa8d0cf423f76a6c17c095b01c6f3472073e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75d9dfe3b68a9c74938f1f78ce5af6f6fb3166b3de340161284e810af10a8ce7(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a861a333194faa5dee3641423fc87458d618681b059c312dd6cc08c1693c42ad(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobEnv]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f536e8994431e09692984503b99cad665464f63f1aac2d9b9dddd8b6fed6ac2e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__144ae7e83fdeb1c027f078f532dd92481b3c76452c7576a990a2400ae32e16f9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6baf81aae3afbcdeccf5edc14e4d6d90c659b5e8e2e766e946fbea70313b6406(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__777bf3bb9c39c9ea1c095fb80074547b0797b6754e24e059c7ef97ad3af07756(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5403dd0c51a58329b0e945ea452fa3de87004e9d02a2a4d6f151c6a6dc9cce2f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18b3fe5323a39cb8d0270c25173bfff3e09e7306a0f203ea088ce0e14dcb140b(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobEnv]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08d2c1d7b70088de9900003f6d2297d587d9c9e739ad4c178d73ecf56410a20c(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b2634b2e48123aa0c70c221cd1b7371ea6c38c5c0a8d6b599589598ac02bb7b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15f4e39cbb6a07b54461484531dc90792d88124ac99413bf57d50dd17d7db149(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c22b4571fccd4c4940732d52194c01f17d8da1cdeef879575030ff50244965d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33fdb84f283c1f34b01bef66fb9b0ecd36af101ee0ada491a9ff95cb562d1279(
    value: typing.Optional[AppSpecJobGit],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c04eb7945a7f896fdf4d993531051948a593c18b4ab890e4dbb372b7b52d7a2(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__633158b3aa5e169e137b809bac885fcef4b5eb384bb4a77656c9f0334cd7239d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4344cc2f962299aef6663702955b6876dfe41462a5f55171776c7450a17bd63d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb0953a7912b1344115af56418706f23ccce1210898de4fd87bd78244853ea76(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee97e03f3dc94eebb0f37943a502f31d66a38ee3b064ad5939902d31259f2408(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fdcd28c133407ec21c6b06bf14ad59d6f6e656a145cdbf2299c70ebd0ee7059(
    value: typing.Optional[AppSpecJobGithub],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61494db0431da4d97abebad512c852521311bae05b819a85f041b305fde6ed93(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3794062fa8fa6fb5f84908514e110e0aa0c8f96f17de8f4c61d36357a8a007e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd7e51358e3ac0a4e2967c304cd414690fe65738fbbadeeddfaabcd74fc053f4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__242eb697436c98884b812533820c1426263b5b1957534672506fdc5d61442e20(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__875fb9eba129ca9d7b73f4283047a7b8a3aa5c466ad0003d35a91cb1849bd41c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d00fe80a4a10dfa94cc9284e14fdaf623dd0095bfbdf01f1a0bd45a5234aff8d(
    value: typing.Optional[AppSpecJobGitlab],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44dd460b7f7ece75329b21baffe70152a36bce40236dbc74d512c4119dac008e(
    *,
    registry_type: builtins.str,
    repository: builtins.str,
    deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]]] = None,
    digest: typing.Optional[builtins.str] = None,
    registry: typing.Optional[builtins.str] = None,
    registry_credentials: typing.Optional[builtins.str] = None,
    tag: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5eeed21080bebcc3d53c42ca866601775f7a32d0de1503da046b5a946091c68a(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14c11d566166be2420cb88c9fe29a7b290dede25dd44aa5ba72c101f4bdf4cc1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb04f6f50e009bac35a8b4bb60430463aeff5d03cebdbe27b268e8ed64367c46(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb739a1d1d717a2db9c804168c6fa753cd670222151d1c4912974a2f78f33b11(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5adadc9903540a47218af4b7fe1688d011059f98617fb8e11afd4bdb52324c64(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ef1c52a18c76dfb80adc2024f7610d7d57e02fdb4c0479327c45e00636790b3(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc4f8b1f9e918655ffaa97eea16c9822a0346821c98823ab86d23fa44a7a2def(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobImageDeployOnPush]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cd85444be5a67c54256de5338649b0d7a4046c0aec288c2dee02f4893bce331(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9ec17e73190a6d6fd02c1d33a320297ca0b37683beb704085cc19ca1d6844ef(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d7fe7a1ec7a76dc0f25f113848f80ee2ce90f6b04ef879df227bcbd9249847e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobImageDeployOnPush]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__286e4bf5349c35c6712b71146edd054a932f0d5cbfbe3e3b047a501042cbc02b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__653c716e3db0c009d35157deee00c0744f6aae54b3cb47c4170db7dbdff9a0b4(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a6d1cacff41d41001a33540ca1d00cbafddc82616f19967df59850670c606d3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44a928b806b2e79622234fae7615f9bc372581804aaccb91d4f3861521adf705(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24cabaad8f6a9cbb51315101f3e3b22d89a6247df0fcc13087639c4c2bca2d9e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c2541bf4036dac0523136eef2561e638c445c5a06238e2def6236aa53ba5469(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__309d6fe324367aff40918dfe79c7b5d7809486ddead845080f63771b728984fd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__934e545667a613a39845890be41fbdba26b6fb1cd5909396f6bb662ddb066156(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b0bb53f23ab5475a7b10a19a9ce3d74c10c2e10b28c875c422c35016edb438a(
    value: typing.Optional[AppSpecJobImage],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fcab48dd8148ba73276bc7cf28e43a80c3599bcbf631f1fbeb7b0dd88c5fc0fb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d614a30876ec98aa8f2abbd97ac0529048bb0d1cf877f040f9beb4f7f0ecd39(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9db4b79b73feaeb3de3ead74f39421ddb34540e4602797862e909ef2671c2db(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c0aaa26e3aca95d7e64dcde1aeecedc744e85315f6d8d36c4db18d15c0cb8e0(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56a055a5c368fa883f559f651ee80d2449e6e249bd954e0ae476763451067de0(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2d7b2536af6ed63dec4d7dc031b3d592344f8f3dd2a8eac6e43e1827b4954bf(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJob]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__394c27d42c29c8731fe8ecbcc1f2f5104e7d2b28329a37196fe761cfc249c39c(
    *,
    name: builtins.str,
    datadog: typing.Optional[typing.Union[AppSpecJobLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]]] = None,
    logtail: typing.Optional[typing.Union[AppSpecJobLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]]] = None,
    open_search: typing.Optional[typing.Union[AppSpecJobLogDestinationOpenSearch, typing.Dict[builtins.str, typing.Any]]] = None,
    papertrail: typing.Optional[typing.Union[AppSpecJobLogDestinationPapertrail, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__101b1d73ee96df873cebf135ee73e0d56e034a8d909951fd5116730532ebdc2b(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff9ce25fb00b6a5c6ec5bbc3ff6302a2818c3db7cd8fa29f8d84c5662e43aa5e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a606f03fefd8b502e5bebdadb5dca2dc5bb5c5af31d95f107d7f16632544592a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad8ddfa1a77f12b43abcedc0b90c1dea8d5f2462c1663edd4e72c7f75184ad2d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__306c169885dea306970d6f0707dea4d5b1a243cc8235cd38b49b88677921f952(
    value: typing.Optional[AppSpecJobLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83a83f0de9b87e6b8787de7c3f30b0ad41ec8c5d664f62208c42605112b0f21f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46ee5113f2a65afbd0ef773dec10c1bafec7735a9d00bb0f33690801c0541daf(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e69fc03f4bf8c67a028d49e1481d9bdf7b318b6a6c6be4ea9789856f0f2e542c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4dc4fed8078d1ba433d860b9542a95f1c859df6d0d3c2ab45bcc871bf02b3e2(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b8578d0b8e7bdf97398623e58b91ee613ab34d2a7529331583afd1ff02d4ee9(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcd4f7722d4a6f9950bfbade435d98cc065c343a3a63ed9aadbaddf1fde2ac96(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecJobLogDestination]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f24899d209686731ab7718ccf26782f11d30f542dfd262414fa63f272a74bb5(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__597b2ae08864a8fa0a03aead6d19a4b17428f4dd013d3b13139fa77a7a15ddff(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e096fcb00094ffb2d5a944feac4a56e69810dbc9c3cf4f7dc73e6b9d57b6e400(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6e3a410dd16eaf7115ff186a2acfa787ee73df688a23591a77ff4be47840717(
    value: typing.Optional[AppSpecJobLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ee84eb08fa535f20570fe8f0d9746ef7bb06d154bd72a8c52edb9d2f8c4089e(
    *,
    basic_auth: typing.Union[AppSpecJobLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
    cluster_name: typing.Optional[builtins.str] = None,
    endpoint: typing.Optional[builtins.str] = None,
    index_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b5f8bdf0d8194818f9b0441404e52f1f0007707df2be8b723e1c06a74495656(
    *,
    password: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d55a07390f2758fb189aad92630d380e4153a6bfea5ef441e45a826cf3809388(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cd628054bbb99339a26fd90f49fa0242ec256ce1676082ffe2be186851dd875(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b3836505b7e350e2b621b7997c08921aab443d51b4a084bfd06ea7cd9961af5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e064dca62d8de626b5b0bc62d86dda7369f75a1f0dd85a4523c5baf5e633aac6(
    value: typing.Optional[AppSpecJobLogDestinationOpenSearchBasicAuth],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83e273109b65e0a3aa1fa900bfb9c4d036524e9a374566c952c222d0b633b0e0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d97812cdc74cfafb6d14bf563483e23b8e6c53e57516161fb2406cbcc44227ea(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9d86fea83f3006b3a3b07787aeef812b60c1f709a6c19a0e5b59d6f89762669(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__224afa9c81c048abd5527af33f0024b11e426b8ee8e2b54a84125a4cd5600e9c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3d8ea6de3b050ad7c53f18c6cbd6f1d31b064e2efea42feeced22acf750c3c3(
    value: typing.Optional[AppSpecJobLogDestinationOpenSearch],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c54c6302a955add499770ad0d79dc5f3413214a394503a474c44ceaa1050cb7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__224f80cb3500186b16570ef51a87716f88707e8fcf58e62bdfc57f01b625e627(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c8be2635576aa2fc08c276ccaa1528542ba0978504f2ca3ad9774d995549522(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJobLogDestination]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1393d74439e71eb445bd00e802e99ebfe0008c710e4372897abd910662c3f67(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f212e4b20635771509c548b3bee48bea1e2ce7cbc13729347efe29e8af5cdff(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95d446055a38a1abcc588a8279dc0bfd1deaa62f6a9aa209c62355feb241e36d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6412d999330b443f1c69f0e6346d192e6caf2d6dcc0cdcdb73d0303be6a5183(
    value: typing.Optional[AppSpecJobLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__927916c8a5b60022fded4a29d6df7a2fcecdd35a3cde3a50ae967ac15083d62e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6336c3d655aa6f99d17127e5736b3e92b689063bfc170fbd7623822f1f12e2e6(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobAlert, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7557e04810f1997f0d93eb7c0ac38b56e3f32308596214e3039920ca5d81c906(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobEnv, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5624d7ad0afd565fbdba1f8adc46c0f2a190938b2c3490a6d3839ea434b4ec2(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJobLogDestination, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eac2642fcf284e0bdcdf5330b173d53a4246212a28764e801fa252faf4a475da(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51e7ae88791f9e07f0c139ff7d98d63dc311ec640e19602cf5f71dd3a3b3a687(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e5d9da277f56cd490220afafddf56df19c570af7e3e98447365ab9781ea9676(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__538856a7762973bb974e279c687fc7f4d6db184fdd5c32c7d8b8b8a834cba654(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02a7a572c932498e6a4aa2fc043db56f53cd9fc22d55231808e7c0a74bca7203(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__821c8bd094b69a4f523542c9a5a3f63ed0965ea7b2c2c2ab3bd65a6a4fb77746(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__328e634de23bfe5811755ed029b8945a332cb884272980a2e61e71cad99489e9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51843a8c1e8bd6866691ec29e4231b373a87973c5078ecff4a4671ebc7ff3204(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f62d07e36d0275d95d5e90ec8e63e38ec300705f60a3f7d76e3896a743c28c2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__845898d6101a73a56d73bdfbeed921744c4d5bf175e1c442d16930d6961b8126(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecJob]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f80cb57838b4966dcc391dddd77729fa17881cfba97b3d5460254ef944c7a4cf(
    *,
    grace_period_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__684469dd0f8280a6c99614d2ddbfe7f4a15d61ece3f04a163a553bdb604e0fcc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d2a1a638d13b8d04fb7fc54ba34b5868b53dca6f0193ae044e438eccd345a01(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ce3d8c8c0e6f31b4b0786a5230e3f0eddb34e474b09681f8528a6c0bba67308(
    value: typing.Optional[AppSpecJobTermination],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cced29cc874c69f6ae69068913551d4930752c2e41e214fe5eae83b5a53b2055(
    *,
    archive: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    offline_page_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b83459b2c4f659b26dd75433f21eb96e20ed59db96c00407bc7aaf90bfd28391(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dcf31c7733d50b4e082323b402a843ce7b1ea8270deb26d704299865e7f2b09(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a90babe3fd0f553b7314c8963196234fa3a18c1614c137e050f2051887ecd05b(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce6886bc915f099183f6a2c8b595bee758cd033969f40484efc6ba5e13d9545e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbb4859728d0c04caa95d162b2b73fcad26942570bc1af82ff133a90eddef5a5(
    value: typing.Optional[AppSpecMaintenance],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e52978efe4b2396ab96a4f0f1c4f07a8f6b366ddd702b6f073fc21a4c8bb8a6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ac17a09c84cfef40d965e613ec763cff31189f1d28c67e10e09fe7bf16f9f1d(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecAlert, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88c174e62e79a0d27a962c395ff22ef66b131c78e54820bf2011e032144a2b45(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecDatabase, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bed8f38599577acab1e383d5d6b058ec7df2898b518b92501daed3abc00cf1e5(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecDomain, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f394c20a297073ae77916263c17fc04a7043446f4fe9feaf7dd68c67f591ea87(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecEgress, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b271275838996e60237f4875497b9d9be245426093b713c81d0f51f56cb2414(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecEnv, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e129cac45cb7f39eb2bdc92b5c7cd7b703abd8241b6234155cbad296c9bc8330(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecFunction, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__451e0a243239d94819cdc19aa11202bd6125f1b3c0ee90b2846456ba5c264182(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecJob, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a575f19e9aeeb36d6f4e20ce859f9b272b89974b31b4433b612fd29bf99e1d9(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecService, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7a3f99dae64b041b907069b883620ca7c421a9e1ccbb28ccc992ca5307b4b9b(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecStaticSite, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7aeb55ae46c35e7953665ca8d2f53d39db0f792de286744f953fd5b956aafada(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecVpc, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b7d7b21b1ef833279447b25a47e32c4542cc522d6205324662700b193670cfb(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorker, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08f0d3dae87a499a7228f0c5fb4a26f5d2af425090eea5e34484ce889a35a9b5(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e63d31298a251d40e17b4a3ad17a8691064eb295664a2f69738de482164edc81(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__500e3758f60a3b420025cc85c355eb1932b9ec463a0716d5f3479cc5c2ca57af(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8877f34f9dcf53e59d3b09245390ced72395e77254856699c1bb7d83e9a181c2(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33d86794683989d331be49302725dc1e55e87c5e42d1571816211e979d050e08(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82b0f9cbc8018fb6fc1aaa6f721c5f37f4dce020bf7ace10b229fcf7a210a0f2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3ff3602c572c287f4c84e53c7346e84152e850bf366a068dafbb80bd52bf38b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b88fdf8f6ae6e302739d5cd89a8ee11d44200bc8d0086d3a22bc7983f658cdaa(
    value: typing.Optional[AppSpec],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e83db37d611925e081fef563955859bf2fbe6d4c53a69f725614b73196cc8632(
    *,
    name: builtins.str,
    alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceAlert, typing.Dict[builtins.str, typing.Any]]]]] = None,
    autoscaling: typing.Optional[typing.Union[AppSpecServiceAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    bitbucket: typing.Optional[typing.Union[AppSpecServiceBitbucket, typing.Dict[builtins.str, typing.Any]]] = None,
    build_command: typing.Optional[builtins.str] = None,
    cors: typing.Optional[typing.Union[AppSpecServiceCors, typing.Dict[builtins.str, typing.Any]]] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceEnv, typing.Dict[builtins.str, typing.Any]]]]] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    git: typing.Optional[typing.Union[AppSpecServiceGit, typing.Dict[builtins.str, typing.Any]]] = None,
    github: typing.Optional[typing.Union[AppSpecServiceGithub, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[AppSpecServiceGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    health_check: typing.Optional[typing.Union[AppSpecServiceHealthCheck, typing.Dict[builtins.str, typing.Any]]] = None,
    http_port: typing.Optional[jsii.Number] = None,
    image: typing.Optional[typing.Union[AppSpecServiceImage, typing.Dict[builtins.str, typing.Any]]] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_size_slug: typing.Optional[builtins.str] = None,
    internal_ports: typing.Optional[typing.Sequence[jsii.Number]] = None,
    log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceLogDestination, typing.Dict[builtins.str, typing.Any]]]]] = None,
    routes: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceRoutes, typing.Dict[builtins.str, typing.Any]]]]] = None,
    run_command: typing.Optional[builtins.str] = None,
    source_dir: typing.Optional[builtins.str] = None,
    termination: typing.Optional[typing.Union[AppSpecServiceTermination, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__677a7d3e4066d253fb60aa58610734af078eb569f15cbcc21f8d36a8d2b10d37(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    destinations: typing.Optional[typing.Union[AppSpecServiceAlertDestinations, typing.Dict[builtins.str, typing.Any]]] = None,
    disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__691d93ff411bb93f8b66db08ce06984caee747ba17f3558220f96d648c44de60(
    *,
    emails: typing.Optional[typing.Sequence[builtins.str]] = None,
    slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47773438cbaa86368070337f2e67e36b1e0687ba89569b4d91aa07c72dfbc4e2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e12c18b2a110bc35fd9de9761d22a7ded55f05b58800c1e5790e40b7e1570279(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3688a5d797eba65c08d235be8aa3b7fa129293f8130765f4c3d4b165395502a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__210cac7d23afda1458727082b73c036c12c7de9afeed431b4a3076b6ffc7016c(
    value: typing.Optional[AppSpecServiceAlertDestinations],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dac18fbb27bc9c9ffafef0546b3130ee7d01b2030e75643f1e3194acfe3f6324(
    *,
    channel: builtins.str,
    url: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__297c3ce6c3e70e7f2f423e5e93d93c94d0a52b568764c14e829b64ccfdd39ea7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a69e796cc779849817588d6ff2c0641e197c1be48f25ca83ac9c35fce2edd3f4(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a38f51d4eb4b5582bc50ae4e0c8887f3b34343d5c006e31f4f3705221e6e813(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edb3ee558d90338d306bf0e00cd18e1d6a257ed87a18bcedf30519b63bb59cd3(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__607206e81b49a930709ea31649c56b6137f1dca2feb2db32c591f17eed4d0ae3(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d7884eb362d4bc7a0fe52df60247bbc90297ad7a3ab14d76696502c856f0aec(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlertDestinationsSlackWebhooks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7275af08599a17442be98e90eb0948a7e24f4ea112f702c2d6aaacea3a5aa58e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f3369e13bd756fbc960979734680766e2e89bc4b3ae95e7b3faa93e764b076a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18533f6f8fecd6b198769d58464981d3c80b2e0bf88b62c77e88008aeb75a9d3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72a90bcc0278b0a145b870d586057d666526f36f6554ad57210969fe51e3ce4e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlertDestinationsSlackWebhooks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__960cf37f6de07dfd1473cd9fe30222ac81b7dfcf25b79ce3e4687f67ce0a9dd8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88174e08d2f617e7070e5fc2084f47e44702b6fdc49ca72849fd8d151f5a9936(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9fa798b69266197fc2dc33856cb045a5d36f2052c8adf75e2d02861991fa49a5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc83bd6bb9af7156e9441adca62f2f38792e6a0546742543a1a6d038e67c7dee(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6693c7e9ade61c977b35a6d66686eb94efc776797bbb5ce3893a08e2f8a6ec4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f33b16cfd72bbc3d3a684a8f1847c8a9d79c19594de88c07c7516cc8389215f5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceAlert]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f0b2220f47e72e5653a3a5e59321a6a0d4bdc0d48b2588f8442b6f631c7c5e2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67b677f2d6680aff68e2ad7a1326af5bb50a85c1dec01ce1554d151d8b41249e(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6014802f5c8b24ed014a699fdf15f82a0a8e7d733eadfae3a5708c73fed1976(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f39101af717b2d8617820ec1c586b1fb8824c492df8d5fb945a4fbe26089fdbe(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9098a9eae739062c0a3d36666b94c0879b7faf6cd3251a3a609af20ceb1edeb0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63ea55e84ee7069a98d0d05f0f85386581f6809b123832e39376d1abdb6c9a81(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef61d0d55b9ffd77c52f078c8af9a29fe9cac6bcdfb42c39d9138b5ea2bbb5e4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceAlert]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__985ce244e4360c106ea6d02de443bc3b636d88ef63b1cf0253b2b5eb856b0749(
    *,
    max_instance_count: jsii.Number,
    metrics: typing.Union[AppSpecServiceAutoscalingMetrics, typing.Dict[builtins.str, typing.Any]],
    min_instance_count: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74f50d01f9710b430c966a97ffc12be19d94c7d700ec23d9c4035f70584bec26(
    *,
    cpu: typing.Optional[typing.Union[AppSpecServiceAutoscalingMetricsCpu, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aab0535f77ef524951e46cf11884f1e3c763c512bca9192dde4614c153790b2f(
    *,
    percent: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__164049787e40f73a826c938b477f9f07065cae0a3c017c25ca8eb21e8584f094(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c407dd076d3ed203f244cce51292b0512ca5bce954d31b5d6338abe401aed4e2(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0915e38b9b5a17177ebc57ab6d766be0ccbb06526af4266353c7bee0f89153c(
    value: typing.Optional[AppSpecServiceAutoscalingMetricsCpu],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f90707fe671d922ae3d2b92b1ac8f6ddbe7fb92515e122baf9d2dae96d05d169(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d0a0a10797cc2d91483f08eed91f9d402c4ed9ed75c691108abbd80e341c31b(
    value: typing.Optional[AppSpecServiceAutoscalingMetrics],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f371fe720622a4381e0567ccef81a0cf999d128071d52ddc2ab0931e81bf101b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1c16200d13cc78f0a53f8db0925d9a7cd8e6321930515d79e28164b96ff1862(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85789d7dcbe95a5e3129f40d34d060fbe9c972abbcf58180a3a9fa9c6b58eb3e(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc6603128470624b5d67332b1b63c729b711ef042b11caafb8c6f03cb86fdb1c(
    value: typing.Optional[AppSpecServiceAutoscaling],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__979ada8363c70095e484e9093c20bc2c0b70df675024a85d77292d62c1f3cb92(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcfee9085b9749e8ad0ad6241e2e9d4c826e3dfcce865d051aa6e184fc043065(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__203f0cdb05bea53e0b29a3a635fc8cd147f91d3d0acc8df93cf1c2bde9cfcbed(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41a427b1f6f6ae21f8e7af0474ae1121f3c9b4184e7d7bcb8e2a9dcb2c7b2b14(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10575f32e51e420650af38993498126f27987a7f51233fc3123d15e6b1463766(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5487d1c2ebbf1f73b6e0ab27c37c6454e4d842ef852c75e4730092da615ea70(
    value: typing.Optional[AppSpecServiceBitbucket],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44a8072b4f5b7b5dea4c7147709c903c1b3b863ac8789be82496e9148f96cee8(
    *,
    allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_origins: typing.Optional[typing.Union[AppSpecServiceCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
    expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_age: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66971ba5963e19841f72dcd605329522e7e610142b248336f443a9bd0330fa24(
    *,
    exact: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    regex: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9d396894537c1edb3a13eba0a74effffebb7f352419631bd5680a90c62719e2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c06a24fc9d935c37ad6b32edfafd8aa04fb92d93126e8d725a59b3f2b9200a3e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1dee837843229df9d7af7f9029ebbe7c489b8e64a7c40d44274c0e95d10b220d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f47bf5fe03152a7658b7d4fd0fbfe0a0064ed2e9d75026a6bc8b42014c9b2f1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21ba1011a9b5a1321c765ff92d574d8a2059d2a36c483d665ca092d0becb7f4b(
    value: typing.Optional[AppSpecServiceCorsAllowOrigins],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5da3effddfe810bbff1026140ed7a4d6036aa7584c29bdcbd26fd214cbe2d081(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f560d96810493434eb1022b2065b68c8951990a7bebc2caf92b6590b93a5ecd(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9588d738a914581d8fa98df7c73809a3a8fdcf2d586cb58261a04fa2b863708(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b9958fd4ab30c1c7d968ba912f566dbe676bb8ddc7ad4bc68eb0ff0639f32e3(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56d88d2c1bba219e74b4d04e4ef62aa55846cb6644359b9c1132bffeba55e65c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa12b9d722511b226b70bc8885360a4e90705733d93eaee93c11b8d832cdee13(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__acb44bb902446b4c76f0a1e8d479b0a5730c77aaa135c0577410b2ffc614ebf1(
    value: typing.Optional[AppSpecServiceCors],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2062de1d2b698b443d4444fa2921a0f7eb724d5398f99b6c88c955bdaa2e143e(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f21714640e6ee67f2540a212cc48eacd1e68b60c5dff1946e643c2c62cebdca(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e71578c99d0771ead5008a2c779293fd44088609d791e5cfca5b86e5c12161f(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6db1010770862110676220956dd867a966fae87a56b6a2b5b3a61bfaf69eee1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83eb2d8643729159a4bb86bc1caf0ffee681eb01ad510926a809d21990a112bb(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d77042d46422c784b5416c4532553a68dc618bdf8a497040983ed250b101ffc5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c592fd2cdb98f5890aa8756a9bc05e4b0e9dd35be6bbc6809ccc5dd0f1c087e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceEnv]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4d1554cabac46661cfcebca4044b584176d136fcce02a14e1ae09ab16fcb012(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05b58f5d64b5920bb33534a830c687c1e845739d1842e2eb395e35da17458780(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0a0022a59cbdeecd60f0a2bb55bb6e1700a1605a7485d790c301173f079171c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c89b9191190dfa5552894ed2d0fd902e2e133cedaa1ed740336f29a57c1cf5e3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f975bc1987ebe974c9e03837bf4756bb1592a381c9e992cc9915047425fabe45(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5068c6f1e485700ba665f6f02bd5499b7a2df3865f13baef15f904c2fa9a20f8(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceEnv]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c8bc5542ebad7a14da6f43f476178e579580b8c79a12cbd7add5ce085390f65(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27a947e28e5d753d3882b918704cbd26a52fabb2531148d70a8d4f7f28719ee2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aad5a0a507b3b8c8a8ab682cf0699912418cd6a085cf1edb92931a5e78ad467a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c06473ce62c9e10484b7b18bd97cb6a5a625bf6154a7fc551221413326beabd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c3298ba17fb92782ea19062244d6f78351edf71425652e3df20320477a44427(
    value: typing.Optional[AppSpecServiceGit],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bb40ede89a0b544b35976bf83a9990fe4b59b16144321d450444ca0804b9af0(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a1a2c5175b58e98493783d619fba05581022f57433cc524fe3a3f8ddeebe2de(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd0673d66763d63fdacb048654cf338f93a22c6a17ff2db7b31131eb0683f5ec(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cceece8490fdb3c7336df036f4386fa4ceb07eab5e6aa02eaa4bd24fb1698abf(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f86bc8e30abf7223850c5cebf8b6b609968f588a08ca0049d826df04f8b9eb4a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0556e7f7c0061b941c14147ae1755186d46ed55386ee6c711bf985534f93884(
    value: typing.Optional[AppSpecServiceGithub],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f920f7f33b412724fc2312afb93c239eb8746cf118ba9ef0e84eeeff26231d4(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5a0a404995add9c111faf3df97ad9b92892bdd7777236089b325d098d8124c1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__469b3df6e7298c0e4832dc36217f4baeb47f58f5ec80b307222b20427dcb6955(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c6d900f7eff27605882ad9b0b0994a2e21c5cd098b6c8399bc6f021665b082a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d8ab840145a69fbcd72f381cbec34a1fa18ab90c6079aa9c3072138f806302c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05c32ee459338868aa4efd6358692abf66bc50c07d136ed2f3f8d683831b4942(
    value: typing.Optional[AppSpecServiceGitlab],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dff3423822fbbe36d24554c3a6951943c9099232cae4e55a4c7d0bcc93d4f095(
    *,
    failure_threshold: typing.Optional[jsii.Number] = None,
    http_path: typing.Optional[builtins.str] = None,
    initial_delay_seconds: typing.Optional[jsii.Number] = None,
    period_seconds: typing.Optional[jsii.Number] = None,
    port: typing.Optional[jsii.Number] = None,
    success_threshold: typing.Optional[jsii.Number] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0489b99797eeddb6e549d8ec7664f6e1a0dfe50ef3c30797501845ccb1eb99ab(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60c6f75ba43197f83949a8c2f008775abc671213fa8ecf7e1c77b23059edcc28(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98d43a2c5a032ae49e30e2563742d2d13dac437c55ef3da0c16d84650596e97e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c84403d2326719eee3bc096bda0e963c64008753dba95100c1c14f871d9baf46(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91fb9d1918a7f20dc73f6869c8fe64ce47d9ad9318c6aa15ffc36635e785df33(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6268b69e46b069733163cf76f6fd8071994d6117e61976f7776f0e4e5b3c747b(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5f0bfa6b1c4acfbfb617cf2065b3335550ab18ec5f0281b8eb969fa998bb668(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6ec7d882c9ef2bc44ec65b52ce693da01f27cba0e855dc423cd3db02509ebd0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__633e9c4d7fd79f1b533da7dfb5fb36a1696dad86d1d9018040f075f6f276fcb4(
    value: typing.Optional[AppSpecServiceHealthCheck],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__feac39c18ca7b3aeb4ed686400f0e4c560705d0cea003d17cc16cebe1ac1611e(
    *,
    registry_type: builtins.str,
    repository: builtins.str,
    deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]]] = None,
    digest: typing.Optional[builtins.str] = None,
    registry: typing.Optional[builtins.str] = None,
    registry_credentials: typing.Optional[builtins.str] = None,
    tag: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a0b5e6adb65742638796bcc9a918e4584e0f7b94a8cfe560b5b0d9b07c8dee8(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d28db1a1f7e55f307a856c2d01e60ca8fba7ec0337e18735fa1205c5976b57a1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3449baf02b642322b725a7fdab49353eadcd87d4b2681832a17a493333ec927a(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a0006cc6e9c227fe6602da28fbffe94c89b8eb2e4f86388fc01774e744bdd60(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04c760a8877d63b4bafc9e3407c240c2333d7b58eee1a4b88240e36d5f3bb9e9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fbc862e4189921d05f33fd1effa33d037eafe548a1918385a00210a710a39aa(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4c61d393f93dccb6338413b5534916afd1e8f2958029bb2990d08bf2cedb1a1(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceImageDeployOnPush]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44c8b9b00ea987cf04fc58682d0fe19f3641e782a8f567bbcb2cee15aa7180dc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45d9f3dcb924fba617fba1288142ed227673a0c2e9b3fcdf34d8e64a676ca34d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7712ff516ad55d75b92fb2dd4203d1a7bc4a8d2126dc738ceef3fbd9dd8e3456(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceImageDeployOnPush]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38a74141e06ec96ea520ff83e4cabe33d46c20c2ccaa59696abe7e09cf948898(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c89cf67b70355d2d2e049f174b46044b00b96908cf4edf4007aee26579f3d596(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fbc2e1117fdfe3c01aec349db19f074e0a48ccd3843f26cb044de8870fc84c3c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2500bddd31e7a4f55cdc4a5eeddf2ff26eb5359b8b99de01ecdb4f6bedc8f6cc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9108994d87726ae737ecaff374b93f50eaa4ed7405803fdff52645ed2838553(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1586ec17ece3d7b17bae6f4a87b97bda400d904e7f3965423b55e54da438a8e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcf39b6ab499a21d2eeac1cc535ccf754e03784378cde8d642d65f589e0fa915(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6be2c222f7fd4cb2e6d6eb607b24062a43673a859610ed9878cec1559e4c3411(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f69e4b7f489d5ce3054131d8963116c53e5f14e742d9d39a8e00d2adb9155480(
    value: typing.Optional[AppSpecServiceImage],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__445ea9eb916f3004869ab1b9f691434f7a6ac1e6bd775637c8384e1f2a7024e6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__acfb012c04b87928ea0caa121e1c921ed56290b5a81d182f951b717441e1ccca(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a04a77beeaaa74543a78742871de41fbd16b3ec2a6b50939f71f1c70b88e799(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b9fb25b78ae70a781d45e4b828480e5d938fdb433676d9a033e18a94b5244a7(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23cbe2f66c1994c55fb7ebc52508f6d3070f8985ca474b618a2425a3a5dca5a4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16da2f02b850b4517800466438359cc29170fcf67650902c1afe8bc4d97f6217(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecService]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b80100048f682471fa81c84ce23a19ea5157a464bd81414a87e495f1b46f33e1(
    *,
    name: builtins.str,
    datadog: typing.Optional[typing.Union[AppSpecServiceLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]]] = None,
    logtail: typing.Optional[typing.Union[AppSpecServiceLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]]] = None,
    open_search: typing.Optional[typing.Union[AppSpecServiceLogDestinationOpenSearch, typing.Dict[builtins.str, typing.Any]]] = None,
    papertrail: typing.Optional[typing.Union[AppSpecServiceLogDestinationPapertrail, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30f3012bb9a93e0351da6111238992c4562d3a46a61e77f3d3d81b759545fd9e(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de43b364c482db7a39d7b4bcf48da7f3f658e4c883e4b303ad37a496b4fb5ffc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97dfd6b3e83f8a2ebeb446d5123d4ea12ebe0efb8eaca94363604bbf50624a52(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64d066f4a6ce478537df7b7d6a86bacb18aec1b4b37b61de18c0fea9ab0afff9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b998c8446bd5425d72b2197e9badd18791723d63669c81b550fdf0e1ba89322(
    value: typing.Optional[AppSpecServiceLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__070ed101274adcc79b311c77a040da407025af7fcd0608b618b72e0fdac290d1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d37306e457b8a3ec9cb4539b0b5bdf39bbaf711a4f7495a82dcf82f61a65fad5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4ed999da459735860eb7c3ae30f4353cd0aa344db31d2f1fda4475eac13b1e1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12baf602c5f8168beb36464828161bda7cc6797f646387db87d4f5d0415c491e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad34dc7807e796bd1fd0093c95f322067eba8b30428700e9dae733e031b1d31b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96522fd3f507b940b016b043f83bde39ba281199bda99e7c20be85a24a5221f6(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceLogDestination]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b5845d97c85d1db5d72d04d07931aa3ffa0d1dd0496199587478cc02254dbdb(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__731bc80aa1861304f499ab77d10d2f66a394a446c4bd52ed04479fa70f3ec0f0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bade63bcf466906fb7ae33f0c80a96aa7261c3a91818844bb2d48f4e2a71967d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__448eba8fe53b0487a63b908533f6a5f4b66120ceca7d2cb67524e93de7e3256b(
    value: typing.Optional[AppSpecServiceLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4c7c3b53d86c30504630be3654ef9326cf80a36212ce70a105c4e7186611890(
    *,
    basic_auth: typing.Union[AppSpecServiceLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
    cluster_name: typing.Optional[builtins.str] = None,
    endpoint: typing.Optional[builtins.str] = None,
    index_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ea2414b015234933f55bffc1bdb0030961fed80a5acc38815d98164ef5b81c8(
    *,
    password: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b92ab4a89f541fecf8330df163b0ad7770e86a9b3571cbde893901331c8a3f3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c529dae0330747806f1ed2ecbcfd4ab088670d8508d9098dd5436600a392dc7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__849bcac58547576f593c971bfc8066804483d82551cfa7dc5ba81efc92699304(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21a56d3ab27e5a458755a41fb91530091a34c3efabb97900b5b98e84d2a77723(
    value: typing.Optional[AppSpecServiceLogDestinationOpenSearchBasicAuth],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3340c81661cafe8bcfc0538ebcb9068f54658f151c5c38e9281b94e2d4560542(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b50829cb8953c9113909b34a649d6d1d331190ab8566b68c1f12f33673b4c031(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1600c6ba7da5e88a156f61d69fa5a972a0ccb54e2cc1acfa3d18c43c350466c4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95ac9938f9074e220bcf3db5bc5104011a87452021ee2537c8c3a95c0c68b83d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1d865810bf395438a570b505feb2ea45c1ffe5aca15460ce997996dca856c3e(
    value: typing.Optional[AppSpecServiceLogDestinationOpenSearch],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9a25f6710918fcdca18f773afbae505dbbfb14abb789d76339b58cf103a1c2b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__860e2dbeb0497178fa94de043a7b491f1c22d8af74789fbcd162a50543a8e196(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__302263cfd6845503cdbd10fe1b7908e4c846f744ca9e5e9837916a8756b5e3f0(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceLogDestination]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70ff15103afa3ea4a06ba7124b375fd02fc3cb8c19c14f6bbc8dd1b0287a6fd8(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c20222d974b7a759a352b2663695bc2e42d41ce4068bffeac5e2a10c1ffc993c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__857013c964c3ecdf1a518573019ff2fd5bf7d1908308aa0d056ebc68f9ff043d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__027b9d58a39d2b78fbda6a9ac08b88b501e5a9d8e296be52ac094c572121b917(
    value: typing.Optional[AppSpecServiceLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__393346795f5654fd9c842eaa1dff869b28c5663d0a93fb54815a0104d9821696(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db838f8cbb88ce4682de1ea160bfece2841e8508a308159376a66dd92cad412d(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceAlert, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e52dbabd7d90bfd4d06ca601c0ee51835388ed2086d89be87ee94a5bf487ef7(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceEnv, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71830b1e8004c3e118883545bca6cf49fff9dcd6308acaaa5c1ccc4470283828(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceLogDestination, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26341a8e39fc1352d621bf71436ed417587c837d97d4708487fd8bae11d1af17(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecServiceRoutes, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a22022548574b09cabca7b53ff2382e2ce8ca7c9aeac82929b724c8706559a03(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be21ae0329568ef97c7948e15592c794b124ea85024f2d5ce68e6072f4d0138d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd243b6c4ebeda316bfe2b97c54799aa90990f9b82bc9b0fb578de973fbf94e5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2fecd46ea4ece4b65b850d04a42efaf54dd99cae5aca5681222f3c1feac9526(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bafe4b9882c0f91e5f564d1a4f57f652bcc13ac25ea9766236493df39fb0ef3a(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__549847ad9240922f62d1087459c2d70c5e13d620febbd5751a663d7e5afcac01(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f89a581c4a4a6334058bf7f39e59220c716c6a6ea89938770e5105ccafaab1aa(
    value: typing.List[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1283900c8e2f3650701c6b219075a8da2965b7c26c98aff2270cec1911fa080e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5658493ab295515daacb2d7832ed966506a4752b93c0048bccfa40c4d0bd73e7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__077500d09e4bd85dcf27f14afc389ab9b4ed1c5a6dec10f9f58e8161695223d3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b31251e1c68ef137e911f2c53451afdcede567d7dab77e466bad94f93269b795(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecService]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64db7eef5fe9f8912e7540b1905b641473a17d6620a7b2d0b3157e7cf7d7bc7f(
    *,
    path: typing.Optional[builtins.str] = None,
    preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12bc039b16370d4fb2e2d84924e284b3304c6061f0984e22c10028a2c8d6ec48(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5982bde928cd7b9be589c713c33bd9ef111cbc759f3944dd94138bee680d8fc(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42b34f0941d6b4a19cc2b1a9b1369700b1334a7fab210ac212c516bca7ba4ba6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3dff9220ad75b5d449ef9b649d223884bbe237e7cea45e68d9275fc774f3faf(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__036535286d6d6eee484ae8aa495d24e91342b3a882621cb2fadc1155f08d0f85(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df9573640dcc848c4cb06db3d6ef6d67c494608dfe8edd77002eb7396261afd2(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecServiceRoutes]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03f86950289200649e2b9f76162a3e7831a363d359e1cc71205335d85e39c4de(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45fea86e78e8bfd0fd350b264e4b0843bd779258cbc8c54f1fcfde533b3676be(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2efd4968610b0da3704214906464f4adb0c3bb42738d69cdb9e033a2896e34e8(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0e32ef60d22349a36a948dad7bbb3d0bc860ca5fd267ab99d951f39144a4508(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecServiceRoutes]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__636713d0315d2fbfc70225f167516f0be663be910fbab2a53a19b5886fb98212(
    *,
    drain_seconds: typing.Optional[jsii.Number] = None,
    grace_period_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad5c51f0ea650bc4255646ef612885f69baee104c4d9d95e47f4fdcfb1e68e99(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1f50e0d38ea88871be886f6d2bffce0cff4a4b5799dbdebcc12145eca9e3858(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__753741d3d758decbc7c0898e1b92da5ac31b4bb896605306c17c5ec84e0a8281(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe09068b1b8890b603ee4f3b912c6184860d7a6327eec6bb4aea7858994c3343(
    value: typing.Optional[AppSpecServiceTermination],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5551bf6d6d5ce7022a35a629879384ff9cf9d5f9f56e0af2b1a0798c2f58cf73(
    *,
    name: builtins.str,
    bitbucket: typing.Optional[typing.Union[AppSpecStaticSiteBitbucket, typing.Dict[builtins.str, typing.Any]]] = None,
    build_command: typing.Optional[builtins.str] = None,
    catchall_document: typing.Optional[builtins.str] = None,
    cors: typing.Optional[typing.Union[AppSpecStaticSiteCors, typing.Dict[builtins.str, typing.Any]]] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecStaticSiteEnv, typing.Dict[builtins.str, typing.Any]]]]] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    error_document: typing.Optional[builtins.str] = None,
    git: typing.Optional[typing.Union[AppSpecStaticSiteGit, typing.Dict[builtins.str, typing.Any]]] = None,
    github: typing.Optional[typing.Union[AppSpecStaticSiteGithub, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[AppSpecStaticSiteGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    index_document: typing.Optional[builtins.str] = None,
    output_dir: typing.Optional[builtins.str] = None,
    routes: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecStaticSiteRoutes, typing.Dict[builtins.str, typing.Any]]]]] = None,
    source_dir: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__944ba0a525de008439090ebe0170dbf1ac048a1300cdeee8bd86e31ebe4aa95d(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5872c251ea7f422d6ad5cfd194b3363928664f3d10e45a9db91a9a5ad5e0826f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ee592dbd804fde382d61b1b1d5ab4d40bffbb50ec658cc2284ec83e5c293ed4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89b6164db7e12896f24d16300d505dbc5a3f28b1b515426ea29e3d32cb4187eb(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e0b8c5cdb4f76b2a8b9ba295776d140dfea005fcde2a4f38ad0f4830fc509b2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a32041b270ca8e3236d20e73a600e88712708aac4576ed90442e15f5f6b0dd6e(
    value: typing.Optional[AppSpecStaticSiteBitbucket],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2c435c2bc38ec7882c884c873e8320d2de481ed96d542f74bb62d3a00a838f3(
    *,
    allow_credentials: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    allow_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_methods: typing.Optional[typing.Sequence[builtins.str]] = None,
    allow_origins: typing.Optional[typing.Union[AppSpecStaticSiteCorsAllowOrigins, typing.Dict[builtins.str, typing.Any]]] = None,
    expose_headers: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_age: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea24cc1f815e13d7f696ae2393ad71eb998aa65b0f2dcf8e7a7efa7b91364c7d(
    *,
    exact: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    regex: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d245315a1bec694d20208a281f9cda80fffa80c394c25858356bf7e2630b6dd2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96c8f0ddad503aa99bef127165ca3f64c8a51cab11732b4f08e81de96a02d6aa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6a67a9cd7bef88c8c3725990b40de634a1c058ce2b20b9dc236c2bbe9c9160d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f088dc5ee29077898a58de2adcb94c4a3e27e450952780931f3e36167fc845c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da65095e2126e1af5d96908bc4089c6123ea146c356d074796dec56c068ea5a7(
    value: typing.Optional[AppSpecStaticSiteCorsAllowOrigins],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ea2e3b7c25cd5d5a2f8eb067564838ae3e3864d15cd5edd07a43253e2948f72(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7045fd4b3494d283cdfa9138cd560c0a215487a5841c19fed56af46b8ab27c31(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5dcd312027caf3982da9c5b57bc9e2fd2ce5b3c2d6e0514b1437d26a0d3f526(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bb2c8f7097b240d0c026e7bbeddfa500bb5040d2a5c7713bf795bd46e528c7b(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12c4dcab8af7427da5f800af2d220692332c207889f45b239c7a324d5f89a191(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f16e2eab11651f6fba7df613f825e04db7fed2d836b065a01ab38e82035dd00(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f33bf47babd05d6f713d9785878457c136bd7a8766f6bb98d32d12a6b0a8fb8c(
    value: typing.Optional[AppSpecStaticSiteCors],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f45000e7a35ce6e8d139a667ac15f2f56bc0020f55176006d3fb006bf38513b0(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af2a4303a7736cb67b4f4228e2df9442f60cd80e2c9971d25e917f1ed0a5133f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf5c06d860ddfcf2d7e36de7f7b0e65e23d4058a6783802060725d2745671c47(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b1c179e6282dcec6ea3ce64284ae94939247954eb28f678662f70740b65d742(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69ba5bab19fc628584e2163944c7ac7a7f4fd2236c9c27aed2f7b88d4a28bbf9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__070d78774e25f7f045a626383bc2577e9676356ede9dc3918bef6668e44640d1(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3b34a8c542ef9f52042255f2fa004eedea65f0aab979d1943f0f27569aacc61(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteEnv]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04ed76ac66f72d48df19437e0a0d95f1619fae4686162dc83cb5be5dbb4c8e27(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f024651eebd14dd1640b1a9f650bd78dbeef29e46610f4e9e1f5ea7087cdb387(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26460338b515bade8258741960a6bc7064766b993615a01619928aed8fb9c0e8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aff978eb8403c59d2472aa17e1a77f0b4032f2925838321033f614af9615e02c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7932556afa563ab839eb79692d115ede4260485020304c02b176ba6a6672ce4d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e73cef212292755b2364e5699ba7f1333adac04d85ea64bd37ff06499dbeb08(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteEnv]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f0c19f8040084d5f2463df575e378bd476e88a6a802f79715502e545888ef9f(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b183eee85d1cd1c3c6f53cdb827dbdb7da335f20ad2da510864e992db1cf8289(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a64f311ca22f77e0cb8e896ba7487cc71c02b4e79a525b6968d515b7eca6353(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__138aae0b67eced9d0a6c61045600eff7948c0f181fef741717836d0048eb2f2d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67ce6dfc762229b9da172952b8e160f85fb5cb5d0626a60908f6dd8fb2352176(
    value: typing.Optional[AppSpecStaticSiteGit],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f360f7167e0493bf054353beec9c25c7861a353545df29731ac0ed6ee25fe60(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c551ecdc66db01a4f1b8eae075b0fe2d83ba76cd60e02ebad35f8d1e4741044a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45a648045b24886faf8e2630149956f89b31b325764ac4519b4892302cd7cae5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f8674d8532321ccce9fd670d5c357dacd61f991676896fb506741453db1b01a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59e219a785a6420c8ccf9fa87ae2332f53dcb6a42fae0ccae0a2c92ad49b01a9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__262f9c9aa577fd3844608728738694260deb151343a9dd761f3c8a0097e51826(
    value: typing.Optional[AppSpecStaticSiteGithub],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2cb2cab7156878640c59de80c896ff6ace68228d6147175b8c3bf248588fcdf(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1bad7b75b7f423e7400b2f7bdd55a3c1e6a721ede308169834a65abb5bc5db7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52141c456f03f0f429f9bbbb253d1f157606dc99fecb1bd4c63b8cc3299c1662(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a687df483936e5f9d47a8a7c1119951ea9b9721239ffd4fae9012c86ea408ea0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0e7b0ae29f5440fc048571369875aa6f476efc957f2a8fc35e12032e3ac47e0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c86318c4e268de2549dbd0cf810c1039913846833b96dc5dd47e0b40709dbd39(
    value: typing.Optional[AppSpecStaticSiteGitlab],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a9458ac06fb58d06853571911cb5d1085f61b3c218c84c3bfdf4a65267805d8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f0c986033fcc2ec1230981a69c011f277a611a7579d8e4e37ee0b9c9948c669(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0cfb21c39bf23b8367a3f9428aa0c5ba2429b0190883fbf71b3d5650c4b93984(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__470e8aedd8ea67969401565048420f4ca0242a380b9f4a77c26fb6faf411f7f6(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__274142c06b5dc0b894c58d362c12daa2d5bdff26627109742a3ac389f9026677(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11c7e8003b6d0a45b81b4da51115592bebc6ec0eaf39cd83b2f4b3a108c3a160(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSite]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da734de3d059bf11215a7155c0710a98a220a3a1527d170173d5941e01b5245a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f90ed4cee0034e8739d0d8e107f4dec4620f56cfa1cef0fd611e98c7eb456215(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecStaticSiteEnv, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__928af6c90848a5ada99b5f5a7c4a82b40dae2533dfef398572b2436419c39b49(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecStaticSiteRoutes, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80ad1ff221dac9d398380575148dca7d93f2648ab60bafa42ad64400ce6c3226(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1617ae633d14d46537e10a723f04b59c9beb087a1b10a94f515f7239f233241e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2264e1ee92b34580706baffe288c78b1be576a2c29f46ed9e5c97c6d371bf8f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d60a835f9087ab51b76204d357d6b665905469f97749d3ddd7c74c11f473471(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b09b9909039122c4339dbcd9444d9125937c0f464d91e847aa7fde4b74eeff7c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1dc1a83249c3ddc70f2f1c43315810840f6f4348d4839e4b344e106a6354c476(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3301161621a8dfe114066a7a9e9b28d1f7a25b3ac818058d4571d2a6e669f4c4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be9739c40dc58c6ceb10500b0ffa4b9bd4f92d814c633905e1d47ce349ce08e5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8c8eaaebe921f186e6955b3558614f34f60a53fd90d285f6357f488a4fcf178(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e953cb972dc771773b70ef906d667937a36fb9f78804b6706c96eb08a4c9348a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSite]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33c26ecb74dd361707f483f5b2e547f46c542d733e86a63316cee58fa919f653(
    *,
    path: typing.Optional[builtins.str] = None,
    preserve_path_prefix: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__105d9af8e5ef0350d15135c60fc2acf343fa9c0f1a559c8cc2a88e5eb57f4091(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0faf44e4eb81eaa387e86d2da9f6b608616109fe9a6bc92895b3d5c718a8aa91(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1cceb97685b49818719184b805a4f7b443bfa70207383dacf8d95a5e24a58d61(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2fd756ac8d40003a1715fd44d989a324749730d3007b6ccb399bf80068f7162c(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ef31e80d13de1e4b91310e5cc4656da39710eebb9512a3f27accd069df4a475(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff5833b24dff9a20ceee73ef0d952ce905af3f77e6e9236c057f71a32a2087f5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecStaticSiteRoutes]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23555342944237d869aaf29ca06d3ed30659d42e52966e7f300f034e4e2811ab(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f74866adb4e77dc12f82f3611ab27cf47e69597b795cac7a952cf97565e95f08(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2a4b871e4a6b63b260b742c0a9602d70c4211b153bacd2807814b99c258b460(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24a9543cf24c9110eedbd4e191d1d651be72f42c6f599b0c26417da02c46e186(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecStaticSiteRoutes]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df239cf271283d9b54eec6a4d76c8da7becd54971c1266449009f5415fbacd63(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16b57a4060ff4ee91d85653e44263dcccbb8e09cae27622b10d5a6fb7f112a25(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38f1a44c80a824b4841148cbbcae47494ab9f7f1756ccb4d8956b04493c7c789(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b352033b222f3d4593be3225501af36422908befb529abdfcbde0ba56f0b84b7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2020a7e49393c175cae70374ed5a40242d094b595fe86bfc070fc9d763e71b4(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abc133f1e0b7e51162a228aa6a380821c12ca5af2c184173dbddd8a8bd09492f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5319262490e384b15ef3b1644fd3be3cba89d70fb277c83783f1ea83c18fe0ef(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecVpc]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8d9a506a498950d608249d8af3b5e8e14b78f7b7fee75d84dd7c4bf3ffb8279(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__621ac5ba4a2b2a90c69708eda36598e76b302b5e4b1871a427f5d985e1c2c825(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b754f78574e0b5358f46a4643d60fc85dc519d9303a7539075548fe8e53679c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecVpc]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea128fc4f2fa5198b5ab50797ccae8c31cc710116a663d6f8cc2a754e7650ccc(
    *,
    name: builtins.str,
    alert: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerAlert, typing.Dict[builtins.str, typing.Any]]]]] = None,
    autoscaling: typing.Optional[typing.Union[AppSpecWorkerAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    bitbucket: typing.Optional[typing.Union[AppSpecWorkerBitbucket, typing.Dict[builtins.str, typing.Any]]] = None,
    build_command: typing.Optional[builtins.str] = None,
    dockerfile_path: typing.Optional[builtins.str] = None,
    env: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerEnv, typing.Dict[builtins.str, typing.Any]]]]] = None,
    environment_slug: typing.Optional[builtins.str] = None,
    git: typing.Optional[typing.Union[AppSpecWorkerGit, typing.Dict[builtins.str, typing.Any]]] = None,
    github: typing.Optional[typing.Union[AppSpecWorkerGithub, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[AppSpecWorkerGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    image: typing.Optional[typing.Union[AppSpecWorkerImage, typing.Dict[builtins.str, typing.Any]]] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_size_slug: typing.Optional[builtins.str] = None,
    log_destination: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerLogDestination, typing.Dict[builtins.str, typing.Any]]]]] = None,
    run_command: typing.Optional[builtins.str] = None,
    source_dir: typing.Optional[builtins.str] = None,
    termination: typing.Optional[typing.Union[AppSpecWorkerTermination, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15d4f2d67b531897b0da50d601c2afb4db7d8bc46f225685ac05d43253b86407(
    *,
    operator: builtins.str,
    rule: builtins.str,
    value: jsii.Number,
    window: builtins.str,
    destinations: typing.Optional[typing.Union[AppSpecWorkerAlertDestinations, typing.Dict[builtins.str, typing.Any]]] = None,
    disabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e2a480076379fdc57dfa3393ab8019ffc50898129e53bda54b5ffc352f3eef3(
    *,
    emails: typing.Optional[typing.Sequence[builtins.str]] = None,
    slack_webhooks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1520c55dca5b521613f49c32e1885a67797958f7f7dbfe5995d7af36f83d4c72(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0758b457cd7b0379242a7d637178f4006ab9eab2012b75dd3e871572e5930c10(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerAlertDestinationsSlackWebhooks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c785b34beabc10bd2cfb1beb17fb76b8276e47075aa043b15e0502a3cbba0bce(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__011b2e2d18904064ad91186dcb4d3ad0b9a9122045936acf84a442b46674340c(
    value: typing.Optional[AppSpecWorkerAlertDestinations],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f792ffa843e6eebc83cb98bd351d612eb9f4c7ce90eaef8633ec514e6c727fd3(
    *,
    channel: builtins.str,
    url: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ae3af94f21c1d43a96c35f60ecb1eb1a6426bf45b736021256ca5321e9a7941(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__075852cc774a1341839a7d44b89088dc870aa2875a1d2916b89524cce1b5a72b(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1707c8a39db7be0bb0afd9f17aad55e4fb714c14d414115671320ad1d37fa2b4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69450bd583247520b64b11144cf2a43fdf3f74deb14e3c332d210959d683e200(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d78cf03c8a912c95166d2c34ce76fad33273a02d52c395dd912705468bcecf5(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eeb0bb931cc4bb1a99e2d147c14c3f661033dd6552689216077f7d3c61592b77(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlertDestinationsSlackWebhooks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9bb6fe7f43a1797129e2f1115cf7223651859aec1d3f8c7ca4fb267bcd79d4f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__589a2ac5b617a4b585edb52a7beaccaca63569196529718c69c4ba9d424e1a03(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6610487ef3422a5bdced643cbad87c24beef32ab8855b8be406fceab7bd73d3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b5818e0c0a55759306fbd31a696b166860eb786ab8eed3c0f5bc80f3b528262(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlertDestinationsSlackWebhooks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d779aeaf15f9fe7f513b7fa2feac5225dac9eb2f2f37ed3c927b6da1705d897(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0486fa072d1863977fb5a960db7a753158ae782d79cea7cb51c5375e55aca09c(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99ba398ac4fdc394bfc9aa073ff10ff6e27dc0916e3d7f97af50d6030263e811(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a57f859c4926a74b9c6b5580f9aabf0c53748d7fa0c7a78f6844d4a4b89c35f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__466bc79889cae3662156e3772f6e741e934764b2cf181fcd00e87635296f86cf(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36c98090d390bc1f5d8f2c41116cf72880bfff1721e42e61913074f579729763(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerAlert]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84adee9817df423ea2b687521b30a7d86b5e2ce2940c63988a312d313200e5f4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf9d230f4e1c9208f158c7a990c225323b160074e5d21cad637f20df9f23d04a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c77f12a00d0d23ef5ea29b4c3fd37698f0e0dd6d6a5f61c86b011ff265eb407a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4fbac76a1369a25079c77a7a112f3fc2426203297ec9099f8f5e511f84aae91(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__358effd1904febcb01aec98fd5761f41b53e28a4e302f33455fdfa944409d58d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3a5ff044af7bbc90c29273ee7905c7dcfb132aad8b9dc6c47f5ab2ddb4311f8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d30dac253aa611726cdefdeda969a66ef410615252ae5a9f55947719d9e6706d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerAlert]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f16d0f4c43fa29d267ea3ab19edde901e8f6c65ffa662e13e44b146a57a766a(
    *,
    max_instance_count: jsii.Number,
    metrics: typing.Union[AppSpecWorkerAutoscalingMetrics, typing.Dict[builtins.str, typing.Any]],
    min_instance_count: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d891a2e8680a289d5e06dc7778bc1e95145f7cbf76ac71deb5a72369cb87460e(
    *,
    cpu: typing.Optional[typing.Union[AppSpecWorkerAutoscalingMetricsCpu, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e27dc7a67350c82ef67aa83a61638fa61aaedde2946a654e4154ecdee47ae559(
    *,
    percent: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d158cd8d8d6ed19fe20946ac41a9c1872dce59e9468aa292e955f48f963848d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b5b47c22887da7a15d2aa5693d97b1b77470a2b01cdea0ed956975cfab8c945(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdee6c3868e72e86fb304e343b5af4a773112e29ca06b796eeab2a5a2e37fe2b(
    value: typing.Optional[AppSpecWorkerAutoscalingMetricsCpu],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a245093746d2f76c6aa7d9d14e8f20206f85533c153b67a7c47a9a2fa5c7c23(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70d90a7183088a7c6dd5ff55ea5ba10c946b075a67fe7b1aae0469c41c59d0a0(
    value: typing.Optional[AppSpecWorkerAutoscalingMetrics],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__059d6cfea2bda3272f9219569c415ddcbc9c9cfc45c554715381758dcc7d93a8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d813d41015660b1f5165f5ba238641abf2bcd36d33a0e65598711f78b3219e76(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__582b5b167f7a3968317f1c2580354ebafbcb4209a0d18b96aa899754e2017f21(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69d9017062d74f57008e31c4c9f5cb76c3a3ce7e2de0e2ba05e18342f33a7eea(
    value: typing.Optional[AppSpecWorkerAutoscaling],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e22012c3f13c0c0f29ea62a47e9f2bbd152135a4c4e428b4cf4209183c6c246c(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d473b53bdfcac9e83c8610c82d7c7e2e48b817e655deb94d2fa1451a6a3689c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f77db2658ee78dc571c67128d295d0a818d00b5ce3c3f6a3b019de2dfc9f902(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13342b7c889a09e2f54ae26d58d26b9b6a7dc23610d10bab13a8ba4714a265ef(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15511791028d18dd16f85e7aac167781bd18d0726da4d9355566327734442418(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb9ca1443f62baa039f0707396f2423d205257aef24494ab91c5b4f5e726fc32(
    value: typing.Optional[AppSpecWorkerBitbucket],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8aec839d8ad1906433521153e7e6116312082bc9a052d3ccef5cd9d90ebda586(
    *,
    key: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b0db79150e821627f5dca2bffe0728214f4386b9d0dd797d9370021dd72ec0e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1cea1d3bcd159a1b369472e72b868709fa66ce4f05302050bdb789a094ac3cc3(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d7159bbec15ca2ddb459689cc409f71727b13899f3adb35789f3529a1da6a16(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90e96495bcd7f7e66551f83da7fdf1bc21c21b812129cbdce6324a7be99b11a6(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26d169c8ead89ae12659cfec811cc5fba8b3c9dc948137d33d54420470c03572(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0f97db69017474f015f676e54731b7c612191523a07eb0e884ed1ba5d0805ee(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerEnv]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b242b4a7f1b2a697b2093cd897d46c820d78224afc5f06b81a045b31e31c661d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__377a2ee6e16bde6dc2a699717c7c79204b42480dbb6701ee3700deb1f25136ee(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a222587f6826105ab59c75368494a706d7290e54003ee8d7ea0cb6dd2cf7606(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82849edda798b34fa6432b984b567cc6c1b7b68861c7f09c35baf6c9462420ea(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82d164001992b24424628038c8f4a4515a4794f56851f49e30a486c87eea06f2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5846819f648f2c7867282d9d2d39b935d49ff62de6733505b794e14c7477d84(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerEnv]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08c25376637cb623208ef05f45345a5e67230425d7a41c481b98d5076657c418(
    *,
    branch: typing.Optional[builtins.str] = None,
    repo_clone_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92696592aebb78cbe225dbfd48e4fd6de0a6713d59186174ba2ba3a193c18887(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__562ca3ff92ff4480f0a58eaaedf002906844c401ab36a04a6846f5e4a5163ae0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da95fed8fc19e719c537f30777518e3fc1c246c1eb5fc1ba4b0b2941f9d7afd9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94a6fd0eece6433c48cf732fd55ada0e02a585f861b9f353985c50af6a4b6aa9(
    value: typing.Optional[AppSpecWorkerGit],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6941b892e3c58bcd3b98407324a6dc3b122f57cdc7a69347ee24c4181ec1aee(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e4f982996bff76d1cb10e80dfd4c7c69b241210661c2761d2408d2316bca019(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3c19ff97a06f6f9b4c48676c850b64b599a11062d260b7fb76262012c6cdf84(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8af69bdae5bb427f8a9c19a9f0c0c67790d9c72bb9e7cb531f6295228d19c3fb(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c712d5f8c71680feb08ca5f9de33ed92e6d20ab47a1ad48a2aacec88b6541fba(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cf2bb0254fea671cf27b14c18c5c84944575b54721576022c2871bbab97eb52(
    value: typing.Optional[AppSpecWorkerGithub],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b13077619be40abb9f155c2f918dfca129c766da0fafc57d3a0bc3271a6d4a7(
    *,
    branch: typing.Optional[builtins.str] = None,
    deploy_on_push: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    repo: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__608f8dd69ed0a5180d167820848e3a72c62b8049598a21dc94e7c3a99aec1e08(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__177bfd90e21cdb025945d23e92d6b90e76155137886b16465e1f7b85f941399b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e1ffab56ca581815bb2873b3553ed097795f53a67997c2e07e07f7204e9ebd4(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c6075ba94cf89cc34a2e43545eb9f7145e28aef7835317b2f4075e96d712340(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8dda533d9ed7114c273141445bd57be0826e3d31b07b077a0a06d178d8b8091(
    value: typing.Optional[AppSpecWorkerGitlab],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bc4f97e7b08294a09aa7c64759c248417a8ea2cf7f893b56f0e35936abd4a1d(
    *,
    registry_type: builtins.str,
    repository: builtins.str,
    deploy_on_push: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]]] = None,
    digest: typing.Optional[builtins.str] = None,
    registry: typing.Optional[builtins.str] = None,
    registry_credentials: typing.Optional[builtins.str] = None,
    tag: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f5085ada8ff64572db545c1e33e258c50bc32a96a70ae3ec476b048416dc8de(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5473048aec4f7bb903b7f899ed43680cf8bcb4ccce6068b056dd4a5c34eb101(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__786ffcb0628388e44ccad7551933543ebdf4ce6515a8621f0e70ed10f39624bc(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bacccfcc501ff60b7116a6148cf892f7e7586c26169b381d116071b07e7dfe49(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e295b606bdf2f0be6585334cd8f3ea3990d1489e02bb418eb1e8c5ffd221ea70(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff9e0ab6b3499f856b6493f80dea31814b09ba305b8961802c5e913e7e02f163(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c95e8d2bed8f2fa38b766faa045e0ce930babf7f7c3176b7f980ba9dd0c9b4a5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerImageDeployOnPush]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cd9e383caa06720da4c1da497fdd92176239d669e8a5b77d5b7ab6fbd3cf857(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2fc146bcdb5dada026090a15762337495b4a3bde99ccc65526c0b6b7640ec9a9(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab4ad0e43f784840a97313755f8812fc618af6a2248e9e95b7436355a711d638(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerImageDeployOnPush]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b3570cf4fa595bd498bbe420294cd612098dc4e80082e3337c29aa165631516(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eda6fa520ce02c19f993a60c9620b53905df479b670fcb27a80cd59b4f0a04f6(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerImageDeployOnPush, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3645230b75cdfbd3e93d36f6de7136ced46e86943c503f0437d59acc66b0ea7a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7116a6be8b747981168a96a680391f5e6f9527e11600ba3e096f318e52f62a49(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4539e4727ba8e686cc42c6d37e5c1d7907a52cc31ff07cbae6151d45d154dcb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32f212dd3b6e32a0f9e1c2f87de7af399ccac5f5490884ef834ae5db43dc75ce(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d5560abd368a9516080ff7b21c89dfcb60ac7b4161545b942f530bafea14b5e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30b7dc96ae4a1aa76a11debebe567f8ac3bfa15fdcee7554798158872f66a9f0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52b04bb12883cc9e79aff3a7bc6f342f4af99451fb04395a25df3268e475ca8e(
    value: typing.Optional[AppSpecWorkerImage],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f58f461d9d1f567e3e1ff18798d7f4612b5743e63397c3f18340421026a1452a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00504ee9700705205342db70339571cfea6968cd076982a1957a6da399245eee(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d71da69f23d508de6ec9d997a0197bae36a6ce582329fff0f45001677839c95d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__387b56728382af9d7f8ed5842416bde5773bda1eaa926237aadc3baec7e9282a(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21a89a7aec909ffeaf324550093685f164fc47700865bfa9050ed41f1758ec4b(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d3c3c1fa445633a8fe6787616b99526cc905dbe5bbfbda47bb360b5fc8e8afb(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorker]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0bc88ef84a90b462a47619a4dfacaccdf79201e11d6e6a6e3751b7bd8629cc5(
    *,
    name: builtins.str,
    datadog: typing.Optional[typing.Union[AppSpecWorkerLogDestinationDatadog, typing.Dict[builtins.str, typing.Any]]] = None,
    logtail: typing.Optional[typing.Union[AppSpecWorkerLogDestinationLogtail, typing.Dict[builtins.str, typing.Any]]] = None,
    open_search: typing.Optional[typing.Union[AppSpecWorkerLogDestinationOpenSearch, typing.Dict[builtins.str, typing.Any]]] = None,
    papertrail: typing.Optional[typing.Union[AppSpecWorkerLogDestinationPapertrail, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__054045d663727fb4dc9fd343ae4ffed5556e6f2732d28e242c6d6bdcac6d6ad4(
    *,
    api_key: builtins.str,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e457ef71844eab09fe26e6910b68eb8e979009bea23a01a281b01dc0df0b64d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b976b5b3273bf57fa81932a2d380319285d24dd57d73341396dcee1a1b24306(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8483ed09fbcc4a88270746545b5709c3383d14a9f92ac4c6e3a700e93d60c89e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d31239101bb70626afbbf8bd56a4bed7fc29ca16f0d0eba8aa29a189683e506(
    value: typing.Optional[AppSpecWorkerLogDestinationDatadog],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e56ea8d41e6ad406b45fb6389781c160d2fdac4ad7234f652f4367d5227fbc36(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d00ea0f2d291819b2e0df390be040af100b08856d7428e5e7d818705da196f0(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a97f49d65f11feb32ccb76eced07343ba750ca4becc6c419ce16103a42dc94f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98242b3343acf7ac52c87bfbe15e73443453d00ba7fd697fba8f449d32366bab(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26d91e7167929d434c8c96644ee9e6bbbbea1a62386067a45e0e7f5cf790a7a4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21ec745936e8f04a31dc219e356b365161ca93373c4eeffcc62cdde4ae52565f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AppSpecWorkerLogDestination]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0589d4bb65438c850cf5d7513bccfdfe0d52110026ed044a6857039cf04e5615(
    *,
    token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f09e230ac5e41a02169b338c465ea2cc39d7689b35d3310c17316097d9617e04(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ff0d9b5a73fc910f536f0e717ba6e417cc0a2544786d053bfa2a17166eeede6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__200e656c57b49d200a5bfa09383e60f7a7d4bb0230b3ee3929fa30059afb2471(
    value: typing.Optional[AppSpecWorkerLogDestinationLogtail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91e295c130c366ba206a5dcdc7aa141dffde54c4983e42a8620b73405279becc(
    *,
    basic_auth: typing.Union[AppSpecWorkerLogDestinationOpenSearchBasicAuth, typing.Dict[builtins.str, typing.Any]],
    cluster_name: typing.Optional[builtins.str] = None,
    endpoint: typing.Optional[builtins.str] = None,
    index_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47248e56135b4bc18874db7862da6e6dcd35591d64f6023d3c84c2f64cddc1dc(
    *,
    password: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0ef4d07817e7ed507af308e2f53da70b4cae6e351b1c6252fe8bbed8f326e21(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b60a6caf8a3e2ea43052e0fe51f42c6c67713bd8ada1aa9b687d9fac41e9b35(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d25581ef6e96d7c5a52521249b188d1d14a668e15303c628586f1b00fea7b07f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf71bb541402313c6a41c6856f7c3203ce60233dc794b7773fe787b244c28367(
    value: typing.Optional[AppSpecWorkerLogDestinationOpenSearchBasicAuth],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f87e2fc21a66f3278e9a8cbbdc414a00cb415d5aeab5db7ef3d112052132c857(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a02e75bbc88eb9dca9f90e11a4a3a4b5986c68a4e3d012abbc8f06a898351cd6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__789bd8cfc359655191602381db5245ceb3d7f2c3f47d81c416573b7b1ff3eedd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4ecb08516b17f0b8071b350050fed46a19a4fbdb134158755eab55a3e764ef5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f2935075e1dec0b21242e7fcfd55667b492664c3c89038b32a6d211d5b452ef(
    value: typing.Optional[AppSpecWorkerLogDestinationOpenSearch],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0c32b916f7d49f0748fcf8adb84860acf8394c983962c41129c53d843d86180(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50279ba169661c6cf71dd926831204e0663312321574f7be257c709af978ffb8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39306f5e2645d64307a21c6ee153a21268a580900214b5872715eae79cacfcca(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorkerLogDestination]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3dbbeb5a6e5d8703ff31ec8876ad51b604c7ffff4767d95758feb2fd4caff494(
    *,
    endpoint: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d246295cef3d56d2ec1174937da0e79b4d40407f21fad4c643832747336c0115(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b6242759d7c7ee90b21574bf09dd5d8c4189e67d44ee6af053ac72a5f56d777(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__563b69b969e237fdd117a7fbfd567ee39db4a8f476eb63aa2f3fc059fa7d89ae(
    value: typing.Optional[AppSpecWorkerLogDestinationPapertrail],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__312b7de52a955d810df21a3fc69e9314c94ed984c7760e2ea6fb3207b9dca68f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9cd0ee7ce0d45120221bfa9bfd626aa5e6aa9fbd10d9bb8caae90ecc556453d5(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerAlert, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08de3b47c3c90c7165b42e03962437225e946fbe7faf4703df24b61f08485169(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerEnv, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0dab23b186d39bec5473c60d8b615ca561d2ac00247e7420f106bd51a6ce6b69(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AppSpecWorkerLogDestination, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e87d43963494e8bddff17dcf55030f19fb3aef47973aaa68e0176ab28e91c163(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ded5884b8809373c6b9e22ec2d4010674a60117fea2353cbe114619a34992413(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c082085aa2fca0c669ac79ef6cc74b713609fbc91a7e24669f5a1379a4bc2ad9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf1f3255007fe3ce0c568653953d92405669cd54bebf2185add1370976e98fe3(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0bbb61f0f58d1061906be30ff3a99355a5cdeecc64e194be4e31bc348223bd2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab8d9b3c1ac0001c1f23a628153d554f3ed357ea2e10bf9ccf9b7e684f81cd35(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__447970bf71a278c711c281eec2ad7335afd5cf1553a4be3736a5902a74f0ec88(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b588071b616dca70aa3de26a59b0109ac9d6cf5882f16d2cca8732e7822b8ef(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1cb594eebe78865d4411dd225612d1706b790a9ab7abfa090a5bd2fc6ba332e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppSpecWorker]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1fc024fd89f790e34b9cb092aa90984994e4ce8240ca4abc5c80c6331e644b6(
    *,
    grace_period_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c36610f2783f2158aed47e06827edb15c527b1e208fedfed9906e9cda2dfd3a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5799da0b2f4efa53082879d72aa9ff2e2c9e606254bbab69f379848e4c41dbaf(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c7fa13e45834c723dce947174ebd4001cc734ef1af40aede3e7c5f197e30c33(
    value: typing.Optional[AppSpecWorkerTermination],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44ca5eac160d8cef10922e6197498ff5fbec42de3a6c18a740c5248d25c6c648(
    *,
    create: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__147693d99a0c606ca92c57643a713083f48fe911fda23535da8d55712dae1820(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__778262ed6f7c1f2512d123073b0d3f21b12ac5e7345754c702643b1763426fd7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1526192fb2cb9e7adca145d0f95f28c33199ec7366ff4860c026fd58cca6f331(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, AppTimeouts]],
) -> None:
    """Type checking stubs"""
    pass
