from __future__ import annotations

import ast
import typing as t

from pydantic import TypeAdapter

from genguardx._internal.util.constants import DataType


DATE_TIME_FORMAT = "%Y-%m-%d %H:%M:%S"


def cast_value(
    val: t.Any,  # noqa: ANN401 -- Can take any value to cast
    cast_type: str,
) -> t.Any:  # noqa: ANN401 -- Can return any value that is casted to the right cast_type
    """
    One liner to cast the given value to the given type.
    :param value:      The value to cast.
    :param cast_type:  The Feature Type to cast into.
    """
    if val is None:  # Short circuit for None as all types support None
        return None

    # The imports should be kept in sync with TYPING_IMPORTS - needed for annotations eval
    import datetime  # noqa: F401

    import typing_extensions as t

    config = {
        "allow_inf_nan": False,
        "extra": "forbid",
    }
    annotation = DataType.to_python_type(cast_type)
    annotation = eval(annotation)  # noqa: S307 -- The annotation is generated by us and is safe
    if t.is_typeddict(annotation):
        annotation.__pydantic_config__ = config
        adapter = TypeAdapter(annotation)
    else:
        adapter = TypeAdapter(annotation, config=config)
    return adapter.validate_python(val, strict=True)


def parse_user_literal(val: str | None, literal_type: str | None, *, datetime_check: bool = True) -> t.Any:  # noqa: ANN401 -- Depends on the value being parsed
    """
    Take a user entered string and convert it to Python literal or constant.
    Handles edge cases like:
    - BLANK => None

    NOTE: This does not handle nested datetime properly. If we have a Array[Datetime] literal_type
          it will keep the datetimes inside the array as strings and does not parse that into a datetime.datetime
          object in python.

    :param datetime_check: Whether to throw an error for datetime or not - because this function
                           does not case datetimes to datetime.datetime() but rather keeps them as strings
                           This is mainly there asa safety check for developers to think about how datetimes
                           will be handled and they have managed it correctly after this function
    :param val:            The value to convert into a Python object
    """
    if val is None or val.strip() == "":  # Treat empty value as None -- irrespective of literal_type
        return None

    # Allow TRUE/FALSE for SImple Boolean - like excel
    if literal_type == DataType.BOOLEAN.value:
        if val in ("TRUE", "True"):
            return True
        if val in ("FALSE", "False"):
            return False
        raise ValueError(f"Invalid value found for boolean: {val}")

    # A Simple String is just the value as is - so, return it directly
    if literal_type == DataType.STRING.value:
        return val

    if datetime_check is True and literal_type is not None and DataType.DATETIME.value in literal_type:
        raise TypeError(f"Datetimes are not supported. Received: {literal_type}")

    # A Simple DateTime is provided in ISO format already - so, we reutrn it as is
    # NOTE: We don't convert it to datetime.datetime because ast.literal_eval() does not do
    #       that for inner datetimes - like Array[Datetime] or Struct[create_dt: Datetime]
    if literal_type == DataType.DATETIME.value:
        return val

    return ast.literal_eval(val)
