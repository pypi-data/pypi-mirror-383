"""
Code generator for the daolite pipeline designer.

This module generates executable Python code from a visual pipeline design.
"""

import datetime
from typing import List

from daolite.common import ComponentType

from .component_block import ComponentBlock


class CodeGenerator:
    """
    Generates executable Python code from pipeline design.

    This class analyzes the component blocks and connections in a
    pipeline design and produces executable code that creates the
    equivalent daolite pipeline.
    """

    def __init__(self, components: List[ComponentBlock]):
        """
        Initialize with a list of component blocks.

        Args:
            components: List of component blocks in the pipeline
        """
        self.components = components
        self.import_statements = set(
            [
                "import numpy as np",
                "from daolite import Pipeline, PipelineComponent, ComponentType",
            ]
        )

        # Add transfer components between components on different resources
        self.generated_transfer_components = []
        self._add_transfer_components()

    def generate_code(self, pipeline_title=None) -> str:
        """
        Generate executable Python code for the pipeline.

        Args:
            pipeline_title: Optional title for the pipeline visualization

        Returns:
            str: Python code that creates the designed pipeline
        """
        code_parts = []
        preamble = self._add_pramble()
        code_parts.append(preamble)
        # Generate import statements
        self._add_required_imports()
        imports = "\n".join(sorted(self.import_statements))
        code_parts.append(imports)
        code_parts.append("")  # Empty line

        # Generate pipeline creation
        code_parts.append("# Create a pipeline")
        code_parts.append("pipeline = Pipeline()")
        code_parts.append("")  # Empty line

        # Generate component code in dependency order
        ordered_components = self._sort_components_by_dependencies()
        for component in ordered_components:
            code_parts.append(self._generate_component_code(component))
            code_parts.append("")  # Empty line

        # Generate code to run the pipeline
        code_parts.append("# Run the pipeline")
        code_parts.append("timing_results = pipeline.run(debug=True)")
        code_parts.append("")

        # Generate visualization code
        code_parts.append("# Visualize the pipeline timing")
        if pipeline_title:
            code_parts.append("pipeline.visualize(")
            code_parts.append(f'    title="{pipeline_title}",')
            code_parts.append('    save_path="ao_pipeline_timing.png"')
            code_parts.append(")")
        else:
            code_parts.append("pipeline.visualize(")
            code_parts.append('    title="AO Pipeline Timing",')
            code_parts.append('    save_path="ao_pipeline_timing.png"')
            code_parts.append(")")

        return "\n".join(code_parts)

    def _add_pramble(self):
        """Add a comment at the top of the generated code."""
        preamble = "#**************************************************************************\n"
        preamble += "# This code was generated by the daolite pipeline designer\n"
        preamble += "# Edits to this code may be lost if the pipeline is re-exported\n"
        preamble += "# Please use the daolite pipeline designer to make changes\n"
        preamble += f"# Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        preamble += "#**************************************************************************\n\n"
        return preamble

    def _add_required_imports(self):
        """Add required import statements based on component types."""
        # Add imports for compute resources
        self.import_statements.add(
            "from daolite.compute import create_compute_resources"
        )

        # ALWAYS add hardware import - it's required for standard compute resources
        self.import_statements.add("from daolite.compute import hardware")

        # Track which camera functions are used
        used_camera_funcs = set()
        for component in self.components:
            if component.component_type == ComponentType.CAMERA:
                camera_func = component.params.get("camera_function", "PCOCamLink")
                used_camera_funcs.add(camera_func)

        if used_camera_funcs:
            cam_imports = ", ".join(sorted(used_camera_funcs))
            self.import_statements.add(
                f"from daolite.simulation.camera import {cam_imports}"
            )

        # Remove any import of simulate_camera_readout
        self.import_statements = {
            imp
            for imp in self.import_statements
            if "simulate_camera_readout" not in imp
        }

        # Check for component types and add relevant imports
        has_network = False
        for component in self.components:
            # Add component-specific imports
            if component.component_type == ComponentType.CENTROIDER:
                self.import_statements.add(
                    "from daolite.pipeline.centroider import Centroider"
                )

            elif component.component_type == ComponentType.RECONSTRUCTION:
                self.import_statements.add(
                    "from daolite.pipeline.reconstruction import Reconstruction"
                )

            elif component.component_type == ComponentType.CONTROL:
                self.import_statements.add(
                    "from daolite.pipeline.control import FullFrameControl"
                )

            elif component.component_type == ComponentType.CALIBRATION:
                self.import_statements.add(
                    "from daolite.pipeline.calibration import PixelCalibration"
                )

            elif component.component_type == ComponentType.NETWORK:
                has_network = True

        # For visualization
        self.import_statements.add("import matplotlib.pyplot as plt")

        # Add imports for transfer functions
        has_network = False
        has_pcie = False
        for component in self.components:
            if component.component_type == ComponentType.NETWORK:
                transfer_type = component.params.get("transfer_type", "").lower()
                if transfer_type == "pcie":
                    has_pcie = True
                elif transfer_type == "network":
                    has_network = True
        for transfer in getattr(self, "generated_transfer_components", []):
            ttype = transfer.get("transfer_type", "").lower()
            if ttype == "pcie":
                has_pcie = True
            elif ttype == "network":
                has_network = True
        if has_network:
            self.import_statements.add(
                "from daolite.utils.network import network_transfer"
            )
        if has_pcie:
            self.import_statements.add(
                "from daolite.utils.network import pcie_transfer"
            )

    def _generate_component_code(self, component: ComponentBlock) -> str:
        """
        Generate code for a specific component.

        Args:
            component: Component block to generate code for

        Returns:
            str: Python code for adding this component to the pipeline
        """
        lines = []

        # Skip generating code for synthetic components that aren't meant to be in the output
        if hasattr(component, "_is_synthetic") and component._is_synthetic:
            return ""

        # Check if this is a transfer component created by the designer
        is_transfer = False
        transfer_data = None
        # Special handling for generated transfer components
        if (
            component.component_type == ComponentType.NETWORK
            and component.name.startswith(("Network_Transfer_", "PCIe_Transfer_"))
        ):
            is_transfer = True
            # Find this component in our generated transfer list
            for transfer in self.generated_transfer_components:
                if transfer["name"] == component.name:
                    transfer_data = transfer
                    break

        # Add comment
        lines.append(
            f"# Add {component.name} component ({component.component_type.value})"
        )

        # Add component creation code
        lines.append("pipeline.add_component(PipelineComponent(")
        lines.append(
            f"    component_type=ComponentType.{component.component_type.name},"
        )
        lines.append(f'    name="{component.name}",')

        # Add compute resource
        compute_resource = component.get_compute_resource()
        if compute_resource:
            # Try to get a readable name for the compute resource
            compute_code = self._get_compute_resource_code(component)
            lines.append(f"    compute={compute_code},")
        else:
            # Use default values for all required arguments
            lines.append(
                "    compute=create_compute_resources("
                "cores=16, core_frequency=2.6e9, flops_per_cycle=32, "
                "memory_frequency=3.2e9, memory_width=64, memory_channels=8, "
                "network_speed=100e9, time_in_driver=5.0),"
            )

        # Add function name based on component type
        function_name = self._get_function_name_for_component(component)
        # Camera: use selected camera simulation function
        if component.component_type == ComponentType.CAMERA:
            # Use a parameter or default to PCOCamLink
            camera_func = component.params.get("camera_function", "PCOCamLink")
            lines.append(f"    function={camera_func},")
        else:
            lines.append(f"    function={function_name},")

        # Add parameters
        param_lines = self._generate_params_code(component)
        # Insert params block with a trailing comma
        if param_lines:
            # Remove the last '}'
            if param_lines[-1].strip() == "}":
                param_lines[-1] = "},"
            lines.extend([f"    {param_line}" for param_line in param_lines])

        # Add dependencies
        # For generated transfer components, get dependencies from the transfer data
        if is_transfer and transfer_data and "dependencies" in transfer_data:
            dependencies = transfer_data["dependencies"]
            if dependencies:
                deps_str = ", ".join([f'"{dep}"' for dep in dependencies])
                lines.append(f"    dependencies=[{deps_str}]")
                print(
                    f"DEBUG: Generated transfer component {component.name} with dependencies from transfer data: {dependencies}"
                )
            else:
                lines.append("    dependencies=[]  # No dependencies")
                print(
                    f"DEBUG: Generated transfer component {component.name} with NO dependencies from transfer data"
                )
        else:
            dependencies = self._get_component_dependencies(component)
            if dependencies:
                deps_str = ", ".join([f'"{dep}"' for dep in dependencies])
                lines.append(f"    dependencies=[{deps_str}]")
                print(
                    f"DEBUG: Generated component {component.name} with dependencies: {dependencies}"
                )
            else:
                lines.append("    dependencies=[]  # No dependencies")
                print(
                    f"DEBUG: Generated component {component.name} with NO dependencies"
                )

        # Close the function call
        lines.append("))")

        return "\n".join(lines)

    def _get_function_name_for_component(self, component: ComponentBlock) -> str:
        """Get the appropriate function name based on component type."""
        if component.component_type == ComponentType.CAMERA:
            return "simulate_camera_readout"
        elif component.component_type == ComponentType.CENTROIDER:
            return "Centroider"
        elif component.component_type == ComponentType.RECONSTRUCTION:
            return "Reconstruction"
        elif component.component_type == ComponentType.CONTROL:
            return "FullFrameControl"
        elif component.component_type == ComponentType.CALIBRATION:
            return "PixelCalibration"
        elif component.component_type == ComponentType.NETWORK:
            # Check if this is an auto-generated transfer component
            if hasattr(component, "params") and "transfer_type" in component.params:
                transfer_type = component.params["transfer_type"].lower()
                if transfer_type == "pcie":
                    return "pcie_transfer"
                elif transfer_type == "network":
                    return "network_transfer"
            # Default to network_transfer for user-created network components
            return "network_transfer"
        else:
            return "unknown_function"  # Default

    def _get_compute_resource_code(self, component: ComponentBlock) -> str:
        """
        Get code for the component's compute resource.

        Args:
            component: The component block

        Returns:
            str: Python code for the compute resource
        """
        # Check if component is in a GPU container
        parent = getattr(component, "parentItem", lambda: None)()
        is_in_gpu = parent and parent.__class__.__name__.lower() == "gpubox"

        # If component is in a GPU container, use the GPU's compute resource
        if is_in_gpu and hasattr(parent, "gpu_resource"):
            resource = parent.gpu_resource
            if resource:
                resource_name = getattr(resource, "name", "").lower()
                # Check if this is a named hardware resource
                if resource_name and resource_name in [
                    "nvidia_a100_80gb",
                    "nvidia_h100_80gb",
                    "nvidia_rtx_4090",
                    "amd_mi300x",
                ]:
                    self.import_statements.add("from daolite.compute import hardware")
                    return f"hardware.{resource_name}()"
                # Otherwise, create resource with explicit parameters
                return (
                    f"create_compute_resources("
                    f"cores={getattr(resource, 'cores', 16)}, "
                    f"core_frequency={getattr(resource, 'core_frequency', 2.6e9)}, "
                    f"flops_per_cycle={getattr(resource, 'flops_per_cycle', 32)}, "
                    f"memory_frequency={getattr(resource, 'memory_frequency', 3.2e9)}, "
                    f"memory_width={getattr(resource, 'memory_width', 64)}, "
                    f"memory_channels={getattr(resource, 'memory_channels', 8)}, "
                    f"network_speed={getattr(resource, 'network_speed', 100e9)}, "
                    f"time_in_driver={getattr(resource, 'time_in_driver', 5.0)})"
                )

        # If component has its own compute resource, use that
        compute_resource = component.get_compute_resource()
        if compute_resource:
            c = compute_resource
            resource_name = getattr(c, "name", "").lower() if hasattr(c, "name") else ""
            # Check for common hardware names
            if resource_name in [
                "amd_epyc_7763",
                "amd_epyc_9654",
                "intel_xeon_8480",
                "intel_xeon_8462",
                "amd_ryzen_7950x",
                "nvidia_a100_80gb",
                "nvidia_h100_80gb",
                "nvidia_rtx_4090",
                "amd_mi300x",
            ]:
                self.import_statements.add("from daolite.compute import hardware")
                return f"hardware.{resource_name}()"

            # Fallback to explicit resource fields if not a known hardware
            return (
                f"create_compute_resources("
                f"cores={getattr(c, 'cores', 16)}, "
                f"core_frequency={getattr(c, 'core_frequency', 2.6e9)}, "
                f"flops_per_cycle={getattr(c, 'flops_per_cycle', 32)}, "
                f"memory_frequency={getattr(c, 'memory_frequency', 3.2e9)}, "
                f"memory_width={getattr(c, 'memory_width', 64)}, "
                f"memory_channels={getattr(c, 'memory_channels', 8)}, "
                f"network_speed={getattr(c, 'network_speed', 100e9)}, "
                f"time_in_driver={getattr(c, 'time_in_driver', 5.0)})"
            )

        # Try to get parent compute box resource
        if (
            parent
            and parent.__class__.__name__.lower() == "computebox"
            and hasattr(parent, "compute")
        ):
            c = parent.compute
            if c:
                resource_name = (
                    getattr(c, "name", "").lower() if hasattr(c, "name") else ""
                )
                if resource_name in [
                    "amd_epyc_7763",
                    "amd_epyc_9654",
                    "intel_xeon_8480",
                    "intel_xeon_8462",
                    "amd_ryzen_7950x",
                ]:
                    self.import_statements.add("from daolite.compute import hardware")
                    return f"hardware.{resource_name}()"
                return (
                    f"create_compute_resources("
                    f"cores={getattr(c, 'cores', 16)}, "
                    f"core_frequency={getattr(c, 'core_frequency', 2.6e9)}, "
                    f"flops_per_cycle={getattr(c, 'flops_per_cycle', 32)}, "
                    f"memory_frequency={getattr(c, 'memory_frequency', 3.2e9)}, "
                    f"memory_width={getattr(c, 'memory_width', 64)}, "
                    f"memory_channels={getattr(c, 'memory_channels', 8)}, "
                    f"network_speed={getattr(c, 'network_speed', 100e9)}, "
                    f"time_in_driver={getattr(c, 'time_in_driver', 5.0)})"
                )

        # Fallback to default
        return (
            "create_compute_resources("
            "cores=16, core_frequency=2.6e9, flops_per_cycle=32, "
            "memory_frequency=3.2e9, memory_width=64, memory_channels=8, "
            "network_speed=100e9, time_in_driver=5.0)"
        )

    def _generate_params_code(self, component: ComponentBlock) -> List[str]:
        lines = []
        lines.append("params={")
        # --- Use json_runner.py logic for parameter defaults ---
        # CAMERA
        if component.component_type == ComponentType.CAMERA:
            component.params.get("camera_function", "PCOCamLink")
            n_pixels = component.params.get("n_pixels", 1024 * 1024)
            group = component.params.get("group", 50)
            lines.append(f'    "n_pixels": {n_pixels},  # 1MP camera')
            lines.append(
                f'    "group": {group},  # Default packet count (was group_size)'
            )
        # CALIBRATION
        elif component.component_type == ComponentType.CALIBRATION:
            n_pixels = component.params.get("n_pixels", 1024 * 1024)
            group = component.params.get("group", 50)
            lines.append(f'    "n_pixels": {n_pixels},  # 1MP sensor')
            lines.append(f'    "group": {group},  # Default group size')
        # CENTROIDER
        elif component.component_type == ComponentType.CENTROIDER:
            n_valid_subaps = component.params.get("n_valid_subaps", 6400)
            n_pix_per_subap = component.params.get("n_pix_per_subap", 16)
            group = component.params.get("group", 50)
            lines.append(f'    "n_valid_subaps": {n_valid_subaps},  # 80x80')
            lines.append(
                f'    "n_pix_per_subap": {n_pix_per_subap},  # 16 pixels per subap'
            )
            lines.append(f'    "group": {group},  # Default group size')
        # RECONSTRUCTION - Add required parameters for Reconstruction components
        elif component.component_type == ComponentType.RECONSTRUCTION:
            # These parameters are required by the Reconstruction function
            n_slopes = component.params.get(
                "n_slopes", 12800
            )  # Default: 6400 subaps * 2 (x,y slopes)
            n_acts = component.params.get(
                "n_acts", 5000
            )  # Default: 5000 actuators (large AO system)
            group = component.params.get("group", 50)  # Default group size
            lines.append(f'    "n_slopes": {n_slopes},  # 6400 subaps * 2 (x,y slopes)')
            lines.append(
                f'    "n_acts": {n_acts},  # Typical number of actuators for a large AO system'
            )
            lines.append(f'    "group": {group},  # Default group size')
        # CONTROL - Add sensible defaults for control components
        elif component.component_type == ComponentType.CONTROL:
            n_acts = component.params.get("n_acts", 5000)
            lines.append(f'    "n_acts": {n_acts},  # Typical number of actuators')

        # Add custom parameters from component, skipping those already added
        already = {
            "n_pixels",
            "group",
            "n_valid_subaps",
            "n_pix_per_subap",
            "n_slopes",
            "n_acts",
        }
        # Process remaining parameters
        processed_params = {}
        for key, value in component.params.items():
            if key in already:
                continue

            # Handle parameter renaming for Centroider components
            if component.component_type == ComponentType.CENTROIDER:
                # Handle centroid_agenda parameter renaming for compatibility with function signature
                if key == "centroid_agenda":
                    key = "agenda"  # Use the correct parameter name expected by the Centroider function
                # Skip centroid_agenda_path as it's not needed and would cause an error
                elif key == "centroid_agenda_path":
                    continue

            # Handle parameter renaming for Reconstruction components
            elif component.component_type == ComponentType.RECONSTRUCTION:
                # Handle centroid_agenda parameter renaming for compatibility with function signature
                if key == "centroid_agenda":
                    key = "agenda"  # Use the correct parameter name expected by the Reconstruction function
                # Skip centroid_agenda_path as it's not needed and would cause an error
                elif key == "centroid_agenda_path":
                    continue

            processed_params[key] = value

        # Add processed parameters to the lines
        for key, value in processed_params.items():
            if isinstance(value, str):
                lines.append(f'    "{key}": "{value}",')
            else:
                lines.append(f'    "{key}": {value},')
        lines.append("}")
        return lines

    def _sort_components_by_dependencies(self) -> List[ComponentBlock]:
        """
        Sort components in dependency order.

        Returns a list of components where all dependencies come before
        the components that depend on them. Also includes auto-generated transfer components
        at the appropriate places in the dependency chain.

        Returns:
            List[ComponentBlock]: Sorted components including transfer components
        """
        # Create a name-to-component mapping
        comp_map = {comp.name: comp for comp in self.components}

        # First, deduplicate any transfer components with the same name
        unique_transfers = {}
        for transfer in self.generated_transfer_components:
            name = transfer["name"]
            # Keep only the first instance of each named transfer
            if name not in unique_transfers:
                unique_transfers[name] = transfer

        # Use the deduplicated transfers instead
        deduplicated_transfers = list(unique_transfers.values())

        # Create synthetic ComponentBlock objects for all transfer components
        transfer_blocks = []
        for transfer in deduplicated_transfers:
            # Create a synthetic ComponentBlock for the transfer
            transfer_block = ComponentBlock(ComponentType.NETWORK, transfer["name"])
            # Set parameters from the transfer dict
            transfer_block.params = transfer["params"].copy()

            # Set up dependencies correctly from the transfer data
            transfer_block._modified_dependencies = []
            if "dependencies" in transfer and transfer["dependencies"]:
                transfer_block._modified_dependencies = transfer["dependencies"].copy()
            elif transfer.get("src_comp"):
                transfer_block._modified_dependencies = [transfer["src_comp"].name]

            # Add to the mapping - this will be used for dependency resolution
            comp_map[transfer_block.name] = transfer_block
            transfer_blocks.append(transfer_block)

            # Update destination component's dependencies to include this transfer
            # in the dependency graph (not in the actual component)
            dest_comp = transfer.get("dest_comp")
            if dest_comp and dest_comp.name in comp_map:
                # Create modified dependencies to replace source with transfer
                if not hasattr(dest_comp, "_modified_dependencies"):
                    # Start with original dependencies
                    dest_comp._modified_dependencies = (
                        dest_comp.get_dependencies().copy()
                    )

                # Replace direct dependency on source with dependency on transfer
                src_comp = transfer.get("src_comp")
                if src_comp and src_comp.name in dest_comp._modified_dependencies:
                    dest_comp._modified_dependencies.remove(src_comp.name)

                # Add dependency on transfer
                if transfer_block.name not in dest_comp._modified_dependencies:
                    dest_comp._modified_dependencies.append(transfer_block.name)

        # Build the dependency graph
        graph = {}
        for comp in list(self.components) + transfer_blocks:
            # Use modified dependencies if available (these account for transfer components)
            if hasattr(comp, "_modified_dependencies"):
                graph[comp.name] = set(comp._modified_dependencies)
            else:
                graph[comp.name] = set(comp.get_dependencies())

        # Find components with no dependencies
        no_deps = [name for name, deps in graph.items() if not deps]
        sorted_names = []

        # Topological sort
        while no_deps:
            name = no_deps.pop(0)
            sorted_names.append(name)

            # Find all components that depend on this one
            for dep_name, deps in list(graph.items()):
                if name in deps:
                    deps.remove(name)
                    # If no more dependencies, add to no_deps
                    if not deps and dep_name not in sorted_names:
                        no_deps.append(dep_name)

        # Check for circular dependencies
        if len(sorted_names) < len(graph):
            # Some components couldn't be sorted - likely circular dependencies
            # Identify unhandled components
            remaining = set(comp_map.keys()) - set(sorted_names)
            print(
                f"Warning: Circular dependencies detected. Unplaced components: {', '.join(remaining)}"
            )

            # Break the circular dependencies by adding remaining components
            sorted_names.extend(remaining)

        # Convert back to component objects
        sorted_components = []
        for name in sorted_names:
            if name in comp_map:
                sorted_components.append(comp_map[name])

        return sorted_components

    def export_to_file(self, filename: str):
        """
        Export generated code to a Python file.

        Args:
            filename: Path to output file
        """
        code = self.generate_code()

        with open(filename, "w") as f:
            f.write(code)

    def _add_transfer_components(self):
        """
        Analyze component connections and add appropriate transfer components
        when connections cross different compute resources.
        Uses the unified determine_transfer_chain function for transfer inference.
        Handles transfer chains (e.g., GPU->GPU across computers).
        """
        from .data_transfer import determine_transfer_chain

        # Get connections between components
        connections = []
        for src_comp in self.components:
            for port in src_comp.output_ports:
                for dest_comp, _ in port.connected_to:
                    connections.append((src_comp, dest_comp))

        for src_comp, dest_comp in connections:
            transfer_chain = determine_transfer_chain(src_comp, dest_comp)
            prev_name = src_comp.name
            prev_comp = src_comp
            for idx, transfer_type in enumerate(transfer_chain):
                # Name each transfer in the chain uniquely
                transfer_name = f"{transfer_type}_Transfer_{src_comp.name}_to_{dest_comp.name}_step{idx+1}"
                transfer = self._create_transfer_component(
                    prev_comp,
                    dest_comp if idx == len(transfer_chain) - 1 else None,
                    transfer_type,
                    custom_name=transfer_name,
                    dependencies=[prev_name],
                )
                self.generated_transfer_components.append(transfer)
                prev_name = transfer["name"]
                prev_comp = None  # Only the first transfer gets the real src_comp
            # Set up dependency for destination
            if transfer_chain:
                if not hasattr(dest_comp, "_modified_dependencies"):
                    dest_comp._modified_dependencies = (
                        dest_comp.get_dependencies().copy()
                    )
                if src_comp.name in dest_comp._modified_dependencies:
                    dest_comp._modified_dependencies.remove(src_comp.name)
                if prev_name not in dest_comp._modified_dependencies:
                    dest_comp._modified_dependencies.append(prev_name)

    def _create_transfer_component(
        self,
        src_comp,
        dest_comp,
        transfer_type,
        host_comp=None,
        custom_name=None,
        dependencies=None,
    ):
        """
        Create a transfer component between components.

        Args:
            src_comp: Source component (can be None for intermediate transfers)
            dest_comp: Destination component (can be None for intermediate transfers)
            transfer_type: "PCIe" or "Network"
            host_comp: Optional host component for resource information
            custom_name: Optional custom name for the transfer component
            dependencies: List of component names this transfer depends on

        Returns:
            dict: Dictionary representing the transfer component
        """
        # Add network/PCIe imports
        if transfer_type == "Network":
            self.import_statements.add(
                "from daolite.utils.network import network_transfer"
            )
        elif transfer_type == "PCIe":
            self.import_statements.add(
                "from daolite.utils.network import pcie_transfer"
            )

        # Generate a name for the transfer component if not provided
        if custom_name:
            transfer_name = custom_name
        elif src_comp and dest_comp:
            transfer_name = (
                f"{transfer_type}_Transfer_{src_comp.name}_to_{dest_comp.name}"
            )
        elif src_comp:
            transfer_name = f"{transfer_type}_Transfer_{src_comp.name}_to_intermediate"
        elif dest_comp:
            transfer_name = f"{transfer_type}_Transfer_intermediate_to_{dest_comp.name}"
        else:
            transfer_name = f"{transfer_type}_Transfer_intermediate"

        # Add computer number if not significant
        if transfer_name.startswith(f"{transfer_type}_Transfer_"):
            import random

            if "_to_" not in transfer_name:
                # Add random number to make name unique
                transfer_name += f"_{random.randint(1000, 9999)}"

        # Import data size estimation function
        from .data_transfer import estimate_data_size

        # Determine data size based on source and destination components
        data_size = 0
        if src_comp and dest_comp:
            data_size = estimate_data_size(src_comp, dest_comp)
        elif src_comp:
            # Estimate from source component alone - use standard function in data_transfer.py
            data_size = estimate_data_size(src_comp, None)
        elif dest_comp:
            # Estimate from destination component alone - use standard function in data_transfer.py
            data_size = estimate_data_size(None, dest_comp)
        else:
            # Default data size if both are None
            data_size = 1024 * 1024 * 8  # 1MB in bits

        # Ensure minimum data size
        data_size = max(data_size, 1024)

        # Create parameters dictionary
        params = {"n_bits": data_size, "transfer_type": transfer_type.lower()}

        # Add group size - use source group if available
        if src_comp and hasattr(src_comp, "params") and "group" in src_comp.params:
            params["group"] = src_comp.params["group"]
        elif host_comp and hasattr(host_comp, "params") and "group" in host_comp.params:
            params["group"] = host_comp.params["group"]
        else:
            params["group"] = 50  # Default group size

        # Add network-specific parameters
        if transfer_type == "Network" and host_comp:
            # Use .compute for ComputeBox, .gpu_resource for GPUBox
            dest_compute = getattr(host_comp, "compute", None)
            if dest_compute is None:
                dest_compute = getattr(host_comp, "gpu_resource", None)
            if dest_compute:
                params["use_dest_network"] = True
                params["dest_network_speed"] = getattr(
                    dest_compute, "network_speed", 100e9
                )
                params["dest_time_in_driver"] = getattr(
                    dest_compute, "time_in_driver", 5.0
                )

        # Create the transfer component dictionary
        transfer_comp = {
            "name": transfer_name,
            "type": ComponentType.NETWORK,
            "src_comp": src_comp,
            "dest_comp": dest_comp,
            "transfer_type": transfer_type,
            "data_size": data_size,
            "params": params,
            "dependencies": dependencies or [],
        }

        return transfer_comp

    def _get_component_dependencies(self, component: ComponentBlock) -> List[str]:
        """
        Get a list of component names that this component depends on.

        Args:
            component: The component block

        Returns:
            List[str]: List of component names this component depends on
        """
        # Check for modified dependencies first (these account for transfer components)
        if hasattr(component, "_modified_dependencies"):
            return component._modified_dependencies

        # Fall back to the original dependencies from the component
        return component.get_dependencies()
