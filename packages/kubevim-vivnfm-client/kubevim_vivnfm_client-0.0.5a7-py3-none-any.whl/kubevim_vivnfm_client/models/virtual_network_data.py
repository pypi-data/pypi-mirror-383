# coding: utf-8

"""
    vivnfm/vi-vnfm.proto

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: version not set
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from kubevim_vivnfm_client.models.metadata import Metadata
from kubevim_vivnfm_client.models.network_qo_s import NetworkQoS
from kubevim_vivnfm_client.models.network_subnet_data import NetworkSubnetData
from kubevim_vivnfm_client.models.network_type import NetworkType
from typing import Optional, Set
from typing_extensions import Self

class VirtualNetworkData(BaseModel):
    """
    VirtualNetworkData
    """ # noqa: E501
    bandwidth: Union[StrictFloat, StrictInt] = Field(description="Minimum network bandwidth (in Mbps).")
    network_type: Optional[NetworkType] = Field(default=NetworkType.OVERLAY, alias="networkType")
    provider_network: Optional[StrictStr] = Field(default=None, description="Name of the infrastructure provider network used to realize the virtual network. Cardinality can be \"0\" to cover the case where virtual network is not based on infrastructure provider network.", alias="providerNetwork")
    segmentation_id: Optional[StrictStr] = Field(default=None, description="The segmentation identifier of the network that maps to the virtualised network, for which, the segmentation model is defined by the networkType attribute. For instance, for a \"vlan\" networkType, it corresponds to the vlan identifier; and for a \"gre\" networkType, it corresponds to a gre key. Cardinality can be \"0\" to cover the case where networkType is flat network without any specific segmentation.", alias="segmentationId")
    network_qo_s: Optional[List[NetworkQoS]] = Field(default=None, description="Provides information about Quality of Service attributes that the network shall support. Cardinality can be \"0\" for networks without any specified QoS requirements.", alias="networkQoS")
    is_shared: Optional[StrictBool] = Field(default=None, description="Specifies whether the virtualised network is shared among consumers.", alias="isShared")
    layer3_attributes: Optional[List[NetworkSubnetData]] = Field(default=None, description="Attribute list allows setting up a network providing defined layer 3 connectivity.", alias="layer3Attributes")
    metadata: Optional[Metadata] = None
    __properties: ClassVar[List[str]] = ["bandwidth", "networkType", "providerNetwork", "segmentationId", "networkQoS", "isShared", "layer3Attributes", "metadata"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VirtualNetworkData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in network_qo_s (list)
        _items = []
        if self.network_qo_s:
            for _item_network_qo_s in self.network_qo_s:
                if _item_network_qo_s:
                    _items.append(_item_network_qo_s.to_dict())
            _dict['networkQoS'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in layer3_attributes (list)
        _items = []
        if self.layer3_attributes:
            for _item_layer3_attributes in self.layer3_attributes:
                if _item_layer3_attributes:
                    _items.append(_item_layer3_attributes.to_dict())
            _dict['layer3Attributes'] = _items
        # override the default output from pydantic by calling `to_dict()` of metadata
        if self.metadata:
            _dict['metadata'] = self.metadata.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VirtualNetworkData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bandwidth": obj.get("bandwidth"),
            "networkType": obj.get("networkType") if obj.get("networkType") is not None else NetworkType.OVERLAY,
            "providerNetwork": obj.get("providerNetwork"),
            "segmentationId": obj.get("segmentationId"),
            "networkQoS": [NetworkQoS.from_dict(_item) for _item in obj["networkQoS"]] if obj.get("networkQoS") is not None else None,
            "isShared": obj.get("isShared"),
            "layer3Attributes": [NetworkSubnetData.from_dict(_item) for _item in obj["layer3Attributes"]] if obj.get("layer3Attributes") is not None else None,
            "metadata": Metadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None
        })
        return _obj


