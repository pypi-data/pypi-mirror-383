# 贡献流程指南

<cite>
**本文档中引用的文件**
- [CONTRIBUTING.md](file://CONTRIBUTING.md)
- [package.json](file://package.json)
- [eslint.config.js](file://eslint.config.js)
- [README.md](file://README.md)
- [CHANGELOG.md](file://CHANGELOG.md)
- [packages/cli/src/services/CommandService.ts](file://packages/cli/src/services/CommandService.ts)
- [packages/core/src/tools/tools.ts](file://packages/core/src/tools/tools.ts)
- [integration-tests/edit.test.ts](file://integration-tests/edit.test.ts)
</cite>

## 目录
1. [项目概述](#项目概述)
2. [贡献前准备](#贡献前准备)
3. [开发环境设置](#开发环境设置)
4. [代码风格与规范](#代码风格与规范)
5. [分支管理策略](#分支管理策略)
6. [提交信息格式](#提交信息格式)
7. [Pull Request流程](#pull-request流程)
8. [测试要求](#测试要求)
9. [审查流程](#审查流程)
10. [常见贡献场景](#常见贡献场景)
11. [行为准则](#行为准则)
12. [故障排除](#故障排除)

## 项目概述

Qwen Code是一个强大的命令行AI工作流工具，专为开发者设计，基于Google Gemini CLI项目优化，特别针对Qwen3-Coder模型进行了适配。该项目采用Monorepo架构，包含多个子包，支持多种IDE集成和沙箱环境。

### 核心特性
- **代码理解与编辑**：查询和编辑大型代码库，超越传统上下文窗口限制
- **工作流自动化**：自动化操作任务，如处理拉取请求和复杂变基
- **增强解析器**：专门为Qwen-Coder模型优化的解析器
- **视觉模型支持**：自动检测输入中的图像并无缝切换到具备多模态分析能力的视觉模型

**章节来源**
- [README.md](file://README.md#L1-L50)
- [package.json](file://package.json#L1-L20)

## 贡献前准备

### 签署贡献者许可协议（CLA）

所有向本项目做出贡献的人都必须签署[贡献者许可协议](https://cla.developers.google.com/about)（CLA）。您（或您的雇主）保留对您贡献的版权；这仅仅授予我们使用和重新分发您贡献的权利作为项目的一部分。

### 遵守社区准则

本项目遵循[Google开源社区准则](https://opensource.google/conduct/)。

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L1-L20)

## 开发环境设置

### 前置条件

1. **Node.js**：
   - **开发环境**：请使用Node.js `~20.19.0`。由于上游开发依赖问题，需要使用特定版本。可以使用[nvm](https://github.com/nvm-sh/nvm)等工具管理Node.js版本。
   - **生产环境**：在生产环境中运行CLI时，任何版本的Node.js `>=20`均可接受。

2. **Git**：用于版本控制和代码托管

### 克隆仓库

```bash
git clone https://github.com/QwenLM/qwen-code.git
cd qwen-code
```

### 安装依赖

```bash
npm install
```

### 构建项目

```bash
npm run build
```

### 启动开发服务器

```bash
npm start
```

### 沙箱配置（推荐）

沙箱功能高度推荐，至少需要在`~/.env`中设置`GEMINI_SANDBOX=true`，并确保有可用的沙箱提供程序（如`macOS Seatbelt`、`docker`或`podman`）。有关详细信息，请参阅[沙箱文档](#沙箱)。

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L80-L150)
- [package.json](file://package.json#L15-L50)

## 代码风格与规范

### ESLint规则

项目使用ESLint进行代码质量检查，配置位于`eslint.config.js`中。主要规则包括：

#### 导入规范
- 禁止相对跨包导入：`import/no-relative-packages`
- 禁止内部模块导入：`import/no-internal-modules`

#### 类型安全
- 强制数组类型定义：`@typescript-eslint/array-type`
- 禁止显式any类型：`@typescript-eslint/no-explicit-any`
- 强制一致的类型断言：`@typescript-eslint/consistent-type-assertions`

#### 代码风格
- 强制箭头函数体风格：`arrow-body-style`
- 强制curly括号使用：`curly`
- 强制严格相等比较：`eqeqeq`

### Prettier格式化

项目使用Prettier进行代码格式化，通过以下命令运行：

```bash
npm run format
```

### 代码组织原则

- **模块化设计**：每个功能模块应保持独立性和可重用性
- **类型安全**：优先使用TypeScript类型系统
- **错误处理**：完善的错误处理和用户友好的错误消息
- **性能考虑**：避免不必要的计算和内存使用

**章节来源**
- [eslint.config.js](file://eslint.config.js#L1-L100)
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L250-L280)

## 分支管理策略

### 主要分支

- **main**：主分支，包含稳定版本代码
- **develop**：开发分支，用于集成新功能
- **feature/***：功能分支，用于开发新功能
- **hotfix/***：热修复分支，用于紧急修复

### 分支命名规范

```bash
# 功能分支
git checkout -b feature/add-new-command

# 修复分支
git checkout -b hotfix/fix-authentication-issue

# 文档分支
git checkout -b docs/update-contributing-guide
```

### 提交前检查

在提交代码前，务必运行预检检查：

```bash
npm run preflight
```

该命令会执行以下检查：
- 运行所有测试
- 执行ESLint代码检查
- 运行Prettier格式化
- 类型检查
- 其他项目定义的检查

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L150-L180)

## 提交信息格式

### 约定式提交规范

遵循[约定式提交](https://www.conventionalcommits.org/)标准：

```
<类型>[可选范围]: <描述>

[可选正文]

[可选脚注]
```

### 提交类型

- **feat**：新功能
- **fix**：错误修复
- **docs**：文档更新
- **style**：代码格式调整
- **refactor**：代码重构
- **test**：测试相关
- **chore**：构建过程或辅助工具的变动

### 提交信息示例

```bash
# 新功能
feat(cli): 添加--json标志到'config get'命令

# 错误修复
fix(core): 修复不可靠的editCorrector注入额外转义字符

# 文档更新
docs(readme): 更新安装说明和授权部分

# 重构
refactor(tools): 重构工具注册表实现
```

### 提交钩子

建议创建Git预提交钩子以确保提交始终干净：

```bash
echo "# Run npm build and check for errors
if ! npm run preflight; then
  echo 'npm build failed. Commit aborted.'
  exit 1
fi" > .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit
```

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L60-L90)

## Pull Request流程

### PR创建前的准备工作

1. **链接现有问题**：所有PR都应该链接到我们的跟踪器中的现有问题
   - **错误修复**：PR应该链接到错误报告问题
   - **功能**：PR应该链接到已由维护者批准的功能请求或提案问题

2. **保持小而专注**：我们倾向于解决单一问题或添加单一、自包含功能的小型原子PR
   - **做**：创建修复特定错误或添加特定功能的PR
   - **不要**：将多个不相关的更改（例如错误修复、新功能和重构）打包到单个PR中

3. **使用草稿PR**：如果希望获得早期反馈，请使用GitHub的**草稿拉取请求**功能

### PR标题和描述规范

#### PR标题
```
feat(cli): Add --json flag to 'config get' command
```

#### PR描述
```
添加--json标志到'config get'命令，允许以JSON格式输出配置信息。

此功能解决了[#123]中提出的需求，使自动化脚本更容易处理配置数据。

- 添加新的--json标志参数
- 实现JSON格式化输出
- 更新相关文档
- 编写单元测试覆盖新功能

Fixes #123
```

### 自动化检查

在提交PR之前，确保所有自动化检查都通过：

```bash
npm run preflight
```

### PR模板字段

根据项目要求填写PR模板中的各个字段：

1. **变更类型**：选择适当的变更类型（功能、修复、文档等）
2. **相关问题**：链接相关的GitHub问题
3. **变更描述**：详细描述所做的更改
4. **测试**：说明如何测试这些更改
5. **文档**：是否需要更新文档
6. **截图**：如有UI更改，提供截图

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L25-L60)

## 测试要求

### 测试类型

项目包含两种类型的测试：单元测试和集成测试。

#### 单元测试

```bash
# 运行所有包的单元测试
npm run test

# 或单独运行某个包的测试
cd packages/cli
npm run test
```

#### 集成测试

```bash
# 运行端到端测试
npm run test:e2e

# 运行特定的集成测试套件
npm run test:integration:sandbox:none
npm run test:integration:sandbox:docker
npm run test:integration:sandbox:podman
```

### 测试覆盖率

- **单元测试覆盖率**：确保新功能有相应的单元测试
- **集成测试覆盖率**：验证端到端功能的正确性
- **边界情况测试**：测试边缘情况和异常处理

### 测试最佳实践

1. **测试隔离**：每个测试应该是独立的，不依赖其他测试的状态
2. **清晰的测试命名**：测试名称应该清楚地描述测试的目的
3. **充分的断言**：确保测试验证了预期的行为
4. **模拟外部依赖**：使用Mock对象来隔离外部依赖

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L180-L220)
- [integration-tests/edit.test.ts](file://integration-tests/edit.test.ts#L1-L50)

## 审查流程

### 审查标准

代码审查将重点关注以下方面：

1. **代码质量**
   - 是否符合项目编码规范
   - 代码结构是否清晰合理
   - 是否存在潜在的性能问题

2. **功能正确性**
   - 功能是否按预期工作
   - 边界情况是否得到适当处理
   - 错误处理是否完善

3. **测试覆盖**
   - 是否有足够的测试覆盖
   - 测试是否有效且有意义
   - 是否测试了所有重要的功能路径

4. **文档完整性**
   - 代码注释是否充分
   - 用户文档是否更新
   - API文档是否准确

### 审查流程

1. **自动检查**：CI/CD流水线自动运行测试和代码检查
2. **人工审查**：维护者或指定的审查者进行代码审查
3. **反馈处理**：作者根据反馈修改代码
4. **最终合并**：审查通过后合并到主分支

### 审查工具

- **GitHub Pull Requests**：主要的代码审查平台
- **ESLint/Prettier**：自动化代码质量检查
- **Vitest**：测试框架，提供详细的测试报告

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L20-L25)

## 常见贡献场景

### 场景1：修复Bug

#### 步骤1：创建问题
```bash
# 在GitHub Issues中创建bug报告
git checkout -b fix/bug-description
```

#### 步骤2：编写测试
```typescript
// 创建一个失败的测试用例
it('should handle edge case', () => {
  expect(processEdgeCase(input)).toThrowError('Expected error');
});
```

#### 步骤3：修复代码
```typescript
// 修改代码以修复问题
function processEdgeCase(input: any): string {
  if (!input) {
    throw new Error('Input is required');
  }
  // 修复后的逻辑
}
```

#### 步骤4：验证修复
```bash
npm run test
npm run preflight
```

### 场景2：添加新功能

#### 步骤1：设计API
```typescript
// 设计新的工具接口
interface NewFeatureTool {
  name: string;
  execute(params: NewFeatureParams): Promise<NewFeatureResult>;
}
```

#### 步骤2：实现功能
```typescript
// 实现新功能
export class NewFeatureToolImpl implements NewFeatureTool {
  async execute(params: NewFeatureParams): Promise<NewFeatureResult> {
    // 功能实现逻辑
  }
}
```

#### 步骤3：编写测试
```typescript
// 编写完整的测试套件
describe('NewFeatureTool', () => {
  it('should work with valid input', async () => {
    // 测试正常情况
  });
  
  it('should handle invalid input', async () => {
    // 测试错误情况
  });
});
```

### 场景3：改进文档

#### 步骤1：识别改进点
- 查看现有的文档
- 识别不清楚或缺失的部分
- 收集用户反馈

#### 步骤2：编写文档
```markdown
# 新功能文档

## 概述
简要描述新功能及其用途

## 使用方法
详细说明如何使用新功能

## 示例
提供实际使用示例
```

#### 步骤3：更新README
```bash
# 更新README.md中的相关部分
# 添加新功能的使用说明
# 更新安装和配置指南
```

### 场景4：性能优化

#### 步骤1：性能分析
```typescript
// 使用性能分析工具识别瓶颈
console.time('operation');
// 性能关键代码
console.timeEnd('operation');
```

#### 步骤2：实施优化
```typescript
// 应用优化方案
// 使用更高效的数据结构
// 减少不必要的计算
// 实现缓存机制
```

#### 步骤3：验证效果
```bash
# 运行性能测试
npm run test:performance
# 对比优化前后的性能指标
```

**章节来源**
- [packages/cli/src/services/CommandService.ts](file://packages/cli/src/services/CommandService.ts#L1-L50)
- [packages/core/src/tools/tools.ts](file://packages/core/src/tools.ts#L1-L100)

## 行为准则

### 社区价值观

1. **尊重他人**：以友善和专业的态度对待所有社区成员
2. **包容性**：欢迎来自不同背景和经验水平的贡献者
3. **建设性反馈**：提供建设性的批评和建议
4. **协作精神**：乐于帮助他人，分享知识和经验

### 沟通原则

- **清晰表达**：使用明确、简洁的语言
- **积极倾听**：认真听取他人的观点和建议
- **及时响应**：尽快回应问题和评论
- **开放心态**：愿意接受不同的观点和建议

### 冲突解决

遇到分歧时：

1. **冷静处理**：保持冷静和专业
2. **寻求共识**：努力找到双方都能接受的解决方案
3. **求助调解**：必要时寻求维护者的帮助
4. **遵守决定**：尊重最终的决定

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L1-L20)

## 故障排除

### 常见问题及解决方案

#### 1. 依赖安装失败

**问题**：`npm install`失败
**解决方案**：
```bash
# 清理缓存
npm cache clean --force

# 删除node_modules并重新安装
rm -rf node_modules package-lock.json
npm install
```

#### 2. 构建失败

**问题**：`npm run build`失败
**解决方案**：
```bash
# 清理构建目录
npm run clean

# 重新构建
npm run build
```

#### 3. 测试失败

**问题**：测试用例失败
**解决方案**：
```bash
# 运行特定测试
npm run test -- --testNamePattern="failed test name"

# 查看详细日志
VERBOSE=true npm run test
```

#### 4. ESLint错误

**问题**：ESLint检查失败
**解决方案**：
```bash
# 自动修复可修复的问题
npm run lint:fix

# 手动修复剩余问题
npm run lint
```

### 调试技巧

#### 使用调试模式

```bash
# 启动调试模式
npm run debug

# 在VS Code中附加调试器
# 使用F5启动CLI进行交互式调试
```

#### React DevTools调试

```bash
# 启动CLI开发模式
DEV=true npm start

# 安装React DevTools 4.28.5
npm install -g react-devtools@4.28.5
react-devtools
```

#### 沙箱调试

```bash
# 启用沙箱调试
DEBUG=1 gemini

# 检查沙箱容器状态
docker ps | grep qwen
```

### 获取帮助

1. **查阅文档**：首先查看README和CONTRIBUTING.md
2. **搜索Issues**：查看是否有类似问题的讨论
3. **提问**：在GitHub Discussions中提问
4. **联系维护者**：通过邮件或GitHub直接联系维护者

**章节来源**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L280-L302)

## 结论

通过遵循本指南，您可以有效地参与到Qwen Code项目的开发中。记住：

- **从小处着手**：从简单的bug修复或文档改进开始
- **保持耐心**：代码审查可能需要多次迭代
- **持续学习**：项目不断发展，保持学习新技术
- **积极参与**：与其他贡献者交流，分享经验和知识

我们期待您的贡献，共同打造更好的Qwen Code！