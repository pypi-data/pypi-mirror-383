"""
Binance Derivatives Trading COIN Futures REST API

OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import requests
from typing import Optional, List, TypeVar, Union
from binance_common.configuration import ConfigurationRestAPI
from binance_common.models import ApiResponse
from binance_common.signature import Signers
from binance_common.utils import send_request
from .api.account_api import AccountApi
from .api.market_data_api import MarketDataApi
from .api.portfolio_margin_endpoints_api import PortfolioMarginEndpointsApi
from .api.trade_api import TradeApi
from .api.user_data_streams_api import UserDataStreamsApi

from .models import AccountInformationResponse
from .models import FuturesAccountBalanceResponse
from .models import GetCurrentPositionModeResponse
from .models import GetDownloadIdForFuturesOrderHistoryResponse
from .models import GetDownloadIdForFuturesTradeHistoryResponse
from .models import GetDownloadIdForFuturesTransactionHistoryResponse
from .models import GetFuturesOrderHistoryDownloadLinkByIdResponse
from .models import GetFuturesTradeDownloadLinkByIdResponse
from .models import GetFuturesTransactionHistoryDownloadLinkByIdResponse
from .models import GetIncomeHistoryResponse
from .models import NotionalBracketForPairResponse
from .models import NotionalBracketForSymbolResponse
from .models import UserCommissionRateResponse
from .models import BasisResponse
from .models import CheckServerTimeResponse
from .models import CompressedAggregateTradesListResponse
from .models import ContinuousContractKlineCandlestickDataResponse
from .models import ExchangeInformationResponse
from .models import GetFundingRateHistoryOfPerpetualFuturesResponse
from .models import GetFundingRateInfoResponse
from .models import IndexPriceAndMarkPriceResponse
from .models import IndexPriceKlineCandlestickDataResponse
from .models import KlineCandlestickDataResponse
from .models import LongShortRatioResponse
from .models import MarkPriceKlineCandlestickDataResponse
from .models import OldTradesLookupResponse
from .models import OpenInterestResponse
from .models import OpenInterestStatisticsResponse
from .models import OrderBookResponse
from .models import PremiumIndexKlineDataResponse
from .models import QueryIndexPriceConstituentsResponse
from .models import RecentTradesListResponse
from .models import SymbolOrderBookTickerResponse
from .models import SymbolPriceTickerResponse
from .models import TakerBuySellVolumeResponse

from .models import Ticker24hrPriceChangeStatisticsResponse
from .models import TopTraderLongShortRatioAccountsResponse
from .models import TopTraderLongShortRatioPositionsResponse
from .models import ClassicPortfolioMarginAccountInformationResponse
from .models import AccountTradeListResponse
from .models import AllOrdersResponse

from .models import CancelAllOpenOrdersResponse
from .models import CancelMultipleOrdersResponse
from .models import CancelOrderResponse
from .models import ChangeInitialLeverageResponse
from .models import ChangeMarginTypeResponse
from .models import ChangePositionModeResponse
from .models import CurrentAllOpenOrdersResponse
from .models import GetOrderModifyHistoryResponse
from .models import GetPositionMarginChangeHistoryResponse
from .models import ModifyIsolatedPositionMarginResponse
from .models import ModifyMultipleOrdersResponse
from .models import ModifyOrderResponse
from .models import NewOrderResponse
from .models import PositionAdlQuantileEstimationResponse
from .models import PositionInformationResponse
from .models import QueryCurrentOpenOrderResponse
from .models import QueryOrderResponse
from .models import UsersForceOrdersResponse


from .models import StartUserDataStreamResponse


from .models import BasisContractTypeEnum
from .models import BasisPeriodEnum
from .models import ContinuousContractKlineCandlestickDataContractTypeEnum
from .models import ContinuousContractKlineCandlestickDataIntervalEnum
from .models import IndexPriceKlineCandlestickDataIntervalEnum
from .models import KlineCandlestickDataIntervalEnum
from .models import LongShortRatioPeriodEnum
from .models import MarkPriceKlineCandlestickDataIntervalEnum
from .models import OpenInterestStatisticsContractTypeEnum
from .models import OpenInterestStatisticsPeriodEnum
from .models import PremiumIndexKlineDataIntervalEnum
from .models import TakerBuySellVolumeContractTypeEnum
from .models import TakerBuySellVolumePeriodEnum
from .models import TopTraderLongShortRatioAccountsPeriodEnum
from .models import TopTraderLongShortRatioPositionsPeriodEnum
from .models import ChangeMarginTypeMarginTypeEnum
from .models import ModifyIsolatedPositionMarginTypeEnum
from .models import ModifyIsolatedPositionMarginPositionSideEnum
from .models import ModifyOrderSideEnum
from .models import ModifyOrderPriceMatchEnum
from .models import NewOrderSideEnum
from .models import NewOrderTypeEnum
from .models import NewOrderPositionSideEnum
from .models import NewOrderTimeInForceEnum
from .models import NewOrderWorkingTypeEnum
from .models import NewOrderNewOrderRespTypeEnum
from .models import NewOrderPriceMatchEnum
from .models import NewOrderSelfTradePreventionModeEnum
from .models import UsersForceOrdersAutoCloseTypeEnum


from .models import ModifyMultipleOrdersBatchOrdersParameterInner

T = TypeVar("T")


class DerivativesTradingCoinFuturesRestAPI:
    def __init__(
        self,
        configuration: ConfigurationRestAPI,
    ) -> None:
        self.configuration = configuration
        self._session = requests.Session()
        self._signer = (
            Signers.get_signer(
                configuration.private_key, configuration.private_key_passphrase
            )
            if configuration.private_key is not None
            else None
        )

        self._accountApi = AccountApi(self.configuration, self._session, self._signer)
        self._marketDataApi = MarketDataApi(
            self.configuration, self._session, self._signer
        )
        self._portfolioMarginEndpointsApi = PortfolioMarginEndpointsApi(
            self.configuration, self._session, self._signer
        )
        self._tradeApi = TradeApi(self.configuration, self._session, self._signer)
        self._userDataStreamsApi = UserDataStreamsApi(
            self.configuration, self._session, self._signer
        )

    def send_request(
        self, endpoint: str, method: str, params: Optional[dict] = None
    ) -> ApiResponse[T]:
        """
        Sends an request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session, self.configuration, method, endpoint, params
        )

    def send_signed_request(
        self, endpoint: str, method: str, params: Optional[dict] = None
    ) -> ApiResponse[T]:
        """
        Sends a signed request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session,
            self.configuration,
            method,
            endpoint,
            params,
            is_signed=True,
            signer=self._signer,
        )

    def account_information(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[AccountInformationResponse]:
        """
                Account Information (USER_DATA)

                Get current account information.

        * for One-way Mode user, the "positions" will only show the "BOTH" positions
        * for Hedge Mode user, the "positions" will show "BOTH", "LONG", and "SHORT" positions.

        Weight: 5

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[AccountInformationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.account_information(recv_window)

    def futures_account_balance(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[FuturesAccountBalanceResponse]:
        """
                Futures Account Balance (USER_DATA)

                Check futures account balance

        Weight: 1

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[FuturesAccountBalanceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.futures_account_balance(recv_window)

    def get_current_position_mode(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetCurrentPositionModeResponse]:
        """
                Get Current Position Mode(USER_DATA)

                Get user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***

        Weight: 30

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetCurrentPositionModeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_current_position_mode(recv_window)

    def get_download_id_for_futures_order_history(
        self,
        start_time: Union[int, None],
        end_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetDownloadIdForFuturesOrderHistoryResponse]:
        """
                Get Download Id For Futures Order History (USER_DATA)

                Get Download Id For Futures Order History

        * Request Limitation is 10 times per month, shared by front end download page and rest api
        * The time between `startTime` and `endTime` can not be longer than 1 year

        Weight: 5

                Args:
                    start_time (Union[int, None]): Timestamp in ms
                    end_time (Union[int, None]): Timestamp in ms
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetDownloadIdForFuturesOrderHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_download_id_for_futures_order_history(
            start_time, end_time, recv_window
        )

    def get_download_id_for_futures_trade_history(
        self,
        start_time: Union[int, None],
        end_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetDownloadIdForFuturesTradeHistoryResponse]:
        """
                Get Download Id For Futures Trade History (USER_DATA)

                Get download id for futures trade history

        * Request Limitation is 5 times per month, shared by front end download page and rest api
        * The time between `startTime` and `endTime` can not be longer than 1 year

        Weight: 5

                Args:
                    start_time (Union[int, None]): Timestamp in ms
                    end_time (Union[int, None]): Timestamp in ms
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetDownloadIdForFuturesTradeHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_download_id_for_futures_trade_history(
            start_time, end_time, recv_window
        )

    def get_download_id_for_futures_transaction_history(
        self,
        start_time: Union[int, None],
        end_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetDownloadIdForFuturesTransactionHistoryResponse]:
        """
                Get Download Id For Futures Transaction History(USER_DATA)

                Get download id for futures transaction history

        * Request Limitation is 5 times per month, shared by front end download page and rest api
        * The time between `startTime` and `endTime` can not be longer than 1 year

        Weight: 5

                Args:
                    start_time (Union[int, None]): Timestamp in ms
                    end_time (Union[int, None]): Timestamp in ms
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetDownloadIdForFuturesTransactionHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_download_id_for_futures_transaction_history(
            start_time, end_time, recv_window
        )

    def get_futures_order_history_download_link_by_id(
        self,
        download_id: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetFuturesOrderHistoryDownloadLinkByIdResponse]:
        """
                Get Futures Order History Download Link by Id (USER_DATA)

                Get futures order history download link by Id

        * Download link expiration: 24h

        Weight: 5

                Args:
                    download_id (Union[str, None]): get by download id api
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetFuturesOrderHistoryDownloadLinkByIdResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_futures_order_history_download_link_by_id(
            download_id, recv_window
        )

    def get_futures_trade_download_link_by_id(
        self,
        download_id: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetFuturesTradeDownloadLinkByIdResponse]:
        """
                Get Futures Trade Download Link by Id(USER_DATA)

                Get futures trade download link by Id

        * Download link expiration: 24h

        Weight: 5

                Args:
                    download_id (Union[str, None]): get by download id api
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetFuturesTradeDownloadLinkByIdResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_futures_trade_download_link_by_id(
            download_id, recv_window
        )

    def get_futures_transaction_history_download_link_by_id(
        self,
        download_id: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetFuturesTransactionHistoryDownloadLinkByIdResponse]:
        """
                Get Futures Transaction History Download Link by Id (USER_DATA)

                Get futures transaction history download link by Id

        * Download link expiration: 24h

        Weight: 5

                Args:
                    download_id (Union[str, None]): get by download id api
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetFuturesTransactionHistoryDownloadLinkByIdResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_futures_transaction_history_download_link_by_id(
            download_id, recv_window
        )

    def get_income_history(
        self,
        symbol: Optional[str] = None,
        income_type: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        page: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetIncomeHistoryResponse]:
        """
                Get Income History(USER_DATA)

                Get income history

        * If `incomeType ` is not sent, all kinds of flow will be returned
        * "trandId" is unique in the same "incomeType" for a user
        * The time between `startTime` and `endTime` can not be longer than 1 year

        Weight: 20

                Args:
                    symbol (Optional[str] = None):
                    income_type (Optional[str] = None): "TRANSFER","WELCOME_BONUS", "FUNDING_FEE", "REALIZED_PNL", "COMMISSION", "INSURANCE_CLEAR", and "DELIVERED_SETTELMENT"
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    page (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetIncomeHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_income_history(
            symbol, income_type, start_time, end_time, page, limit, recv_window
        )

    def notional_bracket_for_pair(
        self,
        pair: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NotionalBracketForPairResponse]:
        """
                Notional Bracket for Pair(USER_DATA)

                **Not recommended to continue using this v1 endpoint**

        Get the pair's default notional bracket list, may return ambiguous values when there have been multiple different `symbol` brackets under the `pair`, suggest using the following `GET /dapi/v2/leverageBracket` query instead to get the specific `symbol` notional bracket list.

        Weight: 1

                Args:
                    pair (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NotionalBracketForPairResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.notional_bracket_for_pair(pair, recv_window)

    def notional_bracket_for_symbol(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NotionalBracketForSymbolResponse]:
        """
                Notional Bracket for Symbol(USER_DATA)

                Get the symbol's notional bracket list.

        Weight: 1

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NotionalBracketForSymbolResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.notional_bracket_for_symbol(symbol, recv_window)

    def user_commission_rate(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[UserCommissionRateResponse]:
        """
                User Commission Rate (USER_DATA)

                Query user commission rate

        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[UserCommissionRateResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.user_commission_rate(symbol, recv_window)

    def basis(
        self,
        pair: Union[str, None],
        contract_type: Union[BasisContractTypeEnum, None],
        period: Union[BasisPeriodEnum, None],
        limit: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> ApiResponse[BasisResponse]:
        """
                Basis

                Query basis

        * If startTime and endTime are not sent, the most recent data is returned.
        * Only the data of the latest 30 days is available.

        Weight: 1

                Args:
                    pair (Union[str, None]): BTCUSD
                    contract_type (Union[BasisContractTypeEnum, None]): ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
                    period (Union[BasisPeriodEnum, None]): "5m","15m","30m","1h","2h","4h","6h","12h","1d"
                    limit (Optional[int] = None): Default 100; max 1000
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):

                Returns:
                    ApiResponse[BasisResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.basis(
            pair, contract_type, period, limit, start_time, end_time
        )

    def check_server_time(
        self,
    ) -> ApiResponse[CheckServerTimeResponse]:
        """
                Check Server time

                Test connectivity to the Rest API and get the current server time.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[CheckServerTimeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.check_server_time()

    def compressed_aggregate_trades_list(
        self,
        symbol: Union[str, None],
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[CompressedAggregateTradesListResponse]:
        """
                Compressed/Aggregate Trades List

                Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.

        * support querying futures trade histories that are not older than one year
        * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
        * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
        * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
        * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`

        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    from_id (Optional[int] = None): ID to get aggregate trades from INCLUSIVE.
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[CompressedAggregateTradesListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.compressed_aggregate_trades_list(
            symbol, from_id, start_time, end_time, limit
        )

    def continuous_contract_kline_candlestick_data(
        self,
        pair: Union[str, None],
        contract_type: Union[
            ContinuousContractKlineCandlestickDataContractTypeEnum, None
        ],
        interval: Union[ContinuousContractKlineCandlestickDataIntervalEnum, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[ContinuousContractKlineCandlestickDataResponse]:
        """
                Continuous Contract Kline/Candlestick Data

                Kline/candlestick bars for a specific contract type.
        Klines are uniquely identified by their open time.

        * Contract type:
        * PERPETUAL
        * CURRENT_QUARTER
        * NEXT_QUARTER


        1000 | 10
        * The difference between `startTime` and `endTime` can only be up to 200 days
        * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
        * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
        * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
        * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`

        Weight: based on parameter LIMIT
        LIMIT | weight
        ---|---
        [1,100) | 1
        [100, 500) | 2
        [500, 1000] | 5
        > 1000 | 10

                Args:
                    pair (Union[str, None]): BTCUSD
                    contract_type (Union[ContinuousContractKlineCandlestickDataContractTypeEnum, None]): ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
                    interval (Union[ContinuousContractKlineCandlestickDataIntervalEnum, None]):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[ContinuousContractKlineCandlestickDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.continuous_contract_kline_candlestick_data(
            pair, contract_type, interval, start_time, end_time, limit
        )

    def exchange_information(
        self,
    ) -> ApiResponse[ExchangeInformationResponse]:
        """
                Exchange Information

                Current exchange trading rules and symbol information

        Weight: 1

                Args:

                Returns:
                    ApiResponse[ExchangeInformationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.exchange_information()

    def get_funding_rate_history_of_perpetual_futures(
        self,
        symbol: Union[str, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[GetFundingRateHistoryOfPerpetualFuturesResponse]:
        """
                Get Funding Rate History of Perpetual Futures

                Get Funding Rate History of Perpetual Futures

        * empty array will be returned for delivery symbols.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[GetFundingRateHistoryOfPerpetualFuturesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_funding_rate_history_of_perpetual_futures(
            symbol, start_time, end_time, limit
        )

    def get_funding_rate_info(
        self,
    ) -> ApiResponse[GetFundingRateInfoResponse]:
        """
                Get Funding Rate Info

                Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment

        Weight: 0

                Args:

                Returns:
                    ApiResponse[GetFundingRateInfoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_funding_rate_info()

    def index_price_and_mark_price(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
    ) -> ApiResponse[IndexPriceAndMarkPriceResponse]:
        """
                Index Price and Mark Price

                Query index price and mark price

        Weight: 10

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):

                Returns:
                    ApiResponse[IndexPriceAndMarkPriceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.index_price_and_mark_price(symbol, pair)

    def index_price_kline_candlestick_data(
        self,
        pair: Union[str, None],
        interval: Union[IndexPriceKlineCandlestickDataIntervalEnum, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[IndexPriceKlineCandlestickDataResponse]:
        """
                Index Price Kline/Candlestick Data

                Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.


        1000 | 10
        * The difference between `startTime` and `endTime` can only be up to 200 days
        * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
        * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
        * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
        * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`

        Weight: based on parameter LIMIT
        LIMIT | weight
        ---|---
        [1,100) | 1
        [100, 500) | 2
        [500, 1000] | 5
        > 1000 | 10

                Args:
                    pair (Union[str, None]): BTCUSD
                    interval (Union[IndexPriceKlineCandlestickDataIntervalEnum, None]):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[IndexPriceKlineCandlestickDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.index_price_kline_candlestick_data(
            pair, interval, start_time, end_time, limit
        )

    def kline_candlestick_data(
        self,
        symbol: Union[str, None],
        interval: Union[KlineCandlestickDataIntervalEnum, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[KlineCandlestickDataResponse]:
        """
                Kline/Candlestick Data

                Kline/candlestick bars for a symbol.
        Klines are uniquely identified by their open time.

        1000 | 10
        * The difference between `startTime` and `endTime` can only be up to 200 days
        * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
        * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
        * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
        * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`

        Weight: based on parameter LIMIT
        LIMIT | weight
        ---|---
        [1,100) | 1
        [100, 500) | 2
        [500, 1000] | 5
        > 1000 | 10

                Args:
                    symbol (Union[str, None]):
                    interval (Union[KlineCandlestickDataIntervalEnum, None]):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[KlineCandlestickDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.kline_candlestick_data(
            symbol, interval, start_time, end_time, limit
        )

    def long_short_ratio(
        self,
        pair: Union[str, None],
        period: Union[LongShortRatioPeriodEnum, None],
        limit: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> ApiResponse[LongShortRatioResponse]:
        """
                Long/Short Ratio

                Query symbol Long/Short Ratio

        * If startTime and endTime are not sent, the most recent data is returned.
        * Only the data of the latest 30 days is available.

        Weight: 1

                Args:
                    pair (Union[str, None]): BTCUSD
                    period (Union[LongShortRatioPeriodEnum, None]): "5m","15m","30m","1h","2h","4h","6h","12h","1d"
                    limit (Optional[int] = None): Default 100; max 1000
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):

                Returns:
                    ApiResponse[LongShortRatioResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.long_short_ratio(
            pair, period, limit, start_time, end_time
        )

    def mark_price_kline_candlestick_data(
        self,
        symbol: Union[str, None],
        interval: Union[MarkPriceKlineCandlestickDataIntervalEnum, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[MarkPriceKlineCandlestickDataResponse]:
        """
                Mark Price Kline/Candlestick Data

                Kline/candlestick bars for the mark price of a symbol.
        Klines are uniquely identified by their open time.


        1000 | 10
        * The difference between `startTime` and `endTime` can only be up to 200 days
        * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
        * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
        * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
        * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`

        Weight: based on parameter LIMIT
        LIMIT | weight
        ---|---
        [1,100) | 1
        [100, 500) | 2
        [500, 1000] | 5
        > 1000 | 10

                Args:
                    symbol (Union[str, None]):
                    interval (Union[MarkPriceKlineCandlestickDataIntervalEnum, None]):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[MarkPriceKlineCandlestickDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.mark_price_kline_candlestick_data(
            symbol, interval, start_time, end_time, limit
        )

    def old_trades_lookup(
        self,
        symbol: Union[str, None],
        limit: Optional[int] = None,
        from_id: Optional[int] = None,
    ) -> ApiResponse[OldTradesLookupResponse]:
        """
                Old Trades Lookup(MARKET_DATA)

                Get older market historical trades.

        * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.

        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    limit (Optional[int] = None): Default 100; max 1000
                    from_id (Optional[int] = None): ID to get aggregate trades from INCLUSIVE.

                Returns:
                    ApiResponse[OldTradesLookupResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.old_trades_lookup(symbol, limit, from_id)

    def open_interest(
        self,
        symbol: Union[str, None],
    ) -> ApiResponse[OpenInterestResponse]:
        """
                Open Interest

                Get present open interest of a specific symbol.

        Weight: 1

                Args:
                    symbol (Union[str, None]):

                Returns:
                    ApiResponse[OpenInterestResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.open_interest(symbol)

    def open_interest_statistics(
        self,
        pair: Union[str, None],
        contract_type: Union[OpenInterestStatisticsContractTypeEnum, None],
        period: Union[OpenInterestStatisticsPeriodEnum, None],
        limit: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> ApiResponse[OpenInterestStatisticsResponse]:
        """
                Open Interest Statistics

                Query open interest stats


        * If startTime and endTime are not sent, the most recent data is returned.
        * Only the data of the latest 30 days is available.

        Weight: 1

                Args:
                    pair (Union[str, None]): BTCUSD
                    contract_type (Union[OpenInterestStatisticsContractTypeEnum, None]): ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
                    period (Union[OpenInterestStatisticsPeriodEnum, None]): "5m","15m","30m","1h","2h","4h","6h","12h","1d"
                    limit (Optional[int] = None): Default 100; max 1000
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):

                Returns:
                    ApiResponse[OpenInterestStatisticsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.open_interest_statistics(
            pair, contract_type, period, limit, start_time, end_time
        )

    def order_book(
        self,
        symbol: Union[str, None],
        limit: Optional[int] = None,
    ) -> ApiResponse[OrderBookResponse]:
        """
                Order Book

                Query orderbook on specific symbol

        Weight: Adjusted based on the limit:
        Limit | Weight
        ------------ | ------------
        5, 10, 20, 50 | 2
        100 | 5
        500 | 10
        1000 | 20

                Args:
                    symbol (Union[str, None]):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[OrderBookResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.order_book(symbol, limit)

    def premium_index_kline_data(
        self,
        symbol: Union[str, None],
        interval: Union[PremiumIndexKlineDataIntervalEnum, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[PremiumIndexKlineDataResponse]:
        """
                Premium index Kline Data

                Premium index kline bars of a symbol. Klines are uniquely identified by their open time.


        * If startTime and endTime are not sent, the most recent klines are returned.

        Weight: based on parameter LIMIT
        | LIMIT       | weight |
        | ----------- | ------ |
        | [1,100)     | 1      |
        | [100, 500)  | 2      |
        | [500, 1000] | 5      |
        | > 1000      | 10     |

                Args:
                    symbol (Union[str, None]):
                    interval (Union[PremiumIndexKlineDataIntervalEnum, None]):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[PremiumIndexKlineDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.premium_index_kline_data(
            symbol, interval, start_time, end_time, limit
        )

    def query_index_price_constituents(
        self,
        symbol: Union[str, None],
    ) -> ApiResponse[QueryIndexPriceConstituentsResponse]:
        """
                Query Index Price Constituents

                Query index price constituents

        Weight: 1

                Args:
                    symbol (Union[str, None]):

                Returns:
                    ApiResponse[QueryIndexPriceConstituentsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.query_index_price_constituents(symbol)

    def recent_trades_list(
        self,
        symbol: Union[str, None],
        limit: Optional[int] = None,
    ) -> ApiResponse[RecentTradesListResponse]:
        """
                Recent Trades List

                Get recent market trades

        * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.

        Weight: 5

                Args:
                    symbol (Union[str, None]):
                    limit (Optional[int] = None): Default 100; max 1000

                Returns:
                    ApiResponse[RecentTradesListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.recent_trades_list(symbol, limit)

    def symbol_order_book_ticker(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
    ) -> ApiResponse[SymbolOrderBookTickerResponse]:
        """
                Symbol Order Book Ticker

                Best price/qty on the order book for a symbol or symbols.

        * Symbol and pair cannot be sent together
        * If a pair is sent,tickers for all symbols of the pair will be returned
        * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned

        Weight: 2 for a single symbol, 5 when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):

                Returns:
                    ApiResponse[SymbolOrderBookTickerResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.symbol_order_book_ticker(symbol, pair)

    def symbol_price_ticker(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
    ) -> ApiResponse[SymbolPriceTickerResponse]:
        """
                Symbol Price Ticker

                Latest price for a symbol or symbols.

        * Symbol and pair cannot be sent together
        * If a pair is sent,tickers for all symbols of the pair will be returned
        * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned

        Weight: 1 for a single symbol, 2 when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):

                Returns:
                    ApiResponse[SymbolPriceTickerResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.symbol_price_ticker(symbol, pair)

    def taker_buy_sell_volume(
        self,
        pair: Union[str, None],
        contract_type: Union[TakerBuySellVolumeContractTypeEnum, None],
        period: Union[TakerBuySellVolumePeriodEnum, None],
        limit: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> ApiResponse[TakerBuySellVolumeResponse]:
        """
                Taker Buy/Sell Volume

                Taker Buy Volume: the total volume of buy orders filled by takers within the period.
        Taker Sell Volume: the total volume of sell orders filled by takers within the period.

        * If startTime and endTime are not sent, the most recent data is returned.
        * Only the data of the latest 30 days is available.

        Weight: 1

                Args:
                    pair (Union[str, None]): BTCUSD
                    contract_type (Union[TakerBuySellVolumeContractTypeEnum, None]): ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
                    period (Union[TakerBuySellVolumePeriodEnum, None]): "5m","15m","30m","1h","2h","4h","6h","12h","1d"
                    limit (Optional[int] = None): Default 100; max 1000
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):

                Returns:
                    ApiResponse[TakerBuySellVolumeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.taker_buy_sell_volume(
            pair, contract_type, period, limit, start_time, end_time
        )

    def test_connectivity(
        self,
    ) -> ApiResponse[None]:
        """
                Test Connectivity

                Test connectivity to the Rest API.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.test_connectivity()

    def ticker24hr_price_change_statistics(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
    ) -> ApiResponse[Ticker24hrPriceChangeStatisticsResponse]:
        """
                24hr Ticker Price Change Statistics

                24 hour rolling window price change statistics.

        * Symbol and pair cannot be sent together
        * If a pair is sent,tickers for all symbols of the pair will be returned
        * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned

        Weight: 1 for a single symbol, 40 when the symbol parameter is omitted
        Careful when accessing this with no symbol.

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):

                Returns:
                    ApiResponse[Ticker24hrPriceChangeStatisticsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.ticker24hr_price_change_statistics(symbol, pair)

    def top_trader_long_short_ratio_accounts(
        self,
        symbol: Union[str, None],
        period: Union[TopTraderLongShortRatioAccountsPeriodEnum, None],
        limit: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> ApiResponse[TopTraderLongShortRatioAccountsResponse]:
        """
                Top Trader Long/Short Ratio (Accounts)

                The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
        Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
        Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
        Long/Short Ratio (Accounts) = Long Account % / Short Account %

        * If startTime and endTime are not sent, the most recent data is returned.
        * Only the data of the latest 30 days is available.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    period (Union[TopTraderLongShortRatioAccountsPeriodEnum, None]): "5m","15m","30m","1h","2h","4h","6h","12h","1d"
                    limit (Optional[int] = None): Default 100; max 1000
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):

                Returns:
                    ApiResponse[TopTraderLongShortRatioAccountsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.top_trader_long_short_ratio_accounts(
            symbol, period, limit, start_time, end_time
        )

    def top_trader_long_short_ratio_positions(
        self,
        pair: Union[str, None],
        period: Union[TopTraderLongShortRatioPositionsPeriodEnum, None],
        limit: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
    ) -> ApiResponse[TopTraderLongShortRatioPositionsResponse]:
        """
                Top Trader Long/Short Ratio (Positions)

                The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
        Long Position % = Long positions of top traders / Total open positions of top traders
        Short Position % = Short positions of top traders / Total open positions of top traders
        Long/Short Ratio (Positions) = Long Position % / Short Position %

        * If startTime and endTime are not sent, the most recent data is returned.
        * Only the data of the latest 30 days is available.

        Weight: 1

                Args:
                    pair (Union[str, None]): BTCUSD
                    period (Union[TopTraderLongShortRatioPositionsPeriodEnum, None]): "5m","15m","30m","1h","2h","4h","6h","12h","1d"
                    limit (Optional[int] = None): Default 100; max 1000
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):

                Returns:
                    ApiResponse[TopTraderLongShortRatioPositionsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.top_trader_long_short_ratio_positions(
            pair, period, limit, start_time, end_time
        )

    def classic_portfolio_margin_account_information(
        self,
        asset: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ClassicPortfolioMarginAccountInformationResponse]:
        """
                Classic Portfolio Margin Account Information (USER_DATA)

                Get Classic Portfolio Margin current account information.

        * maxWithdrawAmount is for asset transfer out to the spot wallet.

        Weight: 5

                Args:
                    asset (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ClassicPortfolioMarginAccountInformationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._portfolioMarginEndpointsApi.classic_portfolio_margin_account_information(
            asset, recv_window
        )

    def account_trade_list(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
        order_id: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[AccountTradeListResponse]:
        """
                Account Trade List (USER_DATA)

                Get trades for a specific account and symbol.


        * Either symbol or pair must be sent
        * Symbol and pair cannot be sent together
        * Pair and fromId cannot be sent together
        * OrderId can only be sent together with symbol
        * If a pair is sent,tickers for all symbols of the pair will be returned
        * The parameter `fromId` cannot be sent with `startTime` or `endTime`
        * If startTime and endTime are both not sent, then the last 7 days' data will be returned.
        * The time between startTime and endTime cannot be longer than 7 days.

        Weight: 20 with symbol，40 with pair

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):
                    order_id (Optional[str] = None):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    from_id (Optional[int] = None): ID to get aggregate trades from INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[AccountTradeListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.account_trade_list(
            symbol, pair, order_id, start_time, end_time, from_id, limit, recv_window
        )

    def all_orders(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[AllOrdersResponse]:
        """
                All Orders (USER_DATA)

                Get all account orders; active, canceled, or filled.

        * These orders will not be found:
        * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
        * order create time + 90 days < current time


        * Either `symbol` or `pair` must be sent.
        * `pair` can't be sent with `orderId`
        * If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
        * If orderId is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
        * The query time period must be less then 7 days( default as the recent 7 days).

        Weight: 20 with symbol, 40 with pair

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[AllOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.all_orders(
            symbol, pair, order_id, start_time, end_time, limit, recv_window
        )

    def auto_cancel_all_open_orders(
        self,
        symbol: Union[str, None],
        countdown_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[None]:
        """
                Auto-Cancel All Open Orders (TRADE)

                Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.

        * Example usage:
        Call this endpoint at 30s intervals with an countdownTime of 120000 (120s).
        If this endpoint is not called within 120 seconds, all your orders of the specified symbol will be automatically canceled.
        If this endpoint is called with an countdownTime of 0, the countdown timer will be stopped.

        Weight: 10

                Args:
                    symbol (Union[str, None]):
                    countdown_time (Union[int, None]): countdown time, 1000 for 1 second. 0 to cancel the timer
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.auto_cancel_all_open_orders(
            symbol, countdown_time, recv_window
        )

    def cancel_all_open_orders(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelAllOpenOrdersResponse]:
        """
                Cancel All Open Orders(TRADE)

                Cancel All Open Orders

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelAllOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_all_open_orders(symbol, recv_window)

    def cancel_multiple_orders(
        self,
        symbol: Union[str, None],
        order_id_list: Optional[List[int]] = None,
        orig_client_order_id_list: Optional[List[str]] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelMultipleOrdersResponse]:
        """
                Cancel Multiple Orders(TRADE)

                Cancel Multiple Orders

        * Either `orderIdList` or `origClientOrderIdList ` must be sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id_list (Optional[List[int]] = None): max length 10 <br /> e.g. [1234567,2345678]
                    orig_client_order_id_list (Optional[List[str]] = None): max length 10<br /> e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelMultipleOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_multiple_orders(
            symbol, order_id_list, orig_client_order_id_list, recv_window
        )

    def cancel_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelOrderResponse]:
        """
                Cancel Order (TRADE)

                Cancel an active order.


        * Either `orderId` or `origClientOrderId` must be sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def change_initial_leverage(
        self,
        symbol: Union[str, None],
        leverage: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangeInitialLeverageResponse]:
        """
                Change Initial Leverage (TRADE)

                Change user's initial leverage in the specific symbol market.
        For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    leverage (Union[int, None]): target initial leverage: int from 1 to 125
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangeInitialLeverageResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.change_initial_leverage(symbol, leverage, recv_window)

    def change_margin_type(
        self,
        symbol: Union[str, None],
        margin_type: Union[ChangeMarginTypeMarginTypeEnum, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangeMarginTypeResponse]:
        """
                Change Margin Type (TRADE)

                Change user's margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type.
        With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    margin_type (Union[ChangeMarginTypeMarginTypeEnum, None]): ISOLATED, CROSSED
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangeMarginTypeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.change_margin_type(symbol, margin_type, recv_window)

    def change_position_mode(
        self,
        dual_side_position: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangePositionModeResponse]:
        """
                Change Position Mode(TRADE)

                Change user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***

        Weight: 1

                Args:
                    dual_side_position (Union[str, None]): "true": Hedge Mode; "false": One-way Mode
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangePositionModeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.change_position_mode(dual_side_position, recv_window)

    def current_all_open_orders(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CurrentAllOpenOrdersResponse]:
        """
                Current All Open Orders (USER_DATA)

                Get all open orders on a symbol. **Careful** when accessing this with no symbol.

        Weight: 1 for a single symbol, 40 for mutltiple symbols

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CurrentAllOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.current_all_open_orders(symbol, pair, recv_window)

    def get_order_modify_history(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetOrderModifyHistoryResponse]:
        """
                Get Order Modify History (USER_DATA)

                Get order modification history


        * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
        * Order modify history longer than 3 month is not avaliable

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetOrderModifyHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.get_order_modify_history(
            symbol,
            order_id,
            orig_client_order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        )

    def get_position_margin_change_history(
        self,
        symbol: Union[str, None],
        type: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetPositionMarginChangeHistoryResponse]:
        """
                Get Position Margin Change History(TRADE)

                Get position margin change history

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    type (Optional[int] = None): 1: Add position margin,2: Reduce position margin
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetPositionMarginChangeHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.get_position_margin_change_history(
            symbol, type, start_time, end_time, limit, recv_window
        )

    def modify_isolated_position_margin(
        self,
        symbol: Union[str, None],
        amount: Union[float, None],
        type: Union[ModifyIsolatedPositionMarginTypeEnum, None],
        position_side: Optional[ModifyIsolatedPositionMarginPositionSideEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ModifyIsolatedPositionMarginResponse]:
        """
                Modify Isolated Position Margin(TRADE)

                Modify Isolated Position Margin

        * Only for isolated symbol

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    amount (Union[float, None]):
                    type (Union[ModifyIsolatedPositionMarginTypeEnum, None]):
                    position_side (Optional[ModifyIsolatedPositionMarginPositionSideEnum] = None): Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ModifyIsolatedPositionMarginResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.modify_isolated_position_margin(
            symbol, amount, type, position_side, recv_window
        )

    def modify_multiple_orders(
        self,
        batch_orders: Union[List[ModifyMultipleOrdersBatchOrdersParameterInner], None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ModifyMultipleOrdersResponse]:
        """
                Modify Multiple Orders(TRADE)

                Modify Multiple Orders

        * Parameter rules are same with `Modify Order`
        * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
        * The order of returned contents for batch modify orders is the same as the order of the order list.
        * One order can only be modfied for less than 10000 times

        Weight: 5

                Args:
                    batch_orders (Union[List[ModifyMultipleOrdersBatchOrdersParameterInner], None]): order list. Max 5 orders
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ModifyMultipleOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.modify_multiple_orders(batch_orders, recv_window)

    def modify_order(
        self,
        symbol: Union[str, None],
        side: Union[ModifyOrderSideEnum, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        quantity: Optional[float] = None,
        price: Optional[float] = None,
        price_match: Optional[ModifyOrderPriceMatchEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ModifyOrderResponse]:
        """
                Modify Order (TRADE)

                Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

        * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
        * Either `quantity` or `price` must be sent.
        * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
        * However the order will be cancelled by the amendment in the following situations:
        * when the order is in partially filled status and the new `quantity` <= `executedQty`
        * When the order is `GTX` and the new price will cause it to be executed immediately
        * One order can only be modfied for less than 10000 times

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[ModifyOrderSideEnum, None]): `SELL`, `BUY`
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    quantity (Optional[float] = None): quantity measured by contract number, Cannot be sent with `closePosition`=`true`
                    price (Optional[float] = None):
                    price_match (Optional[ModifyOrderPriceMatchEnum] = None): only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ModifyOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.modify_order(
            symbol,
            side,
            order_id,
            orig_client_order_id,
            quantity,
            price,
            price_match,
            recv_window,
        )

    def new_order(
        self,
        symbol: Union[str, None],
        side: Union[NewOrderSideEnum, None],
        type: Union[NewOrderTypeEnum, None],
        position_side: Optional[NewOrderPositionSideEnum] = None,
        time_in_force: Optional[NewOrderTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        reduce_only: Optional[str] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        stop_price: Optional[float] = None,
        close_position: Optional[str] = None,
        activation_price: Optional[float] = None,
        callback_rate: Optional[float] = None,
        working_type: Optional[NewOrderWorkingTypeEnum] = None,
        price_protect: Optional[str] = None,
        new_order_resp_type: Optional[NewOrderNewOrderRespTypeEnum] = None,
        price_match: Optional[NewOrderPriceMatchEnum] = None,
        self_trade_prevention_mode: Optional[
            NewOrderSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NewOrderResponse]:
        """
                New Order (TRADE)

                Send in a new order.


        * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
        * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
        * Condition orders will be triggered when:

        * If parameter`priceProtect`is sent as true:
        * when price reaches the `stopPrice` ，the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
        * "triggerProtect" of a symbol can be got from `GET /dapi/v1/exchangeInfo`

        * `STOP`, `STOP_MARKET`:
        * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
        * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
        * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
        * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
        * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
        * `TRAILING_STOP_MARKET`:
        * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
        * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)

        * For `TRAILING_STOP_MARKET`, if you got such error code.
        ``{"code": -2021, "msg": "Order would immediately trigger."}``
        means that the parameters you send do not meet the following requirements:
        * BUY: `activationPrice` should be smaller than latest price.
        * SELL: `activationPrice` should be larger than latest price.

        * If `newOrderRespType ` is sent as `RESULT` :
        * `MARKET` order: the final FILLED result of the order will be return directly.
        * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.

        * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
        * Follow the same rules for condition orders.
        * If triggered,**close all** current long position( if `SELL`) or current short position( if `BUY`).
        * Cannot be used with `quantity` parameter
        * Cannot be used with `reduceOnly` parameter
        * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
        * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC`.

        Weight: 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)
        0 on IP rate limit(x-mbx-used-weight-1m)

                Args:
                    symbol (Union[str, None]):
                    side (Union[NewOrderSideEnum, None]): `SELL`, `BUY`
                    type (Union[NewOrderTypeEnum, None]):
                    position_side (Optional[NewOrderPositionSideEnum] = None): Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
                    time_in_force (Optional[NewOrderTimeInForceEnum] = None):
                    quantity (Optional[float] = None): quantity measured by contract number, Cannot be sent with `closePosition`=`true`
                    reduce_only (Optional[str] = None): "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with `closePosition`=`true`(Close-All)
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: `^[.A-Z:/a-z0-9_-]{1,36}$`
                    stop_price (Optional[float] = None): Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
                    close_position (Optional[str] = None): `true`, `false`；Close-All,used with `STOP_MARKET` or `TAKE_PROFIT_MARKET`.
                    activation_price (Optional[float] = None): Used with `TRAILING_STOP_MARKET` orders, default as the latest price(supporting different `workingType`)
                    callback_rate (Optional[float] = None): Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 10 where 1 for 1%
                    working_type (Optional[NewOrderWorkingTypeEnum] = None): stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
                    price_protect (Optional[str] = None): "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
                    new_order_resp_type (Optional[NewOrderNewOrderRespTypeEnum] = None): "ACK", "RESULT", default "ACK"
                    price_match (Optional[NewOrderPriceMatchEnum] = None): only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
                    self_trade_prevention_mode (Optional[NewOrderSelfTradePreventionModeEnum] = None): `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers; default `EXPIRE_MAKER`
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NewOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.new_order(
            symbol,
            side,
            type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            new_client_order_id,
            stop_price,
            close_position,
            activation_price,
            callback_rate,
            working_type,
            price_protect,
            new_order_resp_type,
            price_match,
            self_trade_prevention_mode,
            recv_window,
        )

    def position_adl_quantile_estimation(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[PositionAdlQuantileEstimationResponse]:
        """
                Position ADL Quantile Estimation(USER_DATA)

                Query position ADL quantile estimation

        * Values update every 30s.
        * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
        * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
        * If the positions of the symbol are crossed margined in Hedge Mode:
        * "HEDGE" as a sign will be returned instead of "BOTH";
        * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.

        Weight: 5

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[PositionAdlQuantileEstimationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.position_adl_quantile_estimation(symbol, recv_window)

    def position_information(
        self,
        margin_asset: Optional[str] = None,
        pair: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[PositionInformationResponse]:
        """
                Position Information(USER_DATA)

                Get current account information.

        * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
        * for One-way Mode user, the response  will only show the "BOTH" positions
        * for Hedge Mode user, the response will show "BOTH", "LONG", and "SHORT" positions.
        Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.

        Weight: 1

                Args:
                    margin_asset (Optional[str] = None):
                    pair (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[PositionInformationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.position_information(margin_asset, pair, recv_window)

    def query_current_open_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCurrentOpenOrderResponse]:
        """
                Query Current Open Order(USER_DATA)

                Query Current Open Order

        * Either`orderId` or `origClientOrderId` must be sent
        * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCurrentOpenOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_current_open_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def query_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryOrderResponse]:
        """
                Query Order (USER_DATA)

                Check an order's status.

        * These orders will not be found:
        * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
        * order create time + 90 days < current time


        * Either `orderId` or `origClientOrderId` must be sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def users_force_orders(
        self,
        symbol: Optional[str] = None,
        auto_close_type: Optional[UsersForceOrdersAutoCloseTypeEnum] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[UsersForceOrdersResponse]:
        """
                User's Force Orders(USER_DATA)

                User's Force Orders

        * If "autoCloseType" is not sent, orders with both of the types will be returned
        * If "startTime" is not sent, data within 200 days before "endTime" can be queried

        Weight: 20 with symbol, 50 without symbol

                Args:
                    symbol (Optional[str] = None):
                    auto_close_type (Optional[UsersForceOrdersAutoCloseTypeEnum] = None): "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[UsersForceOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.users_force_orders(
            symbol, auto_close_type, start_time, end_time, limit, recv_window
        )

    def close_user_data_stream(
        self,
    ) -> ApiResponse[None]:
        """
                Close User Data Stream(USER_STREAM)

                Close out a user data stream.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamsApi.close_user_data_stream()

    def keepalive_user_data_stream(
        self,
    ) -> ApiResponse[None]:
        """
                Keepalive User Data Stream (USER_STREAM)

                Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamsApi.keepalive_user_data_stream()

    def start_user_data_stream(
        self,
    ) -> ApiResponse[StartUserDataStreamResponse]:
        """
                Start User Data Stream (USER_STREAM)

                Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active `listenKey`, that `listenKey` will be returned and its validity will be extended for 60 minutes.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[StartUserDataStreamResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamsApi.start_user_data_stream()
