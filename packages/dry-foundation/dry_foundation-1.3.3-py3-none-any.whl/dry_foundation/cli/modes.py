"""Application objects for running the app via the CLI."""

import multiprocessing
import os
from abc import ABC, abstractmethod
from functools import partial
from pathlib import Path

from flask.cli import run_command
from gunicorn.app.base import BaseApplication

from ..config import DevelopmentConfig, ProductionConfig
from ..factory import DryFlask


class CustomCLIAppMode(ABC):
    """
    An abstract mixin for running a Flask-based application with a custom CLI.

    This object is designed to allow the typical Flask application CLI
    to be customized so that apps can be created (and launched) using
    a specified mode (e.g., locally launched applications, development
    applications, and production-level applications.

    Parameters
    ----------
    context : click.core.Context
        The click context that is created by running the application
        from the command line via a click command.
    config : Config, optional
        An application configuration object to be used by this mode
        during launch.
    **kwargs :
        Keyword arguments to be passed to other parent classes
        during instantiation (other than the click context).

    Notes
    -----
    Typically, the Flask application object can load a configuration.
    The ``DryFlask`` object provided by this package customizes the
    Flask application object such that it falls back to using a default
    configuration type (generally the ``DevelopmentConfig`` when not
    otherwise specified). This application mode object will override
    that default configuration type with a mode-specific configuration
    type.

    This override is required because configurations cannot always be
    instantiated prior to initializing the application. Many of the
    instance-based configurations used by this package require knowledge
    of the application's instance path, and that path is automatically
    generated by Flask's application object after it determines the
    path.
    """

    def __init__(self, context, config=None, **kwargs):
        self._context = context
        DryFlask.set_default_config_type(self.config_type)
        self.application = self._load_application(config)
        super().__init__(**kwargs)

    @property
    @abstractmethod
    def name(self):
        raise NotImplementedError(
            "Define the name of the custom CLI mode in a subclass."
        )

    @property
    @abstractmethod
    def config_type(self):
        raise NotImplementedError(
            "A configuration type must be defined for each custom CLI mode subclass."
        )

    def _load_application(self, config):
        # CLI invocations that call the application object's `load_app` method appear
        # to hardcode calls to the `create_app` function (at least as of Flask 3.0.3).
        # This preloads the factory function with the configuration as an argument
        # to ensure it is always called.
        # `flask.cli`:
        #     https://github.com/pallets/flask/blob/3.0.3/src/flask/cli.py#L328
        if factory_func := self._context.obj.create_app:
            self._context.obj.create_app = partial(factory_func, config=config)
        return self._context.obj.load_app()


class LocalAppMode(CustomCLIAppMode):
    """
    An object for running the application locally.

    This application object will run the Flask application using the
    built-in Python server on localhost, just like the Flask development
    mode. However, it will launch from port 5001 to avoid conflicting
    with other Python servers that may attempt to run on the default
    port 5000.

    Parameters
    ----------
    context : click.core.Context
        The click context that is created by running the application
        from the command line via a click command.
    config : Config, optional
        An application configuration object to be used by this mode
        during launch.
    host : str, optional
        The hostname to use when launching the application.
    port : int, optional
        The port number to use when launching the application.
    """

    name = "local"
    config_type = ProductionConfig  # local apps have a production configuration
    default_port = 5001
    _debug = False

    def __init__(self, context, config=None, host=None, port=None):
        """Initialize the application in local mode."""
        super().__init__(context, config=config)
        self._host, self._port = self._determine_server(host, port)

    def _determine_server(self, host, port):
        # Use the Flask application host/port if configured (and not explicitly set)
        if server_name := self.application.config.get("SERVER_NAME"):
            server_name_host, _, server_name_port = server_name.partition(":")
            host = host or server_name_host
            port = port or int(server_name_port)
        # Use the default port if no other is specified
        port = port or self.default_port
        return host, port

    def run(self):
        """
        Run the application in local mode.

        Notes
        -----
        This app uses the `invoke` method of a click `Context` object
        to reproduce the standard behavior of `flask run` when running
        the app from the command line. Where Flask's run command parses
        the `FLASK_DEBUG` environment variale (rather than accepting
        `--debug` as an argument directly), this method adjusts the
        environment variable to match the default debug setting of this
        application type. If the `FLASK_DEBUG` variable is already set,
        it will override the application type's default value.
        """
        os.environ.setdefault("FLASK_DEBUG", str(self._debug))
        self._context.invoke(run_command, host=self._host, port=self._port)


class DevelopmentAppMode(LocalAppMode):
    """
    An object for running the application in development mode.

    This application object will run the Flask application using the
    built-in Python server on localhost, just like the Flask development
    mode.
    """

    name = "development"
    config_type = DevelopmentConfig
    default_port = 5000  # traditionally 5000 (set by Flask)
    _debug = True


class ProductionAppMode(CustomCLIAppMode, BaseApplication):
    """
    An object for running the application in production mode (via Gunicorn).

    This application object will run the Flask application using a
    Gunicorn server instead of the built-in Python server. Gunicorn
    settings may be provided directly as option keyword arguments to
    the constructor, or the path to a Gunicorn configuration file may be
    specified in the application configuration using the
    ``"GUNICORN_CONFIG"`` key.


    Parameters
    ----------
    context : click.core.Context
        The click context that is created by running the application
        from the command line via a click command.
    config : Config, optional
        An application configuration object to be used by this mode
        during launch.
    host : str, optional
        The hostname to use when launching the application.
    port : int, optional
        The port number to use when launching the application.
    gunicorn_config_path: os.PathLike, optional
        The path to a Gunicorn configuration file.
    **options :
        Keyword arguments specifying options used by the Gunicorn
        base application. Note that the Gunicorn ``config`` option may
        not be passed as a keyword argument option due to a name
        conflict with the application configuration. Use the
        ``gunicorn_config`` option instead.

    """

    name = "production"
    config_type = ProductionConfig
    default_port = 8000  # traditionally 8000 (set by Gunicorn)
    _default_worker_count = (multiprocessing.cpu_count() * 2) + 1

    def __init__(
        self,
        context,
        config=None,
        host=None,
        port=None,
        gunicorn_config_path=None,
        **options,
    ):
        # Gather and set default Gunicorn options
        options["config"] = self._determine_config(config, gunicorn_config_path)
        options["bind"] = self._determine_binding(host, port, options.pop("bind", None))
        options.setdefault("workers", self._default_worker_count)
        options.setdefault("worker_class", "gthread")
        self.options = options
        base_application_kwargs = {}
        super().__init__(context, config=config, **base_application_kwargs)

    def _determine_config(self, app_config, gunicorn_config_path):
        app_gunicorn_config_path = (
            getattr(app_config, "GUNICORN_CONFIG", None) if app_config else None
        )
        if gunicorn_config_path and app_gunicorn_config_path:
            abs_gunicorn_config_path = Path(gunicorn_config_path).absolute()
            abs_app_gunicorn_config_path = Path(app_gunicorn_config_path).absolute()
            if abs_gunicorn_config_path != abs_app_gunicorn_config_path:
                raise ValueError(
                    "Gunicorn configurations were specified both as a keyword argument "
                    "and as a key in the application configuration, but they do not "
                    "match."
                )
        return gunicorn_config_path or app_gunicorn_config_path

    def _determine_binding(self, host, port, bind_option):
        # Parse any socket binding options
        if port and not host:
            raise ValueError("A host must be specified when the port is given.")
        if host:
            if bind_option:
                raise ValueError(
                    "The `host` may not be specified directly if the `bind` option is used."
                )
            port = port or self.default_port
            bind_option = ":".join([host, str(port)])
        return bind_option

    def load_config(self):
        config = {
            key: value
            for key, value in self.options.items()
            if key in self.cfg.settings and value is not None
        }
        for key, value in config.items():
            self.cfg.set(key.lower(), value)

    def load(self):
        return self.application

    def run(self, *args, **kwargs):
        return super().run(*args, **kwargs)


def _get_all_subclasses(cls):
    # Get all subclasses (recursively) of the given class
    direct_subclasses = set(cls.__subclasses__())
    subsubclasses = {
        subsubcls
        for subcls in direct_subclasses
        for subsubcls in _get_all_subclasses(subcls)
    }
    return direct_subclasses.union(subsubclasses)


cli_modes = {mode.name: mode for mode in _get_all_subclasses(CustomCLIAppMode)}
