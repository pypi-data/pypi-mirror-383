from _typeshed import Incomplete

def integrate(integrand, start, end, C: int = 0): ...

class Meloning:
    eps: Incomplete
    dim: Incomplete
    f: Incomplete
    ints: Incomplete
    def __init__(self, eps, dim, f, ints) -> None: ...
    def slice_out(self, _data): ...
    def slice_in(self, _data): ...
    def new_poly(self, x): ...
    def sum_poly(self, x): ...
    def h(self, _data): ...
    def transform_out_eps(self, _data): ...
    def transform_in_eps(self, _data): ...
    def integrand_in(self, x): ...
    def I_in(self, x): ...
    def I_in_inv(self, y): ...
    def g_in(self, x): ...
    def integrand_out(self, x): ...
    def I_out(self, x): ...
    def I_out_inv(self, y): ...
    def g_out(self, x): ...
    def S_out(self, x): ...
    def g(self, x): ...
    def transform_piece(self, _data): ...

def get_indicator_function(data, threshold, bins: int = 10): ...
def approximate_norms_with_gaussians(vectors, n_components): ...
def gauss(x, weights, means, variances): ...
def get_poly_coeffs(f, degree, a, b, num_samples: int = 1000): ...
def poly(x, coeffs): ...
def get_f(X, data, gaus_deg, poly_deg, threshold, bins): ...

class Encode:
    method: Incomplete
    cplx: Incomplete
    pca_dim: Incomplete
    ind: Incomplete
    eps: Incomplete
    def __init__(self, method, cplx, eps, pca_dim: Incomplete | None = None, ind: Incomplete | None = None) -> None: ...
    in_dim: Incomplete
    dim: Incomplete
    padding: Incomplete
    pca: Incomplete
    LDE: Incomplete
    scaler: Incomplete
    norm_coef: Incomplete
    def fit(self, data) -> None: ...
    def transform(self, data): ...

def set_seed(seed: int): ...
def projection(_data): ...
def get_LDE(data, pca_dim: int = 13, poly_deg: int = 0, eps: float = 0.999, seed: int = 0): ...
