class BFInterpreter {

    func __init__(self, source, cells=None, input=None, output=None) {
        if (input is None) {
            from getch import getch

            func input() {
                while True {
                    result = ord(getch())
                    if (0 <= result <= 255)
                        return result
                }
            }
        }

        if (output is None) {
            sys = pyimport('sys')

            func output(byte) {
                sys.stdout.write(chr(byte))
                sys.stdout.flush()
            }
        }

        if (not isinstance(source, str))
            throw TypeError("BFInterpreter() source must be string")
        if (not isinstance(cells, (int, type(None))))
            throw TypeError("BFInterpreter() cells must be integer")
        if (not callable(input))
            throw TypeError("BFInterpreter() input must be callable")
        if (not callable(output))
            throw TypeError("BFInterpreter() output must be callable")
        if (not (cells is None) and cells <= 0)
            throw ValueError("BFInterpreter() cells must be greater than 0")

        self.running = False

        self.source = source
        self.cells = cells
        self.input = input
        self.output = output

        self._tokenIndex = -1
        self._tokens = []
        self._bracketMap = {}

        stack = []
        comment = False
        tokenIndex = 0

        for ([position, character] of enumerate(source)) {
            if (not comment and character == '#')
                comment = True
            elif (comment and character == '\n')
                comment = False

            if (not comment and character in '<>+-,.[]') {

                if (character == '[') {
                    stack.append(tokenIndex)
                }

                elif (character == ']') {
                    if (not stack)
                        throw SyntaxError("unbalanced brackets")

                    startIndex = stack.pop()

                    self._bracketMap[startIndex] = tokenIndex
                    self._bracketMap[tokenIndex] = startIndex
                }

                self._tokens.append((position, character))
                tokenIndex++

            }
        }

        if stack
            throw SyntaxError("unbalanced brackets")
    }

    func start(self) {
        if (self.running) return;

        self._tokenIndex = -1

        self.running = True
        self.memory = [0]
        self.point = 0

        if (self.cells is not None) {
            self.memory *= self.cells
        }
    }

    func step(self) {
        if (not self.running) return;

        self._tokenIndex++

        if (self._tokenIndex >= len(self._tokens)) {
            self.running = False
            return
        }

        [position, character] = self._tokens[self._tokenIndex]
        dataPointer = self.memory[self.point]

        if (character == '>') {
            self.point++
            if (self.cells is None) {
                if (self.point == len(self.memory)) {
                    self.memory.append(0)
                }
            }
            elif (self.point >= self.cells) {
                throw IndexError("pointer out of bounds")
            }
        }

        elif (character == '<') {
            if (self.point == 0) {
                throw IndexError("pointer out of bounds")
            }
            self.point--
        }

        elif (character == '+') {
            self.memory[self.point] = (dataPointer + 1) % 256
        }

        elif (character == '-') {
            self.memory[self.point] = (dataPointer - 1) % 256
        }

        elif (character == ',') {
            input = self.input()

            if (not (isinstance(input, int) and 0 <= input <= 255))
                throw TypeError("BFInterpreter() input must be returns unsigned 8-bit integer")

            self.memory[self.point] = input
        }

        elif (character == '.') {
            self.output(dataPointer)
        }

        elif (character == '[' and dataPointer == 0) {
            self._tokenIndex = self._bracketMap[self._tokenIndex]
        }

        elif (character == ']' and dataPointer != 0) {
            self._tokenIndex = self._bracketMap[self._tokenIndex]
        }

        return (self.point, position, character)
    }

    func stop(self, cleanUp=True) {
        if (not self.running) return;

        self.running = False

        if cleanUp
            del [self.memory, self.point]
    }

    func __iter__(self) {
        self.start()
        return self
    }

    func __next__(self) {
        result = self.step()

        if (result is None)
            throw StopIteration

        return result
    }
}

func bf_exec(source, cells=None, input=None, output=None) {
    interpreter = BFInterpreter(source, cells, input, output)

    for (_ of interpreter);

    interpreter.stop()
}