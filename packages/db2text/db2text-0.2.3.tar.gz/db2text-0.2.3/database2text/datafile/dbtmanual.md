# db2text

## 概述

这个软件包大致分为2个部分，一个是dbt命令行工具，可用于读取数据库里的对象如表、视图等的结构，根据这些结构生成、修改文本文件。典型应用场景如下：

* 生成结构文本数据，配合版本控制，可以备份、检查、跟踪数据库结构的变动情况。
* 设置模板，自动更新c/c++的源代码，比如oracle pro*c里以下跟结构密切相关的代码都可以自动生成、更新
```
struct stru_note_request {//消息请求队列 note_request
    long     id;                        //请求ID id
    long     group_id;                  //收件组ID group_id
    char     group_name[256];           //收件组名 group_name
    char     note_content[4001];        //消息内容 note_content
    long     note_type;                 //0-短信 1-微信 2-语音 3-工作台
    long     save_days;                 //单位-天
};

```
* 设置模板，自动更新markdown文档，如

| 字段名 | 类型 | 空 | 默认值 | 说明 |
| :----  | :---- | :---- | :---- | :---- |
| xmjdid | bigint(20) |  |  | 项目进度id |
| xmid | bigint(20) |  |  | 项目id |
| cyrid | bigint(20) |  |  | 身份表里的身份id |
| clnr | longblob |  |  | 处理内容 |
| tjsj | datetime |  |  | 提交时间 |
| clff | varchar(50) | 可 |  | 处理方法 |

还有一个部分就是提供一个库，方便大家解析数据库，获取数据结构，进行一些自己的处理。dbt命令行工具可以认为就是用这个库写出来的一个应用吧。

## 安装

```
pip install db2text
```

执行命令为dbt，如果系统内原来有dbt命令，也可以使用db2text，这两个命令是完全等效的。

可以增加一个参数文件名作为执行文件，无参数则读取当前目录下的dbt.txt文件。

参数文件以.md结尾，则扫描.md文件中的配置信息，处理此md文件。

# dbt.txt 配置文件格式

所有#号开头的行为注释行，忽略其内容。

以:开头的行为段开始，后续直到另一个段开始的内容均属于这个段。文件开头为global段，不需要定义段开始。

各段的内容根据不同的段会有差异，扫描执行文件时会把每一行符合x=y格式的内容解析出来做为参数在调用段函数时使用。一段内容全部扫描结束后开始执行这一段。

解析x=y这样的行时，会把x当成属性名，把y当成属性内容存入stdata字典中，即stdata[x]=y。如果x多次定义，以最后一次为准，不过这里有个特例，如果这一行以`\`结尾，则认为这一行没有结束，下一次再遇到相同的x行，会把这两行的属性内容加到一些作为最终的属性内容。比如：

```
table= + .* - abc.* \
table= + abcd.*
```
最终得到的结果就是`table= + .* - abc.* + abcd.*`

不同的数据库各段可能会有差异，不过不同的驱动器会尽可能保持一致，以方便用户切换数据库时学习成本较低。

执行文件中段的数量没有限制，执行时依次处理各段。

## global段

此段定义一些全局变量，目前支持的全局变量有：

* code      设置这个配置文件的字符集，不设置就认为是utf8
* coding    等同于code

如`coding=gbk`则指定当前的配置文件的字符集gbk

## connect段

首先要有一行

`driver=mysql | oracle11 | mssql`

指定连接到哪种数据库，根据数据库的不同，后续的参数会有差异。具体参数可以参考样例文件。样例文件可以在https://gitee.com/chenc224/dbt/tree/master/database2text/datafile/sample 下察看。

增加使用dbcfg方法，这里的配置就容易一些，只用一行比如

`dbcfg=mysql234`

就可以了，后续会自动使用dbcfg来进行数据库连接。注意如果没有设置driver，则使用dbcfg设置中的db内容来作为driver使用。

## readdata段
读入数据库结构，具体数据格式细节随驱动器不同会有差异。

table= +/- 用空格隔开的表名，支持python正则表达式，如`.*`匹配所有表

默认情况下处理所有的对象，如果想处理部分对象，可以在这里指定，+后面跟的对象是需要处理的，-后面跟的对象是不需要处理的。+/-可以多次使用，按照设置的顺序依次检查。注意前面要加一个`+ .*`引入全部对象，再使用`-`才有意义。不设置等同于`+ .*`。

owner=属主 用于oracle等数据库需要读取的对象属主和连接数据库的用户不同时使用。

读入数据保存在dbdata字典中。详情参考下面《设计思路/读数据库模块设计/readdata方法》章节内容。

## export段
将读入的数据库结构导出成文本文件。

这些文件按类组织，如表放在TABLE目录下，视图放在VIEW目录下。目录之下一个对象独立为一个文件。这些文件保存为.sql，尽可能保证是相应对象在数据库中建立的格式。

## render段
file=文件名 行告诉执行器处理哪一个文件。

table= 可以设置只处理部分表，语法参考readdata段的内容。注意readdata段设置则在读入阶段就对表进行筛选，而在render段设置仅在输出时进行筛选。如果想提高处理速度，可以考虑在readdata段设置。如果是一次读入，然后分多次输出（比如输出到不同文件），则考虑在这里设置。

help=y 会让执行器输出传递给jinja2渲染的数据内容，方便写模板时参考。

start=和end=这两行告诉执行器在文件中搜索需要替换的文件内容的头和尾。头和尾可以是同一行，这样可以适应单行方式。搜索以python的re正则模块按行搜索。从文件头开始，搜索到start行之后继续搜索end，start和end以及中间的所有行就是找到的需要替换的文本块。

start和end行中间的内容约定是jinj2模板，使用dbdata["c"]["TABLE"]下对应表的那个字典去渲染。渲染后得到的结果判定是否需要和首尾行合并，判断的方法是取首、尾行分别和start、end行进行正则匹配，如果不匹配，则加上相应的首尾行。

这个设计的应用场景类似我要定义一个结构，首行是

struct stru_表名 {	//表的说明信息

这里的表名和说明信息都是变化的，如果修改了表的说明信息，那么下一次搜索替换的时候就找不到老的结构定义位置了，所以查找首行的时候start行不能写表的说明信息只能写类似  
struct stru_{{ tname }} {  
这样，然后在模板的第一行写上类似  
struct stru_{{ tname }} {	//{{ tdesc }}
	
这样搜索的时候可以正确找到描述不同的首行，替换的时候也可以保证首行被正确修改。

最终得到的结果和要替换的文本块进行比较，如果有差异，则重写文件，用新内容替换掉老的内容。

因为要处理多张表，所以start和end会先用表名{{ name }} 和表注释{{ desc }} 渲染一下。

如果start行搜索不到，则在文件的结尾追加内容

## dot段

生成dot语言(graphviz)的文件，显示表结构

dotdir=指定dot文件目录，未指定则放在当前目录

pdfdir=指定pdf文件放在哪个目录，未指定则放在dotdir目录下

filename=dot和pdf文件名，不带扩展名

dotcmd=neato    指定graphviz布局算法，可以选择twopi、circo、fdp和osage这些，未指定使用fdp。不建议使用dot，patchwork，布局严重有问题，也不建议使用neato、sfdp，生成的pdf尺寸有点问题。

page= 页名称列表，用空格隔开，如 用户类 权限相关 交易 流程控制等 other/其它

page设置的是页名称列表，每个页名称对应一个设置项，other或者其它不需要指定，会把没用过的表全部输出，每页设置如下：

用户类=+ .*user.* 语法参照table=，

每个页名称会生成一页pdf，最终合成得到一个多页的pdf。如果不需要多页pdf，可以不用设置page语句。

## wiki段

生成wiki里的表格。如果指定wiki，可以直接用wiki机器人自动更新wiki内容。如果不指定wiki，则输出文本内容供粘贴。

生成内容类似下面这样

```
{| class="wikitable"
|+ 表名 表的注释内容
! 字段名  !! 类型    !! 说明
|-
|| 字段1名字  || 字段1类型  || 字段1说明
|-
|| 字段2名字  || 字段2类型  || 字段2说明
|}
```

自动更新内容时寻找前两行内容匹配的，注意表的注释内容有差异不影响匹配。从这两行开始直到|}结束的行就是需要更新的区域。

title = name:字段名 desc:注释 ts:类型 default:默认值 :说明

title设置表格有几列，列和数据之间的关系，列是数据中的md列表内容，如果不指定列，这一列由用户自行填写，不做更新。

wiki = wiki  dbcfg配置的wiki登录方式，如果设置，可以用wiki机器人自动更新。如果未设置，则输出文本。

page = 页面名称 即相应页地址最后内容如http://地址/mediawiki/index.php/页面名称

level = 2 如果是一张新表，会在内容的最后增加这个表格，在表格前面还会加一个标题如 == 表名 表的注释内容 ==，这里的level指定=的个数，如果未设置，不增加这个标题行

## end段

发现这个段就意味着执行器停止扫描，这样可以把一些暂时不用的代码放在end段后面。

这个段最好写上，因为执行器的“特性”，实际上它并不处理最后一个段。。。。

# md文件 配置

指定处理.md文件时，会读取.md文件里用`<!-- dbt `开头，` -->`结尾的内容做为配置内容，并根据这些内容进行处理。中间的配置内容参照dbt.txt格式说明。样例如下：

```
<!-- dbt 
(这一部分内容参考dbt.txt格式)
-->
```

# 设计思路

dbt执行时根据dbt.txt里的内容执行相应处理。主要流程就是连接数据库、读取数据库结构、导出结构或者根据结构调整文本。这里连接数据库、读取数据库结构考虑设计成模块化的，这样可以方便替换不同的数据库。后续导出结构或者根据结构调整文本其实不同的数据库是基本类似的，差异可能只是数据结构有不同，所以这一部分设计成通用的。

## db2text 模块

新构建db2text模块替代过往的database2text模块，老的模块结构不合理，需要优化，顺便把名字改短一点。

模块提供一些全局的数据gd和一些函数、类供使用，计划将配置信息、中间结果等都放在gd里。

如果使用import db2text as dt这样的导入方式，需要使用dt.gd.coding这样来使用gd里的数据，函数则使用dt.函数名来使用。建议使用这种方式避免名字污染。

如果使用from db2text import * 这样的导入方式，可以使用gd.coding这样来使用gd里的数据，函数则直接用函数名来使用。

后续dbt改用db2text，全部迁移后老的database2text将会废弃。

gd （global data）的说明可以直接察看data.py，里面有清单和说明。

函数、公用类说明在下面，单起一章。

## 读数据库模块设计

系统已经有一些模块可以用来处理oracle、mysql、mssql，如果有其它数据库要处理，可以在https://gitee.com/chenc224/dbt/issues提需求，也可以根据模块的设计思路自己写一个。

模块使用python编写，定义在dababase2text目录下。命名方法建议使用数据库名称+版本这样的方式如oracle11.py。

考虑在最前面定义
```
import database2text.tool as dbtt
from database2text.tool import *

__all__=["connect","readdata"]
```

模块至少提供connect和readdata方法供调用。

### connect方法

入口参数是一个字典，列出connect段中数据，比如connect段如下
```
:connect
driver=mssql
dbinfo={"server":"库地址", "database":"库名", "user":"用户", "password":"密码", "port":1433, "readonly":true}
dbcfg=dbname
```
则入口参数字典数据是：

{'driver': 'mssql', 'dbinfo': '{"server":"库地址","database":"库名","user":"用户","password":"密码","port":1433,"readonly":true}', 'dbcfg': 'dbname'}

注意上面这个只是用来举例，实际上dbinfo和dbcfg用一个就可以了。

### readdata方法

入口参数是一个字典，列出readdata段中数据，里面会有一些参数控制读取的内容，不同数据库，不同驱动，不同的版本，这些内容会有差异。

返回数据放在dbtt.dbdata多级字典中。千万注意不同的数据库，不同的驱动器版本，返回的结果也会有比较大的差异，甚至于缺失部分数据。以下说明应该看成是一种约定，写驱动的时候会尽可能遵守这些约定。

dbtt.dbdata多级字典结构如下表，例如`dbtt.dbdata["sql"]["TABLE"]["bm"]`就是bm这张表的建表语句。

|数据类别|对象类别|对象名|说明|
|:--|:--|:--|:--|
|sql|TABLE|表名|建表语句|
|exp|TABLE|表名|表结构数据列表|

表结构数据列表是一个列表，每一行是一个字典，是一张表的信息，内容如下：

|字典键值|内容说明|
|:--|:--|
|tname|表名|
|tdesc|表的描述信息|
|ori|从数据库中获取的原始信息，具体细节跟数据库相关|
|c|c列表，用于c/c++字义变量时使用|
|md|md列表,用于输出markdown格式的一些字段数据|

c列表，每一行是一个字典，代表一个字段，字典说明如下

|字典键值|内容说明|
|:--|:--|
|cname|字段名，可以用来定义变量名|
|ns|字段名及长度，用来定义字符型变量，例如char abc[50]|
|cdesc|字段的描述，可用于注释|
|type|字段对应的字段类型,如double，char，int等|

md列表，每一行是一个字典，代表一个字段，字典说明如下

|字典键值|内容说明|
|:--|:--|
|name|字段名|
|desc|注释|
|type|数据类型，原始数据库中的数据类型|
|size|字段长度|
|null|逻辑值，为真表示可为空|
|default|默认值|
|ts|类型+长度，比如char(5)这样的格式|
|pk|逻辑值，为真表示是主键列|
