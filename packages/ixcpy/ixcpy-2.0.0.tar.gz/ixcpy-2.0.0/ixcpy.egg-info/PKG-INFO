Metadata-Version: 2.4
Name: ixcpy
Version: 2.0.0
Summary: Wrapper n√£o oficial para conex√£o com a API do sistema IXC Provedor
Home-page: https://github.com/SousaFelipe/ixcpy
Author: Felipe Sousa
Author-email: fscarmo@proton.me
License: MIT License
Keywords: ixc,ixcsoft,api ixc,ixc provedor,ixc python
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: requests
Dynamic: author
Dynamic: author-email
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: keywords
Dynamic: license
Dynamic: license-file
Dynamic: requires-dist
Dynamic: summary


# ixcpy [![PyPI downloads](https://img.shields.io/pypi/dm/ixcpy.svg)](https://pypi.org/project/ixcpy/)

Esta biblioteca n√£o faz parte das bibliotecas oficiais do <a href="https://ixcsoft.com/ixc-provedor" target="_blank">IXC Provedor</a>.\
O desenvolvimento √© feito de forma independente e utiliza apenas uma "interface" de conex√£o com as funcionalidades providas pela API oficial do IXC.\
Voc√™ poder√° encontrar orienta√ß√µes de como parametrizar as requisi√ß√µes na <a href="https://wikiapiprovedor.ixcsoft.com.br/" target="_blank">WIKI oficial</a>, disponilizada pela pr√≥pria <a href="https://ixcsoft.com/" target="_blank">IXC Soft</a>.


## Dispon√≠vel nos reposit√≥rios <a href="https://pypi.org/">PyPI</a>
###### Adicione ao seu projeto utilizando o comando <a href="https://pypi.org/project/pip/" target="_blank">pip install</a>.

```bash
pip install ixcpy
```


## Configura√ß√£o b√°sica
###### Adicione as vari√°veis de ambiente a um `.env` na raiz do seu projeto:

```dotenv
IXC_ACCESS_TOKEN=conte√∫do-do-token-gerado-dentro-do-ixc-provedor
IXC_SERVER_DOMAIN=www.dom√≠nio-do-seu-servidor-ixc-provedor.com.br
```

> [!NOTE]\
> N√£o sabe como gerar um token? Basta consultar <a href="https://wiki.ixcsoft.com.br/pt-br/API/como_gerar_um_token_para_integra%C3%A7%C3%B5es_API" target="_blank">este tutorial</a>.


## Do jeito mais din√¢mico üòé
###### Realizando uma consulta atrav√©s da classe Connection:

```python
from ixcpy import Connection

connection = Connection(table='cliente')

# O operador "%" far√° a busca em todos os clientes que possuem "Jo√£o" no campo "razao".
connection.where(args='razao % "Jo√£o"')

# Para encontrar um registro pelo nome que seja exatamente igual ao que voc√™ busca,
# substitua o operador "%" pelo "=".
connection.where(args='razao = "Nome Completo do Jo√£o"')

# Para realizar a busca em qualquer outro campo, basta alterar a query,
# como no exemplo abaixo, tendo em vista que o campo deve corresponder
# a uma coluna da tabela que voc√™ est√° buscando, no IXC Provedor.
# Nesse caso, o campo "cnpj_cpf", na tabela "cliente"
connection.where(args='cnpj_cpf = "123.456.789-10"')
```

> Depois de invocar o m√©todo `where()` uma ou mais vezes, basta invocar o m√©todo `many()` na sua inst√¢ncia de `Connection`\
> Ent√£o voc√™ ir√° obter a inst√¢ncia de um objeto do tipo `Response`, de onde poder√° acessar a quantidade de registros retornados, atrav√©s do m√©todo `total()`.\
> E uma lista dos objetos, a partir do m√©todo `records()`, tudo atrav√©s da inst√¢ncia de `Response`.


## Do jeito mais simples üéØ

Supondo que voc√™ possua o ID de um determinado registro e queira busc√°-lo no IXC Provedor, seria contraproducente encadear "chamadas where". 
Nesse caso, basta invocar o m√©todo `one()` em uma inst√¢ncia de `Connection`, passando o ID como par√¢metro, como no exemplo a seguir:

```python
from ixcpy import Connection

connection = Connection(table='cliente')

# Se o IXC encontrar um registro (na tabela "cliente" nesse caso), o m√©todo "one" retornar√° um 'dict'
# onde as chaves ser√£o do tipo 'str' e o valor de cada campo podendo ser 'str', 'int' ou 'bool',
# dependendo do formato retornado pelo IXC Provedor. Se nenhum registro for encontrado,
# o m√©todo "one" retornar√° um 'None'
cliente = connection.one(record_id=12345)
```


## Dica!
Uma op√ß√£o pr√°tica √© criar uma classe personalizada que herde de `Connection`, assim ser√° poss√≠vel encapsular as buscas
detro da subclasse correspondente √† tabela que voc√™ deseja manipular, como no exemplo a seguir:

```python
from ixcpy import Connection

class Cliente(Connection):
    
    def __init__(self):
        super().__init__('cliente')
        
    def lista_por_data_cadastro(self, data_cadastro: str, page: int = 1) -> list:
        self.where(args=f'data_cadastro >= {data_cadastro}')
        resposta = self.many(page=page)
        return resposta.records()

```


## Clone & Setup

```bash
git clone https://github.com/SousaFelipe/ixcpy.git
```
```bash
cd ixcpy
```
```bash
python -m venv .venv
```
```bash
.venv\Scripts\activate
```
```bash
python -m pip install -r requirements.txt
```


## Contribui√ß√µes

Contribui√ß√µes s√£o sempre bem-vindas!\
Se voc√™ conhece uma maneira melhor de fazer algo, por favor, me avise!
Caso contr√°rio, √© sempre melhor fazer um PR na branch main.

At.te,\
<b>Felipe S. Carmo</b>.
