diff -Naur solvers/glucose421/Makefile solvers/g421/Makefile
--- solvers/glucose421/Makefile	1970-01-01 01:00:00
+++ solvers/g421/Makefile	2023-07-12 01:52:06
@@ -0,0 +1,37 @@
+### Makefile ---
+
+## Author: aign
+## Keywords:
+
+# main parameters
+CXX      := c++
+CXXFLAGS := -std=c++11 -fPIC -Wall -Wno-deprecated -fno-strict-aliasing -Wno-parentheses -DINCREMENTAL
+CXXOPT   := -O3 -DNDEBUG
+CXXDEBUG := -O0 -g3
+CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
+INCLUDES := -I..
+LIBS     := -L.
+SOURCES  := core/lcm.cc core/Solver.cc utils/Options.cc utils/System.cc
+OBJECTS  := $(SOURCES:.cc=.o)
+TRGT     :=  glucose421
+
+# gather compiler options
+CXXARGS := $(CXXFLAGS) $(INCLUDES) $(CXXOPT)
+
+# targets
+.PHONY: all clean lib
+
+all: lib
+
+lib: $(OBJECTS)
+	@-ar cr lib$(TRGT).a $(OBJECTS)
+
+%.o: %.cc
+	$(CXX) $(CXXARGS) -c $< -o $@
+
+clean:
+	@-rm $(OBJECTS)
+
+allclean:
+	@-find . -name '*.o' -delete
+	@-find . -name '*.a' -delete
diff -Naur solvers/glucose421/core/BoundedQueue.h solvers/g421/core/BoundedQueue.h
--- solvers/glucose421/core/BoundedQueue.h	2023-05-09 15:19:52
+++ solvers/g421/core/BoundedQueue.h	2023-07-12 01:52:06
@@ -48,14 +48,14 @@
  **************************************************************************************************/
 
 
-#ifndef BoundedQueue_h
-#define BoundedQueue_h
+#ifndef Glucose421_BoundedQueue_h
+#define Glucose421_BoundedQueue_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
 //=================================================================================================
 
-namespace Glucose {
+namespace Glucose421 {
 
 template <class T>
 class bqueue {
diff -Naur solvers/glucose421/core/Solver.cc solvers/g421/core/Solver.cc
--- solvers/glucose421/core/Solver.cc	2023-05-09 15:19:52
+++ solvers/g421/core/Solver.cc	2023-07-12 01:52:06
@@ -49,13 +49,12 @@
 
 #include <math.h>
 
-#include "utils/System.h"
-#include "mtl/Sort.h"
-#include "core/Solver.h"
-#include "core/Constants.h"
-#include"simp/SimpSolver.h"
+#include "glucose421/utils/System.h"
+#include "glucose421/mtl/Sort.h"
+#include "glucose421/core/Solver.h"
+#include "glucose421/core/Constants.h"
 
-using namespace Glucose;
+using namespace Glucose421;
 
 
 //=================================================================================================
@@ -153,6 +152,7 @@
 , randomizeFirstDescent(false)
 , garbage_frac(opt_garbage_frac)
 , certifiedOutput(NULL)
+, certifiedPyFile(NULL)
 , certifiedUNSAT(false) // Not in the first parallel version
 , vbyte(false)
 , panicModeLastRemoved(0), panicModeLastRemovedShared(0)
@@ -183,6 +183,7 @@
 , order_heap(VarOrderLt(activity))
 , progress_estimate(0)
 , remove_satisfied(true)
+, warm_start(false)
 ,lastLearntClause(CRef_Undef)
 // Resource constraints:
 //
@@ -389,7 +390,7 @@
     watchesBin.init(mkLit(v, true));
     unaryWatches.init(mkLit(v, false));
     unaryWatches.init(mkLit(v, true));
-    assigns.push(l_Undef);
+    assigns.push(g421l_Undef);
     vardata.push(mkVarData(CRef_Undef, 0));
     activity.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
     seen.push(0);
@@ -397,6 +398,7 @@
     polarity.push(sign);
     forceUNSAT.push(0);
     decision.push();
+    assump.push(false);
     trail.capacity(v + 1);
     setDecisionVar(v, dvar);
 
@@ -421,15 +423,15 @@
     if(certifiedUNSAT) {
         for(i = j = 0, p = lit_Undef; i < ps.size(); i++) {
             oc.push(ps[i]);
-            if(value(ps[i]) == l_True || ps[i] == ~p || value(ps[i]) == l_False)
+            if(value(ps[i]) == g421l_True || ps[i] == ~p || value(ps[i]) == g421l_False)
                 flag = 1;
         }
     }
 
     for(i = j = 0, p = lit_Undef; i < ps.size(); i++)
-        if(value(ps[i]) == l_True || ps[i] == ~p)
+        if(value(ps[i]) == g421l_True || ps[i] == ~p)
             return true;
-        else if(value(ps[i]) != l_False && ps[i] != p)
+        else if(value(ps[i]) != g421l_False && ps[i] != p)
             ps[j++] = p = ps[i];
     ps.shrink(i - j);
 
@@ -543,12 +545,12 @@
 bool Solver::satisfied(const Clause &c) const {
 #ifdef INCREMENTAL
     if(incremental)
-        return (value(c[0]) == l_True) || (value(c[1]) == l_True);
+        return (value(c[0]) == g421l_True) || (value(c[1]) == g421l_True);
 #endif
 
     // Default mode
     for(int i = 0; i < c.size(); i++)
-        if(value(c[i]) == l_True)
+        if(value(c[i]) == g421l_True)
             return true;
     return false;
 }
@@ -575,7 +577,7 @@
         int nb = 0;
         for(int k = 0; k < wbin.size(); k++) {
             Lit imp = wbin[k].blocker;
-            if(permDiff[var(imp)] == MYFLAG && value(imp) == l_True) {
+            if(permDiff[var(imp)] == MYFLAG && value(imp) == g421l_True) {
                 nb++;
                 permDiff[var(imp)] = MYFLAG - 1;
             }
@@ -606,7 +608,7 @@
     if(decisionLevel() > level) {
         for(int c = trail.size() - 1; c >= trail_lim[level]; c--) {
             Var x = var(trail[c]);
-            assigns[x] = l_Undef;
+            assigns[x] = g421l_Undef;
             if(phase_saving > 1 || ((phase_saving == 1) && c > trail_lim.last())) {
                 polarity[x] = sign(trail[c]);
             }
@@ -628,12 +630,12 @@
     // Random decision:
     if(((randomizeFirstDescent && conflicts == 0) || drand(random_seed) < random_var_freq) && !order_heap.empty()) {
         next = order_heap[irand(random_seed, order_heap.size())];
-        if(value(next) == l_Undef && decision[next])
+        if(value(next) == g421l_Undef && decision[next])
             stats[rnd_decisions]++;
     }
 
     // Activity based decision:
-    while(next == var_Undef || value(next) != l_Undef || !decision[next])
+    while(next == var_Undef || value(next) != g421l_Undef || !decision[next])
         if(order_heap.empty()) {
             next = var_Undef;
             break;
@@ -693,9 +695,9 @@
         Clause &c = ca[confl];
         // Special case for binary clauses
         // The first one has to be SAT
-        if(p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
+        if(p != lit_Undef && c.size() == 2 && value(c[0]) == g421l_False) {
 
-            assert(value(c[1]) == l_True);
+            assert(value(c[1]) == g421l_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp;
         }
@@ -752,7 +754,7 @@
                             lastDecisionLevel.push(q);
                     } else {
                         if(isSelector(var(q))) {
-                            assert(value(q) == l_False);
+                            assert(value(q) == g421l_False);
                             selectors.push(q);
                         } else
                             out_learnt.push(q);
@@ -878,8 +880,8 @@
         assert(reason(var(analyze_stack.last())) != CRef_Undef);
         Clause &c = ca[reason(var(analyze_stack.last()))];
         analyze_stack.pop(); //
-        if(c.size() == 2 && value(c[0]) == l_False) {
-            assert(value(c[1]) == l_True);
+        if(c.size() == 2 && value(c[0]) == g421l_False) {
+            assert(value(c[1]) == g421l_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp;
         }
@@ -950,7 +952,7 @@
 
 
 void Solver::uncheckedEnqueue(Lit p, CRef from) {
-    assert(value(p) == l_Undef);
+    assert(value(p) == g421l_Undef);
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
@@ -962,7 +964,59 @@
     return;
 }
 
+//=================================================================================================
+// Propagate and check (added for PySat):
+bool Solver::prop_check(const vec<Lit>& assumps, vec<Lit>& prop, int psaving)
+{
+    prop.clear();
 
+    if (!ok)
+        return false;
+
+    bool    st = true;
+    int  level = decisionLevel();
+    CRef confl = CRef_Undef;
+
+    // dealing with phase saving
+    int psaving_copy = phase_saving;
+    phase_saving = psaving;
+
+    // propagate each assumption at a new decision level
+    for (int i = 0; st && confl == CRef_Undef && i < assumps.size(); ++i) {
+        Lit p = assumps[i];
+
+        if (value(p) == g421l_False)
+            st = false;
+        else if (value(p) != g421l_True) {
+            newDecisionLevel ();
+            uncheckedEnqueue(p);
+            confl = propagate();
+        }
+    }
+
+    // copying the result
+    if (decisionLevel() > level) {
+        for (int c = trail_lim[level]; c < trail.size(); ++c)
+            prop.push(trail[c]);
+
+        // if there is a conflict, pushing
+        // the conflicting literal as well
+        // here we may choose a wrong literal
+        // in Glucose if the clause is binary!
+        if (confl != CRef_Undef)
+            prop.push(ca[confl][0]);
+
+        // backtracking
+        cancelUntil(level);
+    }
+
+    // restoring phase saving
+    phase_saving = psaving_copy;
+
+    return st && confl == CRef_Undef;
+}
+
+
 /*_________________________________________________________________________________________________
 |
 |  propagate : [void]  ->  [Clause*]
@@ -993,11 +1047,11 @@
 
             Lit imp = wbin[k].blocker;
 
-            if(value(imp) == l_False) {
+            if(value(imp) == g421l_False) {
                 return wbin[k].cref;
             }
 
-            if(value(imp) == l_Undef) {
+            if(value(imp) == g421l_Undef) {
                 uncheckedEnqueue(imp, wbin[k].cref);
             }
         }
@@ -1006,7 +1060,7 @@
         for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if(value(blocker) == l_True) {
+            if(value(blocker) == g421l_True) {
                 *j++ = *i++;
                 continue;
             }
@@ -1024,7 +1078,7 @@
             // If 0th watch is true, then clause is already satisfied.
             Lit first = c[0];
             Watcher w = Watcher(cr, first);
-            if(first != blocker && value(first) == l_True) {
+            if(first != blocker && value(first) == g421l_True) {
 
                 *j++ = w;
                 continue;
@@ -1034,14 +1088,14 @@
               int choosenPos = -1;
               for (int k = 2; k < c.size(); k++) {
 
-            if (value(c[k]) != l_False){
+            if (value(c[k]) != g421l_False){
               if(decisionLevel()>assumptions.size()) {
                 choosenPos = k;
                 break;
               } else {
                 choosenPos = k;
 
-                if(value(c[k])==l_True || !isSelector(var(c[k]))) {
+                if(value(c[k])== g421l_True || !isSelector(var(c[k]))) {
                   break;
                 }
               }
@@ -1056,7 +1110,7 @@
 #endif
             for(int k = 2; k < c.size(); k++) {
 
-                if(value(c[k]) != l_False) {
+                if(value(c[k]) != g421l_False) {
                     c[1] = c[k];
                     c[k] = false_lit;
                     watches[~c[1]].push(w);
@@ -1068,7 +1122,7 @@
 #endif
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
-            if(value(first) == l_False) {
+            if(value(first) == g421l_False) {
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -1116,7 +1170,7 @@
     for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
         // Try to avoid inspecting the clause:
         Lit blocker = i->blocker;
-        if(value(blocker) == l_True) {
+        if(value(blocker) == g421l_True) {
             *j++ = *i++;
             continue;
         }
@@ -1133,7 +1187,7 @@
         i++;
         Watcher w = Watcher(cr, c[0]);
         for(int k = 1; k < c.size(); k++) {
-            if(value(c[k]) != l_False) {
+            if(value(c[k]) != g421l_False) {
                 c[0] = c[k];
                 c[k] = false_lit;
                 unaryWatches[~c[0]].push(w);
@@ -1158,7 +1212,7 @@
             int maxlevel = -1;
             int index = -1;
             for(int k = 1; k < c.size(); k++) {
-                assert(value(c[k]) == l_False);
+                assert(value(c[k]) == g421l_False);
                 assert(level(var(c[k])) <= level(var(c[0])));
                 if(level(var(c[k])) > maxlevel) {
                     index = k;
@@ -1267,7 +1321,7 @@
 void Solver::rebuildOrderHeap() {
     vec <Var> vs;
     for(Var v = 0; v < nVars(); v++)
-        if(decision[v] && value(v) == l_Undef)
+        if(decision[v] && value(v) == g421l_Undef)
             vs.push(v);
     order_heap.build(vs);
 
@@ -1317,8 +1371,8 @@
 void Solver::adaptSolver() {
     bool adjusted = false;
     bool reinit = false;
-    printf("c\nc Try to adapt solver strategies\nc \n");
-      printf("c Adjusting solver for the SAT Race 2015 (alpha feature)\n");
+    //printf("c\nc Try to adapt solver strategies\nc \n");
+    //printf("c Adjusting solver for the SAT Race 2015 (alpha feature)\n");
     /*printf("c key successive Conflicts       : %" PRIu64"\n",stats[noDecisionConflict]);
     printf("c nb unary clauses learnt        : %" PRIu64"\n",stats[nbUn]);
     printf("c key avg dec per conflicts      : %.2f\n", (float)decisions / (float)conflicts);
@@ -1329,7 +1383,7 @@
         coLBDBound = 4;
         glureduce = true;
         adjusted = true;
-        printf("c Adjusting for low decision levels.\n");
+        //printf("c Adjusting for low decision levels.\n");
         reinit = true;
         firstReduceDB = 2000;
         nbclausesbeforereduce = firstReduceDB;
@@ -1343,10 +1397,10 @@
         var_decay = 0.999;
         max_var_decay = 0.999;
         adjusted = true;
-        printf("c Adjusting for low successive conflicts.\n");
+        //printf("c Adjusting for low successive conflicts.\n");
     }
     if(stats[noDecisionConflict] > 54400) {
-        printf("c Adjusting for high successive conflicts.\n");
+        //printf("c Adjusting for high successive conflicts.\n");
         chanseokStrategy = true;
         glureduce = true;
         coLBDBound = 3;
@@ -1360,12 +1414,12 @@
         var_decay = 0.91;
         max_var_decay = 0.91;
         adjusted = true;
-        printf("c Adjusting for a very large number of true glue clauses found.\n");
+        //printf("c Adjusting for a very large number of true glue clauses found.\n");
     }
     if(!adjusted) {
-        printf("c Nothing extreme in this problem, continue with glucose default strategies.\n");
+        //printf("c Nothing extreme in this problem, continue with glucose default strategies.\n");
     }
-    printf("c\n");
+    //printf("c\n");
     if(adjusted) { // Let's reinitialize the glucose restart strategy counters
         lbdQueue.fastclear();
         sumLBD = 0;
@@ -1386,7 +1440,7 @@
             }
         }
         learnts.shrink(i - j);
-        printf("c Activating Chanseok Strategy: moved %d clauses to the permanent set.\n", moved);
+        //printf("c Activating Chanseok Strategy: moved %d clauses to the permanent set.\n", moved);
     }
 
     if(reinit) {
@@ -1405,7 +1459,7 @@
 }
 printf("c reinitialization of all variables activity/phase/learnt clauses.\n");
 */
-        printf("c Removing of non permanent clauses.\n");
+        //printf("c Removing of non permanent clauses.\n");
     }
 
 }
@@ -1442,7 +1496,7 @@
         //printf("nbClauses : %d, nbLearnts : %d\n", clauses.size(), learnts.size());
         if (!simplifyAll())
         {
-            return l_False;
+            return g421l_False;
         }
         performLCM = 0;
     }
@@ -1453,7 +1507,7 @@
             parallelImportUnaryClauses();
 
             if(parallelImportClauses())
-                return l_False;
+                return g421l_False;
 
         }
         CRef confl = propagate();
@@ -1461,7 +1515,7 @@
         if(confl != CRef_Undef) {
             newDescent = false;
             if(parallelJobIsFinished())
-                return l_Undef;
+                return g421l_Undef;
 
             if(!aDecisionWasMade)
                 stats[noDecisionConflict]++;
@@ -1483,14 +1537,14 @@
                        (int) stats[nbReduceDB], nLearnts(), (int) stats[nbDL2], (int) stats[nbRemovedClauses], progressEstimate() * 100);
             }
             if(decisionLevel() == 0) {
-                return l_False;
+                return g421l_False;
 
             }
             if(adaptStrategies && conflicts == 100000) {
                 cancelUntil(0);
                 adaptSolver();
                 adaptStrategies = false;
-                return l_Undef;
+                return g421l_Undef;
             }
 
             trailQueue.push(trail.size());
@@ -1573,13 +1627,13 @@
                 }
 
                 cancelUntil(bt);
-                return l_Undef;
+                return g421l_Undef;
             }
 
 
             // Simplify the set of problem clauses:
             if(decisionLevel() == 0 && !simplify()) {
-                return l_False;
+                return g421l_False;
             }
             // Perform clause database reduction !
             if((chanseokStrategy && !glureduce && learnts.size() > firstReduceDB) ||
@@ -1599,12 +1653,12 @@
             while(decisionLevel() < assumptions.size()) {
                 // Perform user provided assumption:
                 Lit p = assumptions[decisionLevel()];
-                if(value(p) == l_True) {
+                if(value(p) == g421l_True) {
                     // Dummy decision level:
                     newDecisionLevel();
-                } else if(value(p) == l_False) {
+                } else if(value(p) == g421l_False) {
                     analyzeFinal(~p, conflict);
-                    return l_False;
+                    return g421l_False;
                 } else {
                     next = p;
                     break;
@@ -1616,9 +1670,9 @@
                 decisions++;
                 next = pickBranchLit();
                 if(next == lit_Undef) {
-                    printf("c last restart ## conflicts  :  %d %d \n", conflictC, decisionLevel());
+                    //printf("c last restart ## conflicts  :  %d %d \n", conflictC, decisionLevel());
                     // Model found:
-                    return l_True;
+                    return g421l_True;
                 }
             }
 
@@ -1713,13 +1767,16 @@
 
     model.clear();
     conflict.clear();
-    if(!ok) return l_False;
+    if(!ok) return g421l_False;
     double curTime = cpuTime();
 
     solves++;
 
+    for (int i = 0; i < assumptions.size(); i++)
+      assump[var(assumptions[i])] = true;
 
-    lbool status = l_Undef;
+
+    lbool status = g421l_Undef;
     if(!incremental && verbosity >= 1) {
         printf("c ========================================[ MAGIC CONSTANTS ]==============================================\n");
         printf("c | Constants are supposed to work well together :-)                                                      |\n");
@@ -1757,7 +1814,7 @@
 
     // Search:
     int curr_restarts = 0;
-    while(status == l_Undef) {
+    while(status == g421l_Undef) {
         status = search(
                 luby_restart ? luby(restart_inc, curr_restarts) * luby_restart_factor : 0); // the parameter is useless in glucose, kept to allow modifications
 
@@ -1769,7 +1826,7 @@
         printf("c =========================================================================================================\n");
 
     if(certifiedUNSAT) { // Want certified output
-        if(status == l_False) {
+        if(status == g421l_False) {
             if(vbyte) {
                 write_char('a');
                 write_lit(0);
@@ -1782,23 +1839,23 @@
     }
 
 
-    if(status == l_True) {
+    if(status == g421l_True) {
         // Extend & copy model:
         model.growTo(nVars());
         for(int i = 0; i < nVars(); i++) model[i] = value(i);
-    } else if(status == l_False && conflict.size() == 0)
+    } else if(status == g421l_False && conflict.size() == 0)
         ok = false;
 
+    //cancelUntil(0);
+    if (!warm_start || status != g421l_True)  // no 'default' backtracking in case of warm restarts
+        cancelUntil(0);
 
-    cancelUntil(0);
-
-
     double finalTime = cpuTime();
-    if(status == l_True) {
+    if(status == g421l_True) {
         nbSatCalls++;
         totalTime4Sat += (finalTime - curTime);
     }
-    if(status == l_False) {
+    if(status == g421l_False) {
         nbUnsatCalls++;
         totalTime4Unsat += (finalTime - curTime);
     }
@@ -1808,11 +1865,198 @@
 
 }
 
+//=================================================================================================
+// Add a clause in the warm start mode:
+bool Solver::addClauseWarm(vec<Lit>& ps)
+{
+    if (!ok) return false;
+    if (!warm_start || decisionLevel() == 0) return addClause(ps);
 
+    // checking if clause is satisfied and remove false/duplicate literals
+    sort(ps);
+    Lit p; int i, j, nws, max_i;
+    vec<int> ws(2, -1);  // potentially watched literals
+    for (i = j = nws = max_i = 0, p = lit_Undef; i < ps.size(); i++) {
+        Var x = var(ps[i]);
+        if ((value(ps[i]) == g421l_True && level(x) == 0) || ps[i] == ~p)
+            return true;
+        else if ((value(ps[i]) != g421l_False || level(x) > 0) && ps[i] != p) {
+            if (value(ps[i]) != g421l_False && nws < 2)
+                ws[nws++] = j;
+            if (level(x) > level(var(ps[max_i])))
+                max_i = j;
 
+            ps[j++] = p = ps[i];
+        }
+    }
+    ps.shrink(i - j);
 
+    // analyzing which level to backtrack to (if any)
+    if (ps.size() != 0) {
+        if (ps.size() > 1) {
+            if (nws) {
+                p = ps[0]; ps[0] = ps[ws[0]]; ps[ws[0]] = p;
+                if (nws == 2) {
+                    p = ps[1]; ps[1] = ps[ws[1]]; ps[ws[1]] = p;
+                }
+            }
+            else {
+                // no satisfied literals in this clause
+                p = ps[max_i]; ps[max_i] = ps[0]; ps[0] = p;
 
+                max_i = 1;
+                for (int i = 2; i < ps.size(); ++i) {
+                    if (level(var(ps[i])) > level(var(ps[max_i])))
+                        max_i = i;
+                }
+
+                p = ps[max_i]; ps[max_i] = ps[1]; ps[1] = p;
+
+                cancelUntil(level(var(p)));
+            }
+            CRef cr = ca.alloc(ps, false);
+            clauses.push(cr);
+            attachClause(cr);
+
+            if (!nws) {
+                // if the clause was falsified
+                if (value(ps[0]) == g421l_Undef)
+                    // enqueue unless already true
+                    uncheckedEnqueue(ps[0], cr);
+                else if (value(ps[0]) == g421l_False && resolveConflicts(cr) == false)
+                    ok = false;
+            }
+        }
+        else {
+            // a single literal in the clause => enqueue it at level 0
+            cancelUntil(0);
+            uncheckedEnqueue(ps[0]);
+            ok = (propagate() == CRef_Undef);
+        }
+    }
+    else {
+        // there is no literal left in the clause!
+        cancelUntil(0);
+        ok = false;
+    }
+
+    return ok;
+}
+
 //=================================================================================================
+// Resolve conflicts, if appear after adding a clause in the warm start mode:
+bool Solver::resolveConflicts(CRef confl)
+{
+    int backtrack_level;
+    vec <Lit> learnt_clause, selectors;
+    unsigned int nblevels, szWithoutSelectors = 0;
+    bool blocked = false;
+    bool aDecisionWasMade = false;
+
+    while (confl != CRef_Undef) {
+        newDescent = false;
+        /* if(parallelJobIsFinished()) */
+        /*     return g421l_Undef; */
+
+        if(!aDecisionWasMade)
+            stats[noDecisionConflict]++;
+        aDecisionWasMade = false;
+
+        stats[sumDecisionLevels] += decisionLevel();
+        stats[sumTrail] += trail.size();
+        // CONFLICT
+        conflicts++;
+        conflictsRestarts++;
+        if(conflicts % 5000 == 0 && var_decay < max_var_decay)
+            var_decay += 0.01;
+
+        if(decisionLevel() == 0) return false;
+
+        /* if(adaptStrategies && conflicts == 100000) { */
+        /*     cancelUntil(0); */
+        /*     adaptSolver(); */
+        /*     adaptStrategies = false; */
+        /*     return g421l_Undef; */
+        /* } */
+
+        trailQueue.push(trail.size());
+        // BLOCK RESTART (CP 2012 paper)
+        if(conflictsRestarts > LOWER_BOUND_FOR_BLOCKING_RESTART && lbdQueue.isvalid() && trail.size() > R * trailQueue.getavg()) {
+            lbdQueue.fastclear();
+            stats[nbstopsrestarts]++;
+            if(!blocked) {
+                stats[lastblockatrestart] = starts;
+                stats[nbstopsrestartssame]++;
+                blocked = true;
+            }
+        }
+
+        learnt_clause.clear();
+        selectors.clear();
+
+        analyze(confl, learnt_clause, selectors, backtrack_level, nblevels, szWithoutSelectors);
+
+        lbdQueue.push(nblevels);
+        sumLBD += nblevels;
+
+        cancelUntil(backtrack_level);
+
+        if(certifiedUNSAT) {
+            if(vbyte) {
+                write_char('a');
+                for(int i = 0; i < learnt_clause.size(); i++)
+                    write_lit(2 * (var(learnt_clause[i]) + 1) + sign(learnt_clause[i]));
+                write_lit(0);
+            }
+            else {
+                for(int i = 0; i < learnt_clause.size(); i++)
+                    fprintf(certifiedOutput, "%i ", var(learnt_clause[i]) *
+                                                    (-2 * sign(learnt_clause[i]) + 1));
+                fprintf(certifiedOutput, "0\n");
+            }
+        }
+
+
+        if(learnt_clause.size() == 1) {
+            uncheckedEnqueue(learnt_clause[0]);
+            stats[nbUn]++;
+            parallelExportUnaryClause(learnt_clause[0]);
+        } else {
+            CRef cr;
+            if(chanseokStrategy && nblevels <= coLBDBound) {
+                cr = ca.alloc(learnt_clause, false);
+                permanentLearnts.push(cr);
+                stats[nbPermanentLearnts]++;
+            } else {
+                cr = ca.alloc(learnt_clause, true);
+                ca[cr].setLBD(nblevels);
+                ca[cr].setOneWatched(false);
+                learnts.push(cr);
+                claBumpActivity(ca[cr]);
+            }
+#ifdef INCREMENTAL
+            ca[cr].setSizeWithoutSelectors(szWithoutSelectors);
+#endif
+            if(nblevels <= 2) { stats[nbDL2]++; } // stats
+            if(ca[cr].size() == 2) stats[nbBin]++; // stats
+            attachClause(cr);
+            lastLearntClause = cr; // Use in multithread (to hard to put inside ParallelSolver)
+            parallelExportClauseDuringSearch(ca[cr]);
+            uncheckedEnqueue(learnt_clause[0], cr);
+        }
+
+        varDecayActivity();
+        claDecayActivity();
+
+        confl = propagate();
+    }
+
+    return true;
+}
+
+
+
+//=================================================================================================
 // Writing CNF to DIMACS:
 //
 // FIXME: this needs to be rewritten completely.
@@ -1830,7 +2074,7 @@
     if(satisfied(c)) return;
 
     for(int i = 0; i < c.size(); i++)
-        if(value(c[i]) != l_False)
+        if(value(c[i]) != g421l_False)
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max) + 1);
     fprintf(f, "0\n");
 }
@@ -1866,7 +2110,7 @@
         if(!satisfied(ca[clauses[i]])) {
             Clause &c = ca[clauses[i]];
             for(int j = 0; j < c.size(); j++)
-                if(value(c[j]) != l_False)
+                if(value(c[j]) != g421l_False)
                     mapVar(var(c[j]), map, max);
         }
 
@@ -1876,7 +2120,7 @@
     fprintf(f, "p cnf %d %d\n", max, cnt);
 
     for(int i = 0; i < assumptions.size(); i++) {
-        assert(value(assumptions[i]) != l_False);
+        assert(value(assumptions[i]) != g421l_False);
         fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max) + 1);
     }
 
diff -Naur solvers/glucose421/core/Solver.h solvers/g421/core/Solver.h
--- solvers/glucose421/core/Solver.h	2023-05-09 15:19:52
+++ solvers/g421/core/Solver.h	2023-07-12 01:52:06
@@ -47,20 +47,20 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  **************************************************************************************************/
 
-#ifndef Glucose_Solver_h
-#define Glucose_Solver_h
+#ifndef Glucose421_Solver_h
+#define Glucose421_Solver_h
 
-#include "mtl/Heap.h"
-#include "mtl/Alg.h"
-#include "utils/Options.h"
-#include "core/SolverTypes.h"
-#include "core/BoundedQueue.h"
-#include "core/Constants.h"
-#include "mtl/Clone.h"
-#include "core/SolverStats.h"
+#include "glucose421/mtl/Heap.h"
+#include "glucose421/mtl/Alg.h"
+#include "glucose421/utils/Options.h"
+#include "glucose421/core/SolverTypes.h"
+#include "glucose421/core/BoundedQueue.h"
+#include "glucose421/core/Constants.h"
+#include "glucose421/mtl/Clone.h"
+#include "glucose421/core/SolverStats.h"
 
 
-namespace Glucose {
+namespace Glucose421 {
 // Core stats 
 
 enum CoreStats {
@@ -137,6 +137,7 @@
     bool    solve        (Lit p, Lit q);            // Search for a model that respects two assumptions.
     bool    solve        (Lit p, Lit q, Lit r);     // Search for a model that respects three assumptions.
     bool    okay         () const;                  // FALSE means solver is in a conflicting state
+    bool    prop_check   (const vec<Lit>& assumps, vec<Lit>& prop, int psaving = 0); // compute a list of propagated literals given a set of assumptions
 
        // Convenience versions of 'toDimacs()':
     void    toDimacs     (FILE* f, const vec<Lit>& assumps);            // Write CNF to file in DIMACS-format.
@@ -169,6 +170,11 @@
     int     nVars      ()      const;       // The current number of variables.
     int     nFreeVars  ()      ;
 
+    // Warm start mode:
+    void setStartMode(bool warm = false);
+    bool addClauseWarm(vec<Lit>& ps);
+    bool resolveConflicts(CRef confl);
+
     inline char valuePhase(Var v) {return polarity[v];}
 
     // Incremental mode
@@ -240,6 +246,7 @@
     // Certified UNSAT ( Thanks to Marijn Heule
     // New in 2016 : proof in DRAT format, possibility to use binary output
     FILE*               certifiedOutput;
+    void*               certifiedPyFile;
     bool                certifiedUNSAT;
     bool                vbyte;
 
@@ -341,6 +348,7 @@
     vec<CRef>           mostActiveClauses; // Used to keep most active clauses (instead of removing them)
 
     vec<lbool>          assigns;          // The current assignments.
+    vec<bool>           assump;           // Declares if a variable is an assumption variable or not.
     vec<char>           polarity;         // The preferred polarity of each variable.
     vec<char>           forceUNSAT;
     void                bumpForceUNSAT(Lit q); // Handles the forces
@@ -357,6 +365,7 @@
     Heap<VarOrderLt>    order_heap;       // A priority queue of variables ordered with respect to the variable activity.
     double              progress_estimate;// Set by 'search()'.
     bool                remove_satisfied; // Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.
+    bool                warm_start;       // Warm start if set to true.
     vec<unsigned int>   permDiff;           // permDiff[var] contains the current conflict number... Used to count the number of  LBD
 
 
@@ -454,8 +463,8 @@
     int      level            (Var x) const;
     double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
     bool     withinBudget     ()      const;
-    inline bool isSelector(Var v) {return (incremental && v>nbVarsInitialFormula);}
-
+    //inline bool isSelector(Var v) {return (incremental && v>nbVarsInitialFormula);}
+    inline bool isSelector(Var v) { return (incremental && assump[v]); }
     // Static helpers:
     //
 
@@ -537,19 +546,19 @@
         garbageCollect(); }
 
 // NOTE: enqueue does not set the ok flag! (only public methods do)
-inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }
-inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
+inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != g421l_Undef ? value(p) != g421l_False : (uncheckedEnqueue(p, from), true); }
+inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); if (warm_start && decisionLevel()) return addClauseWarm(add_tmp); return addClause_(add_tmp); }
 inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
  inline bool     Solver::locked          (const Clause& c) const {
    if(c.size()>2)
-     return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c;
+     return value(c[0]) == g421l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c;
    return
-     (value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c)
+     (value(c[0]) == g421l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c)
      ||
-     (value(c[1]) == l_True && reason(var(c[1])) != CRef_Undef && ca.lea(reason(var(c[1]))) == &c);
+     (value(c[1]) == g421l_True && reason(var(c[1])) != CRef_Undef && ca.lea(reason(var(c[1]))) == &c);
  }
 inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
 
@@ -588,11 +597,11 @@
 // FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
 // pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
 // all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.
-inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }
-inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }
+inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == g421l_True; }
+inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == g421l_True; }
+inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == g421l_True; }
+inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == g421l_True; }
+inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == g421l_True; }
 inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }
 inline bool     Solver::okay          ()      const   { return ok; }
 
@@ -601,7 +610,10 @@
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }
 
+// Warm start mode:
+inline void     Solver::setStartMode (bool warm) { warm_start = warm; cancelUntil(0); }
 
+
 /************************************************************
  * Compute LBD functions
  *************************************************************/
@@ -646,7 +658,7 @@
 
 inline void Solver::printLit(Lit l)
 {
-    printf("%s%d:%c", sign(l) ? "-" : "", var(l)+1, value(l) == l_True ? '1' : (value(l) == l_False ? '0' : 'X'));
+    printf("%s%d:%c", sign(l) ? "-" : "", var(l)+1, value(l) == g421l_True ? '1' : (value(l) == g421l_False ? '0' : 'X'));
 }
 
 
diff -Naur solvers/glucose421/core/SolverStats.h solvers/g421/core/SolverStats.h
--- solvers/glucose421/core/SolverStats.h	2023-05-09 15:19:52
+++ solvers/g421/core/SolverStats.h	2023-07-12 01:52:06
@@ -47,12 +47,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  **************************************************************************************************/
 
-#ifndef SOLVERSTATS_H
-#define	SOLVERSTATS_H
+#ifndef Glucose421_SolverStats_h
+#define	Glucose421_SolverStats_h
 
-#include "mtl/Map.h"
+#include "glucose421/mtl/Map.h"
 #include <string>
-namespace Glucose {
+namespace Glucose421 {
 
     class SolverStats {
     protected:
diff -Naur solvers/glucose421/core/SolverTypes.h solvers/g421/core/SolverTypes.h
--- solvers/glucose421/core/SolverTypes.h	2023-05-09 15:19:52
+++ solvers/g421/core/SolverTypes.h	2023-07-12 01:52:06
@@ -48,21 +48,26 @@
  **************************************************************************************************/
 
 
-#ifndef Glucose_SolverTypes_h
-#define Glucose_SolverTypes_h
+#ifndef Glucose421_SolverTypes_h
+#define Glucose421_SolverTypes_h
 
 #include <assert.h>
 #include <stdint.h>
+
+#ifdef _MSC_VER
+#define putc_unlocked(a,b) putc(a,b)
+#else
 #include <pthread.h>
+#endif
 
-#include "mtl/IntTypes.h"
-#include "mtl/Alg.h"
-#include "mtl/Vec.h"
-#include "mtl/Map.h"
-#include "mtl/Alloc.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/Alg.h"
+#include "glucose421/mtl/Vec.h"
+#include "glucose421/mtl/Map.h"
+#include "glucose421/mtl/Alloc.h"
 
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Variables, literals, lifted booleans, clauses:
@@ -113,9 +118,9 @@
 //       does enough constant propagation to produce sensible code, and this appears to be somewhat
 //       fragile unfortunately.
 
-#define l_True  (Glucose::lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
-#define l_False (Glucose::lbool((uint8_t)1))
-#define l_Undef (Glucose::lbool((uint8_t)2))
+#define g421l_True  (Glucose421::lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
+#define g421l_False (Glucose421::lbool((uint8_t)1))
+#define g421l_Undef (Glucose421::lbool((uint8_t)2))
 
 class lbool {
     uint8_t value;
diff -Naur solvers/glucose421/core/lcm.cc solvers/g421/core/lcm.cc
--- solvers/glucose421/core/lcm.cc	2023-05-09 15:19:52
+++ solvers/g421/core/lcm.cc	2023-07-12 01:52:06
@@ -1,9 +1,10 @@
-#include "Solver.h"
-#include "mtl/Sort.h"
-using namespace Glucose;
+#include "glucose421/core/Solver.h"
+#include "glucose421/mtl/Sort.h"
 
+using namespace Glucose421;
 
 
+
 // simplify All
 //
 CRef Solver::simplePropagate()
@@ -25,18 +26,18 @@
 
             Lit imp = wbin[k].blocker;
 
-            if (value(imp) == l_False){
+            if (value(imp) == g421l_False){
                 return wbin[k].cref;
             }
 
-            if (value(imp) == l_Undef){
+            if (value(imp) == g421l_Undef){
                 simpleUncheckEnqueue(imp, wbin[k].cref);
             }
         }
         for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;){
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if (value(blocker) == l_True){
+            if (value(blocker) == g421l_True){
                 *j++ = *i++; continue;
             }
 
@@ -54,7 +55,7 @@
             // why not simply do i->blocker=first in this case?
             Lit     first = c[0];
             //  Watcher w     = Watcher(cr, first);
-            if (first != blocker && value(first) == l_True){
+            if (first != blocker && value(first) == g421l_True){
                 i->blocker = first;
                 *j++ = *i++; continue;
             }
@@ -63,7 +64,7 @@
             if (incremental){ // ----------------- INCREMENTAL MODE
                 int choosenPos = -1;
                 for (int k = 2; k < c.size(); k++){
-                    if (value(c[k]) != l_False){
+                    if (value(c[k]) != g421l_False){
                         if (decisionLevel()>assumptions.size()){
                             choosenPos = k;
                             break;
@@ -71,7 +72,7 @@
                         else{
                             choosenPos = k;
 
-                            if (value(c[k]) == l_True || !isSelector(var(c[k]))) {
+                            if (value(c[k]) == g421l_True || !isSelector(var(c[k]))) {
                                 break;
                             }
                         }
@@ -91,7 +92,7 @@
             else{  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
                 for (int k = 2; k < c.size(); k++){
 
-                    if (value(c[k]) != l_False){
+                    if (value(c[k]) != g421l_False){
                         // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
                         // the blocker is first in the watcher. However,
                         // the blocker in the corresponding watcher in ~first is not c[1]
@@ -106,7 +107,7 @@
             // Did not find watch -- clause is unit under assignment:
             i->blocker = first;
             *j++ = *i++;
-            if (value(first) == l_False){
+            if (value(first) == g421l_False){
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -138,7 +139,7 @@
     for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
         // Try to avoid inspecting the clause:
         Lit blocker = i->blocker;
-        if(value(blocker) == l_True) {
+        if(value(blocker) == g421l_True) {
             *j++ = *i++;
             continue;
         }
@@ -155,7 +156,7 @@
         i++;
         Watcher w = Watcher(cr, c[0]);
         for(int k = 1; k < c.size(); k++) {
-            if(value(c[k]) != l_False) {
+            if(value(c[k]) != g421l_False) {
                 c[0] = c[k];
                 c[k] = false_lit;
                 unaryWatches[~c[0]].push(w);
@@ -181,7 +182,7 @@
 
 
 void Solver::simpleUncheckEnqueue(Lit p, CRef from){
-    assert(value(p) == l_Undef);
+    assert(value(p) == g421l_Undef);
     assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
     vardata[var(p)].reason = from;
     trail.push_(p);
@@ -192,7 +193,7 @@
     for (int c = trail.size() - 1; c >= trailRecord; c--)
     {
         Var x = var(trail[c]);
-        assigns[x] = l_Undef;
+        assigns[x] = g421l_Undef;
 
     }
     qhead = trailRecord;
@@ -224,9 +225,9 @@
             Clause& c = ca[confl];
             // Special case for binary clauses
             // The first one has to be SAT
-            if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
+            if (p != lit_Undef && c.size() == 2 && value(c[0]) == g421l_False) {
 
-                assert(value(c[1]) == l_True);
+                assert(value(c[1]) == g421l_True);
                 Lit tmp = c[0];
                 c[0] = c[1], c[1] = tmp;
             }
@@ -274,8 +275,8 @@
     CRef confl;
 
     for (i = 0, j = 0; i < c.size(); i++){
-        if (value(c[i]) == l_Undef){
-            //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
+        if (value(c[i]) == g421l_Undef){
+            //printf("///@@@ uncheckedEnqueue:index = %d. g421l_Undef\n", i);
             simpleUncheckEnqueue(~c[i]);
             c[j++] = c[i];
             confl = simplePropagate();
@@ -284,8 +285,8 @@
             }
         }
         else{
-            if (value(c[i]) == l_True){
-                //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
+            if (value(c[i]) == g421l_True){
+                //printf("///@@@ uncheckedEnqueue:index = %d. g421l_True\n", i);
                 c[j++] = c[i];
                 True_confl = true;
                 confl = reason(var(c[i]));
@@ -293,7 +294,7 @@
             }
             else{
                 falseLit.push(c[i]);
-                //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
+                //printf("///@@@ uncheckedEnqueue:index = %d. g421l_False\n", i);
             }
         }
     }
@@ -350,11 +351,11 @@
             if (!removed(cr)){
                 sat = false_lit = false;
                 for (int i = 0; i < c.size(); i++){
-                    if (value(c[i]) == l_True){
+                    if (value(c[i]) == g421l_True){
                         sat = true;
                         break;
                     }
-                    else if (value(c[i]) == l_False){
+                    else if (value(c[i]) == g421l_False){
                         false_lit = true;
                     }
                 }
@@ -366,7 +367,7 @@
 
                     if (false_lit){
                         for (li = lj = 0; li < c.size(); li++){
-                            if (value(c[li]) != l_False){
+                            if (value(c[li]) != g421l_False){
                                 c[lj++] = c[li];
                             }
                         }
@@ -444,11 +445,11 @@
             if (!removed(cr)){
                 sat = false_lit = false;
                 for (int i = 0; i < c.size(); i++){
-                    if (value(c[i]) == l_True){
+                    if (value(c[i]) == g421l_True){
                         sat = true;
                         break;
                     }
-                    else if (value(c[i]) == l_False){
+                    else if (value(c[i]) == g421l_False){
                         false_lit = true;
                     }
                 }
@@ -460,7 +461,7 @@
 
                     if (false_lit){
                         for (li = lj = 0; li < c.size(); li++){
-                            if (value(c[li]) != l_False){
+                            if (value(c[li]) != g421l_False){
                                 c[lj++] = c[li];
                             }
                         }
diff -Naur solvers/glucose421/mtl/Alg.h solvers/g421/mtl/Alg.h
--- solvers/glucose421/mtl/Alg.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Alg.h	2023-07-12 01:52:06
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Alg_h
-#define Glucose_Alg_h
+#ifndef Glucose421_Alg_h
+#define Glucose421_Alg_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Useful functions on vector-like types:
diff -Naur solvers/glucose421/mtl/Alloc.h solvers/g421/mtl/Alloc.h
--- solvers/glucose421/mtl/Alloc.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Alloc.h	2023-07-12 01:52:06
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Glucose_Alloc_h
-#define Glucose_Alloc_h
+#ifndef Glucose421_Alloc_h
+#define Glucose421_Alloc_h
 
-#include "mtl/XAlloc.h"
-#include "mtl/Vec.h"
+#include "glucose421/mtl/XAlloc.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Simple Region-based memory allocator:
diff -Naur solvers/glucose421/mtl/Clone.h solvers/g421/mtl/Clone.h
--- solvers/glucose421/mtl/Clone.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Clone.h	2023-07-12 01:52:06
@@ -1,8 +1,8 @@
-#ifndef Glucose_Clone_h
-#define Glucose_Clone_h
+#ifndef Glucose421_Clone_h
+#define Glucose421_Clone_h
 
 
-namespace Glucose {
+namespace Glucose421 {
 
     class Clone {
         public:
diff -Naur solvers/glucose421/mtl/Heap.h solvers/g421/mtl/Heap.h
--- solvers/glucose421/mtl/Heap.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Heap.h	2023-07-12 01:52:06
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Heap_h
-#define Glucose_Heap_h
+#ifndef Glucose421_Heap_h
+#define Glucose421_Heap_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // A heap implementation with support for decrease/increase key.
diff -Naur solvers/glucose421/mtl/Map.h solvers/g421/mtl/Map.h
--- solvers/glucose421/mtl/Map.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Map.h	2023-07-12 01:52:06
@@ -17,15 +17,15 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Map_h
-#define Glucose_Map_h
+#ifndef Glucose421_Map_h
+#define Glucose421_Map_h
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/Vec.h"
 #include <string>
 #include <unordered_map>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Default hash/equals functions
diff -Naur solvers/glucose421/mtl/Queue.h solvers/g421/mtl/Queue.h
--- solvers/glucose421/mtl/Queue.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Queue.h	2023-07-12 01:52:06
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Queue_h
-#define Glucose_Queue_h
+#ifndef Glucose421_Queue_h
+#define Glucose421_Queue_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 
diff -Naur solvers/glucose421/mtl/Sort.h solvers/g421/mtl/Sort.h
--- solvers/glucose421/mtl/Sort.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Sort.h	2023-07-12 01:52:06
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Sort_h
-#define Glucose_Sort_h
+#ifndef Glucose421_Sort_h
+#define Glucose421_Sort_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
 //=================================================================================================
 // Some sorting algorithms for vec's
 
 
-namespace Glucose {
+namespace Glucose421 {
 
 template<class T>
 struct LessThan_default {
diff -Naur solvers/glucose421/mtl/Vec.h solvers/g421/mtl/Vec.h
--- solvers/glucose421/mtl/Vec.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/Vec.h	2023-07-12 01:52:06
@@ -18,17 +18,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Vec_h
-#define Glucose_Vec_h
+#ifndef Glucose421_Vec_h
+#define Glucose421_Vec_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/XAlloc.h"
 #include<string.h>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Automatically resizable arrays
@@ -118,7 +118,7 @@
 void vec<T>::capacity(int min_cap) {
     if (cap >= min_cap) return;
     int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
-    if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
+    if (add > INT_MAX - cap || (((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM))
         throw OutOfMemoryException();
  }
 
diff -Naur solvers/glucose421/mtl/VecThreads.h solvers/g421/mtl/VecThreads.h
--- solvers/glucose421/mtl/VecThreads.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/VecThreads.h	2023-07-12 01:52:06
@@ -19,17 +19,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_VecThreads_h
-#define Glucose_VecThreads_h
+#ifndef Glucose421_VecThreads_h
+#define Glucose421_VecThreads_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/XAlloc.h"
 #include<string.h>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Automatically resizable arrays
diff -Naur solvers/glucose421/mtl/XAlloc.h solvers/g421/mtl/XAlloc.h
--- solvers/glucose421/mtl/XAlloc.h	2023-05-09 15:19:52
+++ solvers/g421/mtl/XAlloc.h	2023-07-12 01:52:06
@@ -18,14 +18,14 @@
 **************************************************************************************************/
 
 
-#ifndef Glucose_XAlloc_h
-#define Glucose_XAlloc_h
+#ifndef Glucose421_XAlloc_h
+#define Glucose421_XAlloc_h
 
 #include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Simple layer on top of malloc/realloc to catch out-of-memory situtaions and provide some typing:
diff -Naur solvers/glucose421/utils/Options.cc solvers/g421/utils/Options.cc
--- solvers/glucose421/utils/Options.cc	2023-05-09 15:19:52
+++ solvers/g421/utils/Options.cc	2023-07-12 01:52:06
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "mtl/Sort.h"
-#include "utils/Options.h"
-#include "utils/ParseUtils.h"
+#include "glucose421/mtl/Sort.h"
+#include "glucose421/utils/Options.h"
+#include "glucose421/utils/ParseUtils.h"
 
-using namespace Glucose;
+using namespace Glucose421;
 
-void Glucose::parseOptions(int& argc, char** argv, bool strict)
+void Glucose421::parseOptions(int& argc, char** argv, bool strict)
 {
     int i, j;
     for (i = j = 1; i < argc; i++){
@@ -54,15 +54,15 @@
 }
 
 
-void Glucose::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
-void Glucose::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
-void Glucose::printUsageAndExit (int argc, char** argv, bool verbose)
+void Glucose421::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
+void Glucose421::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
+void Glucose421::printUsageAndExit (int argc, char** argv, bool verbose)
 {
     const char* usage = Option::getUsageString();
     if (usage != NULL)
         fprintf(stderr, usage, argv[0]);
 
-        sort(Option::getOptionList(), Option::OptionLt());
+    sort(Option::getOptionList(), Option::OptionLt());
 
     const char* prev_cat  = NULL;
     const char* prev_type = NULL;
diff -Naur solvers/glucose421/utils/Options.h solvers/g421/utils/Options.h
--- solvers/glucose421/utils/Options.h	2023-05-09 15:19:52
+++ solvers/g421/utils/Options.h	2023-07-12 01:52:06
@@ -17,19 +17,19 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Options_h
-#define Glucose_Options_h
+#ifndef Glucose421_Options_h
+#define Glucose421_Options_h
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
-#include "utils/ParseUtils.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/Vec.h"
+#include "glucose421/utils/ParseUtils.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //==================================================================================================
 // Top-level option parse/help functions:
diff -Naur solvers/glucose421/utils/ParseUtils.h solvers/g421/utils/ParseUtils.h
--- solvers/glucose421/utils/ParseUtils.h	2023-05-09 15:19:52
+++ solvers/g421/utils/ParseUtils.h	2023-07-12 01:52:06
@@ -18,110 +18,14 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_ParseUtils_h
-#define Glucose_ParseUtils_h
+#ifndef Glucose421_ParseUtils_h
+#define Glucose421_ParseUtils_h
 
 #include <stdlib.h>
 #include <stdio.h>
-#include <math.h>
 
-#include <zlib.h>
+namespace Glucose421 {
 
-namespace Glucose {
-
-//-------------------------------------------------------------------------------------------------
-// A simple buffered character stream class:
-
-static const int buffer_size = 1048576;
-
-
-class StreamBuffer {
-    gzFile        in;
-    unsigned char buf[buffer_size];
-    int           pos;
-    int           size;
-
-    void assureLookahead() {
-        if (pos >= size) {
-            pos  = 0;
-            size = gzread(in, buf, sizeof(buf)); } }
-
-public:
-    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0) { assureLookahead(); }
-
-    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }
-    void operator ++ ()       { pos++; assureLookahead(); }
-    int  position    () const { return pos; }
-};
-
-
-//-------------------------------------------------------------------------------------------------
-// End-of-file detection functions for StreamBuffer and char*:
-
-
-static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }
-static inline bool isEof(const char*   in) { return *in == '\0'; }
-
-//-------------------------------------------------------------------------------------------------
-// Generic parse functions parametrized over the input-stream type.
-
-
-template<class B>
-static void skipWhitespace(B& in) {
-    while ((*in >= 9 && *in <= 13) || *in == 32)
-        ++in; }
-
-
-template<class B>
-static void skipLine(B& in) {
-    for (;;){
-        if (isEof(in)) return;
-        if (*in == '\n') { ++in; return; }
-        ++in; } }
-
-template<class B>
-static double parseDouble(B& in) { // only in the form X.XXXXXe-XX
-    bool    neg= false;
-	double accu = 0.0;
-	double currentExponent = 1;
-	int exponent;
-	
-    skipWhitespace(in);
-    if(*in == EOF) return 0;
-    if      (*in == '-') neg = true, ++in;
-    else if (*in == '+') ++in;
-    if (*in < '1' || *in > '9') printf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-	accu = (double)(*in - '0');
-	++in;
-	if (*in != '.') printf("PARSE ERROR! Unexpected char: %c\n", *in),exit(3);
-	++in; // skip dot
-	currentExponent = 0.1;
-    while (*in >= '0' && *in <= '9')
-        accu = accu + currentExponent * ((double)(*in - '0')),
-		currentExponent /= 10,
-        ++in;
-	if (*in != 'e') printf("PARSE ERROR! Unexpected char: %c\n", *in),exit(3);
-	++in; // skip dot
-	exponent = parseInt(in); // read exponent
-	accu *= pow(10,exponent);
-	return neg ? -accu:accu;
-}
-
-
-template<class B>
-static int parseInt(B& in) {
-    int     val = 0;
-    bool    neg = false;
-    skipWhitespace(in);
-    if      (*in == '-') neg = true, ++in;
-    else if (*in == '+') ++in;
-    if (*in < '0' || *in > '9') fprintf(stderr, "PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-    while (*in >= '0' && *in <= '9')
-        val = val*10 + (*in - '0'),
-        ++in;
-    return neg ? -val : val; }
-
-
 // String matching: in case of a match the input iterator will be advanced the corresponding
 // number of characters.
 template<class B>
@@ -136,16 +40,6 @@
     return true; 
 }
 
-// String matching: consumes characters eagerly, but does not require random access iterator.
-template<class B>
-static bool eagerMatch(B& in, const char* str) {
-    for (; *str != '\0'; ++str, ++in)
-        if (*str != *in)
-            return false;
-    return true; }
-
-
-//=================================================================================================
 }
 
 #endif
diff -Naur solvers/glucose421/utils/System.cc solvers/g421/utils/System.cc
--- solvers/glucose421/utils/System.cc	2023-05-09 15:19:52
+++ solvers/g421/utils/System.cc	2023-07-12 01:52:06
@@ -18,14 +18,14 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "utils/System.h"
+#include "glucose421/utils/System.h"
 
 #if defined(__linux__)
 
 #include <stdio.h>
 #include <stdlib.h>
 
-using namespace Glucose;
+using namespace Glucose421;
 
 // TODO: split the memory reading functions into two: one for reading high-watermark of RSS, and
 // one for reading the current virtual memory size.
@@ -67,14 +67,14 @@
     return peak_kb;
 }
 
-double Glucose::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
-double Glucose::memUsedPeak() { 
+double Glucose421::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
+double Glucose421::memUsedPeak() { 
     double peak = memReadPeak() / 1024;
     return peak == 0 ? memUsed() : peak; }
 
 #elif defined(__FreeBSD__)
 
-double Glucose::memUsed(void) {
+double Glucose421::memUsed(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_maxrss / 1024; }
@@ -84,12 +84,12 @@
 #elif defined(__APPLE__)
 #include <malloc/malloc.h>
 
-double Glucose::memUsed(void) {
+double Glucose421::memUsed(void) {
     malloc_statistics_t t;
     malloc_zone_statistics(NULL, &t);
     return (double)t.max_size_in_use / (1024*1024); }
 
 #else
-double Glucose::memUsed() { 
+double Glucose421::memUsed() { 
     return 0; }
 #endif
diff -Naur solvers/glucose421/utils/System.h solvers/g421/utils/System.h
--- solvers/glucose421/utils/System.h	2023-05-09 15:19:52
+++ solvers/g421/utils/System.h	2025-09-16 17:09:19
@@ -18,18 +18,18 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_System_h
-#define Glucose_System_h
+#ifndef Glucose421_System_h
+#define Glucose421_System_h
 
-#if defined(__linux__)
-#include <fpu_control.h>
-#endif
+// #if defined(__linux__)
+// #include <fpu_control.h>
+// #endif
 
-#include "mtl/IntTypes.h"
+#include "glucose421/mtl/IntTypes.h"
 
 //-------------------------------------------------------------------------------------------------
 
-namespace Glucose {
+namespace Glucose421 {
 
 static inline double cpuTime(void); // CPU-time in seconds.
 static inline double realTime(void);
@@ -44,22 +44,57 @@
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #include <time.h>
 
-static inline double Glucose::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
+static inline double Glucose421::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
 
 #else
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <unistd.h>
 
-static inline double Glucose::cpuTime(void) {
+static inline double Glucose421::cpuTime(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
 
 #endif
 
+
+#ifdef _MSC_VER
+
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <stdint.h> // portable: uint64_t   MSVC: __int64
+
+// MSVC defines this in winsock2.h!?
+typedef struct timeval {
+    long tv_sec;
+    long tv_usec;
+} timeval;
+
+static inline int gettimeofday(struct timeval * tp, struct timezone * tzp)
+{
+    // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
+    // This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)
+    // until 00:00:00 January 1, 1970
+    static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
+
+    SYSTEMTIME  system_time;
+    FILETIME    file_time;
+    uint64_t    time;
+
+    GetSystemTime( &system_time );
+    SystemTimeToFileTime( &system_time, &file_time );
+    time =  ((uint64_t)file_time.dwLowDateTime )      ;
+    time += ((uint64_t)file_time.dwHighDateTime) << 32;
+
+    tp->tv_sec  = (long) ((time - EPOCH) / 10000000L);
+    tp->tv_usec = (long) (system_time.wMilliseconds * 1000);
+    return 0;
+}
+#endif
+
 // Laurent: I know that this will not compile directly under Windows... sorry for that
-static inline double Glucose::realTime() {
+static inline double Glucose421::realTime() {
     struct timeval tv;
     gettimeofday(&tv, NULL);
     return (double)tv.tv_sec + (double) tv.tv_usec / 1000000; }
