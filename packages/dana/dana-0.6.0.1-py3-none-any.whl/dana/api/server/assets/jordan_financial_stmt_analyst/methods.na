from knowledge import knows
from knowledge import docs
from knowledge import raw_docs
from common import State
from common import build_compression_prompt
from common import PLANNING_SYSTEM_PROMPT
from common import EXECUTION_SYSTEM_PROMPT
from common import EXECUTION_PROMPT
from common import STEP_BREAK
from common import COMPLEXITY_CLASSIFIER    
from common import SIMPLE_PLANNING_TEMPLATE
from common import MODERATE_PLANNING_TEMPLATE
from common import COMPLEX_PLANNING_TEMPLATE
from common import FOCUSED_PLANNING_PROMPT
from common import build_execution_prompt
from common import get_enchance_step_prompt
import yaml.py

STEPS_TO_START_COMPRESSION = 3
N_STEPS_TO_MERGE = 2

def get_tools() -> str:
    tools = {}
    for tool in docs.list_tools():
        tools[tool["function"]["name"]] = {"description" : tool["function"]["description"]}
    # tools.extend(knows.list_tools())
    # tools.extend(code.list_tools())
    return yaml.dump(tools, sort_keys=True)
    # return tools

TOOLS = get_tools()

def classify_complexity(question: str) -> dict[str, str]:
    """Classify question complexity and return classification details."""
    complexity_prompt = COMPLEXITY_CLASSIFIER.format(question=question)
    complexity_result = reason(complexity_prompt, resources=[], temperature=0)
    
    # Extract complexity level and select corresponding template
    if "SIMPLE" in complexity_result.upper():
        return {
            "level": "SIMPLE",
            "template": SIMPLE_PLANNING_TEMPLATE,
            "max_steps": "2 steps maximum"
        }
    elif "COMPLEX" in complexity_result.upper():
        return {
            "level": "COMPLEX", 
            "template": COMPLEX_PLANNING_TEMPLATE,
            "max_steps": "5+ steps as needed"
        }
    else:  # MODERATE or any unrecognized result defaults to MODERATE
        return {
            "level": "MODERATE",
            "template": MODERATE_PLANNING_TEMPLATE,
            "max_steps": "3-4 steps"
        }

def plan_ahead(data : State, complexity : str) -> State:
    # Step 1: Classify complexity and get template in one call
    complexity_info = classify_complexity(data.original_problem)
    
    # Step 3: Create focused planning prompt with ONLY the relevant template
    focused_plan_prompt = FOCUSED_PLANNING_PROMPT.format(
        system_plan_prompt=PLANNING_SYSTEM_PROMPT,
        complexity_level=complexity,
        max_steps=complexity_info["max_steps"],
        template=complexity_info["template"],
        question=data.original_problem
    )
    template = knows.get_plan(data.original_problem, 3)
    # template = "EMPTY"
    # log(template)
    str_plan = reason(f"{focused_plan_prompt}. Example plan : {template}", resources=[knows], temperature=0)
    
    # Step 4: Parse the plan into steps using STEP_BREAK (---)
    steps = str_plan.split(STEP_BREAK)
    new_steps = []
    current_buffer = []
    for step in steps:
        if ("STEP" in step):
            current_buffer.append(step)
            if len(current_buffer) == N_STEPS_TO_MERGE:
                new_step = "\n".join(current_buffer)
                new_steps.append(new_step)
                current_buffer = []
    if len(current_buffer) > 0:
        new_step = "\n".join(current_buffer)
        new_steps.append(new_step)
    data.steps = new_steps
    return data

def should_get_data(data: State) -> bool:
    if data.has_data == True:
        return False
    if len(data.steps) == 0:
        return True
    if "DATA" in data.current_step:
        return True
    return False

def should_execute(data: State) -> bool:
    if ("STEP" in data.current_step):
        return True
    if len(data.steps) == 0:
        return True
    return False

def fetch_all_data(data: State, execution_prompt: str) -> State:
    try:
        if len(data.steps) == 0:
            step_answer = reason(execution_prompt, temperature=0, resources=[raw_docs, knows])
        else:
            # step_answer = docs.load_financial_data("ABC")
            step_answer = reason(execution_prompt, temperature=0, resources=[docs])
        return step_answer
    except:
        step_answer = reason(execution_prompt, temperature=0, resources=[raw_docs, knows])
        return step_answer
    

def execute_step(data : State) -> State:
    log("="*50)
    log(data.current_step)
    if should_execute(data) == True:
        need_to_get_data = should_get_data(data)        
        
        # Use regular EXECUTION_PROMPT for calculations and analysis
        
        if need_to_get_data == True:
            execution_prompt = build_execution_prompt(data.original_problem, TOOLS, data.context, data.current_step)
            step_answer = fetch_all_data(data, execution_prompt)
            data.has_data = True
        else:
            enchance_prompt = get_enchance_step_prompt(data.current_step, data.context, data.original_problem)
            data.current_step = reason(enchance_prompt, temperature=0, resources=[knows])
            execution_prompt = build_execution_prompt(data.original_problem, TOOLS, data.context, data.current_step)
            step_answer = reason(execution_prompt, temperature=0, resources=[docs])
        log("-"*50)
        log(step_answer)    
        data.context = f"{data.context}. \n---\n{data.current_step} \n{step_answer}\n---"
        data.current_answer = step_answer
        data.count = data.count + 1
        log("-"*50)
        data.has_new_context = True
    return data

def compress_context(data : State) -> State:
    if data.has_new_context == True:
            # log(data.context)
            previous_step_name = data.previous_step.split("\n")[0]
            current_step_name = data.current_step.split("\n")[0]
            compression_prompt = build_compression_prompt(data.context, previous_step_name, current_step_name, previous_step_name, current_step_name, data.original_problem)
            compressed_context = reason(compression_prompt, resources=[], temperature=0)
            data.context = compressed_context
            log("-"*50)
            log(compressed_context)
            log("="*50)
            data.has_new_context = False
    return data

# def check_temporal_consistency(step_result : str) -> str:
#     """
#     Optional function to check for common temporal inconsistencies in step results.
#     Can be called after execute_step() to validate period usage.
#     """
#     import re.py
    
#     warnings = []
    
#     # Check for numbers without period labels
#     number_pattern = r'\$[\d,]+[KMB]?(?!\s*(?:Q[1-4]|FY|2024|2023|quarterly|annual))'
#     unlabeled_numbers = re.findall(number_pattern, step_result)
#     if unlabeled_numbers:
#         warnings.append("⚠️ Found financial figures without time period labels")
    
#     # Check for mixed quarterly/annual in same calculation
#     has_quarterly = bool(re.search(r'Q[1-4]|quarterly', step_result, re.IGNORECASE))
#     has_annual = bool(re.search(r'annual|yearly|FY', step_result, re.IGNORECASE))
#     if has_quarterly and has_annual:
#         if "annualized" not in step_result.lower() and "converted" not in step_result.lower():
#             warnings.append("⚠️ Mixing quarterly and annual figures - ensure proper conversion")
    
#     # Check for growth rate confusion
#     if "growth" in step_result.lower():
#         if re.search(r'[0-9]+%.*growth', step_result) and not re.search(r'quarterly|annual|monthly', step_result):
#             warnings.append("⚠️ Growth rate found without time period specification")
    
#     if warnings:
#         warning_text = "\n".join(warnings)
#         return f"{step_result}\n\n**TEMPORAL CONSISTENCY WARNINGS**:\n{warning_text}"
    
#     return step_result

