"""BasicTemplate: MVP version of single standard project template

Focus on core functionality validation, avoiding template selection complexity
"""

import textwrap


class BasicTemplate:
    """MVP version: Single standard template

    Design philosophy:
    - Avoid template selection complexity, focus on validating core processes
    - Single standard structure to meet 90% of user needs
    - Only includes core methods used directly by Builder
    - Supports MCP's three core capabilities: tools, resources, prompts
    - Minimalist principle: empty directory structure, no example files
    """

    def __init__(self) -> None:
        """Initialize basic template instance."""
        self.template_name = "basic-mcp-server"
        self.version = "1.0.0"

    def get_structure(self) -> dict[str, str]:
        """Return standard project structure definition - core Builder usage"""
        return {
            "config.yaml": "Server configuration file",
            "pyproject.toml": "Python project configuration",
            "server.py": "Server entry file",
            "README.md": "Project documentation",
            "AGENTS.md": "AI agent development guidelines",
            "CHANGELOG.md": "Version change log",
            ".env": "Environment variables configuration file",
            ".gitignore": "Git ignore file",
            "tools/": "Tools implementation directory",
            "resources/": "Resources implementation directory",
            "prompts/": "Prompt template directory",
        }

    def get_server_template(self) -> str:
        """Return server entry file template - core Builder usage"""
        return (
            textwrap.dedent(
                '''
            # !/usr/bin/env python3
            """
            {description}
            Generated by MCP Factory

            This server automatically discovers and registers components from:
            - tools/ directory: @server.tool() functions
            - resources/ directory: @server.resource() functions
            - prompts/ directory: @server.prompt() functions
            """

            import sys
            from pathlib import Path

            import yaml

            from mcp_factory.server import ManagedServer


            class ConfigurationError(Exception):
                \"\"\"Configuration error\"\"\"
                pass

            def load_config():
                """Load and validate configuration"""
                config_path = Path(__file__).parent / "config.yaml"
                try:
                    with open(config_path, encoding='utf-8') as f:
                        config = yaml.safe_load(f)

                    # Validate required configuration
                    if not config or 'server' not in config:
                        raise ConfigurationError("Invalid configuration: missing 'server' section")

                    server_config = config['server']
                    if 'name' not in server_config:
                        raise ConfigurationError("Invalid configuration: missing 'server.name'")

                    return config

                except FileNotFoundError:
                    print(f"Error: Configuration file not found: {{config_path}}")
                    sys.exit(1)
                except ConfigurationError as e:
                    print(f"Error: {{e}}")
                    sys.exit(1)

            def create_server(config):
                """Create and configure the ManagedServer"""
                server_config = config['server']
                management_config = config.get('management', {{}})

                # Create server with basic configuration first
                server_params = {{
                    'name': server_config['name'],
                    'instructions': server_config.get('instructions', ''),
                    'expose_management_tools': management_config.get('expose_management_tools', True)
                }}

                # Load middleware from configuration
                try:
                    from mcp_factory.middleware import load_middleware_from_config
                    middleware_instances = load_middleware_from_config(config)
                    if middleware_instances:
                        server_params['middleware'] = middleware_instances
                        print(f"✅ Loaded {{len(middleware_instances)}} middleware(s)")
                except ImportError:
                    print("⚠️  Middleware support not available, skipping middleware loading")
                except Exception as e:
                    print(f"❌ Failed to load middleware: {{e}}")

                server = ManagedServer(**server_params)

                # Configure external servers if present
                if 'mcpServers' in config:
                    try:
                        from mcp_factory.mounting import ServerRegistry
                        registry = ServerRegistry(server)
                        server_configs = registry.parse_external_servers_config(config)
                        registry.register_servers(server_configs)
                        lifespan = registry.create_lifespan({{"auto_start": True}})
                        if lifespan:
                            server._lifespan = lifespan
                            print("🔗 External servers configured")
                    except ImportError:
                        print("⚠️  ServerRegistry not available, skipping external servers")
                    except Exception as e:
                        print(f"⚠️  External servers configuration failed: {{e}}")

                # Store full config for component registration
                server._config = config

                return server

            def register_components(server):
                """Register project components using ComponentManager"""
                try:
                    from mcp_factory.project.components import ComponentManager
                    project_path = Path(__file__).parent

                    # Check if auto-discovery is enabled
                    config = getattr(server, "_config", {{}})
                    auto_discovery_config = config.get("components", {{}}).get("auto_discovery", {{}})

                    if auto_discovery_config.get("enabled", False):
                        # Auto-discover components and update server config
                        print("🔍 Auto-discovering project components...")
                        discovered_components = ComponentManager.discover_project_components(project_path)

                        if discovered_components:
                            # Smart merge: keep manual configuration, add newly discovered components
                            if "components" not in config:
                                config["components"] = {{}}

                            config_updated = False
                            for comp_type, discovered_items in discovered_components.items():
                                existing_items = config["components"].get(comp_type, [])
                                existing_modules = {{item.get("module") for item in existing_items}}

                                # Ensure all existing components have enabled attribute
                                for existing_item in existing_items:
                                    if "enabled" not in existing_item:
                                        existing_item["enabled"] = True
                                        config_updated = True

                                # Only add non-existing components, deduplicate based on module path
                                for discovered_item in discovered_items:
                                    if discovered_item.get("module") not in existing_modules:
                                        # Newly discovered components are enabled by default
                                        discovered_item["enabled"] = True
                                        existing_items.append(discovered_item)
                                        config_updated = True

                                config["components"][comp_type] = existing_items

                            server._config = config

                            # No longer write back to config file, maintain static and clean configuration
                            # auto_discovery discovers components at runtime, used directly in memory
                            print("💾 Components registered in memory only, config file remains static")

                            total_discovered = sum(len(comps) for comps in discovered_components.values())
                            print(f"📦 Discovered {{total_discovered}} components: {{', '.join(f'{{len(comps)}} {{name}}' for name, comps in discovered_components.items())}}")
                        else:
                            print("📂 No components found in project directories")

                    # Register components (both declared and discovered)
                    ComponentManager.register_components(server, project_path)
                    print("✅ Components registered successfully")

                except ImportError:
                    print("⚠️  ComponentManager not available, skipping auto-discovery")
                except Exception as e:
                    print(f"⚠️  Component registration failed: {{e}}")
                    print("💡 You can still add tools manually using @server.tool()")

            # Optional: Add your custom tools here
            # Example:
            # @server.tool()
            # def my_custom_tool(input_data: str) -> str:
            # \"\"\"Your custom tool description\"\"\"
            # return f"Processed: {{input_data}}"

            def main():
                """Main entry point"""
                print("🚀 Starting MCP Server...")

                # Load configuration
                config = load_config()
                print(f"📋 Loaded configuration for: {{config['server']['name']}}")

                # Create server
                server = create_server(config)
                print(f"🏗️  Created server: {{server.name}}")

                # Register components
                register_components(server)

                # Start server
                print(f"🎯 Instructions: {{server.instructions}}")
                print("🔄 Starting server (Press Ctrl+C to stop)...")

                try:
                    # Get transport configuration
                    transport_config = config.get('transport', {{}})
                    transport = transport_config.get('transport', 'stdio')

                    if transport in ['sse', 'streamable-http']:
                        host = transport_config.get('host', '127.0.0.1')
                        port = transport_config.get('port', 8000)
                        print(f"🌐 Server will start on: {{transport}}://{{host}}:{{port}}")
                        server.run(transport=transport, host=host, port=port)
                    else:
                        print(f"🔗 Server will start with: {{transport}} transport")
                        server.run(transport=transport)
                except KeyboardInterrupt:
                    print("\\n👋 Server stopped by user")
                except Exception as e:
                    print(f"❌ Server error: {{e}}")
                    sys.exit(1)

            if __name__ == "__main__":
                main()
        '''
            ).strip()
            + "\n"
        )

    def get_pyproject_template(self) -> str:
        """Return pyproject.toml template"""
        return textwrap.dedent(
            """
            [build-system]
            requires = ["setuptools>=61.0", "wheel"]
            build-backend = "setuptools.build_meta"

            [project]
            name = "{name}"
            version = "1.0.0"
            description = "{description}"
            readme = "README.md"
            requires-python = ">=3.10"
            dependencies = [
                "mcp-factory>=1.3.0",
                "pydantic>=2.0.0",
                "pyyaml>=6.0.0"
            ]



            [tool.setuptools]
            py-modules = []

            [tool.setuptools.packages.find]
            where = ["."]
            include = []

            [project.optional-dependencies]
            dev = [
                "pytest>=7.0.0",
                "pytest-asyncio>=0.21.0",
                "black>=23.0.0",
                "ruff>=0.1.0"
            ]

            [tool.black]
            line-length = 88
            target-version = ["py310"]

            [tool.ruff]
            line-length = 88
            target-version = "py310"
        """
        ).strip()

    def get_readme_template(self) -> str:
        """Return README.md template"""
        return textwrap.dedent(
            """
            # {name}

            {description}

            # # Quick Start

            ```bash
            # Install dependencies
            uv sync

            # Start server
            uv run python server.py
            ```

            # # Configuration

            Add to your Claude Desktop config (`claude_desktop_config.json`):

            ```json
            {{
              "mcpServers": {{
                "{name}": {{
                  "command": "uv",
                  "args": ["run", "python", "server.py"],
                  "cwd": "/path/to/{name}"
                }}
              }}
            }}
            ```

            # # Project Structure

            ```
            {name}/
            ├── config.yaml          # Server configuration
            ├── pyproject.toml       # Python project configuration
            ├── server.py            # Server entry file
            ├── README.md            # Documentation
            ├── CHANGELOG.md         # Version change log
            ├── .env                 # Environment variables configuration
            ├── .gitignore           # Git ignore file
            ├── tools/               # Tools implementation directory
            ├── resources/           # Resources implementation directory
            └── prompts/             # Prompt template directory
            ```

            # # Development

            Edit `server.py` to add your functionality:

            ```python
            @server.tool()
            def my_tool(arg: str) -> str:
                \"\"\"Tool description\"\"\"
                return f"Result: {{{{arg}}}}"
            ```

            # # Advanced Usage

            For advanced features and examples, see the [examples directory](../examples/) in the mcp-factory repository.

            ---

            *Generated by [MCP Factory](https://github.com/your-org/mcp-factory)*
        """
        ).strip()

    def get_env_template(self) -> str:
        """Return .env file template"""
        return textwrap.dedent(
            """
            # JWT authentication configuration
            FASTMCP_AUTH_BEARER_ISSUER=https://your-auth-server.com
            FASTMCP_AUTH_BEARER_AUDIENCE=your-app-name
            FASTMCP_AUTH_BEARER_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----
            # Please replace with your JWT verification public key
            MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
            -----END PUBLIC KEY-----"

            # Optional: JWKS endpoint (for dynamic key retrieval)
            # FASTMCP_AUTH_BEARER_JWKS_URI=https://your-auth-server.com/.well-known/jwks.json

            # Other environment variables
            DEBUG=true
            LOG_LEVEL=INFO
        """
        ).strip()

    def get_changelog_template(self) -> str:
        """Return CHANGELOG.md template"""
        return textwrap.dedent(
            """
            # Changelog

            All notable changes to this MCP server will be documented in this file.

            The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
            and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

            # # [Unreleased]

            # ## Added
            - Initial MCP server implementation

            # ## Changed

            # ## Deprecated

            # ## Removed

            # ## Fixed

            # ## Security

            # # [1.0.0] - {date}

            # ## Added
            - Initial release
            - Basic server configuration
            - Core MCP functionality
            - Tools, resources, and prompts modules
        """
        ).strip()

    def get_gitignore_template(self) -> str:
        """Return .gitignore file template"""
        return textwrap.dedent(
            """
            # Python
            __pycache__/
            *.py[cod]
            *$py.class
            *.so

            # Distribution / packaging
            .Python
            build/
            develop-eggs/
            dist/
            downloads/
            eggs/
            .eggs/
            lib/
            lib64/
            parts/
            sdist/
            var/
            wheels/
            *.egg-info/
            .installed.cfg
            *.egg
            MANIFEST

            # Unit test / coverage reports
            htmlcov/
            .tox/
            .coverage
            .coverage.*
            .cache
            nosetests.xml
            coverage.xml
            *.cover
            .hypothesis/
            .pytest_cache/

            # Environments
            .env
            .env.*
            .venv
            env/
            venv/
            ENV/
            env.bak/
            venv.bak/

            # IDE
            .vscode/
            .idea/
            *.swp
            *.swo

            # OS
            .DS_Store
            Thumbs.db
            Desktop.ini

            # Logs
            *.log
            logs/

            # MCP Server specific
            cache/
            data/local/
            temp/
            *.pid
            *.sock

            # Local config overrides
            config.local.yaml
            .env.production
            .env.staging
        """
        ).strip()

    def get_agents_template(self) -> str:
        """Return AGENTS.md template"""
        return textwrap.dedent(
            """
            # Project Overview
            {description}

            This is an MCP (Model Context Protocol) server built with mcp-factory. It provides tools, resources, and prompts accessible via the MCP protocol.

            # # Server Configuration
            **Claude Desktop Configuration (`claude_desktop_config.json`):**
            ```json
            {{
              "mcpServers": {{
                "{name}": {{
                  "command": "uv",
                  "args": ["run", "python", "server.py"],
                  "cwd": "/path/to/{name}"
                }}
              }}
            }}
            ```

            **Direct Connection:**
            ```bash
            # Navigate to project directory first
            cd /path/to/{name}
            uv run python server.py
            ```

            > **Note**: For alternative configuration methods (different environments, authentication, etc.),
            > see the [MCP Configuration Guide](https://github.com/modelcontextprotocol/docs) or consult
            > your MCP client documentation.

            # # Build and Test Commands
            ```bash
            # Install dependencies
            uv sync

            # Run the server (always from mcp-factory root)
            cd /path/to/mcp-factory
            uv run python workspace/projects/{name}/server.py

            # Test the server using mcp-inspector-server tools
            # Call inspect_mcp_server with server_command parameter
            # Call comprehensive_server_test for full validation
            # Use call_mcp_tool to test individual functions
            ```

            # # Code Style Guidelines
            - Use `uv run ruff format .` to format code (from project directory)
            - Run `uv run ruff check .` before committing
            - Use type hints: functions return `dict[str, Any]` for tools
            - Add docstrings to all functions (required for MCP registration)
            - Use direct function parameters, not Pydantic models

            # # Testing Instructions
            - Use mcp-inspector-server tools for all testing
            - Call `inspect_mcp_server` to verify server connectivity
            - Use `comprehensive_server_test` for complete validation
            - Test individual tools with `call_mcp_tool`
            - Run `uv run ruff check .` to catch linting issues
            - Always verify server starts from mcp-factory root directory

            # # Security Considerations
            - Validate all input parameters in tools
            - Be cautious with file system access in tools
            - Don't expose sensitive data through resources
            - Use appropriate error handling to avoid information leakage

            # # Component Management
            This project supports dynamic component discovery and registration:

            **Adding Components:**
            - Tools: Create `.py` files in `tools/` directory with functions decorated with `@tool`
            - Resources: Create `.py` files in `resources/` directory with functions decorated with `@resource`
            - Prompts: Create `.py` files in `prompts/` directory with functions decorated with `@prompt`

            **Component Discovery:**
            - Components are automatically discovered and registered in `config.yaml`
            - Use descriptive function names and comprehensive docstrings
            - Ensure all parameters are JSON-serializable for MCP compatibility

            # # Development Notes
            - **Path requirements**: Always run server from mcp-factory root directory
            - **Schema requirements**: Use `dict[str, Any]` returns, ensure JSON-serializable parameters
            - **Component discovery**: Components are automatically found and registered in `config.yaml`
        """
        ).strip()
