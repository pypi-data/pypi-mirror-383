/* Template for a specific morphology code. */

#pragma GCC optimize("02,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")

#define PY_SSIZE_T_CLEAN
#include <numpy/arrayobject.h>
#include <Python.h>
#include "morphomath/threading.h"

#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#define ADD(a, b)  ((a) + (b))
#define MUL(a, b)  ((a) * (b))
#define OP  {operator}
#define NPT  {numpy_type}


{func_elementary_patch}


{func_elementary_loop}


static PyObject* py_morpho(PyObject* Py_UNUSED(self), PyObject* args, PyObject* kwargs) {
  // declaration
  static char *kwlist[] = {"src", "dst", "threads", NULL};
  PyArrayObject *src, *dst = NULL;
  long int threads = 0;

  // parse and check
  if ( !PyArg_ParseTupleAndKeywords(
    args, kwargs, "O!|O!$l", kwlist,
    &PyArray_Type, &src, &PyArray_Type, &dst, &threads
    )
  ) {
    return NULL;
  }
  threads = get_num_threads(threads);
  if ( PyArray_NDIM(src) != {dim} ) {
    PyErr_SetString(PyExc_ValueError, "'src' requires {dim} dimensions");
    return NULL;
  }

  // allocate the output array
  if ( dst == NULL ) {
    dst = (PyArrayObject *)PyArray_EMPTY({dim}, PyArray_SHAPE(src), PyArray_TYPE(src), 0);
    if ( dst == NULL ) {
        return PyErr_NoMemory();
      }
  } else {
    // verification of dst
    if ( PyArray_NDIM(dst) != {dim} ) {
      PyErr_SetString(PyExc_ValueError, "'dst' requires {dim} dimensions");
      return NULL;
    }
    for ( long int i = 0; i < {dim}; ++i) {
      if ( PyArray_DIM(src, i) != PyArray_DIM(dst, i) ) {
        PyErr_SetString(PyExc_ValueError, "'src' and 'dst' have not the same shapes");
        return NULL;
      }
    }
    if ( PyArray_TYPE(src) != PyArray_TYPE(dst) ) {
      PyErr_SetString(PyExc_ValueError, "'src' and 'dst' have not the same dtype");
      return NULL;
    }
  }

  // main code
  Py_BEGIN_ALLOW_THREADS
  morpho_valid(dst, src, threads);
  Py_END_ALLOW_THREADS

  return (PyObject*)dst;
}


static PyMethodDef morphoMethods[] = {
  {
    "morpho", (PyCFunction)py_morpho, METH_VARARGS | METH_KEYWORDS,
    R"({description}
    )"
  },
  {NULL, NULL, 0, NULL}
};


static struct PyModuleDef morpho = {
  PyModuleDef_HEAD_INIT,
  "morpho",
  "This is an autogenerated c module.",
  -1,
  morphoMethods
};


PyMODINIT_FUNC PyInit_morpho(void)
{
  import_array();
  if ( PyErr_Occurred() ) {
    return NULL;
  }
  return PyModule_Create(&morpho);
}

