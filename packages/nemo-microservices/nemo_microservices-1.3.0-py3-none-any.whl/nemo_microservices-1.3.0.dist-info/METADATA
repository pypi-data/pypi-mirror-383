Metadata-Version: 2.3
Name: nemo-microservices
Version: 1.3.0
Summary: The official Python library for the NeMo Microservices API
Project-URL: Homepage, https://docs.nvidia.com/nemo/microservices/latest/about/index.html
Author: NVIDIA Corporation
License: Apache-2.0
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Operating System :: MacOS
Classifier: Operating System :: Microsoft :: Windows
Classifier: Operating System :: OS Independent
Classifier: Operating System :: POSIX
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Typing :: Typed
Requires-Python: >=3.9
Requires-Dist: anyio<5,>=3.5.0
Requires-Dist: distro<2,>=1.7.0
Requires-Dist: httpx<1,>=0.23.0
Requires-Dist: pydantic<3,>=1.9.0
Requires-Dist: sniffio
Requires-Dist: typing-extensions<5,>=4.10
Provides-Extra: aiohttp
Requires-Dist: aiohttp; extra == 'aiohttp'
Requires-Dist: httpx-aiohttp>=0.1.8; extra == 'aiohttp'
Provides-Extra: data-designer
Requires-Dist: eval-type-backport; (python_version == '3.9') and extra == 'data-designer'
Requires-Dist: huggingface-hub>=0.34.4; extra == 'data-designer'
Requires-Dist: jinja2<4,>=3.1.6; extra == 'data-designer'
Requires-Dist: numpy>=1.23.5; extra == 'data-designer'
Requires-Dist: pandas>=1.5.3; extra == 'data-designer'
Requires-Dist: pyarrow>=19.0.1; extra == 'data-designer'
Requires-Dist: pydantic>=2.9.2; extra == 'data-designer'
Requires-Dist: pygments>=2.19.2; extra == 'data-designer'
Requires-Dist: python-json-logger==2.0.7; extra == 'data-designer'
Requires-Dist: pyyaml>=6.0.1; extra == 'data-designer'
Requires-Dist: requests<3,>=2.32.2; extra == 'data-designer'
Requires-Dist: rich>=13.7.1; extra == 'data-designer'
Provides-Extra: safe-synthesizer
Requires-Dist: datasets>=2.14.0; extra == 'safe-synthesizer'
Requires-Dist: eval-type-backport; (python_version == '3.9') and extra == 'safe-synthesizer'
Requires-Dist: faker>=20.0; extra == 'safe-synthesizer'
Requires-Dist: huggingface-hub>=0.34.4; extra == 'safe-synthesizer'
Requires-Dist: pandas>=2.1.3; extra == 'safe-synthesizer'
Requires-Dist: pydantic[email]>=2.9.2; extra == 'safe-synthesizer'
Requires-Dist: smart-open==7.0.5; extra == 'safe-synthesizer'
Description-Content-Type: text/markdown

# NVIDIA NeMo Microservices Python SDK

[![PyPI version](https://img.shields.io/pypi/v/nemo-microservices.svg?label=pypi%20(stable))](https://pypi.org/project/nemo-microservices/)

The NVIDIA NeMo Microservices Python SDK provides convenient access to the NeMo Microservices REST API from any Python 3.9+
application. The SDK includes type definitions for all request parameters and response fields,
and offers both synchronous and asynchronous clients powered by [httpx](https://github.com/encode/httpx).

[Stainless](https://www.stainless.com/) generates this SDK from the [NVIDIA NeMo Microservices REST API](https://docs.nvidia.com/nemo/microservices/latest/api/index.html).

## Documentation

You can find the platform documentation at [NVIDIA NeMo Microservices Documentation](https://docs.nvidia.com/nemo/microservices/latest/about/index.html).
The [NVIDIA NeMo Microservice APIs](https://docs.nvidia.com/nemo/microservices/latest/api/index.html) section documents the REST API.

## Installation

This project downloads and installs additional third-party open source software projects. Review the license terms of these open source projects before use.

```sh
pip install nemo-microservices
```

## Usage

This section describes how to use the NeMo microservices Python SDK.

### Import the Main Client Class

Import the main client class from the `nemo_microservices` package and create a client instance as follows:

```python
from nemo_microservices import NeMoMicroservices

client = NeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test"
)

# Sample API call 
page = client.namespaces.list()
print(page.data)
```

- For the `base_url`, point to the default host for NeMo microservices. This sets up the client to interact with the NeMo microservices APIs except the NIM Proxy microservice APIs.
- For the `inference_base_url`, point to the host for the NIM Proxy microservice. You can also directly point to the host for a NIM microservice if the cluster admin in your organization has deployed it, or point to a NIM microservice on build.nvidia.com.

After creating the client instance, you can use the client to interact with the NeMo microservices APIs.

## Async Usage

If you want to use the asynchronous client, simply import `AsyncNeMoMicroservices` instead of `NeMoMicroservices` and use `await` with each API call:

```python
import asyncio
from nemo_microservices import AsyncNeMoMicroservices

client = AsyncNeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test"
)

# Sample API call
async def main() -> None:
    page = await client.namespaces.list()
    print(page.data)


asyncio.run(main())
```

Functionality between the synchronous and asynchronous clients is otherwise identical.

### With aiohttp

By default, the async client uses `httpx` for HTTP requests. However, for improved concurrency performance you may also use `aiohttp` as the HTTP backend.

You can enable this by installing `aiohttp`:

```sh
pip install 'nemo-microservices[aiohttp]'
```

Then you can enable it by instantiating the client with `http_client=DefaultAioHttpClient()`:

```python
import asyncio
from nemo_microservices import DefaultAioHttpClient
from nemo_microservices import AsyncNeMoMicroservices


async def main() -> None:
    async with AsyncNeMoMicroservices(
        base_url="http://nemo.test",
        inference_base_url="http://nim.test",
        http_client=DefaultAioHttpClient(),
    ) as client:
        page = await client.namespaces.list()
        print(page.data)


asyncio.run(main())
```

## Using Types

Nested request parameters are [TypedDicts](https://docs.python.org/3/library/typing.html#typing.TypedDict). Responses are [Pydantic models](https://docs.pydantic.dev) which also provide helper methods for things like:

- Serializing back into JSON, `model.to_json()`
- Converting to a dictionary, `model.to_dict()`

Typed requests and responses provide autocomplete and documentation within your editor. If you would like to see type errors in VS Code to help catch bugs, set `python.analysis.typeCheckingMode` to `basic`.

## Pagination

List methods in the NeMo microservices API are paginated.

This library provides auto-paginating iterators with each list response, so you do not have to request successive pages manually:

```python
from nemo_microservices import NeMoMicroservices

client = NeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test"
)

all_projects = []
# Automatically fetches more pages as needed.
for project in client.projects.list():
    # Do something with project here
    all_projects.append(project)
print(all_projects)
```

Or, asynchronously:

```python
import asyncio
from nemo_microservices import AsyncNeMoMicroservices

client = AsyncNeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test"
)

async def main() -> None:
    all_projects = []
    # Iterate through items across all pages, issuing requests as needed.
    async for project in client.projects.list():
        all_projects.append(project)
    print(all_projects)


asyncio.run(main())
```

Alternatively, you can use the `.has_next_page()`, `.next_page_info()`, or `.get_next_page()` methods for more granular control working with pages:

```python
first_page = await client.projects.list()
if first_page.has_next_page():
    print(f"will fetch next page using these details: {first_page.next_page_info()}")
    next_page = await first_page.get_next_page()
    print(f"number of items we just fetched: {len(next_page.data)}")

# Remove `await` for non-async usage.
```

Or just work directly with the returned data:

```python
first_page = await client.projects.list()
for project in first_page.data:
    print(project.created_at)

# Remove `await` for non-async usage.
```

## Nested Parameters

Nested parameters are dictionaries, typed using `TypedDict`, for example:

```python
from nemo_microservices import NeMoMicroservices

client = NeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test"
)

customization_config = client.customization.configs.create(
    max_seq_length=0,
    training_options=[
        {
            "finetuning_type": "p_tuning",
            "micro_batch_size": 0,
            "num_gpus": 0,
            "training_type": "sft",
        }
    ],
    ownership={},
)
print(customization_config.ownership)
```

## Handling Errors

The library raises errors when it cannot connect to the API or when the API returns a non-success status code.

### API Connection Errors

When the library cannot connect to the API (for example, due to network connection problems or a timeout), it raises a subclass of `nemo_microservices.APIConnectionError`.

When the API returns a non-success status code (that is, 4xx or 5xx
response), it raises a subclass of `nemo_microservices.APIStatusError`, containing `status_code` and `response` properties.

All errors inherit from `nemo_microservices.APIError`.

```python
import nemo_microservices
from nemo_microservices import NeMoMicroservices

client = NeMoMicroservices()

try:
    client.namespaces.list()
except nemo_microservices.APIConnectionError as e:
    print("The server could not be reached")
    print(e.__cause__)  # an underlying Exception, likely raised within httpx.
except nemo_microservices.RateLimitError as e:
    print("A 429 status code was received; we should back off a bit.")
except nemo_microservices.APIStatusError as e:
    print("Another non-200-range status code was received")
    print(e.status_code)
    print(e.response)
```

Error codes are as follows:

| Status Code | Error Type                 |
| ----------- | -------------------------- |
| 400         | `BadRequestError`          |
| 401         | `AuthenticationError`      |
| 403         | `PermissionDeniedError`    |
| 404         | `NotFoundError`            |
| 422         | `UnprocessableEntityError` |
| 429         | `RateLimitError`           |
| >=500       | `InternalServerError`      |
| N/A         | `APIConnectionError`       |

## Retries

Certain errors are automatically retried 2 times by default, with a short exponential backoff.
Connection errors (for example, due to a network connectivity problem), 408 Request Timeout, 409 Conflict,
429 Rate Limit, and >=500 Internal errors are all retried by default.

You can use the `max_retries` option to configure or disable retry settings:

```python
from nemo_microservices import NeMoMicroservices

# Configure the default for all requests:
client = NeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test",
    # default is 2
    max_retries=0,
)

# Or, configure per-request:
client.with_options(max_retries=5).namespaces.list()
```

## Timeouts

By default, requests time out after 1 minute. You can configure this with a `timeout` option,
which accepts a float or an [`httpx.Timeout`](https://www.python-httpx.org/advanced/timeouts/#fine-tuning-the-configuration) object:

```python
from nemo_microservices import NeMoMicroservices

# Configure the default for all requests:
client = NeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test",
    # 20 seconds (default is 1 minute)
    timeout=20.0,
)

# More granular control:
client = NeMoMicroservices(
    timeout=httpx.Timeout(60.0, read=5.0, write=10.0, connect=2.0),
)

# Override per-request:
client.with_options(timeout=5.0).namespaces.list()
```

On timeout, an `APITimeoutError` is thrown.

Note that requests that time out are [retried twice by default](https://github.com/stainless-sdks/nemo-microservices-v1-python/tree/main/#retries).

## Advanced Usage

### Logging

We use the standard library [`logging`](https://docs.python.org/3/library/logging.html) module.

You can enable logging by setting the environment variable `NEMO_MICROSERVICES_LOG` to `info`.

```shell
$ export NEMO_MICROSERVICES_LOG=info
```

Or to `debug` for more verbose logging.

#### How to Tell Whether `None` Means `null` or Missing

In an API response, a field may be explicitly `null`, or missing entirely; in either case, its value is `None` in this library. You can differentiate the two cases with `.model_fields_set`:

```py
if response.my_field is None:
  if 'my_field' not in response.model_fields_set:
    print('Got json like {}, without a "my_field" key present at all.')
  else:
    print('Got json like {"my_field": null}.')
```

### Accessing Raw Response Data (e.g. Headers)

You can access the "raw" response object by prefixing `.with_raw_response.` to any HTTP method call, for example:

```py
from nemo_microservices import NeMoMicroservices

client = NeMoMicroservices(base_url="http://nemo.test", inference_base_url="http://nim.test")
response = client.namespaces.with_raw_response.list()
print(response.headers.get('X-My-Header'))

namespace = response.parse()  # get the object that `namespaces.list()` would have returned
print(namespace.id)
```

These methods return an `APIResponse` object.

The async client returns an `AsyncAPIResponse` with the same structure, the only difference being `await`able methods for reading the response content.

#### `.with_streaming_response`

The above interface eagerly reads the full response body when you make the request, which may not always be what you want.

To stream the response body, use `.with_streaming_response` instead, which requires a context manager and only reads the response body once you call `.read()`, `.text()`, `.json()`, `.iter_bytes()`, `.iter_text()`, `.iter_lines()` or `.parse()`. In the async client, these are async methods.

```python
with client.namespaces.with_streaming_response.list() as response:
    print(response.headers.get("X-My-Header"))

    for line in response.iter_lines():
        print(line)
```

The context manager is required so that the response will reliably be closed.

### Making Custom/Undocumented Requests

This library is typed for convenient access to the documented API.

If you need to access undocumented endpoints, params, or response properties, you can still use the library.

#### Undocumented Endpoints

To make requests to undocumented endpoints, you can make requests using `client.get`, `client.post`, and other
http verbs. The client will respect options (such as retries) when making this request.

```py
import httpx

response = client.post(
    "/foo",
    cast_to=httpx.Response,
    body={"my_param": True},
)

print(response.headers.get("x-foo"))
```

#### Undocumented Request Params

If you want to explicitly send an extra param, you can do so with the `extra_query`, `extra_body`, and `extra_headers` request
options.

#### Undocumented Response Properties

To access undocumented response properties, you can access the extra fields like `response.unknown_prop`. You
can also get all the extra fields on the Pydantic model as a dict with
[`response.model_extra`](https://docs.pydantic.dev/latest/api/base_model/#pydantic.BaseModel.model_extra).

### Configuring the HTTP Client

You can directly override the [httpx client](https://www.python-httpx.org/api/#client) to customize it for your use case, including:

- Support for [proxies](https://www.python-httpx.org/advanced/proxies/)
- Custom [transports](https://www.python-httpx.org/advanced/transports/)
- Additional [advanced](https://www.python-httpx.org/advanced/clients/) functionality

```python
import httpx
from nemo_microservices import NeMoMicroservices, DefaultHttpxClient

client = NeMoMicroservices(
    base_url="http://nemo.test",
    inference_base_url="http://nim.test",
    http_client=DefaultHttpxClient(
        proxy="http://my.test.proxy.example.com",
        transport=httpx.HTTPTransport(local_address="0.0.0.0"),
    ),
)
```

You can also customize the client on a per-request basis by using `with_options()`:

```python
client.with_options(http_client=DefaultHttpxClient(...))
```

### Managing HTTP Resources

By default the library closes underlying HTTP connections whenever the client is [garbage collected](https://docs.python.org/3/reference/datamodel.html#object.__del__). You can manually close the client using the `.close()` method if desired, or use a context manager that closes when exiting.

```py
from nemo_microservices import NeMoMicroservices

with NeMoMicroservices() as client:
  # make requests here
  ...

# HTTP client is now closed
```

## Versioning

This package generally follows [SemVer](https://semver.org/spec/v2.0.0.html) conventions, while it might release certain backwards-incompatible changes as minor versions:

1. Changes that only affect static types, without breaking runtime behavior.
2. Changes to library internals which are technically public but not intended or documented for external use. Open a GitHub issue to let us know if you are relying on such internals.
3. Changes that we do not expect to impact the vast majority of users in practice.

We take backwards-compatibility seriously and work hard to ensure you can rely on a smooth upgrade experience.

We welcome your feedback; please contact us with questions, bugs, or suggestions.

### Determining the Installed Version

If you've upgraded to the latest version but can't find any new features you were expecting, your Python environment is likely still using an older version.

You can determine the version that is being used at runtime with:

```py
import nemo_microservices
print(nemo_microservices.__version__)
```

## Requirements

Python 3.9 or higher.