# Test file for storage
"""
Performance tests for OSDU Storage Service
Generated by OSDU Performance Testing Framework

This module contains comprehensive performance tests for the OSDU Storage Service,
including operations for creating, retrieving, and querying storage records.

Test Coverage:
- Create storage records (File.Generic kind)
- Retrieve individual storage records by ID
- Query all records with specific kind (GET)
- Query records by attributes (POST)
- Legal tag setup and management

Author: OSDU Performance Testing Framework
Date: 2025-09-16
"""

import json
import os
import requests
from osdu_perf import BaseService


class StoragePerformanceTest(BaseService):
    """
    Performance test class for OSDU Storage Service.
    
    This class implements comprehensive performance tests for the Storage Service APIs,
    including record creation, retrieval, and querying operations. The class follows
    the OSDU Performance Testing Framework conventions and will be automatically
    discovered and executed by the framework.
    
    Attributes:
        name (str): Service name identifier
        record_counter (int): Counter for generating unique record IDs
        prehook_executed (bool): Flag to ensure prerequisite setup runs only once
        legal_tag_name (str): Name of the legal tag used for storage records
    """
    
    def __init__(self, client=None):
        """
        Initialize the StoragePerformanceTest instance.
        
        Args:
            client: HTTP client instance for making API requests
        """
        super().__init__(client)
        self.name = "storage"
        self.record_counter = 0
        self.prehook_executed = False
        self.legal_tag_name = "storagerecord"



    
    def execute(self, headers=None, partition=None, base_url=None):
        """
        Execute the complete suite of storage performance tests.
        
        This method orchestrates the execution of all storage service performance tests
        in the correct order. Each test is wrapped in exception handling to ensure
        the test suite continues even if individual tests fail.
        
        Test Execution Order:
        1. Create storage record (File.Generic type)
        2. Retrieve the created record by ID
        3. Query all records with specific kind (GET method)
        4. Query records by attributes (POST method)
        
        Args:
            headers (dict): HTTP headers including authentication tokens
            partition (str): Data partition ID for multi-tenant isolation
            base_url (str): Base URL for the storage service API
        """
        print(f"üî• Executing {self.name} performance tests...")
        
        # Test 1: Create a new storage record
        try:
            self._test_create_storage_record_file_generic(headers, partition, base_url)
        except Exception as e:
            print(f"‚ùå Error in create record test: {e}")
        
        # Test 2: Retrieve the created record
        try:
            self._test_get_storage_record(headers, partition, base_url)
        except Exception as e:
            print(f"‚ùå Error in get record test: {e}")
        
        # Test 3: Query all records with kind filter (GET)
        try:
            self._test_get_all_records_with_kind(headers, partition, base_url)
        except Exception as e:
            print(f"‚ùå Error in get all records test: {e}")
        
        # Test 4: Query specific records by attributes (POST)
        try:
            self._test_query_records_by_attributes(headers, partition, base_url)
        except Exception as e:
            print(f"‚ùå Error in query records test: {e}")

        print(f"‚úÖ Completed {self.name} performance tests")


    def provide_explicit_token(self) -> str:
        """
        Provide an explicit token for service execution.
        
        Override this method if you need custom token logic.
        
        Returns:
            str: Authentication token for API requests
        """
        # TODO: Implement custom token logic if needed
        # Example: return "Bearer your-custom-token-here"
        print("[Storage] Providing explicit token for authentication...")
        return os.getenv("ADME_BEARER_TOKEN")
    
        
    def prehook(self, headers=None, partition=None, base_url=None):
        """
        Pre-hook tasks before service execution.
        
        Use this method to set up test data, configurations, or prerequisites.
        This function will only execute once per test session.
        
        Args:
            headers: HTTP headers including authentication
            partition: Data partition ID  
            host: Host URL for the service
        """
        # Ensure prehook only executes once
        if self.prehook_executed:
            print(f"üîß Prehook already executed for {self.name} tests, skipping...")
            return
    
        print(f"üîß Setting up prerequisites for {self.name} tests...")
        
        try:
            # Create legal tag required for storage records
            url = base_url + "/api/legal/v1/legaltags"

            
            # Set required headers
            headers["Content-Type"] = "application/json"
            headers["data-partition-id"] = partition
            headers['accept'] = 'application/json'

            payload = {
                "name": self.legal_tag_name,
                "description": "Legal Tag added for Storage Performance Tests",
                "properties": {
                    "countryOfOrigin": ["US"],
                    "contractId": "No Contract Related",
                    "expirationDate": "2099-01-01",
                    "dataType": "Public Domain Data",
                    "originator": "OSDU",
                    "securityClassification": "Public",
                    "exportClassification": "EAR99",
                    "personalData": "No Personal Data"
                }
            }
            
            response = requests.post(url, json=payload, headers=headers)
            print(f"Create Legal Tag '{self.legal_tag_name}' status: {response.status_code}")
            
            if response.status_code in [200, 201, 409]:  # 409 means already exists
                print(f"‚úÖ Legal tag '{self.legal_tag_name}' is ready for use")
                self.prehook_executed = True
            else:
                print(f"‚ùå Failed to create legal tag: {response.text}")
                
        except Exception as e:
            print(f"‚ùå Error in prehook setup: {e}")
            # Don't mark as executed if there was an error
            return
        
        print(f"‚úÖ Prerequisites setup completed for {self.name} tests")

    def posthook(self, headers=None, partition=None, base_url=None):
        """
        Post-hook tasks after service execution.
        
        Use this method for cleanup, reporting, or post-test validations.
        
        Args:
            headers: HTTP headers including authentication
            partition: Data partition ID  
            host: Host URL for the service
        """
        print(f"üßπ Cleaning up after {self.name} tests...")
        # TODO: Implement cleanup logic (e.g., delete test data, reset state)
        # Example: Remove test records, generate reports, validate cleanup
        pass
    
    

    def _test_create_storage_record_file_generic(self, headers, partition, base_url):
        """
        Test creating a storage record of kind File.Generic.
        
        This test creates a new storage record using the Storage Service v2 API.
        The record follows the OSDU File.Generic schema and includes all required
        fields such as ACL, legal tags, and data payload.
        
        API Endpoint: PUT /api/storage/v2/records
        
        Args:
            headers (dict): HTTP headers including authentication
            partition (str): Data partition ID for multi-tenant isolation
            base_url (str): Base URL for the storage service
        """
        print("[Test] [create a storage record of kind File.Generic] API tested: /api/storage/v2/records")
        url = base_url + "/api/storage/v2/records"
        
        # Generate unique record ID using incrementing counter
        self.record_counter += 1
        
        # Construct the storage record payload following OSDU File.Generic schema
        payload = [{
            "id": f"{partition}:dataset--File.Generic:{self.record_counter}",
            "kind": f"{partition}:wks:dataset--File.Generic:1.0.0",
            "acl": {
                "owners": [f"data.default.owners@{partition}.dataservices.energy"],
                "viewers": [f"data.default.viewers@{partition}.dataservices.energy"]
            },
            "legal": {
                "legaltags": [f"{partition}-storagerecord"],
                "otherRelevantDataCountries": ["US"],
                "status": "compliant"
            },
            "data": {
                "Name": "Example File",
                "ResourceSecurityClassification": "Public",
                "FileSourceInfo": {
                    "FileSource": "s3://bucket/sample.csv",
                    "PreloadFilePath": "sample.csv"
                }
            }
        }]
        
        # Set required HTTP headers for the API request
        headers["Content-Type"] = "application/json"
        headers["data-partition-id"] = partition
        headers['accept'] = 'application/json'
        
        # Create the storage record using PUT method
        # Note: Storage API uses PUT for record creation/update operations
        response = self.client.put(url, data=json.dumps(payload), headers=headers)
        print(f"Create record status: {response.status_code}")
        
        if response.status_code == 201:
            print(f"‚úÖ Successfully created record: {payload[0]['id']}")
        else:
            print(f"‚ùå Failed to create record: {payload[0]['id']}")
       


    def _test_get_storage_record(self, headers, partition, base_url):
        """
        Test retrieving a specific storage record by its ID.
        
        This test retrieves a storage record using its unique identifier.
        It attempts to fetch the record that was created in the previous test.
        
        API Endpoint: GET /api/storage/v2/records/{id}
        
        Args:
            headers (dict): HTTP headers including authentication
            partition (str): Data partition ID for multi-tenant isolation
            base_url (str): Base URL for the storage service
        """
        print("[Test] [get a storage record] API tested: /api/storage/v2/records/{id}")
        
        # Use the most recently created record ID, or fallback to ID with counter 1
      
        record_id = f"{partition}:dataset--File.Generic:1"
        
        print(f"Retrieving record with ID: {record_id}")
        url = f"{base_url}/api/storage/v2/records/{record_id}"
        
        # Set required HTTP headers
        headers["data-partition-id"] = partition
        headers['accept'] = 'application/json'
        
        # Retrieve the storage record
        response = self.client.get(url, headers=headers)
        print(f"Get record status: {response.status_code}")
        
        if response.status_code == 200:
            print(f"‚úÖ Successfully retrieved record: {record_id}")
            # Optionally, validate the retrieved record structure
            try:
                record_data = response.json()
                print(f"   Record kind: {record_data.get('kind', 'Unknown')}")
            except Exception as e:
                print(f"   Could not parse record data: {e}")
        else:
            print(f"‚ùå Failed to retrieve record: {record_id}")


    def _test_get_all_records_with_kind(self, headers, partition, base_url):
        """
        Test querying all storage records with a specific kind using GET method.
        
        This test retrieves all storage records that match a specific kind pattern
        using query parameters. It uses the GET method with URL parameters to
        filter records by kind, limit results, and sort order.
        
        API Endpoint: GET /api/storage/v2/query/records
        
        Args:
            headers (dict): HTTP headers including authentication
            partition (str): Data partition ID for multi-tenant isolation
            base_url (str): Base URL for the storage service
        """
        print("[Test] [get all storage records with kind] API tested: /api/storage/v2/query/records (GET)")
        
        # Build the query endpoint URL
        url = f"{base_url}/api/storage/v2/query/records"
        
        # Define query parameters for filtering and pagination
        params = {
            'limit': 1000,  # Maximum number of records to return
            'kind': f"{partition}:wks:dataset--File.Generic:1.0.0",  # Filter by record kind
            'deleted': 'false',  # Only retrieve active (non-deleted) records
            'sortOrder': 'DESC'  # Sort by creation time, newest first
        }
        
        # Set required HTTP headers
        headers["data-partition-id"] = partition
        headers['accept'] = 'application/json'
        
        print(f"Retrieving records with parameters: {params}")
        
        # Execute the query request
        response = self.client.get(url, headers=headers, params=params)
        print(f"Get all records status: {response.status_code}")
        
        if response.status_code == 200:
            try:
                response_data = response.json()
                record_count = len(response_data.get('records', []))
                total_count = response_data.get('totalCount', 0)
                print(f"‚úÖ Successfully retrieved {record_count} records (Total: {total_count})")
                
                # Display sample record IDs for verification
                records = response_data.get('records', [])
                if records:
                    print(f"Sample record IDs:")
                    for i, record in enumerate(records[:3]):  # Show first 3 records
                        record_id = record.get('id', 'Unknown ID')
                        record_kind = record.get('kind', 'Unknown Kind')
                        print(f"  {i+1}. {record_id} (Kind: {record_kind})")
                else:
                    print("No records found in response")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Response received but failed to parse JSON: {e}")
        else:
            print(f"‚ùå Failed to retrieve records. Status: {response.status_code}")
            try:
                print(f"Error response: {response.text}")
            except:
                print("Could not read response text")


    def _test_query_records_by_attributes(self, headers, partition, base_url):
        print("[Test] [query storage records by attributes] API tested: /api/storage/v2/query/records,  POST")
        
        # Build the URL for POST query endpoint
        url = f"{base_url}/api/storage/v2/query/records"
        
        # Create the JSON payload based on the curl command
        # Using the created record ID to query for specific records
        query_payload = {
            "records": [
                f"{partition}:dataset--File.Generic:{self.record_counter}"  # Query for the created record
            ],
            "attributes": [
                "id",
                "kind", 
                "acl",
                "legal",
                "data"
            ]
        }
        
        # Set required headers
        headers["Content-Type"] = "application/json"
        headers["data-partition-id"] = partition
        headers['accept'] = 'application/json'
        
        print(f"Querying records with payload: {query_payload}")
        
        response = self.client.post(url, json=query_payload, headers=headers)
        print(f"Query records status: {response.status_code}")
        
        if response.status_code == 200:
            try:
                response_data = response.json()
                records = response_data.get('records', [])
                record_count = len(records)
                print(f"‚úÖ Successfully queried {record_count} records")
                
                # Print details of retrieved records
                if records:
                    print(f"Retrieved record details:")
                    for i, record in enumerate(records):
                        record_id = record.get('id', 'Unknown ID')
                        record_kind = record.get('kind', 'Unknown Kind')
                        print(f"  {i+1}. ID: {record_id}")
                        print(f"     Kind: {record_kind}")
                        
                        # Show legal tags if available
                        legal = record.get('legal', {})
                        legal_tags = legal.get('legaltags', [])
                        if legal_tags:
                            print(f"     Legal Tags: {', '.join(legal_tags)}")
                else:
                    print("No records found in response")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Response received but failed to parse JSON: {e}")
                print(f"Raw response: {response.text}")
        else:
            print(f"‚ùå Failed to query records. Status: {response.status_code}")
            try:
                print(f"Response: {response.text}")
            except:
                print("Could not read response text")


# Additional test methods can be added here
# Each method should follow the pattern: def test_scenario_name(self, headers, partition, base_url):


