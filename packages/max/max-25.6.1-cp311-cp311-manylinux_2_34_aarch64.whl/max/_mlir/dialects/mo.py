
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "mo"

@_ods_cext.register_operation(_Dialect)
class IfOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.if"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, cond, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def thenRegion(self):
    return self.regions[0]

  @builtins.property
  def elseRegion(self):
    return self.regions[1]

def if_(results_, cond, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IfOp(results_=results_, cond=cond, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FromTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.shape.from_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shape_from_tensor(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return FromTensorOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ToTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.shape.to_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shape_to_tensor(result, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return ToTensorOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastToOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.static.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def static_broadcast_to(result, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastToOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.static.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def static_reshape(result, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return ReshapeOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def abs(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AbsOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def add(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AddOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddSingletonDimOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.add_singleton_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def add_singleton_dim(result, input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return AddSingletonDimOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.distributed.allgather"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, outChain, inputs, signalBuffers, inChain, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(signalBuffers))
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(outputs)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def signalBuffers(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def inChain(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 2)
    return self.operation.operands[start]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outChain(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def distributed_allgather(outputs, out_chain, inputs, signal_buffers, in_chain, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(AllGatherOp(outputs=outputs, outChain=out_chain, inputs=inputs, signalBuffers=signal_buffers, inChain=in_chain, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AllReduceSumOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.distributed.allreduce.sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, outChain, inputs, signalBuffers, inChain, device, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(signalBuffers))
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["device"] = (device if (
    isinstance(device, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('M_DeviceRefAttr')) else
      _ods_ir.AttrBuilder.get('M_DeviceRefAttr')(device, context=_ods_context))
    results = []
    results.append(output)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def signalBuffers(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def inChain(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 2)
    return self.operation.operands[start]

  @builtins.property
  def device(self):
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def outChain(self):
    return self.operation.results[1]

def distributed_allreduce_sum(output, out_chain, inputs, signal_buffers, in_chain, device, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AllReduceSumOp(output=output, outChain=out_chain, inputs=inputs, signalBuffers=signal_buffers, inChain=in_chain, device=device, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def and_(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AndOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArgMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.arg_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def arg_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ArgMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArgMinOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.arg_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def arg_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ArgMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArgNonzeroOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.arg_nonzero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def arg_nonzero(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ArgNonzeroOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssertOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond, message, *, inChain=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if inChain is not None: operands.append(inChain)
    operands.append(cond)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(message, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inChain(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[0]

  @builtins.property
  def cond(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def message(self):
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

  @builtins.property
  def chain(self):
    return self.operation.results[0]

def assert_(cond, message, *, in_chain=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AssertOp(cond=cond, message=message, inChain=in_chain, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtanhOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atanh(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtanhOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AvgPoolCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.avg_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self):
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def avg_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return AvgPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.avg_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self):
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def avg_pool(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return AvgPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BandPartOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.linalg.band_part"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, num_lower, num_upper, exclude, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(num_lower)
    operands.append(num_upper)
    operands.append(exclude)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def num_lower(self):
    return self.operation.operands[1]

  @builtins.property
  def num_upper(self):
    return self.operation.operands[2]

  @builtins.property
  def exclude(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def linalg_band_part(result, input, num_lower, num_upper, exclude, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return BandPartOp(result=result, input=input, num_lower=num_lower, num_upper=num_upper, exclude=exclude, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BatchMatmulOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.batch_matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, transpose_b=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose_b is not None: attributes["transpose_b"] = (transpose_b if (
        isinstance(transpose_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(transpose_b, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self):
    return self.operation.operands[0]

  @builtins.property
  def input_b(self):
    return self.operation.operands[1]

  @builtins.property
  def transpose_b(self):
    return self.operation.attributes["transpose_b"]

  @transpose_b.setter
  def transpose_b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose_b"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def batch_matmul(result, input_a, input_b, *, transpose_b=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return BatchMatmulOp(result=result, input_a=input_a, input_b=input_b, transpose_b=transpose_b, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BottomKOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.bottom_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def K(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def sorted(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def bottom_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return BottomKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BroadcastShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.broadcast_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self):
    return self.operation.results[0]

def broadcast_shape(shape, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastShapeOp(shape=shape, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastToOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def newShape(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def broadcast_to(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastToOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.buffer.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_create(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferCreateOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferTransferOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.buffer.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, dst, inChain, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(dst)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.operands[1]

  @builtins.property
  def inChain(self):
    return self.operation.operands[2]

  @builtins.property
  def outChain(self):
    return self.operation.results[0]

def buffer_transfer(src, dst, in_chain, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return BufferTransferOp(src=src, dst=dst, inChain=in_chain, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, symbol, *, prefix=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["symbol"] = (symbol if (
    isinstance(symbol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(symbol, context=_ods_context))
    if prefix is not None: attributes["prefix"] = (prefix if (
        isinstance(prefix, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(prefix, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def symbol(self):
    return self.operation.attributes["symbol"]

  @symbol.setter
  def symbol(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbol"] = value

  @builtins.property
  def prefix(self):
    return self.operation.attributes["prefix"]

  @prefix.setter
  def prefix(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["prefix"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(results_, operands_, symbol, *, prefix=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CallOp(results_=results_, operands_=operands_, symbol=symbol, prefix=prefix, outputParamDecls=output_param_decls, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cast(result, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return CastOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ceil(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return CeilOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChainCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.chain.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def chain_create(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ChainCreateOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatFromListOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.concat_from_list"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def concat_from_list(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConcatFromListOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, axis, inputs, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self):
    return self.operation.operands[0]

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def concat(result, axis, inputs, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConcatOp(result=result, axis=axis, inputs=inputs, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantExternalOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.constant.external"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, align, device, *, hasAlias=None, isPlaceholder=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["align"] = (align if (
    isinstance(align, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('UI64Attr')) else
      _ods_ir.AttrBuilder.get('UI64Attr')(align, context=_ods_context))
    attributes["device"] = (device if (
    isinstance(device, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('M_DeviceRefAttr')) else
      _ods_ir.AttrBuilder.get('M_DeviceRefAttr')(device, context=_ods_context))
    if hasAlias is not None: attributes["hasAlias"] = (hasAlias if (
        isinstance(hasAlias, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(hasAlias, context=_ods_context))
    if isPlaceholder is not None: attributes["isPlaceholder"] = (isPlaceholder if (
        isinstance(isPlaceholder, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isPlaceholder, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def align(self):
    return self.operation.attributes["align"]

  @align.setter
  def align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align"] = value

  @builtins.property
  def device(self):
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def hasAlias(self):
    return self.operation.attributes["hasAlias"]

  @hasAlias.setter
  def hasAlias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hasAlias"] = value

  @builtins.property
  def isPlaceholder(self):
    return self.operation.attributes["isPlaceholder"]

  @isPlaceholder.setter
  def isPlaceholder(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isPlaceholder"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_external(result, name, align, device, *, has_alias=None, is_placeholder=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantExternalOp(result=result, name=name, align=align, device=device, hasAlias=has_alias, isPlaceholder=is_placeholder, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant(result, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.constant.scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1168')) else
      _ods_ir.AttrBuilder.get('anonymous_1168')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def constant_scalar(result, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantScalarOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(num_groups)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def num_groups(self):
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self):
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self):
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def conv(result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConvOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, num_groups=num_groups, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.conv_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(output_paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def output_paddings(self):
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self):
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self):
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def conv_transpose(result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConvTransposeOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, output_paddings=output_paddings, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cos(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return CosOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CumSumOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.cumsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, exclusive, reverse, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exclusive"] = (exclusive if (
    isinstance(exclusive, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(exclusive, context=_ods_context))
    attributes["reverse"] = (reverse if (
    isinstance(reverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(reverse, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def exclusive(self):
    return self.operation.attributes["exclusive"]

  @exclusive.setter
  def exclusive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exclusive"] = value

  @builtins.property
  def reverse(self):
    return self.operation.attributes["reverse"]

  @reverse.setter
  def reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reverse"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cumsum(result, input, axis, exclusive, reverse, *, loc=None, ip=None) -> _ods_ir.Value:
  return CumSumOp(result=result, input=input, axis=axis, exclusive=exclusive, reverse=reverse, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CustomOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, symbol, *, device=None, parameters=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["symbol"] = (symbol if (
    isinstance(symbol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(symbol, context=_ods_context))
    if device is not None: attributes["device"] = (device if (
        isinstance(device, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('M_DeviceRefAttr')) else
          _ods_ir.AttrBuilder.get('M_DeviceRefAttr')(device, context=_ods_context))
    if parameters is not None: attributes["parameters"] = (parameters if (
        isinstance(parameters, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(parameters, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def symbol(self):
    return self.operation.attributes["symbol"]

  @symbol.setter
  def symbol(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbol"] = value

  @builtins.property
  def device(self):
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def parameters(self):
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def custom(results_, operands_, symbol, *, device=None, parameters=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CustomOp(results_=results_, operands_=operands_, symbol=symbol, device=device, parameters=parameters, outputParamDecls=output_param_decls, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DebugPrintOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.debug.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, inChain, value, *, label=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(value, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inChain(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def label(self):
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

  @builtins.property
  def outChain(self):
    return self.operation.results[0]

def debug_print(in_chain, value, *, label=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return DebugPrintOp(inChain=in_chain, value=value, label=label, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DebugTensorPrintOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.debug.tensor.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, inChain, input, *, label=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inChain)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inChain(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def label(self):
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

  @builtins.property
  def outChain(self):
    return self.operation.results[0]

def debug_tensor_print(in_chain, input, *, label=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return DebugTensorPrintOp(inChain=in_chain, input=input, label=label, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DebugTensorUnsafePrintOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.debug.tensor.unsafe.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def label(self):
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

def debug_tensor_unsafe_print(input, *, label=None, loc=None, ip=None) -> _ods_ir.Operation:
  return DebugTensorUnsafePrintOp(input=input, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def div(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return DivOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def equal(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.Value:
  return EqualOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ErfOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def erf(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ErfOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def exp(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ExpOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.fence"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def fence(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FenceOp(inputs=inputs, results=results, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def floor(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return FloorOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherNdOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.gather_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, batchDims, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["batchDims"] = (batchDims if (
    isinstance(batchDims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(batchDims, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def batchDims(self):
    return self.operation.attributes["batchDims"]

  @batchDims.setter
  def batchDims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batchDims"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gather_nd(result, input, indices, batch_dims, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return GatherNdOp(result=result, input=input, indices=indices, batchDims=batch_dims, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gather(result, input, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return GatherOp(result=result, input=input, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherSumOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.gather_sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gather_sum(result, input, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return GatherSumOp(result=result, input=input, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GeluOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.gelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gelu(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return GeluOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GraphOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.graph"

  _ODS_REGIONS = (1, True)

  def __init__(self, name, signature, functionType, inputParameters, resultParameters, counter, *, isSubgraph=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["signature"] = (signature if (
    isinstance(signature, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1117')) else
      _ods_ir.AttrBuilder.get('anonymous_1117')(signature, context=_ods_context))
    attributes["functionType"] = (functionType if (
    isinstance(functionType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1121')) else
      _ods_ir.AttrBuilder.get('anonymous_1121')(functionType, context=_ods_context))
    attributes["inputParameters"] = (inputParameters if (
    isinstance(inputParameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KGEN_ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('KGEN_ParamDeclArrayAttr')(inputParameters, context=_ods_context))
    attributes["resultParameters"] = (resultParameters if (
    isinstance(resultParameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KGEN_ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('KGEN_ParamDeclArrayAttr')(resultParameters, context=_ods_context))
    if bool(isSubgraph): attributes["isSubgraph"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def signature(self):
    return self.operation.attributes["signature"]

  @signature.setter
  def signature(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signature"] = value

  @builtins.property
  def functionType(self):
    return self.operation.attributes["functionType"]

  @functionType.setter
  def functionType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["functionType"] = value

  @builtins.property
  def inputParameters(self):
    return self.operation.attributes["inputParameters"]

  @inputParameters.setter
  def inputParameters(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputParameters"] = value

  @builtins.property
  def resultParameters(self):
    return self.operation.attributes["resultParameters"]

  @resultParameters.setter
  def resultParameters(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resultParameters"] = value

  @builtins.property
  def isSubgraph(self):
    return "isSubgraph" in self.operation.attributes

  @isSubgraph.setter
  def isSubgraph(self, value):
    if bool(value):
      self.operation.attributes["isSubgraph"] = _ods_ir.UnitAttr.get()
    elif "isSubgraph" in self.operation.attributes:
      del self.operation.attributes["isSubgraph"]

  @isSubgraph.deleter
  def isSubgraph(self):
    del self.operation.attributes["isSubgraph"]

  @builtins.property
  def body(self):
    return self.regions[0]

def graph(name, signature, function_type, input_parameters, result_parameters, counter, *, is_subgraph=None, loc=None, ip=None) -> _ods_ir.Operation:
  return GraphOp(name=name, signature=signature, functionType=function_type, inputParameters=input_parameters, resultParameters=result_parameters, counter=counter, isSubgraph=is_subgraph, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GreaterEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def greater_equal(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.Value:
  return GreaterEqualOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def greater(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.Value:
  return GreaterOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GuardOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.guard"

  _ODS_REGIONS = (0, True)

  def __init__(self, chain, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(chain)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def chain(self):
    return self.operation.operands[0]

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def guard(chain, inputs, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GuardOp(chain=chain, inputs=inputs, results=results, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class IndexToTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.index.to_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def index_to_tensor(result, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return IndexToTensorOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InvokeShapeFuncOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.invoke_shape_func"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, shapeFuncName, *, outputParamDecls=None, kgenParams=None, dataDeptTensors=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shapeFuncName"] = (shapeFuncName if (
    isinstance(shapeFuncName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(shapeFuncName, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    if kgenParams is not None: attributes["kgenParams"] = (kgenParams if (
        isinstance(kgenParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(kgenParams, context=_ods_context))
    if dataDeptTensors is not None: attributes["dataDeptTensors"] = (dataDeptTensors if (
        isinstance(dataDeptTensors, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(dataDeptTensors, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def shapeFuncName(self):
    return self.operation.attributes["shapeFuncName"]

  @shapeFuncName.setter
  def shapeFuncName(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shapeFuncName"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def kgenParams(self):
    if "kgenParams" not in self.operation.attributes:
      return None
    return self.operation.attributes["kgenParams"]

  @kgenParams.setter
  def kgenParams(self, value):
    if value is not None:
      self.operation.attributes["kgenParams"] = value
    elif "kgenParams" in self.operation.attributes:
      del self.operation.attributes["kgenParams"]

  @kgenParams.deleter
  def kgenParams(self):
    del self.operation.attributes["kgenParams"]

  @builtins.property
  def dataDeptTensors(self):
    if "dataDeptTensors" not in self.operation.attributes:
      return None
    return self.operation.attributes["dataDeptTensors"]

  @dataDeptTensors.setter
  def dataDeptTensors(self, value):
    if value is not None:
      self.operation.attributes["dataDeptTensors"] = value
    elif "dataDeptTensors" in self.operation.attributes:
      del self.operation.attributes["dataDeptTensors"]

  @dataDeptTensors.deleter
  def dataDeptTensors(self):
    del self.operation.attributes["dataDeptTensors"]

def invoke_shape_func(inputs, shape_func_name, *, output_param_decls=None, kgen_params=None, data_dept_tensors=None, loc=None, ip=None) -> _ods_ir.Operation:
  return InvokeShapeFuncOp(inputs=inputs, shapeFuncName=shape_func_name, outputParamDecls=output_param_decls, kgenParams=kgen_params, dataDeptTensors=data_dept_tensors, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class IsInfOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.is_inf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def is_inf(result, input_x, *, loc=None, ip=None) -> _ods_ir.Value:
  return IsInfOp(result=result, input_x=input_x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsNaNOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.is_nan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def is_nan(result, input_x, *, loc=None, ip=None) -> _ods_ir.Value:
  return IsNaNOp(result=result, input_x=input_x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.isqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def isqrt(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return IsqrtOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LayerNormOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.layer_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, gamma, beta, epsilon, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(gamma)
    operands.append(beta)
    operands.append(epsilon)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def gamma(self):
    return self.operation.operands[1]

  @builtins.property
  def beta(self):
    return self.operation.operands[2]

  @builtins.property
  def epsilon(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def layer_norm(result, input, gamma, beta, epsilon, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return LayerNormOp(result=result, input=input, gamma=gamma, beta=beta, epsilon=epsilon, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LayoutTransformOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.layout.transform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, kgenParams=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if kgenParams is not None: attributes["kgenParams"] = (kgenParams if (
        isinstance(kgenParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(kgenParams, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kgenParams(self):
    if "kgenParams" not in self.operation.attributes:
      return None
    return self.operation.attributes["kgenParams"]

  @kgenParams.setter
  def kgenParams(self, value):
    if value is not None:
      self.operation.attributes["kgenParams"] = value
    elif "kgenParams" in self.operation.attributes:
      del self.operation.attributes["kgenParams"]

  @kgenParams.deleter
  def kgenParams(self):
    del self.operation.attributes["kgenParams"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def layout_transform(result, input, *, kgen_params=None, loc=None, ip=None) -> _ods_ir.Value:
  return LayoutTransformOp(result=result, input=input, kgenParams=kgen_params, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListAppendOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.list.append"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, element, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(element)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def element(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_append(result, input, element, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListAppendOp(result=result, input=input, element=element, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.list.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_concat(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListConcatOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.list.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_create(result, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListCreateOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.list.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_get(result, input, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListGetOp(result=result, input=input, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListInsertOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.list.insert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, element, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(element)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def element(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_insert(result, input, element, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListInsertOp(result=result, input=input, element=element, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.list.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, start, end, step, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(end)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.operands[1]

  @builtins.property
  def end(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_slice(result, input, start, end, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListSliceOp(result=result, input=input, start=start, end=end, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log1pOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.log1p"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log1p(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return Log1pOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def log(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return LogOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogSoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.logsoftmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def logsoftmax(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return LogSoftmaxOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatmulAllReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.distributed.matmul_allreduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, outChain, inputs, weights, signalBuffers, inChain, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(weights))
    operands.extend(_get_op_results_or_values(signalBuffers))
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(outputs)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def weights(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def signalBuffers(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 2)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def inChain(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 3)
    return self.operation.operands[start]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outChain(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def distributed_matmul_allreduce(outputs, out_chain, inputs, weights, signal_buffers, in_chain, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(MatmulAllReduceOp(outputs=outputs, outChain=out_chain, inputs=inputs, weights=weights, signalBuffers=signal_buffers, inChain=in_chain, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MatmulOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, transpose_b=None, packed_b=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose_b is not None: attributes["transpose_b"] = (transpose_b if (
        isinstance(transpose_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(transpose_b, context=_ods_context))
    if packed_b is not None: attributes["packed_b"] = (packed_b if (
        isinstance(packed_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(packed_b, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self):
    return self.operation.operands[0]

  @builtins.property
  def input_b(self):
    return self.operation.operands[1]

  @builtins.property
  def transpose_b(self):
    return self.operation.attributes["transpose_b"]

  @transpose_b.setter
  def transpose_b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose_b"] = value

  @builtins.property
  def packed_b(self):
    return self.operation.attributes["packed_b"]

  @packed_b.setter
  def packed_b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["packed_b"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def matmul(result, input_a, input_b, *, transpose_b=None, packed_b=None, loc=None, ip=None) -> _ods_ir.Value:
  return MatmulOp(result=result, input_a=input_a, input_b=input_b, transpose_b=transpose_b, packed_b=packed_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def max(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MaxOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxPoolCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.max_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def max_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MaxPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.max_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def max_pool(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MaxPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MeanOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.mean"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mean(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MeanOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MergeDimOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.merge_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def merge_dim(result, input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return MergeDimOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def min(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MinOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ModOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mod(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ModOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mul(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MulOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MutableLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.mutable.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, outTensor, outChain, inBuffer, inChain, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(outTensor)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self):
    return self.operation.operands[0]

  @builtins.property
  def inChain(self):
    return self.operation.operands[1]

  @builtins.property
  def outTensor(self):
    return self.operation.results[0]

  @builtins.property
  def outChain(self):
    return self.operation.results[1]

def mutable_load(out_tensor, out_chain, in_buffer, in_chain, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MutableLoadOp(outTensor=out_tensor, outChain=out_chain, inBuffer=in_buffer, inChain=in_chain, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MutableStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.mutable.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, inTensor, inChain, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inTensor)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self):
    return self.operation.operands[0]

  @builtins.property
  def inTensor(self):
    return self.operation.operands[1]

  @builtins.property
  def inChain(self):
    return self.operation.operands[2]

  @builtins.property
  def outChain(self):
    return self.operation.results[0]

def mutable_store(in_buffer, in_tensor, in_chain, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MutableStoreOp(inBuffer=in_buffer, inTensor=in_tensor, inChain=in_chain, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MutableStoreSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.mutable.store.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, slice, start, stop, step, inChain, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(slice)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self):
    return self.operation.operands[0]

  @builtins.property
  def slice(self):
    return self.operation.operands[1]

  @builtins.property
  def start(self):
    return self.operation.operands[2]

  @builtins.property
  def stop(self):
    return self.operation.operands[3]

  @builtins.property
  def step(self):
    return self.operation.operands[4]

  @builtins.property
  def inChain(self):
    return self.operation.operands[5]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outChain(self):
    return self.operation.results[0]

def mutable_store_slice(in_buffer, slice, start, stop, step, in_chain, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MutableStoreSliceOp(inBuffer=in_buffer, slice=slice, start=start, stop=stop, step=step, inChain=in_chain, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NegativeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.negative"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def negative(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return NegativeOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NonMaximumSuppressionOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.non_maximum_suppression"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, boxes, scores, maxOutputBoxesPerClass, iouThreshold, scoreThreshold, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(boxes)
    operands.append(scores)
    operands.append(maxOutputBoxesPerClass)
    operands.append(iouThreshold)
    operands.append(scoreThreshold)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def boxes(self):
    return self.operation.operands[0]

  @builtins.property
  def scores(self):
    return self.operation.operands[1]

  @builtins.property
  def maxOutputBoxesPerClass(self):
    return self.operation.operands[2]

  @builtins.property
  def iouThreshold(self):
    return self.operation.operands[3]

  @builtins.property
  def scoreThreshold(self):
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def non_maximum_suppression(output, boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return NonMaximumSuppressionOp(output=output, boxes=boxes, scores=scores, maxOutputBoxesPerClass=max_output_boxes_per_class, iouThreshold=iou_threshold, scoreThreshold=score_threshold, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def not_equal(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.Value:
  return NotEqualOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def not_(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return NotOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def or_(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return OrOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OutputOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, parameters=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    if parameters is not None: attributes["parameters"] = (parameters if (
        isinstance(parameters, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('KGEN_ParameterExprArrayAttr')) else
          _ods_ir.AttrBuilder.get('KGEN_ParameterExprArrayAttr')(parameters, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def parameters(self):
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

def output(operands_, *, parameters=None, loc=None, ip=None) -> _ods_ir.Operation:
  return OutputOp(operands_=operands_, parameters=parameters, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PadConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.pad.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, constant, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    operands.append(constant)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddings(self):
    return self.operation.operands[1]

  @builtins.property
  def constant(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def pad_constant(result, input, paddings, constant, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return PadConstantOp(result=result, input=input, paddings=paddings, constant=constant, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PadReflectOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.pad.reflect"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddings(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def pad_reflect(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return PadReflectOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PadRepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.pad.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddings(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def pad_repeat(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return PadRepeatOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def pow(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.Value:
  return PowOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RandomNormalOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.random.normal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, mean, variance, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(mean)
    operands.append(variance)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self):
    return self.operation.operands[0]

  @builtins.property
  def mean(self):
    return self.operation.operands[1]

  @builtins.property
  def variance(self):
    return self.operation.operands[2]

  @builtins.property
  def seed(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def random_normal(result, shape, mean, variance, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return RandomNormalOp(result=result, shape=shape, mean=mean, variance=variance, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RandomUniformOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.random.uniform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, lowerBound, upperBound, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(lowerBound)
    operands.append(upperBound)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self):
    return self.operation.operands[0]

  @builtins.property
  def lowerBound(self):
    return self.operation.operands[1]

  @builtins.property
  def upperBound(self):
    return self.operation.operands[2]

  @builtins.property
  def seed(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def random_uniform(result, shape, lower_bound, upper_bound, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return RandomUniformOp(result=result, shape=shape, lowerBound=lower_bound, upperBound=upper_bound, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RangeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.range"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, limit, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(start)
    operands.append(limit)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def limit(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def range(result, start, limit, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return RangeOp(result=result, start=start, limit=limit, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RebindOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.rebind"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def rebind(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return RebindOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceAddOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.reduce.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reduce_add(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReduceAddOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.reduce.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reduce_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReduceMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMinOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.reduce.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reduce_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReduceMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMulOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.reduce.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reduce_mul(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReduceMulOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReluOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def relu(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReluOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def newShape(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reshape(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReshapeOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResizeBicubicOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.resize.bicubic"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resize_bicubic(result, input, size, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ResizeBicubicOp(result=result, input=input, size=size, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResizeLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.resize.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, antialias, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    attributes["antialias"] = (antialias if (
    isinstance(antialias, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(antialias, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self):
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def antialias(self):
    return self.operation.attributes["antialias"]

  @antialias.setter
  def antialias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["antialias"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resize_linear(result, input, size, coordinate_transform_mode, antialias, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ResizeLinearOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, antialias=antialias, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResizeNearestOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.resize.nearest"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, *, round_mode=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        isinstance(round_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(round_mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self):
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resize_nearest(result, input, size, coordinate_transform_mode, *, round_mode=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ResizeNearestOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, round_mode=round_mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoiAlignOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.roi_align"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(rois)
    operands.append(output_height)
    operands.append(output_width)
    operands.append(spatial_scale)
    operands.append(sampling_ratio)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["aligned"] = (aligned if (
    isinstance(aligned, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Builtin_StringAttr')) else
      _ods_ir.AttrBuilder.get('Builtin_StringAttr')(mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def rois(self):
    return self.operation.operands[1]

  @builtins.property
  def output_height(self):
    return self.operation.operands[2]

  @builtins.property
  def output_width(self):
    return self.operation.operands[3]

  @builtins.property
  def spatial_scale(self):
    return self.operation.operands[4]

  @builtins.property
  def sampling_ratio(self):
    return self.operation.operands[5]

  @builtins.property
  def aligned(self):
    return self.operation.attributes["aligned"]

  @aligned.setter
  def aligned(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aligned"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def roi_align(result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return RoiAlignOp(result=result, input=input, rois=rois, output_height=output_height, output_width=output_width, spatial_scale=spatial_scale, sampling_ratio=sampling_ratio, aligned=aligned, mode=mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def round(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return RoundOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterAddOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_add(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterAddOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_max(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterMaxOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterMinOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_min(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterMinOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterMulOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_mul(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterMulOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdAddOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter_nd.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_nd_add(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterNdAddOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter_nd.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_nd_max(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterNdMaxOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdMinOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter_nd.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_nd_min(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterNdMinOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdMulOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter_nd.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_nd_mul(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterNdMulOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter_nd(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterNdOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def scatter(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ScatterOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, cond, x, y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(x)
    operands.append(y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def x(self):
    return self.operation.operands[1]

  @builtins.property
  def y(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def select(result, cond, x, y, *, loc=None, ip=None) -> _ods_ir.Value:
  return SelectOp(result=result, cond=cond, x=x, y=y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShapeOfOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.shape_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self):
    return self.operation.results[0]

def shape_of(shape, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ShapeOfOp(shape=shape, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sin(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return SinOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceDimOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.slice_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, start, stop, step, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.operands[1]

  @builtins.property
  def stop(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def slice_dim(result, input, axis, start, stop, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return SliceDimOp(result=result, input=input, axis=axis, start=start, stop=stop, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceDimOuterOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.slice_dim_outer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, start, stop, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(stop)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.operands[1]

  @builtins.property
  def stop(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def slice_dim_outer(result, input, start, stop, *, loc=None, ip=None) -> _ods_ir.Value:
  return SliceDimOuterOp(result=result, input=input, start=start, stop=stop, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, start, stop, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.operands[1]

  @builtins.property
  def stop(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def slice(result, input, start, stop, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return SliceOp(result=result, input=input, start=start, stop=stop, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def softmax(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return SoftmaxOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitDimOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.split_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def split_dim(result, input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return SplitDimOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, input, splitSizes, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(splitSizes)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def splitSizes(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def split(results_, input, split_sizes, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SplitOp(results_=results_, input=input, splitSizes=split_sizes, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sqrt(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return SqrtOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SqueezeShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.squeeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, remove_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(remove_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self):
    return self.operation.operands[0]

  @builtins.property
  def remove_indices(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def squeeze_shape(result, input_shape, remove_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return SqueezeShapeOp(result=result, input_shape=input_shape, remove_indices=remove_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sub(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return SubOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tanh(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return TanhOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, repeats, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(repeats)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def repeats(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tile(result, input, repeats, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return TileOp(result=result, input=input, repeats=repeats, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TopKOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.top_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def K(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def sorted(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def top_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return TopKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TransferOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, outChain, input, inChain, *, alwaysElideSameDeviceCopy=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if alwaysElideSameDeviceCopy is not None: attributes["alwaysElideSameDeviceCopy"] = (alwaysElideSameDeviceCopy if (
        isinstance(alwaysElideSameDeviceCopy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(alwaysElideSameDeviceCopy, context=_ods_context))
    results = []
    results.append(result)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def inChain(self):
    return self.operation.operands[1]

  @builtins.property
  def alwaysElideSameDeviceCopy(self):
    return self.operation.attributes["alwaysElideSameDeviceCopy"]

  @alwaysElideSameDeviceCopy.setter
  def alwaysElideSameDeviceCopy(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alwaysElideSameDeviceCopy"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def outChain(self):
    return self.operation.results[1]

def transfer(result, out_chain, input, in_chain, *, always_elide_same_device_copy=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return TransferOp(result=result, outChain=out_chain, input=input, inChain=in_chain, alwaysElideSameDeviceCopy=always_elide_same_device_copy, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, perm, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(perm)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def perm(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def transpose(result, input, perm, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return TransposeOp(result=result, input=input, perm=perm, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.trunc"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def trunc(input, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return TruncOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnsqueezeShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.unsqueeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, padding_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(padding_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self):
    return self.operation.operands[0]

  @builtins.property
  def padding_indices(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def unsqueeze_shape(result, input_shape, padding_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return UnsqueezeShapeOp(result=result, input_shape=input_shape, padding_indices=padding_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WhileConditionOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.while.condition"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def args(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

def while_condition(condition, args, *, loc=None, ip=None) -> _ods_ir.Operation:
  return WhileConditionOp(condition=condition, args=args, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class XorOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def xor(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return XorOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WhileOp(_ods_ir.OpView):
  OPERATION_NAME = "mo.while"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def condRegion(self):
    return self.regions[0]

  @builtins.property
  def bodyRegion(self):
    return self.regions[1]

def while_(results_, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WhileOp(results_=results_, inputs=inputs, loc=loc, ip=ip))
