
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "rmo"

@_ods_cext.register_operation(_Dialect)
class MOArgMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.arg_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_arg_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOArgMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOArgMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.arg_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_arg_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOArgMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.reduce.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_reduce_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOReduceMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.reduce.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_reduce_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOReduceMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def add(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AddOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def and_(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AndOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.avg_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter_shape, strides, dilations, paddings, ceil_mode, count_boundary, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["filter_shape"] = (filter_shape if (
    isinstance(filter_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(filter_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["ceil_mode"] = (ceil_mode if (
    isinstance(ceil_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.attributes["filter_shape"]

  @filter_shape.setter
  def filter_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self):
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def ceil_mode(self):
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceil_mode"] = value

  @builtins.property
  def count_boundary(self):
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def avg_pool(input, filter_shape, strides, dilations, paddings, ceil_mode, count_boundary, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return AvgPoolOp(input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, ceil_mode=ceil_mode, count_boundary=count_boundary, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.broadcast_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, shapeLike, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(shapeLike)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shapeLike(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def broadcast_like(result, input, shape_like, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastLikeOp(result=result, input=input, shapeLike=shape_like, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastToOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, newShape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["newShape"] = (newShape if (
    isinstance(newShape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(newShape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def newShape(self):
    return self.operation.attributes["newShape"]

  @newShape.setter
  def newShape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["newShape"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def broadcast_to(input, new_shape, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return BroadcastToOp(input=input, newShape=new_shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, axis, *, out_dim=None, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Builtin_IntegerAttr')) else
      _ods_ir.AttrBuilder.get('Builtin_IntegerAttr')(axis, context=_ods_context))
    if out_dim is not None: attributes["out_dim"] = (out_dim if (
        isinstance(out_dim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_1069')) else
          _ods_ir.AttrBuilder.get('anonymous_1069')(out_dim, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def out_dim(self):
    if "out_dim" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_dim"]

  @out_dim.setter
  def out_dim(self, value):
    if value is not None:
      self.operation.attributes["out_dim"] = value
    elif "out_dim" in self.operation.attributes:
      del self.operation.attributes["out_dim"]

  @out_dim.deleter
  def out_dim(self):
    del self.operation.attributes["out_dim"]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def concat(inputs, axis, *, out_dim=None, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConcatOp(inputs=inputs, axis=axis, out_dim=out_dim, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter, strides, dilations, paddings, num_groups, *, input_layout=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["num_groups"] = (num_groups if (
    isinstance(num_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI64Attr')) else
      _ods_ir.AttrBuilder.get('SI64Attr')(num_groups, context=_ods_context))
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self):
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def num_groups(self):
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def input_layout(self):
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def conv(input, filter, strides, dilations, paddings, num_groups, *, input_layout=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConvOp(input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, num_groups=num_groups, input_layout=input_layout, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.conv_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter, strides, dilations, paddings, output_paddings, *, input_layout=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["output_paddings"] = (output_paddings if (
    isinstance(output_paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(output_paddings, context=_ods_context))
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self):
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def output_paddings(self):
    return self.operation.attributes["output_paddings"]

  @output_paddings.setter
  def output_paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_paddings"] = value

  @builtins.property
  def input_layout(self):
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def conv_transpose(input, filter, strides, dilations, paddings, output_paddings, *, input_layout=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ConvTransposeOp(input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, output_paddings=output_paddings, input_layout=input_layout, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def div(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return DivOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def equal(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return EqualOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def greater_equal(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return GreaterEqualOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def greater(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return GreaterOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOATanhOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_atanh(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOATanhOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAbsOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_abs(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOAbsOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAddOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_add(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOAddOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAndOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_and(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOAndOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOArgNonzeroOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.arg_nonzero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_arg_nonzero(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOArgNonzeroOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAvgPoolCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.avg_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self):
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_avg_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOAvgPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.avg_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self):
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_avg_pool(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOAvgPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBandPartOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.linalg.band_part"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, num_lower, num_upper, exclude, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(num_lower)
    operands.append(num_upper)
    operands.append(exclude)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def num_lower(self):
    return self.operation.operands[1]

  @builtins.property
  def num_upper(self):
    return self.operation.operands[2]

  @builtins.property
  def exclude(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_linalg_band_part(result, input, num_lower, num_upper, exclude, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOBandPartOp(result=result, input=input, num_lower=num_lower, num_upper=num_upper, exclude=exclude, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBatchMatmulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.batch_matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, transpose_b=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose_b is not None: attributes["transpose_b"] = (transpose_b if (
        isinstance(transpose_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(transpose_b, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self):
    return self.operation.operands[0]

  @builtins.property
  def input_b(self):
    return self.operation.operands[1]

  @builtins.property
  def transpose_b(self):
    if "transpose_b" not in self.operation.attributes:
      return None
    return self.operation.attributes["transpose_b"]

  @transpose_b.setter
  def transpose_b(self, value):
    if value is not None:
      self.operation.attributes["transpose_b"] = value
    elif "transpose_b" in self.operation.attributes:
      del self.operation.attributes["transpose_b"]

  @transpose_b.deleter
  def transpose_b(self):
    del self.operation.attributes["transpose_b"]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_batch_matmul(result, input_a, input_b, *, transpose_b=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOBatchMatmulOp(result=result, input_a=input_a, input_b=input_b, transpose_b=transpose_b, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBottomKOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.bottom_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def K(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def sorted(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def mo_bottom_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MOBottomKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOBroadcastShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.broadcast_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self):
    return self.operation.results[0]

def mo_broadcast_shape(shape, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOBroadcastShapeOp(shape=shape, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBroadcastToOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def newShape(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_broadcast_to(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOBroadcastToOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCastOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_cast(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOCastOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_ceil(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOCeilOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, axis, inputs, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self):
    return self.operation.operands[0]

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_concat(result, axis, inputs, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOConcatOp(result=result, axis=axis, inputs=inputs, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOConvOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(num_groups)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def num_groups(self):
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self):
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self):
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_conv(result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOConvOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, num_groups=num_groups, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOConvTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.conv_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(output_paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def output_paddings(self):
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self):
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self):
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_conv_transpose(result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOConvTransposeOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, output_paddings=output_paddings, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCosOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_cos(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOCosOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCumSumOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.cumsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, exclusive, reverse, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exclusive"] = (exclusive if (
    isinstance(exclusive, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(exclusive, context=_ods_context))
    attributes["reverse"] = (reverse if (
    isinstance(reverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(reverse, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def exclusive(self):
    return self.operation.attributes["exclusive"]

  @exclusive.setter
  def exclusive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exclusive"] = value

  @builtins.property
  def reverse(self):
    return self.operation.attributes["reverse"]

  @reverse.setter
  def reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reverse"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_cumsum(result, input, axis, exclusive, reverse, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOCumSumOp(result=result, input=input, axis=axis, exclusive=exclusive, reverse=reverse, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MODivOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_div(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MODivOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOErfOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_erf(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOErfOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOExpOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_exp(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOExpOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOFloorOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_floor(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOFloorOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGatherNdOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.gather_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, batchDims, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["batchDims"] = (batchDims if (
    isinstance(batchDims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(batchDims, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def batchDims(self):
    return self.operation.attributes["batchDims"]

  @batchDims.setter
  def batchDims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batchDims"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_gather_nd(result, input, indices, batch_dims, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOGatherNdOp(result=result, input=input, indices=indices, batchDims=batch_dims, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_gather(result, input, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOGatherOp(result=result, input=input, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGeluOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.gelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_gelu(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOGeluOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGreaterEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_greater_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOGreaterEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGreaterOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_greater(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOGreaterOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOIsInfOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.is_inf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_is_inf(result, input_x, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOIsInfOp(result=result, input_x=input_x, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOIsNaNOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.is_nan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_is_nan(result, input_x, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOIsNaNOp(result=result, input_x=input_x, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOIsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.isqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_isqrt(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOIsqrtOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOLog1pOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.log1p"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_log1p(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOLog1pOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOLogOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_log(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOLogOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOLogSoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.logsoftmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_logsoftmax(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOLogSoftmaxOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMatmulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self):
    return self.operation.operands[0]

  @builtins.property
  def input_b(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_matmul(result, input_a, input_b, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMatmulOp(result=result, input_a=input_a, input_b=input_b, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_max(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMaxOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMaxPoolCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.max_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_max_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMaxPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMaxPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.max_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def strides(self):
    return self.operation.operands[2]

  @builtins.property
  def dilations(self):
    return self.operation.operands[3]

  @builtins.property
  def paddings(self):
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_max_pool(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMaxPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMeanOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mean"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_mean(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMeanOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_min(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMinOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOModOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_mod(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOModOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_mul(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMulOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMutableLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mutable.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, outTensor, outChain, inBuffer, inChain, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(outTensor)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self):
    return self.operation.operands[0]

  @builtins.property
  def inChain(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outTensor(self):
    return self.operation.results[0]

  @builtins.property
  def outChain(self):
    return self.operation.results[1]

def mo_mutable_load(out_tensor, out_chain, in_buffer, in_chain, *, output_param_decls=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MOMutableLoadOp(outTensor=out_tensor, outChain=out_chain, inBuffer=in_buffer, inChain=in_chain, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOMutableStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mutable.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, inTensor, inChain, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inTensor)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self):
    return self.operation.operands[0]

  @builtins.property
  def inTensor(self):
    return self.operation.operands[1]

  @builtins.property
  def inChain(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outChain(self):
    return self.operation.results[0]

def mo_mutable_store(in_buffer, in_tensor, in_chain, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMutableStoreOp(inBuffer=in_buffer, inTensor=in_tensor, inChain=in_chain, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMutableStoreSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mutable.store.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, slice, start, stop, step, inChain, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(slice)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self):
    return self.operation.operands[0]

  @builtins.property
  def slice(self):
    return self.operation.operands[1]

  @builtins.property
  def start(self):
    return self.operation.operands[2]

  @builtins.property
  def stop(self):
    return self.operation.operands[3]

  @builtins.property
  def step(self):
    return self.operation.operands[4]

  @builtins.property
  def inChain(self):
    return self.operation.operands[5]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outChain(self):
    return self.operation.results[0]

def mo_mutable_store_slice(in_buffer, slice, start, stop, step, in_chain, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOMutableStoreSliceOp(inBuffer=in_buffer, slice=slice, start=start, stop=stop, step=step, inChain=in_chain, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONegativeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.negative"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_negative(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MONegativeOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONonMaximumSuppressionOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.non_maximum_suppression"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, boxes, scores, maxOutputBoxesPerClass, iouThreshold, scoreThreshold, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(boxes)
    operands.append(scores)
    operands.append(maxOutputBoxesPerClass)
    operands.append(iouThreshold)
    operands.append(scoreThreshold)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def boxes(self):
    return self.operation.operands[0]

  @builtins.property
  def scores(self):
    return self.operation.operands[1]

  @builtins.property
  def maxOutputBoxesPerClass(self):
    return self.operation.operands[2]

  @builtins.property
  def iouThreshold(self):
    return self.operation.operands[3]

  @builtins.property
  def scoreThreshold(self):
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def mo_non_maximum_suppression(output, boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MONonMaximumSuppressionOp(output=output, boxes=boxes, scores=scores, maxOutputBoxesPerClass=max_output_boxes_per_class, iouThreshold=iou_threshold, scoreThreshold=score_threshold, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_not_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MONotEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONotOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_not(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MONotOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOOrOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_or(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOOrOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPadConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.pad.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, constant, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    operands.append(constant)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddings(self):
    return self.operation.operands[1]

  @builtins.property
  def constant(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_pad_constant(result, input, paddings, constant, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOPadConstantOp(result=result, input=input, paddings=paddings, constant=constant, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPadReflectOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.pad.reflect"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddings(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_pad_reflect(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOPadReflectOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPadRepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.pad.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddings(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_pad_repeat(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOPadRepeatOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPowOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_pow(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOPowOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORandomNormalOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.random.normal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, mean, variance, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(mean)
    operands.append(variance)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self):
    return self.operation.operands[0]

  @builtins.property
  def mean(self):
    return self.operation.operands[1]

  @builtins.property
  def variance(self):
    return self.operation.operands[2]

  @builtins.property
  def seed(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_random_normal(result, shape, mean, variance, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MORandomNormalOp(result=result, shape=shape, mean=mean, variance=variance, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORandomUniformOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.random.uniform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, lowerBound, upperBound, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(lowerBound)
    operands.append(upperBound)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self):
    return self.operation.operands[0]

  @builtins.property
  def lowerBound(self):
    return self.operation.operands[1]

  @builtins.property
  def upperBound(self):
    return self.operation.operands[2]

  @builtins.property
  def seed(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_random_uniform(result, shape, lower_bound, upper_bound, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MORandomUniformOp(result=result, shape=shape, lowerBound=lower_bound, upperBound=upper_bound, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORangeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.range"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, limit, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(start)
    operands.append(limit)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def limit(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_range(result, start, limit, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MORangeOp(result=result, start=start, limit=limit, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceAddOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.reduce.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_reduce_add(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOReduceAddOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceMulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.reduce.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_reduce_mul(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOReduceMulOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReluOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_relu(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOReluOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def newShape(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_reshape(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOReshapeOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOResizeBicubicOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.resize.bicubic"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_resize_bicubic(result, input, size, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOResizeBicubicOp(result=result, input=input, size=size, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOResizeLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.resize.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, antialias, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    attributes["antialias"] = (antialias if (
    isinstance(antialias, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(antialias, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self):
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def antialias(self):
    return self.operation.attributes["antialias"]

  @antialias.setter
  def antialias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["antialias"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_resize_linear(result, input, size, coordinate_transform_mode, antialias, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOResizeLinearOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, antialias=antialias, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOResizeNearestOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.resize.nearest"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, *, round_mode=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        isinstance(round_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(round_mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self):
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_resize_nearest(result, input, size, coordinate_transform_mode, *, round_mode=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOResizeNearestOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, round_mode=round_mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORoiAlignOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.roi_align"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(rois)
    operands.append(output_height)
    operands.append(output_width)
    operands.append(spatial_scale)
    operands.append(sampling_ratio)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["aligned"] = (aligned if (
    isinstance(aligned, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Builtin_StringAttr')) else
      _ods_ir.AttrBuilder.get('Builtin_StringAttr')(mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def rois(self):
    return self.operation.operands[1]

  @builtins.property
  def output_height(self):
    return self.operation.operands[2]

  @builtins.property
  def output_width(self):
    return self.operation.operands[3]

  @builtins.property
  def spatial_scale(self):
    return self.operation.operands[4]

  @builtins.property
  def sampling_ratio(self):
    return self.operation.operands[5]

  @builtins.property
  def aligned(self):
    return self.operation.attributes["aligned"]

  @aligned.setter
  def aligned(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aligned"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_roi_align(result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MORoiAlignOp(result=result, input=input, rois=rois, output_height=output_height, output_width=output_width, spatial_scale=spatial_scale, sampling_ratio=sampling_ratio, aligned=aligned, mode=mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORoundOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_round(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MORoundOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterAddOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_add(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterAddOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_max(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterMaxOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_min(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterMinOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterMulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_mul(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterMulOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdAddOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter_nd.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_nd_add(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterNdAddOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter_nd.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_nd_max(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterNdMaxOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter_nd.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_nd_min(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterNdMinOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdMulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter_nd.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_nd_mul(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterNdMulOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter_nd(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterNdOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def updates(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_scatter(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOScatterOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSelectOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, cond, x, y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(x)
    operands.append(y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def x(self):
    return self.operation.operands[1]

  @builtins.property
  def y(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_select(result, cond, x, y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOSelectOp(result=result, cond=cond, x=x, y=y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOShapeOfOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.shape_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self):
    return self.operation.results[0]

def mo_shape_of(shape, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOShapeOfOp(shape=shape, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_sin(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOSinOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, start, stop, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.operands[1]

  @builtins.property
  def stop(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_slice(result, input, start, stop, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOSliceOp(result=result, input=input, start=start, stop=stop, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_softmax(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOSoftmaxOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSplitOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, input, splitSizes, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(splitSizes)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def splitSizes(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def mo_split(results_, input, split_sizes, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MOSplitOp(results_=results_, input=input, splitSizes=split_sizes, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MOSqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_sqrt(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOSqrtOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSqueezeShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.squeeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, remove_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(remove_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self):
    return self.operation.operands[0]

  @builtins.property
  def remove_indices(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_squeeze_shape(result, input_shape, remove_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOSqueezeShapeOp(result=result, input_shape=input_shape, remove_indices=remove_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSubOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_sub(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOSubOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTanhOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_tanh(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOTanhOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTileOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, repeats, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(repeats)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def repeats(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_tile(result, input, repeats, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOTileOp(result=result, input=input, repeats=repeats, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTopKOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.top_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def K(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.operands[2]

  @builtins.property
  def sorted(self):
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def mo_top_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MOTopKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOTransferOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, outChain, input, inChain, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def inChain(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def outChain(self):
    return self.operation.results[1]

def mo_transfer(result, out_chain, input, in_chain, *, output_param_decls=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MOTransferOp(result=result, outChain=out_chain, input=input, inChain=in_chain, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, perm, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(perm)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def perm(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_transpose(result, input, perm, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOTransposeOp(result=result, input=input, perm=perm, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTruncOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.trunc"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_trunc(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOTruncOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOUnsqueezeShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.unsqueeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, padding_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(padding_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self):
    return self.operation.operands[0]

  @builtins.property
  def padding_indices(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_unsqueeze_shape(result, input_shape, padding_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOUnsqueezeShapeOp(result=result, input_shape=input_shape, padding_indices=padding_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOXorOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mo_xor(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return MOXorOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatmulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def matmul(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MatmulOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def max(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MaxOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.max_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter_shape, strides, dilations, paddings, ceil_mode, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["filter_shape"] = (filter_shape if (
    isinstance(filter_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(filter_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["ceil_mode"] = (ceil_mode if (
    isinstance(ceil_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self):
    return self.operation.attributes["filter_shape"]

  @filter_shape.setter
  def filter_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self):
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def ceil_mode(self):
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceil_mode"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def max_pool(input, filter_shape, strides, dilations, paddings, ceil_mode, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MaxPoolOp(input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, ceil_mode=ceil_mode, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def min(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MinOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ModOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mod(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ModOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mul(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return MulOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def not_equal(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return NotEqualOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def or_(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return OrOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def pow(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return PowOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RebindTensorShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.rebind_tensor_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, outputParamDecls=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def message(self):
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rebind_tensor_shape(output, input, *, output_param_decls=None, message=None, loc=None, ip=None) -> _ods_ir.Value:
  return RebindTensorShapeOp(output=output, input=input, outputParamDecls=output_param_decls, message=message, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, newShape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["newShape"] = (newShape if (
    isinstance(newShape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(newShape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def newShape(self):
    return self.operation.attributes["newShape"]

  @newShape.setter
  def newShape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["newShape"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def reshape(input, new_shape, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ReshapeOp(input=input, newShape=new_shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def input_x(self):
    return self.operation.operands[1]

  @builtins.property
  def input_y(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def select(cond, input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return SelectOp(cond=cond, input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShapeToTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.shape_to_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    isinstance(shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(shape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shape_to_tensor(shape, *, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return ShapeToTensorOp(shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sigmoid(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return SigmoidOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, starts, stops, steps, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["starts"] = (starts if (
    isinstance(starts, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(starts, context=_ods_context))
    attributes["stops"] = (stops if (
    isinstance(stops, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(stops, context=_ods_context))
    attributes["steps"] = (steps if (
    isinstance(steps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(steps, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def starts(self):
    return self.operation.attributes["starts"]

  @starts.setter
  def starts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["starts"] = value

  @builtins.property
  def stops(self):
    return self.operation.attributes["stops"]

  @stops.setter
  def stops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stops"] = value

  @builtins.property
  def steps(self):
    return self.operation.attributes["steps"]

  @steps.setter
  def steps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["steps"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def slice(input, starts, stops, steps, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return SliceOp(input=input, starts=starts, stops=stops, steps=steps, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def sub(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return SubOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyAddOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_add(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyAddOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyDivOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_div(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyDivOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyGreaterEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_greater_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyGreaterEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyGreaterOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_greater(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyGreaterOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_max(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyMaxOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_min(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyMinOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyModOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_mod(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyModOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyMulOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_mul(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyMulOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyNotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_not_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyNotEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyPadConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.pad.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, value, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddings(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_pad_constant(result, input, paddings, value, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyPadConstantOp(result=result, input=input, paddings=paddings, value=value, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartyPowOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_pow(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartyPowOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThirdPartySubOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.3p.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def _3p_sub(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.Value:
  return ThirdPartySubOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TopKOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.top_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, k, axis, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["k"] = (k if (
    isinstance(k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI64Attr')) else
      _ods_ir.AttrBuilder.get('SI64Attr')(k, context=_ods_context))
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI64Attr')) else
      _ods_ir.AttrBuilder.get('SI64Attr')(axis, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def k(self):
    return self.operation.attributes["k"]

  @k.setter
  def k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["k"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def top_k(input, k, axis, *, output_param_decls=None, results=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return TopKOp(input=input, k=k, axis=axis, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class XorOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self):
    return self.operation.operands[0]

  @builtins.property
  def input_y(self):
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self):
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def xor(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.Value:
  return XorOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result
