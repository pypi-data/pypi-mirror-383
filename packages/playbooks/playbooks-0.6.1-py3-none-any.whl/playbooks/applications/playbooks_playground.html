<!DOCTYPE html>
<html lang="en" data-theme="wireframe">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playbooks playground</title>
    
    <!-- Google Fonts - Lato -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS with DaisyUI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.14/dist/full.min.css" rel="stylesheet" type="text/css" />
    
    <!-- React and ReactDOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Heroicons -->
    <script src="https://unpkg.com/heroicons@2.0.18/24/outline/index.js" type="module"></script>
    
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <style>
        /* Set Lato as the default font family */
        body {
            font-family: 'Lato', sans-serif;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 300 !important;
        }
        
        /* Custom styles for syntax highlighting and markdown */
        .markdown-content {
            line-height: 1.6;
        }
        
        .markdown-content p {
            margin: 0.5rem 0;
        }
        
        .markdown-content p:first-child {
            margin-top: 0;
        }
        
        .markdown-content p:last-child {
            margin-bottom: 0;
        }
        
        .markdown-content h1, .markdown-content h2, .markdown-content h3, 
        .markdown-content h4, .markdown-content h5, .markdown-content h6 {
            margin: 1rem 0 0.5rem 0;
            font-weight: bold;
        }
        
        .markdown-content ul, .markdown-content ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        
        .markdown-content li {
            margin: 0.25rem 0;
        }
        
        .markdown-content blockquote {
            border-left: 4px solid #e5e7eb;
            padding-left: 1rem;
            margin: 1rem 0;
            color: #6b7280;
            font-style: italic;
        }
        
        .markdown-content pre {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1rem 0;
        }
        
        .markdown-content code {
            background: #f1f5f9;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
        }
        
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
        
        .markdown-content strong {
            font-weight: bold;
        }
        
        .markdown-content em {
            font-style: italic;
        }
        
        .markdown-content a {
            color: #3b82f6;
            text-decoration: underline;
        }
        
        .markdown-content a:hover {
            color: #1d4ed8;
        }

        .chat-bubble.chat-bubble-assistant::before {
            display: none;
        }
        .chat-bubble.chat-bubble-assistant {
            background: none;
            padding: 0;
            margin: 0;
            color: black;
        }

        .chat.chat-log {
            margin: 0 !important;
            padding: 0 !important;
        }

        /* Event visibility controls */
        body:not(.show-messages) .event-message {
            display: none !important;
        }
        
        body:not(.show-execution-logs) .event-session-log {
            display: none !important;
        }
    </style>
</head>
<body class="bg-base-200 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // Message component with markdown support
        function Message({ message }) {
            const messageRef = useRef(null);
            
            useEffect(() => {
                if (messageRef.current && window.Prism) {
                    window.Prism.highlightAllUnder(messageRef.current);
                }
            }, [message.content]);
            
            const renderContent = (content, message) => {
                // Handle log entries specially
                if (message.role === 'log' && message.content.indicator) {
                    const logData = message.content;
                    const levelColors = {
                        'HIGH': 'text-red-600',
                        'MEDIUM': 'text-yellow-600',
                        'LOW': 'text-gray-600'
                    };
                    
                    return (
                        <div className={`flex items-start gap-2 ${levelColors[logData.level] || 'text-gray-600'}`}>
                            <span className="flex-1 font-mono text-xs">{message.sender}: {message["metadata"]["log_full"]
                            }</span>
                        </div>
                    );
                }
                
                if (typeof content === 'string') {
                    // Configure marked to handle line breaks properly
                    marked.setOptions({
                        breaks: true, // Convert \n to <br>
                        gfm: true     // GitHub Flavored Markdown
                    });
                    const html = marked.parse(content);
                    return <div className="markdown-content" dangerouslySetInnerHTML={{ __html: html }} />;
                }
                return <div>{content}</div>;
            };
            
            const getBadgeColor = (role) => {
                switch (role) {
                    case 'user': return 'badge';
                    case 'assistant': return 'badge';
                    case 'system': return 'badge';
                    default: return 'badge';
                }
            };
            
            const getChatClass = (role) => {
                const side = role === 'user' ? 'chat-start' : 'chat-start';
                let eventClass = '';
                
                // Add event type classes for filtering
                if (role === 'assistant' || role === 'user') {
                    eventClass += ' event-message';
                }
                if (role === 'log') {
                    eventClass += ' event-session-log';
                }
                
                return `chat ${side} chat-${role}${eventClass}`;
            };

            const getChatBubbleClass = (role) => {
                switch (role) {
                    case 'user': return 'chat-bubble chat-bubble-primary chat-bubble-user';
                    case 'assistant': return 'chat-bubble chat-bubble-assistant';
                    case 'system': return 'text-xs pl-3';
                    case 'log': return 'text-sm pl-3 opacity-75';
                    default: return 'chat-bubble-neutral';
                }
            };
            
            const renderChatHeader = (message) => {
                if (message.role === 'system' || message.role === 'log') {
                    return null;
                }
                if (message.role === 'assistant') {
                    return (
                        <div className="chat-header">
                            <span className="text-xs">
                                {message.messageType === 'MEETING_BROADCAST_REQUEST' && message.meetingId 
                                    ? `MEETING: ${message.sender} → Meeting(${message.meetingId})` 
                                    : message.messageType 
                                        ? `${message.messageType}: ${message.sender} → ${message.recipient}` 
                                        : `${message.sender} → ${message.recipient}`}
                            </span>
                            {message.timestamp && (
                                <time className="text-xs opacity-50 ml-2">
                                    {new Date(message.timestamp).toLocaleTimeString()}
                                </time>
                            )}
                        </div>
                    );
                }

                if (message.role === 'user') {
                    return (
                        <div className="chat-header">
                            {message.timestamp && (
                                <time className="text-xs opacity-50 ml-2">
                                    {new Date(message.timestamp).toLocaleTimeString()}
                                </time>
                            )}
                        </div>
                    );
                }
            };
            
            return (
                <div className={`${getChatClass(message.role)}`} ref={messageRef}>
                    {renderChatHeader(message)}
                    
                    <div className={`${getChatBubbleClass(message.role)} ${message.isStreaming ? 'relative' : ''}`}>
                        {renderContent(message.content, message)}
                        {message.isStreaming && (
                            <span className="inline-block ml-1 w-2 h-4 bg-current opacity-75 animate-pulse">|</span>
                        )}
                    </div>
                </div>
            );
        }
        
        // Status indicator component
        function StatusIndicator({ status, text, eventCount }) {
            const getStatusColor = () => {
                switch (status) {
                    case 'connected': return 'bg-success';
                    case 'connecting': return 'bg-warning';
                    case 'disconnected': return 'bg-error';
                    default: return 'bg-base-300';
                }
            };
            
            return (
                <div className="flex items-center gap-4 justify-center">
                    <div className="flex items-center gap-2">
                        <div className={`w-3 h-3 rounded-full ${getStatusColor()}`}></div>
                        <span className="text-sm">{text}</span>
                    </div>
                    <div className="badge badge-outline badge-sm">
                        Events: {eventCount}
                    </div>
                </div>
            );
        }
        
        // Welcome screen component
        function WelcomeScreen() {
            return (
                <div className="text-center p-8">
                    <h3 className="text-2xl font-bold mb-4">Welcome to Playbooks Playground!</h3>
                    <p className="text-base-content/70 mb-6">
                        This is a playground to run and interact with Playbooks programs. 
                        It also serves as documentation for how to integrate web UI with Playbooks web server.
                    </p>
                    <div className="steps steps-vertical lg:steps-horizontal">
                        <div className="step step-primary">
                            <div className="text-left">
                                <div className="font-semibold">Start playground</div>
                                <div className="text-sm opacity-70">
                                    Run <code className="bg-base-200 px-2 py-1 rounded">
                                        playbooks playground
                                    </code> to start server and open browser
                                </div>
                            </div>
                        </div>
                        <div className="step step-primary">
                            <div className="text-left">
                                <div className="font-semibold">Enter Playbooks program path</div>
                                <div className="text-sm opacity-70">Use the default or enter your own</div>
                            </div>
                        </div>
                        <div className="step step-primary">
                            <div className="text-left">
                                <div className="font-semibold">Run the program</div>
                                <div className="text-sm opacity-70">Click "Run Program" to begin</div>
                            </div>
                        </div>
                        <div className="step step-primary">
                            <div className="text-left">
                                <div className="font-semibold">See it in action</div>
                                <div className="text-sm opacity-70">Watch and interact with the AI agents in real-time!</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        
        // Main App component
        function App() {
            const [ws, setWs] = useState(null);
            const [runId, setRunId] = useState(null);
            const [eventCounter, setEventCounter] = useState(0);
            const [isConnected, setIsConnected] = useState(false);
            const [status, setStatus] = useState('disconnected');
            const [statusText, setStatusText] = useState('Disconnected');
            const [messages, setMessages] = useState([]);
            const [streamingMessages, setStreamingMessages] = useState(new Map()); // Track streaming messages by agent_id
            const [playbookPath, setPlaybookPath] = useState('tests/data/02-personalized-greeting.pb');
            const [messageInput, setMessageInput] = useState('');
            const [showWelcome, setShowWelcome] = useState(true);
            const [showMessages, setShowMessages] = useState(true);
            const [showExecutionLogs, setShowExecutionLogs] = useState(false);
            const messagesEndRef = useRef(null);
            
            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };
            
            useEffect(() => {
                scrollToBottom();
            }, [messages, streamingMessages]);
            
            // Update body classes for event filtering
            useEffect(() => {
                const body = document.body;
                if (showMessages) {
                    body.classList.add('show-messages');
                } else {
                    body.classList.remove('show-messages');
                }
                
                if (showExecutionLogs) {
                    body.classList.add('show-execution-logs');
                } else {
                    body.classList.remove('show-execution-logs');
                }
            }, [showMessages, showExecutionLogs]);
            
            // Set initial body classes
            useEffect(() => {
                const body = document.body;
                if (showMessages) {
                    body.classList.add('show-messages');
                }
                if (showExecutionLogs) {
                    body.classList.add('show-execution-logs');
                }
            }, []);
            
            const updateStatus = (newStatus, text) => {
                setStatus(newStatus);
                setStatusText(text);
            };
            
            const toggleEventDisplay = (eventType) => {
                if (eventType === 'messages') {
                    setShowMessages(prev => !prev);
                } else if (eventType === 'session_log_entry') {
                    setShowExecutionLogs(prev => !prev);
                }
            };
            
            const addMessage = (role, sender, content, timestamp = null, recipient = null, messageType = null, meetingId = null, metadata = null) => {
                const message = {
                    id: Date.now(),
                    role,
                    sender,
                    recipient,
                    messageType,
                    meetingId,
                    content,
                    timestamp: timestamp || new Date().toISOString(),
                    metadata
                };
                setMessages(prev => [...prev, message]);
            };
            
            const formatSessionLogEntry = (event) => {
                // Use appropriate log format based on item type
                const logFormat = event.log_compact || event.log_full || event.content;
                
                // Add visual indicators based on item type
                const typeIndicators = {
                    'playbookcall': '📞',
                    'playbookcallresult': '✅',
                    'sessionlogitemplaybook_start': '▶️',
                    'sessionlogitemplaybook_end': '⏹️',
                    'sessionlogitemllm_request': '🤖',
                    'sessionlogitemllm_response': '💬',
                    'sessionlogitemstep_execution': '→',
                    'sessionlogitemvariable_update': '📝',
                    'sessionlogitemagent_message': '📨',
                    'sessionlogitemerror': '❌',
                    'sessionlogitemdebug': '🐛',
                    'message': '💭'
                };
                
                const indicator = typeIndicators[event.item_type] || '📄';
                
                return {
                    type: event.item_type,
                    level: event.level,
                    indicator: indicator,
                    content: logFormat,
                    metadata: event.metadata
                };
            };
            
            const handleEvent = (event) => {
                setEventCounter(prev => prev + 1);
                
                const type = event.type;
                const timestamp = event.timestamp;
                
                // Debug logging
                console.log(`Event received: ${type}`, event);
                
                switch (type) {
                    case 'connection_established':
                        addMessage('system', 'System', `Connected to session ${event.run_id.slice(0, 8)}...`, timestamp);
                        break;
                        
                    case 'run_started':
                        addMessage('system', 'System', 'Playbook execution started', timestamp);
                        break;
                        
                    // Non-streaming agent messages (commented out in favor of streaming)
                    // Uncomment this case if you want to use non-streaming messages instead
                    // case 'agent_message':
                    //     const sender = `${event.sender_klass}(${event.sender_id})`;
                    //     const recipient = `${event.recipient_klass}(${event.recipient_id})`;
                    //     const messageType = event.message_type;
                    //     const meetingId = event.metadata?.meeting_id;
                    //     const message = event.message;
                    //     
                    //     if (message && message !== '<eom>') {
                    //         addMessage('assistant', sender, message, timestamp, recipient, messageType, meetingId);
                    //     }
                    //     break;
                        
                    case 'agent_streaming_update':
                        const streamingSender = `${event.agent_klass}(${event.agent_id})`;
                        const streamingRecipient = event.recipient_id ? `${event.recipient_klass || 'Unknown'}(${event.recipient_id})` : 'HumanAgent(human)';
                        const streamingKey = `${event.agent_klass}-${event.agent_id}`;
                        
                        setStreamingMessages(prev => {
                            const newMap = new Map(prev);
                            const existing = newMap.get(streamingKey) || { 
                                role: 'assistant',
                                sender: streamingSender,
                                recipient: streamingRecipient,
                                messageType: event.message_type || 'DIRECT',
                                content: '', 
                                timestamp: timestamp,
                                id: `streaming-${streamingKey}-${Date.now()}`,
                                isStreaming: true
                            };
                            existing.content += event.content;
                            newMap.set(streamingKey, existing);
                            return newMap;
                        });
                        break;
                        
                    case 'agent_streaming_complete':
                        const completedKey = `${event.agent_klass}-${event.agent_id}`;
                        
                        setStreamingMessages(prev => {
                            const newMap = new Map(prev);
                            const streamingMessage = newMap.get(completedKey);
                            
                            if (streamingMessage) {
                                // Add the completed streaming message as a regular message
                                addMessage('assistant', streamingMessage.sender, streamingMessage.content, streamingMessage.timestamp, streamingMessage.recipient, streamingMessage.messageType);
                                
                                // Remove from streaming messages
                                newMap.delete(completedKey);
                            }
                            return newMap;
                        });
                        break;
                        
                    case 'human_input_requested':
                        addMessage('system', 'System', 'Waiting for your input...', timestamp);
                        break;
                        
                    case 'human_message':
                        addMessage('system', 'System', 'You sent a message', timestamp);
                        break;
                        
                    case 'meeting_broadcast':
                        const meetingSender = `${event.sender_klass}(${event.sender_id})`;
                        addMessage('system', `Meeting ${event.meeting_id}`, `${meetingSender}: ${event.message}`, timestamp);
                        break;
                        
                    case 'run_terminated':
                        addMessage('system', 'System', 'Playbook execution completed', timestamp);
                        break;
                        
                    case 'error':
                        addMessage('system', 'Error', event.message || 'Unknown error occurred', timestamp);
                        break;
                        
                    case 'session_log_entry':
                        console.log('Session log entry received:', event);
                        const logSender = `${event.agent_klass}(${event.agent_id})`;
                        const formattedLog = formatSessionLogEntry(event);
                        addMessage('log', logSender, formattedLog, timestamp, null, null, null, event);
                        break;
                        
                    case 'agent_created':
                        addMessage('system', 'System', `New agent created: ${event.agent_klass}(${event.agent_id})`, timestamp);
                        break;
                        
                    default:
                        console.log('Unhandled event type:', type, event);
                }
            };
            
            const connectWebSocket = (runId) => {
                try {
                    const websocket = new WebSocket(`ws://localhost:8001/ws/${runId}`);
                    
                    websocket.onopen = () => {
                        updateStatus('connected', `Connected (${runId.slice(0, 8)}...)`);
                        setIsConnected(true);
                        setShowWelcome(false);
                    };
                    
                    websocket.onmessage = (event) => {
                        try {
                            console.log('WebSocket message received:', event.data);
                            const data = JSON.parse(event.data);
                            handleEvent(data);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                        }
                    };
                    
                    websocket.onclose = () => {
                        updateStatus('disconnected', 'Disconnected');
                        setIsConnected(false);
                    };
                    
                    websocket.onerror = (error) => {
                        addMessage('system', 'Error', 'WebSocket connection error');
                        console.error('WebSocket error:', error);
                    };
                    
                    setWs(websocket);
                    
                } catch (error) {
                    addMessage('system', 'Error', `WebSocket connection failed: ${error.message}`);
                    updateStatus('disconnected', 'Error');
                }
            };
            
            const startChat = async () => {
                try {
                    updateStatus('connecting', 'Connecting...');
                    
                    const response = await fetch('http://localhost:8000/runs/new', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            path: playbookPath
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}: ${JSON.stringify(await response.json())}`);
                    }
                    
                    const data = await response.json();
                    setRunId(data.run_id);
                    connectWebSocket(data.run_id);
                    
                } catch (error) {
                    addMessage('system', 'Error', `Failed to start chat: ${error}`);
                    updateStatus('disconnected', 'Error');
                }
            };
            
            const stopChat = () => {
                if (ws) {
                    ws.close();
                    setWs(null);
                }
                setRunId(null);
                setEventCounter(0);
                updateStatus('disconnected', 'Disconnected');
                setIsConnected(false);
            };
            
            const sendMessage = () => {
                const message = messageInput.trim();
                if (!message || !isConnected) return;
                
                addMessage('user', 'You', message);
                
                ws.send(JSON.stringify({
                    type: 'human_message',
                    run_id: runId,
                    message: message
                }));
                
                setMessageInput('');
            };
            
            const handleKeyPress = (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            };
            
            return (
                <div className="flex flex-col h-screen">
                    {/* Header */}
                    <div className="bg-primary text-primary-content p-4 text-center">
                        <h1 className="text-2xl font-bold mb-2">▶ Playbooks playground</h1>
                        <StatusIndicator status={status} text={statusText} eventCount={eventCounter} />
                    </div>
                    
                    {/* Controls */}
                    <div className="bg-base-100 p-4 border-b border-base-300">
                        <div className="flex gap-4 items-center flex-wrap">
                            <input
                                type="text"
                                placeholder="Playbook path"
                                className="input input-bordered flex-1 min-w-[200px]"
                                value={playbookPath}
                                onChange={(e) => setPlaybookPath(e.target.value)}
                            />
                            <button
                                className="btn btn-primary"
                                onClick={startChat}
                                disabled={isConnected}
                            >
                                {isConnected ? 'Running...' : 'Run Program'}
                            </button>
                            <button
                                className="btn btn-secondary"
                                onClick={stopChat}
                                disabled={!isConnected}
                            >
                                Stop Program
                            </button>
                        </div>
                        
                        {/* Event Type Filters - Always visible */}
                        <div className="mt-4 flex gap-4 items-center flex-wrap">
                            <span className="text-sm font-semibold">Show Events:</span>
                            <label className="label cursor-pointer gap-2">
                                <input
                                    type="checkbox"
                                    className="checkbox checkbox-sm"
                                    checked={showMessages}
                                    onChange={() => toggleEventDisplay('messages')}
                                />
                                <span className="label-text">Messages</span>
                            </label>
                            <label className="label cursor-pointer gap-2">
                                <input
                                    type="checkbox"
                                    className="checkbox checkbox-sm"
                                    checked={showExecutionLogs}
                                    onChange={() => toggleEventDisplay('session_log_entry')}
                                />
                                <span className="label-text">Execution Logs</span>
                            </label>
                        </div>
                    </div>
                    
                    {/* Chat Container */}
                    <div className="flex-1 flex flex-col bg-base-100 m-4 rounded-lg shadow-lg overflow-hidden">
                        {/* Messages */}
                        <div className="flex-1 overflow-y-auto p-4 space-y-4">
                            {showWelcome && <WelcomeScreen />}
                            {messages.map((message) => (
                                <Message key={message.id} message={message} />
                            ))}
                            {Array.from(streamingMessages.values()).map((message) => (
                                <Message key={message.id} message={message} />
                            ))}
                            <div ref={messagesEndRef} />
                        </div>
                        
                        {/* Input Area */}
                        <div className="p-4 border-t border-base-300">
                            <div className="flex gap-2">
                                <input
                                    type="text"
                                    placeholder="Type your message..."
                                    className="input input-bordered flex-1"
                                    value={messageInput}
                                    onChange={(e) => setMessageInput(e.target.value)}
                                    onKeyPress={handleKeyPress}
                                    disabled={!isConnected}
                                />
                                <button
                                    className="btn btn-primary"
                                    onClick={sendMessage}
                                    disabled={!isConnected || !messageInput.trim()}
                                >
                                    Send
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        
        // Initialize the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

<!--
Playbooks Playground - Enhanced with React, Tailwind CSS, and DaisyUI

Usage Instructions:
1. Start the playground: playbooks playground (starts server and opens browser automatically)
2. Alternatively, manual setup:
   a. Start web server: playbooks webserver
   b. Open this HTML file in a web browser
3. Enter a playbook path (default: tests/data/02-personalized-greeting.pb)
4. Click "Run program" to create a new session
5. Chat with your AI agents in real-time!

Features:
- Modern React-based UI with hooks and state management
- Tailwind CSS + DaisyUI for beautiful, responsive design
- Real-time WebSocket communication
- Markdown rendering with syntax highlighting (Prism.js)
- Modern chat interface with avatars and message bubbles
- Enhanced status indicators and progress tracking
- Responsive design that works on all devices
- All modern frameworks loaded via CDN (no build process)

Technologies Used:
- React 18 with in-browser JSX compilation (Babel standalone)
- Tailwind CSS 3.x for utility-first styling
- DaisyUI 4.x for component library
- Marked.js for markdown rendering
- Prism.js for syntax highlighting
- Heroicons for consistent iconography

API Endpoints Used:
- POST http://localhost:8000/runs/new - Create new playbook run
- WebSocket ws://localhost:8001/ws/{run_id} - Real-time events
-->