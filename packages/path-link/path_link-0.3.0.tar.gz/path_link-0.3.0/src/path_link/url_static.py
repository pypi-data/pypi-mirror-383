"""Static URL model generator with deterministic ordering and atomic writes.

This module generates a static dataclass for project URLs that provides
IDE autocomplete without requiring runtime configuration loading.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import Optional, Union

from path_link.url_factory import ProjectUrls
from path_link.url_model import ValidationMode


def generate_static_url_model_text(mode: ValidationMode = ValidationMode.LENIENT) -> str:
    """
    Generates the Python code for the static URL dataclass model.

    Args:
        mode: Validation mode to use when loading URLs (default: lenient)

    Returns:
        Python source code as a string
    """
    lines = [
        "from dataclasses import dataclass, field",
        "",
        "# This file is auto-generated by path-link. Do not edit manually.",
        "# Run `pathlink gen-static-urls` to regenerate.",
        "",
        "@dataclass(frozen=True)",
        "class ProjectUrlsStatic:",
        '    """A static, auto-generated dataclass for project URLs."""',
        "",
    ]

    # Instantiate from merged sources to get all URL fields
    try:
        model = ProjectUrls.from_merged(mode=mode)
    except Exception:
        # If merged loading fails, try just pyproject
        try:
            model = ProjectUrls.from_pyproject(mode=mode)
        except Exception:
            # If that fails too, return empty model with comment
            lines.append("    # No URLs configured")
            lines.append("    pass")
            return "\n".join(lines)

    # Get all fields and sort them for deterministic output (stable diffs)
    field_names = sorted(model.__class__.model_fields.keys())

    if not field_names:
        # No fields, generate empty model
        lines.append("    # No URLs configured")
        lines.append("    pass")
    else:
        for field_name in field_names:
            # Get the actual URL value from the model instance
            url_value = getattr(model, field_name)

            # Create field with simple string default (no factories for URLs)
            line = f'    {field_name}: str = "{url_value}"'
            lines.append(line)

    # Add empty line at end for clean formatting
    lines.append("")

    return "\n".join(lines)


def write_url_dataclass_file(
    output_path: Optional[Union[str, Path]] = None,
    mode: Union[ValidationMode, str, None] = None,
) -> None:
    """
    Generates and writes the static URL dataclass file with atomic write.

    Uses atomic file operations to prevent TOCTOU vulnerabilities:
    1. Write to temporary file
    2. Flush and sync to disk
    3. Atomically replace target file

    Args:
        output_path: Optional output path (default: src/project_paths/project_urls_static.py)
        mode: Validation mode (lenient or strict). If None, defaults to lenient.

    Raises:
        FileNotFoundError: If file write verification fails
    """
    # Determine validation mode
    if mode is None:
        validation_mode = ValidationMode.LENIENT
    elif isinstance(mode, str):
        validation_mode = ValidationMode(mode.lower())
    else:
        validation_mode = mode

    # Determine output path
    if output_path is None:
        # Default path within the src directory
        output_path = Path(__file__).parent / "project_urls_static.py"

    resolved_path = Path(output_path).resolve()
    resolved_path.parent.mkdir(parents=True, exist_ok=True)

    # Generate the code
    generated_code = generate_static_url_model_text(validation_mode)

    # Write to a temporary file first to avoid race conditions (TOCTOU)
    temp_path = resolved_path.with_suffix(".tmp")

    # Write and sync to disk before replace (prevents TOCTOU vulnerability)
    with temp_path.open("w", encoding="utf-8") as f:
        f.write(generated_code)
        f.flush()
        os.fsync(f.fileno())  # Ensure data is written to disk

    # Atomically replace the old file with the new one (atomic on POSIX)
    temp_path.replace(resolved_path)

    # Verify the file exists (after atomic replace, no TOCTOU risk)
    if resolved_path.exists():
        print(f"✅ Static URL model written to {resolved_path}")
    else:
        raise FileNotFoundError(f"❌ Failed to write static URL model to {resolved_path}")
