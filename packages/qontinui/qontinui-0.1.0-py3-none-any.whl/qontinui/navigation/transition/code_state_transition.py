"""Code-based state transition - ported from Qontinui framework.

Transition implementation defined in Python code (as opposed to DSL/JSON configuration).
"""

from collections.abc import Callable
from dataclasses import dataclass, field
from typing import Any

from ...model.transition.state_transition import StateTransition, StaysVisible, TaskSequence


@dataclass
class CodeStateTransition(StateTransition):
    """Code-based state transition implementation.

    Python implementation of code-based state transitions (originally JavaStateTransition in Brobot).

    CodeStateTransition represents transitions defined through Python code using callable
    functions. This implementation enables dynamic, programmatic state navigation where transition
    logic can involve complex conditions, external data, or runtime calculations that cannot be
    expressed declaratively in DSL/JSON configuration.

    Key components:
    - Transition Function: Callable that executes the transition logic
    - Activation List: States to activate after successful transition
    - Exit List: States to deactivate after successful transition
    - Visibility Control: Whether source state remains visible post-transition
    - Path Score: Weight for path-finding algorithms (higher = less preferred)

    State reference handling:
    - Uses state names during definition (IDs not yet assigned)
    - Names are converted to IDs during initialization
    - Both name and ID sets are maintained for flexibility
    - Supports multiple target states for branching transitions

    Transition execution flow:
    1. Callable is invoked to perform transition logic
    2. If True is returned, transition is considered successful
    3. States in 'activate' set become active
    4. States in 'exit' set become inactive
    5. Success counter is incremented for metrics

    Common use patterns:
    - Complex navigation logic that depends on runtime conditions
    - Transitions involving external API calls or data validation
    - Dynamic state activation based on application state
    - Fallback transitions with custom error handling

    In the model-based approach, CodeStateTransition provides the flexibility needed for
    complex automation scenarios where declarative configuration transitions are insufficient. It
    bridges the gap between high-level state modeling and low-level action execution, enabling
    sophisticated navigation strategies.

    This contrasts with DSL-based transitions that are created from JSON configuration
    files generated by the Qontinui configuration website.
    """

    # State management
    activate: set[int] = field(default_factory=set)
    """State IDs to activate after successful transition."""

    activate_names: set[str] = field(default_factory=set)
    """State names to activate (converted to IDs during initialization)."""

    exit: set[int] = field(default_factory=set)
    """State IDs to deactivate after successful transition."""

    exit_names: set[str] = field(default_factory=set)
    """State names to deactivate (converted to IDs during initialization)."""

    # Transition logic
    transition_function: Callable[[], bool] | None = None
    """Python callable that implements the transition logic."""

    # Post-transition state
    stays_visible_after_transition: StaysVisible = StaysVisible.NONE
    """Controls whether source state remains visible after transition."""

    # Path-finding
    _score: int = 100
    """Path-finding weight for this transition (lower is better)."""

    # Metrics
    times_successful: int = 0
    """Counter for successful transition executions."""

    def execute(self) -> bool:
        """Execute the transition function.

        Returns:
            True if transition succeeded, False otherwise
        """
        if self.transition_function is None:
            return False

        try:
            success = self.transition_function()
            if success:
                self.times_successful += 1
            return success
        except Exception as e:
            # Log error but don't crash
            import logging

            logging.error(f"Transition function failed: {e}")
            return False

    def get_activated_states(self) -> set[int]:
        """Get state IDs that will be activated.

        Returns:
            Set of state IDs to activate
        """
        return self.activate.copy()

    def get_deactivated_states(self) -> set[int]:
        """Get state IDs that will be deactivated.

        Returns:
            Set of state IDs to deactivate
        """
        return self.exit.copy()

    def set_state_ids(self, name_to_id: dict[str, Any]) -> None:
        """Convert state names to IDs.

        Args:
            name_to_id: Mapping of state names to IDs
        """
        # Convert activate names to IDs
        for name in self.activate_names:
            if name in name_to_id:
                self.activate.add(name_to_id[name])

        # Convert exit names to IDs
        for name in self.exit_names:
            if name in name_to_id:
                self.exit.add(name_to_id[name])

    # Abstract method implementations from StateTransition

    def get_task_sequence_optional(self) -> TaskSequence | None:
        """Get task sequence (None for code-based transitions).

        Returns:
            None - code transitions don't use task sequences
        """
        return None

    def get_stays_visible_after_transition(self) -> StaysVisible:
        """Get visibility behavior after transition.

        Returns:
            StaysVisible enum value
        """
        return self.stays_visible_after_transition

    def set_stays_visible_after_transition(self, stays_visible: StaysVisible) -> None:
        """Set visibility behavior after transition.

        Args:
            stays_visible: StaysVisible enum value
        """
        self.stays_visible_after_transition = stays_visible

    def get_activate(self) -> set[int]:
        """Get state IDs to activate.

        Returns:
            Set of state IDs
        """
        return self.activate

    def set_activate(self, activate: set[int]) -> None:
        """Set state IDs to activate.

        Args:
            activate: Set of state IDs
        """
        self.activate = activate

    def get_exit(self) -> set[int]:
        """Get state IDs to exit.

        Returns:
            Set of state IDs
        """
        return self.exit

    def set_exit(self, exit: set[int]) -> None:
        """Set state IDs to exit.

        Args:
            exit: Set of state IDs
        """
        self.exit = exit

    def get_score(self) -> int:
        """Get path-finding score.

        Returns:
            Score value
        """
        return self._score

    def set_score(self, score: int) -> None:
        """Set path-finding score.

        Args:
            score: Score value
        """
        self._score = score

    @property
    def score(self) -> int:
        """Get path-finding score as a property.

        Returns:
            Score value
        """
        return self._score

    @score.setter
    def score(self, value: int) -> None:
        """Set path-finding score as a property.

        Args:
            value: Score value
        """
        self._score = value

    def get_times_successful(self) -> int:
        """Get success count.

        Returns:
            Number of successful executions
        """
        return self.times_successful

    def set_times_successful(self, times_successful: int) -> None:
        """Set success count.

        Args:
            times_successful: Number of successful executions
        """
        self.times_successful = times_successful

    @property
    def to_state(self) -> str | None:
        """Get the target state name this transition leads to.

        Returns:
            First activated state name or None
        """
        return next(iter(self.activate_names), None) if self.activate_names else None

    @property
    def from_state(self) -> str | None:
        """Get the source state name this transition comes from.

        Returns:
            None for code transitions (source is implicit)
        """
        return None

    @property
    def transition_type(self) -> str:
        """Get the transition type identifier.

        Returns:
            Type identifier
        """
        return "code"

    @property
    def probability(self) -> float:
        """Get transition success probability.

        Returns:
            Probability based on success history
        """
        return 1.0  # Default to 1.0 for code transitions

    @property
    def name(self) -> str:
        """Get transition name.

        Returns:
            Generated name based on activated states
        """
        if self.activate_names:
            return f"CodeTransition->{','.join(sorted(self.activate_names))}"
        return "CodeTransition"

    @property
    def priority(self) -> int:
        """Get transition priority.

        Returns:
            Priority (inverse of score)
        """
        return -self._score  # Higher score = lower priority

    def check_conditions(self) -> bool:
        """Check if transition conditions are met.

        Returns:
            True if conditions are met
        """
        # For code transitions, conditions are checked during execute
        return True

    def __str__(self) -> str:
        """String representation."""
        activated = ", ".join(self.activate_names) if self.activate_names else "None"
        exited = ", ".join(self.exit_names) if self.exit_names else "None"
        return f"CodeTransition(activate=[{activated}], exit=[{exited}], score={self.score})"
