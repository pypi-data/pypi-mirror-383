<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Server Test - {{server_name}}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #4a5568;
            margin-bottom: 10px;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }

        .tools-section, .resources-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tool-card, .resource-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .tool-name, .resource-name {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .tool-description, .resource-description {
            color: #718096;
            margin-bottom: 15px;
        }

        .test-form {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #4a5568;
            font-weight: 500;
            font-size: 14px;
        }

        .param-info {
            font-size: 12px;
            color: #718096;
            margin-bottom: 3px;
        }

        .param-required {
            color: #e53e3e;
            font-weight: 600;
        }

        .param-optional {
            color: #38a169;
        }

        .param-type {
            background: #edf2f7;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
        }

        input, textarea, select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 20px;
            background: #4299e1;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
            min-width: 80px;
        }

        button:hover {
            background: #3182ce;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        /* ÂÅúÊ≠¢ÊåâÈíÆÊ†∑Âºè */
        button[style*="background: rgb(245, 101, 101)"] {
            background: #f56565 !important;
        }

        button[style*="background: rgb(245, 101, 101)"]:hover {
            background: #e53e3e !important;
        }

        .result {
            margin-top: 15px;
            padding: 15px;
            background: #edf2f7;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
            display: none;
        }

        .result.success {
            background: #f0fff4;
            border-left-color: #48bb78;
        }

        .result.error {
            background: #fff5f5;
            border-left-color: #f56565;
        }

        .navigation {
            text-align: center;
            margin-top: 30px;
        }

        .nav-link {
            color: #4299e1;
            text-decoration: none;
            margin: 0 15px;
            padding: 10px 20px;
            border: 1px solid #4299e1;
            border-radius: 6px;
            display: inline-block;
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: #4299e1;
            color: white;
        }

        pre {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ MCP Server Test</h1>
            <p>ÊµãËØï <strong>{{server_name}}</strong> v{{server_version}} ÁöÑÂäüËÉΩ</p>
        </div>

        <div class="status">
            ‚úÖ ÊúçÂä°Âô®Ê≠£Âú®ËøêË°å
        </div>

        <div class="tools-section">
            <div class="section-title">
                <span>üîß</span>
                ÂèØÁî®Â∑•ÂÖ∑
            </div>
            <div id="tools-container">
                <div class="empty-state">
                    <div class="icon">‚è≥</div>
                    <p>Ê≠£Âú®Âä†ËΩΩÂ∑•ÂÖ∑...</p>
                </div>
            </div>
        </div>

        <div class="resources-section">
            <div class="section-title">
                <span>üìÅ</span>
                ÂèØÁî®ËµÑÊ∫ê
            </div>
            <div id="resources-container">
                <div class="empty-state">
                    <div class="icon">‚è≥</div>
                    <p>Ê≠£Âú®Âä†ËΩΩËµÑÊ∫ê...</p>
                </div>
            </div>
        </div>

        <div class="navigation">
            <a href="/setup" class="nav-link">‚öôÔ∏è ÊúçÂä°Âô®ËÆæÁΩÆ</a>
            <a href="/config" class="nav-link">üîß Á≥ªÁªüÈÖçÁΩÆ</a>
            <a href="/health" class="nav-link">üíö ÂÅ•Â∫∑Ê£ÄÊü•</a>
            <a href="/info" class="nav-link">‚ÑπÔ∏è ÊúçÂä°Âô®‰ø°ÊÅØ</a>
        </div>
    </div>

    <script>
        // Á´ØÁÇπÈÖçÁΩÆ
        const ENDPOINTS = {
            tools: '{{tools_endpoint}}',
            resources: '{{resources_endpoint}}',
            toolCall: '{{tool_call_endpoint}}',
            sse: '{{sse_endpoint}}',
            sseStop: '{{sse_stop_endpoint}}',
            openaiSSE: '{{openai_sse_endpoint}}',
            openaiSSEStop: '{{openai_sse_stop_endpoint}}'
        };
        
        // Ë∞ÉËØïÔºöÊâìÂç∞Á´ØÁÇπÈÖçÁΩÆ
        console.log('ENDPOINTSÈÖçÁΩÆ:', ENDPOINTS);
        
        // ÊµãËØïÁΩëÁªúËøûÊé•
        async function testNetworkConnection() {
            try {
                console.log('Testing basic fetch to server...');
                const response = await fetch('/info');
                console.log('Basic fetch successful:', response.status);
                
                console.log('Testing OpenAI SSE endpoint availability...');
                const testResponse = await fetch(ENDPOINTS.openaiSSE, {
                    method: 'OPTIONS'
                });
                console.log('OPTIONS request result:', testResponse.status);
            } catch (error) {
                console.error('Network test failed:', error);
            }
        }
        
        // È°µÈù¢Âä†ËΩΩÊó∂ÊµãËØïÁΩëÁªúËøûÊé•
        testNetworkConnection();

        // È°µÈù¢Âä†ËΩΩÊó∂ÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', async function() {
            await loadStreamingInfo();
            loadTools();
            loadResources();
        });

        // Âä†ËΩΩÂ∑•ÂÖ∑ÂàóË°®
        async function loadTools() {
            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'tools/list'
                    })
                });

                const result = await response.json();

                if (result.result && result.result.tools) {
                    renderTools(result.result.tools);
                } else {
                    showEmptyState('tools-container', 'üîß', 'ÊöÇÊó†ÂèØÁî®Â∑•ÂÖ∑');
                }
            } catch (error) {
                console.error('Failed to load tools:', error);
                showEmptyState('tools-container', '‚ùå', 'Âä†ËΩΩÂ∑•ÂÖ∑Â§±Ë¥•');
            }
        }

        // Ê∏≤ÊüìÂ∑•ÂÖ∑
        function renderTools(tools) {
            const container = document.getElementById('tools-container');
            container.innerHTML = '';

            // Â≠òÂÇ®Â∑•ÂÖ∑‰ø°ÊÅØÂà∞ÂÖ®Â±ÄÂèòÈáè
            window.mcpTools = tools;

            if (tools.length === 0) {
                showEmptyState('tools-container', 'üîß', 'ÊöÇÊó†ÂèØÁî®Â∑•ÂÖ∑');
                return;
            }

            tools.forEach(tool => {
                const toolCard = document.createElement('div');
                toolCard.className = 'tool-card';

                const toolName = document.createElement('div');
                toolName.className = 'tool-name';
                const supportsStreaming = streamingTools.includes(tool.name);
                const streamingBadge = supportsStreaming ? ' üåä' : ' üìÑ';
                const streamingTitle = supportsStreaming ? 'ÊîØÊåÅÊµÅÂºèËæìÂá∫' : '‰ªÖÊîØÊåÅHTTP';
                const streamingType = supportsStreaming ? 'SSE' : 'HTTP';
                toolName.innerHTML = tool.name + streamingBadge + ' <span style="font-size: 12px; color: #718096; font-weight: normal;" title="' + streamingTitle + '">(' + streamingType + ')</span>';

                const toolDescription = document.createElement('div');
                toolDescription.className = 'tool-description';
                toolDescription.textContent = tool.description;

                const testForm = document.createElement('div');
                testForm.className = 'test-form';

                // ÂàõÂª∫ÂèÇÊï∞ËæìÂÖ•Ê°Ü
                const properties = tool.input_schema?.properties || {};
                const required = tool.input_schema?.required || [];
                
                Object.keys(properties).forEach(paramName => {
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';

                    const label = document.createElement('label');
                    const isRequired = required.includes(paramName);
                    label.innerHTML = paramName + (isRequired ? ' <span class="param-required">*</span>' : ' <span class="param-optional">(ÂèØÈÄâ)</span>');

                    const property = properties[paramName];
                    
                    // Ê∑ªÂä†ÂèÇÊï∞‰ø°ÊÅØ
                    const paramInfo = document.createElement('div');
                    paramInfo.className = 'param-info';
                    let infoText = '';
                    if (property.type) {
                        infoText += '<span class="param-type">' + property.type + '</span> ';
                    }
                    if (property.description) {
                        infoText += property.description;
                    }
                    if (property.default !== undefined) {
                        infoText += ' (ÈªòËÆ§: ' + JSON.stringify(property.default) + ')';
                    }
                    if (property.minimum !== undefined || property.maximum !== undefined) {
                        infoText += ' (ËåÉÂõ¥: ' + (property.minimum || '-‚àû') + ' ~ ' + (property.maximum || '+‚àû') + ')';
                    }
                    if (property.enum) {
                        infoText += ' (ÂèØÈÄâÂÄº: ' + property.enum.join(', ') + ')';
                    }
                    paramInfo.innerHTML = infoText;

                    const input = document.createElement('input');

                    // Ê†πÊçÆJSON SchemaÁ±ªÂûãËÆæÁΩÆÊ≠£Á°ÆÁöÑËæìÂÖ•Á±ªÂûã
                    switch (property.type) {
                        case 'integer':
                        case 'number':
                            input.type = 'number';
                            if (property.minimum !== undefined) {
                                input.min = property.minimum;
                            }
                            if (property.maximum !== undefined) {
                                input.max = property.maximum;
                            }
                            if (property.type === 'integer') {
                                input.step = '1';
                            }
                            if (property.default !== undefined) {
                                input.value = property.default;
                            }
                            break;
                        case 'boolean':
                            input.type = 'checkbox';
                            if (property.default !== undefined) {
                                input.checked = property.default;
                            }
                            break;
                        case 'array':
                            input.type = 'text';
                            input.placeholder = 'JSONÊï∞ÁªÑÊ†ºÂºèÔºåÂ¶Ç ["item1", "item2"]';
                            if (property.default !== undefined) {
                                input.value = JSON.stringify(property.default);
                            }
                            break;
                        default:
                            input.type = 'text';
                            if (property.enum) {
                                // Â¶ÇÊûúÊúâÊûö‰∏æÂÄºÔºåÂàõÂª∫‰∏ãÊãâÈÄâÊã©
                                const select = document.createElement('select');
                                select.name = paramName;
                                
                                // Ê∑ªÂä†Á©∫ÈÄâÈ°πÔºàÂ¶ÇÊûú‰∏çÊòØÂøÖÈúÄÁöÑÔºâ
                                if (!isRequired) {
                                    const emptyOption = document.createElement('option');
                                    emptyOption.value = '';
                                    emptyOption.textContent = '-- ËØ∑ÈÄâÊã© --';
                                    select.appendChild(emptyOption);
                                }
                                
                                property.enum.forEach(enumValue => {
                                    const option = document.createElement('option');
                                    option.value = enumValue;
                                    option.textContent = enumValue;
                                    if (property.default === enumValue) {
                                        option.selected = true;
                                    }
                                    select.appendChild(option);
                                });
                                
                                formGroup.appendChild(label);
                                formGroup.appendChild(paramInfo);
                                formGroup.appendChild(select);
                                testForm.appendChild(formGroup);
                                return;
                            } else {
                                if (property.default !== undefined) {
                                    input.value = property.default;
                                }
                                input.placeholder = property.description || '';
                            }
                    }

                    input.name = paramName;
                    if (isRequired) {
                        input.required = true;
                    }

                    formGroup.appendChild(label);
                    formGroup.appendChild(paramInfo);
                    formGroup.appendChild(input);
                    testForm.appendChild(formGroup);
                });

                const buttonGroup = document.createElement('div');
                buttonGroup.style.display = 'flex';
                buttonGroup.style.gap = '10px';
                buttonGroup.style.alignItems = 'center';

                const testButton = document.createElement('button');
                testButton.textContent = 'ÊµãËØï';
                testButton.id = 'test-btn-' + tool.name;
                testButton.onclick = () => handleTestButtonClick(tool.name, testForm, testButton);
                buttonGroup.appendChild(testButton);

                const openaiButton = document.createElement('button');
                openaiButton.textContent = 'OpenAIÊ†ºÂºè';
                openaiButton.id = 'openai-btn-' + tool.name;
                openaiButton.style.background = '#10b981';
                openaiButton.onclick = () => handleOpenAITestButtonClick(tool.name, testForm, openaiButton);
                buttonGroup.appendChild(openaiButton);

                testForm.appendChild(buttonGroup);

                const result = document.createElement('div');
                result.className = 'result';
                result.id = 'result-' + tool.name;

                toolCard.appendChild(toolName);
                toolCard.appendChild(toolDescription);
                toolCard.appendChild(testForm);
                toolCard.appendChild(result);
                container.appendChild(toolCard);
            });
        }

        // Ê£ÄÊü•Â∑•ÂÖ∑ÊòØÂê¶ÊîØÊåÅÊµÅÂºèËæìÂá∫
        let streamingTools = [];

        // Ë∑üË∏™Ê¥ªË∑ÉÁöÑÊµÅÂºè‰ºöËØù
        let activeStreams = new Map(); // toolName -> { sessionId, reader, abortController }
        let activeOpenAIStreams = new Map(); // toolName -> { sessionId, reader, abortController }

        // Ëé∑ÂèñÊîØÊåÅÊµÅÂºèËæìÂá∫ÁöÑÂ∑•ÂÖ∑ÂàóË°®
        async function loadStreamingInfo() {
            try {
                const response = await fetch('/info');
                const data = await response.json();
                streamingTools = data.streaming_tools || [];
            } catch (error) {
                console.warn('Failed to load streaming info:', error);
            }
        }

        // Â§ÑÁêÜÊµãËØï/ÂÅúÊ≠¢ÊåâÈíÆÁÇπÂáª
        async function handleTestButtonClick(toolName, formElement, buttonElement) {
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊ¥ªË∑ÉÁöÑÊµÅÂºè‰ºöËØù
            if (activeStreams.has(toolName)) {
                // ÂÅúÊ≠¢ÊµÅÂºèËæìÂá∫
                await stopTool(toolName, buttonElement);
            } else {
                // ÂºÄÂßãÊµãËØï
                await testTool(toolName, formElement, buttonElement);
            }
        }

        // Â§ÑÁêÜOpenAIÊ†ºÂºèÊµãËØï/ÂÅúÊ≠¢ÊåâÈíÆÁÇπÂáª
        async function handleOpenAITestButtonClick(toolName, formElement, buttonElement) {
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊ¥ªË∑ÉÁöÑOpenAIÊµÅÂºè‰ºöËØù
            if (activeOpenAIStreams.has(toolName)) {
                // ÂÅúÊ≠¢OpenAIÊµÅÂºèËæìÂá∫
                await stopOpenAITool(toolName, buttonElement);
            } else {
                // ÂºÄÂßãOpenAIÊ†ºÂºèÊµãËØï
                await testToolWithOpenAI(toolName, formElement, buttonElement);
            }
        }

        // ÂÅúÊ≠¢Â∑•ÂÖ∑ÊµÅÂºèËæìÂá∫
        async function stopTool(toolName, buttonElement) {
            const streamInfo = activeStreams.get(toolName);
            if (!streamInfo) return;

            try {
                // ÂèñÊ∂àÊµÅÂºèËØªÂèñ
                if (streamInfo.abortController) {
                    streamInfo.abortController.abort();
                }

                // Ë∞ÉÁî®ÂÅúÊ≠¢APIÔºàÂ¶ÇÊûúÊúâsession_idÔºâ
                if (streamInfo.sessionId) {
                    const response = await fetch('/api/streaming/stop', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: streamInfo.sessionId
                        })
                    });

                    const result = await response.json();
                    console.log('Stop API result:', result);
                }

                // Ê∏ÖÁêÜ‰ºöËØù
                activeStreams.delete(toolName);

                // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
                buttonElement.textContent = 'ÊµãËØï';
                buttonElement.style.background = '#4299e1';

                // ÊòæÁ§∫ÂÅúÊ≠¢Ê∂àÊÅØ
                const resultElement = document.getElementById('result-' + toolName);
                if (resultElement) {
                    resultElement.className = 'result';
                    resultElement.innerHTML = '<strong>üõë Â∑≤ÂÅúÊ≠¢:</strong> ÊµÅÂºèËæìÂá∫Â∑≤Ë¢´Áî®Êà∑ÂÅúÊ≠¢';
                }

            } catch (error) {
                console.error('Stop failed:', error);
            }
        }

        // ÂÅúÊ≠¢OpenAIÂ∑•ÂÖ∑ÊµÅÂºèËæìÂá∫
        async function stopOpenAITool(toolName, buttonElement) {
            const streamInfo = activeOpenAIStreams.get(toolName);
            if (!streamInfo) return;

            try {
                // ÂèñÊ∂àÊµÅÂºèËØªÂèñ
                if (streamInfo.abortController) {
                    streamInfo.abortController.abort();
                }

                // Ê∏ÖÁêÜ‰ºöËØù
                activeOpenAIStreams.delete(toolName);

                // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
                buttonElement.textContent = 'OpenAIÊ†ºÂºè';
                buttonElement.style.background = '#10b981';

                // ÊòæÁ§∫ÂÅúÊ≠¢Ê∂àÊÅØ
                const resultElement = document.getElementById('result-' + toolName);
                if (resultElement) {
                    resultElement.className = 'result';
                    resultElement.innerHTML = '<strong>üõë Â∑≤ÂÅúÊ≠¢:</strong> OpenAIÊ†ºÂºèÊµÅÂºèËæìÂá∫Â∑≤Ë¢´Áî®Êà∑ÂÅúÊ≠¢';
                }

            } catch (error) {
                console.error('OpenAI Stop failed:', error);
            }
        }

        // ÊµãËØïÂ∑•ÂÖ∑
        async function testTool(toolName, formElement, buttonElement) {
            const inputs = formElement.querySelectorAll('input, select');
            const arguments = {};

            // Ëé∑ÂèñÂ∑•ÂÖ∑ÁöÑSchema‰ø°ÊÅØ
            const tool = window.mcpTools.find(t => t.name === toolName);
            const properties = tool?.inputSchema?.properties || {};

            inputs.forEach(input => {
                const value = input.type === 'checkbox' ? input.checked : input.value.trim();
                const property = properties[input.name] || {};

                if (value !== '' || input.type === 'checkbox') {
                    // Ê†πÊçÆËæìÂÖ•Á±ªÂûãÂ§ÑÁêÜÂÄº
                    switch (input.type) {
                        case 'number':
                            if (value !== '') {
                                const numValue = parseFloat(value);
                                if (!isNaN(numValue)) {
                                    // Ê£ÄÊü•ÊòØÂê¶ÊòØÊï¥Êï∞Á±ªÂûãÔºàstep‰∏∫1Ë°®Á§∫Êï¥Êï∞Ôºâ
                                    arguments[input.name] = input.step === '1' ? parseInt(value) : numValue;
                                }
                            }
                            break;
                        case 'checkbox':
                            arguments[input.name] = input.checked;
                            break;
                        case 'text':
                            if (value !== '') {
                                // Â∞ùËØïËß£ÊûêJSONÊï∞ÁªÑ
                                if (value.startsWith('[') && value.endsWith(']')) {
                                    try {
                                        arguments[input.name] = JSON.parse(value);
                                    } catch (e) {
                                        arguments[input.name] = value;
                                    }
                                } else {
                                    arguments[input.name] = value;
                                }
                            }
                            break;
                        default:
                            if (value !== '') {
                                arguments[input.name] = value;
                            }
                    }
                } else if (property.default !== undefined) {
                    // Â¶ÇÊûúÊ≤°ÊúâËæìÂÖ•ÂÄº‰ΩÜÊúâÈªòËÆ§ÂÄºÔºå‰ΩøÁî®ÈªòËÆ§ÂÄº
                    arguments[input.name] = property.default;
                }
            });

            const resultElement = document.getElementById('result-' + toolName);
            resultElement.style.display = 'block';
            resultElement.className = 'result';

            // Ê£ÄÊü•ÊòØÂê¶ÊîØÊåÅÊµÅÂºèËæìÂá∫
            const supportsStreaming = streamingTools.includes(toolName);

            if (supportsStreaming) {
                // Êõ¥Êñ∞ÊåâÈíÆ‰∏∫ÂÅúÊ≠¢Áä∂ÊÄÅ
                buttonElement.textContent = 'ÂÅúÊ≠¢';
                buttonElement.style.background = '#f56565';

                resultElement.innerHTML = 'üîÑ ‰ΩøÁî®ÊµÅÂºèËæìÂá∫ÊµãËØï‰∏≠...';
                await testToolWithSSE(toolName, arguments, resultElement, buttonElement);
            } else {
                resultElement.innerHTML = 'üîÑ ‰ΩøÁî®HTTPÊµãËØï‰∏≠...';
                await testToolWithHTTP(toolName, arguments, resultElement);
                // HTTPË∞ÉÁî®ÂÆåÊàêÂêéÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                buttonElement.textContent = 'ÊµãËØï';
                buttonElement.style.background = '#4299e1';
            }
        }

        // ‰ΩøÁî®HTTPÊµãËØïÂ∑•ÂÖ∑
        async function testToolWithHTTP(toolName, arguments, resultElement) {
            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: Date.now(),
                        method: 'tools/call',
                        params: {
                            name: toolName,
                            arguments: arguments
                        }
                    })
                });

                const result = await response.json();

                if (result.result) {
                    resultElement.className = 'result success';
                    const content = result.result.content?.[0]?.text || JSON.stringify(result.result, null, 2);
                    resultElement.innerHTML = '<strong>‚úÖ HTTPÊàêÂäü:</strong><pre>' + content + '</pre>';
                } else if (result.error) {
                    resultElement.className = 'result error';
                    resultElement.innerHTML = '<strong>‚ùå HTTPÈîôËØØ:</strong> ' + result.error.message;
                }
            } catch (error) {
                resultElement.className = 'result error';
                resultElement.innerHTML = '<strong>üö´ HTTPËØ∑Ê±ÇÂ§±Ë¥•:</strong> ' + error.message;
            }
        }

        // ‰ΩøÁî®OpenAIÊ†ºÂºèÊµãËØïÂ∑•ÂÖ∑
        async function testToolWithOpenAI(toolName, formElement, buttonElement) {
            const inputs = formElement.querySelectorAll('input, select');
            const arguments = {};

            // Ëé∑ÂèñÂ∑•ÂÖ∑ÁöÑSchema‰ø°ÊÅØ
            const tool = window.mcpTools.find(t => t.name === toolName);
            const properties = tool?.inputSchema?.properties || {};

            inputs.forEach(input => {
                const value = input.type === 'checkbox' ? input.checked : input.value.trim();
                const property = properties[input.name] || {};

                if (value !== '' || input.type === 'checkbox') {
                    // Ê†πÊçÆËæìÂÖ•Á±ªÂûãÂ§ÑÁêÜÂÄº
                    switch (input.type) {
                        case 'number':
                            if (value !== '') {
                                const numValue = parseFloat(value);
                                if (!isNaN(numValue)) {
                                    // Ê£ÄÊü•ÊòØÂê¶ÊòØÊï¥Êï∞Á±ªÂûãÔºàstep‰∏∫1Ë°®Á§∫Êï¥Êï∞Ôºâ
                                    arguments[input.name] = input.step === '1' ? parseInt(value) : numValue;
                                }
                            }
                            break;
                        case 'checkbox':
                            arguments[input.name] = input.checked;
                            break;
                        case 'text':
                            if (value !== '') {
                                // Â∞ùËØïËß£ÊûêJSONÊï∞ÁªÑ
                                if (value.startsWith('[') && value.endsWith(']')) {
                                    try {
                                        arguments[input.name] = JSON.parse(value);
                                    } catch (e) {
                                        arguments[input.name] = value;
                                    }
                                } else {
                                    arguments[input.name] = value;
                                }
                            }
                            break;
                        default:
                            if (value !== '') {
                                arguments[input.name] = value;
                            }
                    }
                } else if (property.default !== undefined) {
                    // Â¶ÇÊûúÊ≤°ÊúâËæìÂÖ•ÂÄº‰ΩÜÊúâÈªòËÆ§ÂÄºÔºå‰ΩøÁî®ÈªòËÆ§ÂÄº
                    arguments[input.name] = property.default;
                }
            });

            const resultElement = document.getElementById('result-' + toolName);
            resultElement.style.display = 'block';
            resultElement.className = 'result';

            // Êõ¥Êñ∞ÊåâÈíÆ‰∏∫ÂÅúÊ≠¢Áä∂ÊÄÅ
            buttonElement.textContent = 'ÂÅúÊ≠¢';
            buttonElement.style.background = '#f56565';

            resultElement.innerHTML = 'üîÑ ‰ΩøÁî®OpenAIÊ†ºÂºèÊµÅÂºèËæìÂá∫ÊµãËØï‰∏≠...';
            await testToolWithOpenAISSE(toolName, arguments, resultElement, buttonElement);
        }

        // ‰ΩøÁî®OpenAIÊ†ºÂºèSSEÊµãËØïÂ∑•ÂÖ∑
        async function testToolWithOpenAISSE(toolName, arguments, resultElement, buttonElement) {
            try {
                console.log('Creating OpenAI SSE request for tool:', toolName, 'with arguments:', arguments);
                console.log('OpenAI SSE URL:', ENDPOINTS.openaiSSE);

                // ÂàõÂª∫AbortControllerÁî®‰∫éÂèñÊ∂àËØ∑Ê±Ç
                const abortController = new AbortController();

                const response = await fetch(ENDPOINTS.openaiSSE, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        tool_name: toolName,
                        arguments: arguments
                    }),
                    signal: abortController.signal
                }).catch(error => {
                    console.error('Fetch error details:', error);
                    console.error('Error name:', error.name);
                    console.error('Error message:', error.message);
                    throw error;
                });

                console.log('OpenAI SSE response status:', response.status);
                console.log('OpenAI SSE response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }

                // Ëé∑Âèñ‰ºöËØùID
                const sessionId = response.headers.get('X-Session-ID');
                console.log('OpenAI Session ID:', sessionId);

                console.log('Starting to read OpenAI SSE stream...');
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                // Ê≥®ÂÜåÊ¥ªË∑ÉOpenAIÊµÅÂºè‰ºöËØù
                activeOpenAIStreams.set(toolName, {
                    sessionId: sessionId,
                    reader: reader,
                    abortController: abortController
                });
                let buffer = '';
                let output = '';
                let eventLog = [];

                resultElement.innerHTML = '<strong>üîÑ OpenAIÊ†ºÂºèSSEÊµÅÂºèËæìÂá∫:</strong><div id="openai-streaming-container"><pre id="openai-streaming-output"></pre><div id="openai-event-log"></div></div>';
                const outputElement = document.getElementById('openai-streaming-output');
                const eventLogElement = document.getElementById('openai-event-log');

                try {
                    while (true) {
                         const { done, value } = await reader.read();
                         console.log('OpenAI Stream read result:', { done, valueLength: value ? value.length : 0 });

                         if (done) {
                             console.log('OpenAI Stream reading completed');
                             break;
                         }

                         buffer += decoder.decode(value, { stream: true });
                         console.log('OpenAI Current buffer:', buffer);

                         const lines = buffer.split('\n');
                         buffer = lines.pop(); // ‰øùÁïô‰∏çÂÆåÊï¥ÁöÑË°å

                    for (const line of lines) {
                        console.log('Processing OpenAI line:', line);
                        if (line.trim() === '') continue;

                        if (line.startsWith('event:')) {
                            const eventType = line.substring(6).trim();
                            eventLog.push('[Event: ' + eventType + ']');
                            console.log('OpenAI SSE Event:', eventType);
                        } else if (line.startsWith('data:')) {
                            const data = line.substring(5).trim();
                            console.log('OpenAI SSE Raw Data:', data);
                            
                            // Â§ÑÁêÜOpenAIÊ†ºÂºèÁöÑÁâπÊÆäÁªìÊùüÊ†áËÆ∞
                            if (data === '[DONE]') {
                                eventLog.push('[OpenAI DONE Signal]');
                                console.log('OpenAI stream completed with DONE signal');
                                break;
                            }
                            
                            try {
                                const eventData = JSON.parse(data);
                                console.log('OpenAI SSE Parsed Data:', eventData);
                                eventLog.push('[Data: ' + JSON.stringify(eventData) + ']');

                                // Â§ÑÁêÜOpenAIÊ†ºÂºèÁöÑÊµÅÂºèÊï∞ÊçÆ
                                if (eventData.choices && eventData.choices[0] && eventData.choices[0].delta) {
                                    const delta = eventData.choices[0].delta;
                                    if (delta.content) {
                                        output += delta.content;
                                        outputElement.textContent = output;
                                        outputElement.scrollTop = outputElement.scrollHeight;
                                    }
                                    if (delta.tool_calls) {
                                        // Â§ÑÁêÜÂ∑•ÂÖ∑Ë∞ÉÁî®
                                        output += '\n[Tool Call: ' + JSON.stringify(delta.tool_calls, null, 2) + ']\n';
                                        outputElement.textContent = output;
                                        outputElement.scrollTop = outputElement.scrollHeight;
                                    }
                                } else if (eventData.chunk) {
                                    // ÂÖºÂÆπÂéüÊúâÊ†ºÂºè
                                    output += eventData.chunk + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                } else if (eventData.error) {
                                    resultElement.className = 'result error';
                                    resultElement.innerHTML = '<strong>‚ùå OpenAI SSEÈîôËØØ:</strong> ' + eventData.error;
                                    return;
                                } else {
                                    // ÊòæÁ§∫ÂÖ∂‰ªñÁ±ªÂûãÁöÑÊï∞ÊçÆ
                                    output += JSON.stringify(eventData, null, 2) + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                }
                            } catch (e) {
                                // Â¶ÇÊûú‰∏çÊòØJSONÔºåÁõ¥Êé•ÊòæÁ§∫ÂéüÂßãÊï∞ÊçÆ
                                output += data + '\n';
                                outputElement.textContent = output;
                                outputElement.scrollTop = outputElement.scrollHeight;
                                eventLog.push('[Raw Data: ' + data + ']');
                            }
                        }

                        // Êõ¥Êñ∞‰∫ã‰ª∂Êó•Âøó
                        eventLogElement.innerHTML = '<details><summary>OpenAI‰∫ã‰ª∂Êó•Âøó (' + eventLog.length + ')</summary><pre>' + eventLog.join('\\n') + '</pre></details>';
                    }
                }

                resultElement.className = 'result success';
                if (output.trim()) {
                    resultElement.innerHTML = '<strong>‚úÖ OpenAI SSEÊàêÂäü:</strong><pre>' + output + '</pre>';
                } else {
                    resultElement.innerHTML = '<strong>‚úÖ OpenAI SSEÂÆåÊàê:</strong> OpenAIÊ†ºÂºèÊµÅÂºè‰º†ËæìÂ∑≤ÂÆåÊàêÔºå‰ΩÜÊ≤°ÊúâÊé•Êî∂Âà∞Êï∞ÊçÆÂÜÖÂÆπ„ÄÇ<br>' + eventLogElement.innerHTML;
                }

                // Ê∏ÖÁêÜ‰ºöËØùÂπ∂ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                activeOpenAIStreams.delete(toolName);
                buttonElement.textContent = 'OpenAIÊ†ºÂºè';
                buttonElement.style.background = '#10b981';

            } catch (streamError) {
                    console.error('Error reading OpenAI SSE stream:', streamError);
                    resultElement.className = 'result error';

                    // Ê£ÄÊü•ÊòØÂê¶ÊòØÁî®Êà∑‰∏ªÂä®ÂèñÊ∂à
                    if (streamError.name === 'AbortError') {
                        resultElement.innerHTML = '<strong>üõë Â∑≤ÂÅúÊ≠¢:</strong> OpenAIÊ†ºÂºèÊµÅÂºèËæìÂá∫Â∑≤Ë¢´Áî®Êà∑ÂÅúÊ≠¢';
                    } else {
                        resultElement.innerHTML = '<strong>üö´ OpenAI SSEÊµÅËØªÂèñÂ§±Ë¥•:</strong> ' + streamError.message;
                    }

                    // Ê∏ÖÁêÜ‰ºöËØùÂπ∂ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                    activeOpenAIStreams.delete(toolName);
                    buttonElement.textContent = 'OpenAIÊ†ºÂºè';
                    buttonElement.style.background = '#10b981';
                }

            } catch (error) {
                console.error('OpenAI SSE request failed:', error);
                resultElement.className = 'result error';

                // Ê£ÄÊü•ÊòØÂê¶ÊòØÁî®Êà∑‰∏ªÂä®ÂèñÊ∂à
                if (error.name === 'AbortError') {
                    resultElement.innerHTML = '<strong>üõë Â∑≤ÂÅúÊ≠¢:</strong> OpenAIÊ†ºÂºèÊµÅÂºèËæìÂá∫Â∑≤Ë¢´Áî®Êà∑ÂÅúÊ≠¢';
                } else {
                    resultElement.innerHTML = '<strong>üö´ OpenAI SSEËØ∑Ê±ÇÂ§±Ë¥•:</strong> ' + error.message;
                }

                // Ê∏ÖÁêÜ‰ºöËØùÂπ∂ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                activeOpenAIStreams.delete(toolName);
                buttonElement.textContent = 'OpenAIÊ†ºÂºè';
                buttonElement.style.background = '#10b981';
            }
        }

        // ‰ΩøÁî®SSEÊµãËØïÂ∑•ÂÖ∑
        async function testToolWithSSE(toolName, arguments, resultElement, buttonElement) {
            try {
                console.log('Creating SSE request for tool:', toolName, 'with arguments:', arguments);

                // ÂàõÂª∫AbortControllerÁî®‰∫éÂèñÊ∂àËØ∑Ê±Ç
                const abortController = new AbortController();

                const response = await fetch('/sse/tool/call', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        tool_name: toolName,
                        arguments: arguments
                    }),
                    signal: abortController.signal
                });

                console.log('SSE response status:', response.status);
                console.log('SSE response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }

                // Ëé∑Âèñ‰ºöËØùID
                const sessionId = response.headers.get('X-Session-ID');
                console.log('Session ID:', sessionId);

                console.log('Starting to read SSE stream...');
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                // Ê≥®ÂÜåÊ¥ªË∑ÉÊµÅÂºè‰ºöËØù
                activeStreams.set(toolName, {
                    sessionId: sessionId,
                    reader: reader,
                    abortController: abortController
                });
                let buffer = '';
                let output = '';
                let eventLog = [];

                resultElement.innerHTML = '<strong>üîÑ SSEÊµÅÂºèËæìÂá∫:</strong><div id="streaming-container"><pre id="streaming-output"></pre><div id="event-log"></div></div>';
                const outputElement = document.getElementById('streaming-output');
                const eventLogElement = document.getElementById('event-log');

                try {
                    while (true) {
                         const { done, value } = await reader.read();
                         console.log('Stream read result:', { done, valueLength: value ? value.length : 0 });

                         if (done) {
                             console.log('Stream reading completed');
                             break;
                         }

                         buffer += decoder.decode(value, { stream: true });
                         console.log('Current buffer:', buffer);

                         const lines = buffer.split('\n');
                         buffer = lines.pop(); // ‰øùÁïô‰∏çÂÆåÊï¥ÁöÑË°å

                    for (const line of lines) {
                        console.log('Processing line:', line);
                        if (line.trim() === '') continue;

                        if (line.startsWith('event:')) {
                            const eventType = line.substring(6).trim();
                            eventLog.push('[Event: ' + eventType + ']');
                            console.log('SSE Event:', eventType);
                        } else if (line.startsWith('data:')) {
                            const data = line.substring(5).trim();
                            console.log('SSE Raw Data:', data);
                            try {
                                const eventData = JSON.parse(data);
                                console.log('SSE Parsed Data:', eventData);
                                eventLog.push('[Data: ' + JSON.stringify(eventData) + ']');

                                if (eventData.chunk) {
                                    output += eventData.chunk + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                } else if (eventData.error) {
                                    resultElement.className = 'result error';
                                    resultElement.innerHTML = '<strong>‚ùå SSEÈîôËØØ:</strong> ' + eventData.error;
                                    return;
                                } else if (eventData.type) {
                                    // Â§ÑÁêÜÊµÅÂºèÂ∑•ÂÖ∑ÁöÑÁªìÊûÑÂåñÊï∞ÊçÆ
                                    if (eventData.type === 'progress') {
                                        output += 'üîÑ ' + eventData.message + '\n';
                                    } else if (eventData.type === 'data') {
                                        output += 'üìä ' + eventData.field + ': ' + eventData.value + '\n';
                                    } else if (eventData.type === 'result') {
                                        output += '‚úÖ ÊúÄÁªàÁªìÊûú:\n' + JSON.stringify(eventData.data, null, 2) + '\n';
                                    } else {
                                        output += '[' + eventData.type + '] ' + JSON.stringify(eventData, null, 2) + '\n';
                                    }
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                } else {
                                    // ÊòæÁ§∫ÂÖ∂‰ªñÁ±ªÂûãÁöÑÊï∞ÊçÆ
                                    output += JSON.stringify(eventData, null, 2) + '\n';
                                    outputElement.textContent = output;
                                    outputElement.scrollTop = outputElement.scrollHeight;
                                }
                            } catch (e) {
                                // Â¶ÇÊûú‰∏çÊòØJSONÔºåÁõ¥Êé•ÊòæÁ§∫ÂéüÂßãÊï∞ÊçÆ
                                output += data + '\n';
                                outputElement.textContent = output;
                                outputElement.scrollTop = outputElement.scrollHeight;
                                eventLog.push('[Raw Data: ' + data + ']');
                            }
                        }

                        // Êõ¥Êñ∞‰∫ã‰ª∂Êó•Âøó
                        eventLogElement.innerHTML = '<details><summary>‰∫ã‰ª∂Êó•Âøó (' + eventLog.length + ')</summary><pre>' + eventLog.join('\\n') + '</pre></details>';
                    }
                }

                resultElement.className = 'result success';
                if (output.trim()) {
                    resultElement.innerHTML = '<strong>‚úÖ SSEÊàêÂäü:</strong><pre>' + output + '</pre>';
                } else {
                    resultElement.innerHTML = '<strong>‚úÖ SSEÂÆåÊàê:</strong> ÊµÅÂºè‰º†ËæìÂ∑≤ÂÆåÊàêÔºå‰ΩÜÊ≤°ÊúâÊé•Êî∂Âà∞Êï∞ÊçÆÂÜÖÂÆπ„ÄÇ<br>' + eventLogElement.innerHTML;
                }

                // Ê∏ÖÁêÜ‰ºöËØùÂπ∂ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                activeStreams.delete(toolName);
                buttonElement.textContent = 'ÊµãËØï';
                buttonElement.style.background = '#4299e1';

            } catch (streamError) {
                    console.error('Error reading SSE stream:', streamError);
                    resultElement.className = 'result error';

                    // Ê£ÄÊü•ÊòØÂê¶ÊòØÁî®Êà∑‰∏ªÂä®ÂèñÊ∂à
                    if (streamError.name === 'AbortError') {
                        resultElement.innerHTML = '<strong>üõë Â∑≤ÂÅúÊ≠¢:</strong> ÊµÅÂºèËæìÂá∫Â∑≤Ë¢´Áî®Êà∑ÂÅúÊ≠¢';
                    } else {
                        resultElement.innerHTML = '<strong>üö´ SSEÊµÅËØªÂèñÂ§±Ë¥•:</strong> ' + streamError.message;
                    }

                    // Ê∏ÖÁêÜ‰ºöËØùÂπ∂ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                    activeStreams.delete(toolName);
                    buttonElement.textContent = 'ÊµãËØï';
                    buttonElement.style.background = '#4299e1';
                }

            } catch (error) {
                console.error('SSE request failed:', error);
                resultElement.className = 'result error';

                // Ê£ÄÊü•ÊòØÂê¶ÊòØÁî®Êà∑‰∏ªÂä®ÂèñÊ∂à
                if (error.name === 'AbortError') {
                    resultElement.innerHTML = '<strong>üõë Â∑≤ÂÅúÊ≠¢:</strong> ÊµÅÂºèËæìÂá∫Â∑≤Ë¢´Áî®Êà∑ÂÅúÊ≠¢';
                } else {
                    resultElement.innerHTML = '<strong>üö´ SSEËØ∑Ê±ÇÂ§±Ë¥•:</strong> ' + error.message;
                }

                // Ê∏ÖÁêÜ‰ºöËØùÂπ∂ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                activeStreams.delete(toolName);
                buttonElement.textContent = 'ÊµãËØï';
                buttonElement.style.background = '#4299e1';
            }
        }

        // Âä†ËΩΩËµÑÊ∫êÂàóË°®
        async function loadResources() {
            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 2,
                        method: 'resources/list'
                    })
                });

                const result = await response.json();

                if (result.result && result.result.resources) {
                    renderResources(result.result.resources);
                } else {
                    showEmptyState('resources-container', 'üìÅ', 'ÊöÇÊó†ÂèØÁî®ËµÑÊ∫ê');
                }
            } catch (error) {
                console.error('Failed to load resources:', error);
                showEmptyState('resources-container', '‚ùå', 'Âä†ËΩΩËµÑÊ∫êÂ§±Ë¥•');
            }
        }

        // Ê∏≤ÊüìËµÑÊ∫ê
        function renderResources(resources) {
            const container = document.getElementById('resources-container');
            container.innerHTML = '';

            if (resources.length === 0) {
                showEmptyState('resources-container', 'üìÅ', 'ÊöÇÊó†ÂèØÁî®ËµÑÊ∫ê');
                return;
            }

            resources.forEach(resource => {
                const resourceCard = document.createElement('div');
                resourceCard.className = 'resource-card';

                const resourceName = document.createElement('div');
                resourceName.className = 'resource-name';
                resourceName.textContent = resource.name;

                const resourceDescription = document.createElement('div');
                resourceDescription.className = 'resource-description';
                resourceDescription.textContent = resource.description;

                const resourceUri = document.createElement('div');
                resourceUri.innerHTML = '<strong>URI:</strong> ' + resource.uri;

                const testButton = document.createElement('button');
                testButton.textContent = 'ËØªÂèñËµÑÊ∫ê';
                testButton.onclick = () => testResource(resource.uri);

                const result = document.createElement('div');
                result.className = 'result';
                result.id = 'resource-result-' + resource.uri.replace(/[^a-zA-Z0-9]/g, '');

                resourceCard.appendChild(resourceName);
                resourceCard.appendChild(resourceDescription);
                resourceCard.appendChild(resourceUri);
                resourceCard.appendChild(testButton);
                resourceCard.appendChild(result);
                container.appendChild(resourceCard);
            });
        }

        // ÊµãËØïËµÑÊ∫ê
        async function testResource(uri) {
            const resultElement = document.getElementById('resource-result-' + uri.replace(/[^a-zA-Z0-9]/g, ''));
            resultElement.style.display = 'block';
            resultElement.className = 'result';
            resultElement.innerHTML = 'üîÑ ËØªÂèñ‰∏≠...';

            try {
                const response = await fetch('/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: Date.now(),
                        method: 'resources/read',
                        params: {
                            uri: uri
                        }
                    })
                });

                const result = await response.json();

                if (result.result) {
                    resultElement.className = 'result success';
                    resultElement.innerHTML = '<strong>‚úÖ ÊàêÂäü:</strong><pre>' + JSON.stringify(result.result, null, 2) + '</pre>';
                } else if (result.error) {
                    resultElement.className = 'result error';
                    resultElement.innerHTML = '<strong>‚ùå ÈîôËØØ:</strong> ' + result.error.message;
                }
            } catch (error) {
                resultElement.className = 'result error';
                resultElement.innerHTML = '<strong>üö´ ËØ∑Ê±ÇÂ§±Ë¥•:</strong> ' + error.message;
            }
        }

        // ÊòæÁ§∫Á©∫Áä∂ÊÄÅ
        function showEmptyState(containerId, icon, message) {
            const container = document.getElementById(containerId);
            container.innerHTML = '<div class="empty-state"><div class="icon">' + icon + '</div><p>' + message + '</p></div>';
        }
    </script>
</body>
</html>