"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .stream import Stream, StreamTypedDict
from plex_api_client.types import BaseModel
import pydantic
from pydantic import ConfigDict
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class PartTypedDict(TypedDict):
    r"""`Part` represents a particular file or \"part\" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part."""

    audio_profile: NotRequired[Any]
    container: NotRequired[Any]
    r"""The container of the media file, such as `mp4` or `mkv`"""
    duration: NotRequired[int]
    r"""The duration of the media item, in milliseconds"""
    file: NotRequired[Any]
    r"""The local file path at which the part is stored on the server"""
    has64bit_offsets: NotRequired[bool]
    id: NotRequired[int]
    key: NotRequired[Any]
    r"""The key from which the media can be streamed"""
    optimized_for_streaming: NotRequired[bool]
    size: NotRequired[int]
    r"""The size of the media, in bytes"""
    stream: NotRequired[List[StreamTypedDict]]
    video_profile: NotRequired[Any]


class Part(BaseModel):
    r"""`Part` represents a particular file or \"part\" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    audio_profile: Annotated[Optional[Any], pydantic.Field(alias="audioProfile")] = None

    container: Optional[Any] = None
    r"""The container of the media file, such as `mp4` or `mkv`"""

    duration: Optional[int] = None
    r"""The duration of the media item, in milliseconds"""

    file: Optional[Any] = None
    r"""The local file path at which the part is stored on the server"""

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    id: Optional[int] = None

    key: Optional[Any] = None
    r"""The key from which the media can be streamed"""

    optimized_for_streaming: Annotated[
        Optional[bool], pydantic.Field(alias="optimizedForStreaming")
    ] = None

    size: Optional[int] = None
    r"""The size of the media, in bytes"""

    stream: Annotated[Optional[List[Stream]], pydantic.Field(alias="Stream")] = None

    video_profile: Annotated[Optional[Any], pydantic.Field(alias="videoProfile")] = None

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]
