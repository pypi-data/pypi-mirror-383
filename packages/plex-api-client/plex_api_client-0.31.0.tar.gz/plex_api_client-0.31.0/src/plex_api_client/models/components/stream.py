"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from plex_api_client.types import BaseModel
import pydantic
from pydantic import ConfigDict
from typing import Any, Dict, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class StreamTypedDict(TypedDict):
    r"""`Stream` represents a particular stream from a media item, such as the video stream, audio stream, or subtitle stream. The stream may either be part of the file represented by the parent `Part` or, especially for subtitles, an external file. The stream contains more detailed information about the specific stream. For example, a video may include the `aspectRatio` at the `Media` level, but detailed information about the video stream like the color space will be included on the `Stream` for the video stream.  Note that photos do not have streams (mostly as an optimization)."""

    default: NotRequired[bool]
    audio_channel_layout: NotRequired[Any]
    bit_depth: NotRequired[int]
    bitrate: NotRequired[int]
    can_auto_sync: NotRequired[bool]
    r"""For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video."""
    chroma_location: NotRequired[Any]
    chroma_subsampling: NotRequired[Any]
    codec: NotRequired[Any]
    r"""The codec of the stream, such as `h264` or `aac`"""
    color_primaries: NotRequired[Any]
    color_range: NotRequired[Any]
    color_space: NotRequired[Any]
    color_trc: NotRequired[Any]
    display_title: NotRequired[Any]
    r"""A friendly name for the stream, often comprised of the language and codec information"""
    frame_rate: NotRequired[float]
    has_scaling_matrix: NotRequired[Any]
    height: NotRequired[int]
    id: NotRequired[int]
    index: NotRequired[int]
    r"""If the stream is part of the `Part` and not an external resource, the index of the stream within that part"""
    key: NotRequired[Any]
    r"""If the stream is independently streamable, the key from which it can be streamed"""
    language: NotRequired[Any]
    language_code: NotRequired[Any]
    r"""The three character language code for the stream contents"""
    level: NotRequired[int]
    profile: NotRequired[Any]
    ref_frames: NotRequired[int]
    sampling_rate: NotRequired[int]
    selected: NotRequired[bool]
    stream_identifier: NotRequired[int]
    stream_type: NotRequired[int]
    r"""A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics"""
    width: NotRequired[int]


class Stream(BaseModel):
    r"""`Stream` represents a particular stream from a media item, such as the video stream, audio stream, or subtitle stream. The stream may either be part of the file represented by the parent `Part` or, especially for subtitles, an external file. The stream contains more detailed information about the specific stream. For example, a video may include the `aspectRatio` at the `Media` level, but detailed information about the video stream like the color space will be included on the `Stream` for the video stream.  Note that photos do not have streams (mostly as an optimization)."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    default: Optional[bool] = None

    audio_channel_layout: Annotated[
        Optional[Any], pydantic.Field(alias="audioChannelLayout")
    ] = None

    bit_depth: Annotated[Optional[int], pydantic.Field(alias="bitDepth")] = None

    bitrate: Optional[int] = None

    can_auto_sync: Annotated[Optional[bool], pydantic.Field(alias="canAutoSync")] = None
    r"""For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video."""

    chroma_location: Annotated[
        Optional[Any], pydantic.Field(alias="chromaLocation")
    ] = None

    chroma_subsampling: Annotated[
        Optional[Any], pydantic.Field(alias="chromaSubsampling")
    ] = None

    codec: Optional[Any] = None
    r"""The codec of the stream, such as `h264` or `aac`"""

    color_primaries: Annotated[
        Optional[Any], pydantic.Field(alias="colorPrimaries")
    ] = None

    color_range: Annotated[Optional[Any], pydantic.Field(alias="colorRange")] = None

    color_space: Annotated[Optional[Any], pydantic.Field(alias="colorSpace")] = None

    color_trc: Annotated[Optional[Any], pydantic.Field(alias="colorTrc")] = None

    display_title: Annotated[Optional[Any], pydantic.Field(alias="displayTitle")] = None
    r"""A friendly name for the stream, often comprised of the language and codec information"""

    frame_rate: Annotated[Optional[float], pydantic.Field(alias="frameRate")] = None

    has_scaling_matrix: Annotated[
        Optional[Any], pydantic.Field(alias="hasScalingMatrix")
    ] = None

    height: Optional[int] = None

    id: Optional[int] = None

    index: Optional[int] = None
    r"""If the stream is part of the `Part` and not an external resource, the index of the stream within that part"""

    key: Optional[Any] = None
    r"""If the stream is independently streamable, the key from which it can be streamed"""

    language: Optional[Any] = None

    language_code: Annotated[Optional[Any], pydantic.Field(alias="languageCode")] = None
    r"""The three character language code for the stream contents"""

    level: Optional[int] = None

    profile: Optional[Any] = None

    ref_frames: Annotated[Optional[int], pydantic.Field(alias="refFrames")] = None

    sampling_rate: Annotated[Optional[int], pydantic.Field(alias="samplingRate")] = None

    selected: Optional[bool] = None

    stream_identifier: Annotated[
        Optional[int], pydantic.Field(alias="streamIdentifier")
    ] = None

    stream_type: Annotated[Optional[int], pydantic.Field(alias="streamType")] = None
    r"""A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics"""

    width: Optional[int] = None

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]
