"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import httpx
from plex_api_client.models.components import (
    accepts as components_accepts,
    boolint as components_boolint,
    metadata as components_metadata,
)
from plex_api_client.types import BaseModel
from plex_api_client.utils import (
    FieldMetadata,
    HeaderMetadata,
    PathParamMetadata,
    QueryParamMetadata,
)
import pydantic
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetLibraryDetailsGlobalsTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""


class GetLibraryDetailsGlobals(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""


class GetLibraryDetailsRequestTypedDict(TypedDict):
    section_id: str
    r"""The section identifier"""
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""
    include_details: NotRequired[components_boolint.BoolInt]
    r"""Whether or not to include details for a section (types, filters, and sorts). Only exists for backwards compatibility, media providers other than the server libraries have it on always."""


class GetLibraryDetailsRequest(BaseModel):
    section_id: Annotated[
        str,
        pydantic.Field(alias="sectionId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The section identifier"""

    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""

    include_details: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="includeDetails"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Whether or not to include details for a section (types, filters, and sorts). Only exists for backwards compatibility, media providers other than the server libraries have it on always."""


class GetLibraryDetailsMediaContainerTypedDict(TypedDict):
    content: NotRequired[str]
    r"""The flavors of directory found here:
    - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
    - Secondary: These are marked with `\"secondary\": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
    - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `\"search\": true` which used to be used to allow clients to build search dialogs on the fly.
    """
    allow_sync: NotRequired[bool]
    art: NotRequired[str]
    directory: NotRequired[List[components_metadata.MetadataTypedDict]]
    identifier: NotRequired[str]
    library_section_id: NotRequired[int]
    media_tag_prefix: NotRequired[str]
    media_tag_version: NotRequired[int]
    size: NotRequired[int]
    sort_asc: NotRequired[bool]
    thumb: NotRequired[str]
    title1: NotRequired[str]
    view_group: NotRequired[str]
    view_mode: NotRequired[int]


class GetLibraryDetailsMediaContainer(BaseModel):
    content: Optional[str] = None
    r"""The flavors of directory found here:
    - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
    - Secondary: These are marked with `\"secondary\": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
    - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `\"search\": true` which used to be used to allow clients to build search dialogs on the fly.
    """

    allow_sync: Annotated[Optional[bool], pydantic.Field(alias="allowSync")] = None

    art: Optional[str] = None

    directory: Annotated[
        Optional[List[components_metadata.Metadata]], pydantic.Field(alias="Directory")
    ] = None

    identifier: Optional[str] = None

    library_section_id: Annotated[
        Optional[int], pydantic.Field(alias="librarySectionID")
    ] = None

    media_tag_prefix: Annotated[
        Optional[str], pydantic.Field(alias="mediaTagPrefix")
    ] = None

    media_tag_version: Annotated[
        Optional[int], pydantic.Field(alias="mediaTagVersion")
    ] = None

    size: Optional[int] = None

    sort_asc: Annotated[Optional[bool], pydantic.Field(alias="sortAsc")] = None

    thumb: Optional[str] = None

    title1: Optional[str] = None

    view_group: Annotated[Optional[str], pydantic.Field(alias="viewGroup")] = None

    view_mode: Annotated[Optional[int], pydantic.Field(alias="viewMode")] = None


class GetLibraryDetailsResponseBodyTypedDict(TypedDict):
    r"""OK"""

    media_container: NotRequired[GetLibraryDetailsMediaContainerTypedDict]


class GetLibraryDetailsResponseBody(BaseModel):
    r"""OK"""

    media_container: Annotated[
        Optional[GetLibraryDetailsMediaContainer],
        pydantic.Field(alias="MediaContainer"),
    ] = None


class GetLibraryDetailsResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetLibraryDetailsResponseBodyTypedDict]
    r"""OK"""


class GetLibraryDetailsResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetLibraryDetailsResponseBody] = None
    r"""OK"""
