"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import httpx
from plex_api_client.models.components import (
    accepts as components_accepts,
    boolint as components_boolint,
)
from plex_api_client.types import BaseModel
from plex_api_client.utils import FieldMetadata, HeaderMetadata, QueryParamMetadata
import pydantic
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class ReportGlobalsTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""


class ReportGlobals(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""


class State(str, Enum):
    r"""The current state of the media."""

    STOPPED = "stopped"
    BUFFERING = "buffering"
    PLAYING = "playing"
    PAUSED = "paused"


class ReportRequestTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""
    key: NotRequired[str]
    r"""The details key for the item."""
    rating_key: NotRequired[str]
    r"""The rating key attribute for the item."""
    state: NotRequired[State]
    r"""The current state of the media."""
    play_queue_item_id: NotRequired[str]
    r"""If playing media from a play queue, the play queue's ID."""
    time: NotRequired[int]
    r"""The current time offset of playback in ms."""
    duration: NotRequired[int]
    r"""The total duration of the item in ms."""
    continuing: NotRequired[components_boolint.BoolInt]
    r"""When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item."""
    updated: NotRequired[int]
    r"""Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated."""
    offline: NotRequired[components_boolint.BoolInt]
    r"""Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being \"live\"."""
    time_to_first_frame: NotRequired[int]
    r"""Time in seconds till first frame is displayed.  Sent only on the first playing timeline request."""
    time_stalled: NotRequired[int]
    r"""Time in seconds spent buffering since last request."""
    bandwidth: NotRequired[int]
    r"""Bandwidth in kbps as estimated by the client."""
    buffered_time: NotRequired[int]
    r"""Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below."""
    buffered_size: NotRequired[int]
    r"""Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above"""
    x_plex_session_identifier: NotRequired[str]
    r"""Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)"""


class ReportRequest(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""

    key: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The details key for the item."""

    rating_key: Annotated[
        Optional[str],
        pydantic.Field(alias="ratingKey"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The rating key attribute for the item."""

    state: Annotated[
        Optional[State],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The current state of the media."""

    play_queue_item_id: Annotated[
        Optional[str],
        pydantic.Field(alias="playQueueItemID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""If playing media from a play queue, the play queue's ID."""

    time: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The current time offset of playback in ms."""

    duration: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The total duration of the item in ms."""

    continuing: Annotated[
        Optional[components_boolint.BoolInt],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item."""

    updated: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated."""

    offline: Annotated[
        Optional[components_boolint.BoolInt],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being \"live\"."""

    time_to_first_frame: Annotated[
        Optional[int],
        pydantic.Field(alias="timeToFirstFrame"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Time in seconds till first frame is displayed.  Sent only on the first playing timeline request."""

    time_stalled: Annotated[
        Optional[int],
        pydantic.Field(alias="timeStalled"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Time in seconds spent buffering since last request."""

    bandwidth: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Bandwidth in kbps as estimated by the client."""

    buffered_time: Annotated[
        Optional[int],
        pydantic.Field(alias="bufferedTime"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below."""

    buffered_size: Annotated[
        Optional[int],
        pydantic.Field(alias="bufferedSize"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above"""

    x_plex_session_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Session-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)"""


class BandwidthTypedDict(TypedDict):
    bandwidth: NotRequired[int]
    r"""The bandwidth at this time in kbps"""
    resolution: NotRequired[str]
    r"""The user-friendly resolution at this time"""
    time: NotRequired[int]
    r"""Media playback time where this bandwidth started"""


class Bandwidth(BaseModel):
    bandwidth: Optional[int] = None
    r"""The bandwidth at this time in kbps"""

    resolution: Optional[str] = None
    r"""The user-friendly resolution at this time"""

    time: Optional[int] = None
    r"""Media playback time where this bandwidth started"""


class BandwidthsTypedDict(TypedDict):
    r"""A list of media times and bandwidths when trascoding is using with auto adjustment of bandwidth"""

    bandwidth: NotRequired[List[BandwidthTypedDict]]


class Bandwidths(BaseModel):
    r"""A list of media times and bandwidths when trascoding is using with auto adjustment of bandwidth"""

    bandwidth: Annotated[
        Optional[List[Bandwidth]], pydantic.Field(alias="Bandwidth")
    ] = None


class MediaContainerTypedDict(TypedDict):
    r"""`MediaContainer` is the root element of most Plex API responses. It serves as a generic container for various types of content (Metadata, Hubs, Directories, etc.) and includes pagination information (offset, size, totalSize) when applicable.
    Common attributes: - identifier: Unique identifier for this container - size: Number of items in this response page - totalSize: Total number of items available (for pagination) - offset: Starting index of this page (for pagination)
    The container often \"hoists\" common attributes from its children. For example, if all tracks in a container share the same album title, the `parentTitle` attribute may appear on the MediaContainer rather than being repeated on each track.

    """

    identifier: NotRequired[str]
    offset: NotRequired[int]
    r"""The offset of where this container page starts among the total objects available. Also provided in the `X-Plex-Container-Start` header.

    """
    size: NotRequired[int]
    total_size: NotRequired[int]
    r"""The total size of objects available. Also provided in the `X-Plex-Container-Total-Size` header.

    """
    allow_camera_upload: NotRequired[bool]
    allow_channel_access: NotRequired[bool]
    allow_media_deletion: NotRequired[bool]
    allow_sharing: NotRequired[bool]
    allow_sync: NotRequired[bool]
    allow_tuners: NotRequired[bool]
    background_processing: NotRequired[bool]
    certificate: NotRequired[bool]
    companion_proxy: NotRequired[bool]
    country_code: NotRequired[str]
    diagnostics: NotRequired[str]
    event_stream: NotRequired[bool]
    friendly_name: NotRequired[str]
    hub_search: NotRequired[bool]
    item_clusters: NotRequired[bool]
    livetv: NotRequired[int]
    machine_identifier: NotRequired[Any]
    media_providers: NotRequired[bool]
    multiuser: NotRequired[bool]
    music_analysis: NotRequired[int]
    my_plex: NotRequired[bool]
    my_plex_mapping_state: NotRequired[Any]
    my_plex_signin_state: NotRequired[Any]
    my_plex_subscription: NotRequired[bool]
    my_plex_username: NotRequired[str]
    offline_transcode: NotRequired[Any]
    owner_features: NotRequired[str]
    r"""A comma-separated list of features which are enabled for the server owner"""
    platform: NotRequired[str]
    platform_version: NotRequired[str]
    plugin_host: NotRequired[bool]
    push_notifications: NotRequired[bool]
    read_only_libraries: NotRequired[bool]
    streaming_brain_abr_version: NotRequired[int]
    streaming_brain_version: NotRequired[int]
    sync: NotRequired[bool]
    transcoder_active_video_sessions: NotRequired[int]
    transcoder_audio: NotRequired[bool]
    transcoder_lyrics: NotRequired[bool]
    transcoder_photo: NotRequired[bool]
    transcoder_subtitles: NotRequired[bool]
    transcoder_video: NotRequired[bool]
    transcoder_video_bitrates: NotRequired[Any]
    r"""The suggested video quality bitrates to present to the user"""
    transcoder_video_qualities: NotRequired[str]
    transcoder_video_resolutions: NotRequired[Any]
    r"""The suggested video resolutions to the above quality bitrates"""
    updated_at: NotRequired[int]
    updater: NotRequired[bool]
    version: NotRequired[str]
    voice_search: NotRequired[bool]
    bandwidths: NotRequired[BandwidthsTypedDict]
    r"""A list of media times and bandwidths when trascoding is using with auto adjustment of bandwidth"""
    termination_code: NotRequired[int]
    r"""A code describing why the session was terminated by the server."""
    termination_text: NotRequired[str]
    r"""A user friendly and localized text describing why the session was terminated by the server."""


class MediaContainer(BaseModel):
    r"""`MediaContainer` is the root element of most Plex API responses. It serves as a generic container for various types of content (Metadata, Hubs, Directories, etc.) and includes pagination information (offset, size, totalSize) when applicable.
    Common attributes: - identifier: Unique identifier for this container - size: Number of items in this response page - totalSize: Total number of items available (for pagination) - offset: Starting index of this page (for pagination)
    The container often \"hoists\" common attributes from its children. For example, if all tracks in a container share the same album title, the `parentTitle` attribute may appear on the MediaContainer rather than being repeated on each track.

    """

    identifier: Optional[str] = None

    offset: Optional[int] = None
    r"""The offset of where this container page starts among the total objects available. Also provided in the `X-Plex-Container-Start` header.

    """

    size: Optional[int] = None

    total_size: Annotated[Optional[int], pydantic.Field(alias="totalSize")] = None
    r"""The total size of objects available. Also provided in the `X-Plex-Container-Total-Size` header.

    """

    allow_camera_upload: Annotated[
        Optional[bool], pydantic.Field(alias="allowCameraUpload")
    ] = None

    allow_channel_access: Annotated[
        Optional[bool], pydantic.Field(alias="allowChannelAccess")
    ] = None

    allow_media_deletion: Annotated[
        Optional[bool], pydantic.Field(alias="allowMediaDeletion")
    ] = None

    allow_sharing: Annotated[Optional[bool], pydantic.Field(alias="allowSharing")] = (
        None
    )

    allow_sync: Annotated[Optional[bool], pydantic.Field(alias="allowSync")] = None

    allow_tuners: Annotated[Optional[bool], pydantic.Field(alias="allowTuners")] = None

    background_processing: Annotated[
        Optional[bool], pydantic.Field(alias="backgroundProcessing")
    ] = None

    certificate: Optional[bool] = None

    companion_proxy: Annotated[
        Optional[bool], pydantic.Field(alias="companionProxy")
    ] = None

    country_code: Annotated[Optional[str], pydantic.Field(alias="countryCode")] = None

    diagnostics: Optional[str] = None

    event_stream: Annotated[Optional[bool], pydantic.Field(alias="eventStream")] = None

    friendly_name: Annotated[Optional[str], pydantic.Field(alias="friendlyName")] = None

    hub_search: Annotated[Optional[bool], pydantic.Field(alias="hubSearch")] = None

    item_clusters: Annotated[Optional[bool], pydantic.Field(alias="itemClusters")] = (
        None
    )

    livetv: Optional[int] = None

    machine_identifier: Annotated[
        Optional[Any], pydantic.Field(alias="machineIdentifier")
    ] = None

    media_providers: Annotated[
        Optional[bool], pydantic.Field(alias="mediaProviders")
    ] = None

    multiuser: Optional[bool] = None

    music_analysis: Annotated[Optional[int], pydantic.Field(alias="musicAnalysis")] = (
        None
    )

    my_plex: Annotated[Optional[bool], pydantic.Field(alias="myPlex")] = None

    my_plex_mapping_state: Annotated[
        Optional[Any], pydantic.Field(alias="myPlexMappingState")
    ] = None

    my_plex_signin_state: Annotated[
        Optional[Any], pydantic.Field(alias="myPlexSigninState")
    ] = None

    my_plex_subscription: Annotated[
        Optional[bool], pydantic.Field(alias="myPlexSubscription")
    ] = None

    my_plex_username: Annotated[
        Optional[str], pydantic.Field(alias="myPlexUsername")
    ] = None

    offline_transcode: Annotated[
        Optional[Any], pydantic.Field(alias="offlineTranscode")
    ] = None

    owner_features: Annotated[Optional[str], pydantic.Field(alias="ownerFeatures")] = (
        None
    )
    r"""A comma-separated list of features which are enabled for the server owner"""

    platform: Optional[str] = None

    platform_version: Annotated[
        Optional[str], pydantic.Field(alias="platformVersion")
    ] = None

    plugin_host: Annotated[Optional[bool], pydantic.Field(alias="pluginHost")] = None

    push_notifications: Annotated[
        Optional[bool], pydantic.Field(alias="pushNotifications")
    ] = None

    read_only_libraries: Annotated[
        Optional[bool], pydantic.Field(alias="readOnlyLibraries")
    ] = None

    streaming_brain_abr_version: Annotated[
        Optional[int], pydantic.Field(alias="streamingBrainABRVersion")
    ] = None

    streaming_brain_version: Annotated[
        Optional[int], pydantic.Field(alias="streamingBrainVersion")
    ] = None

    sync: Optional[bool] = None

    transcoder_active_video_sessions: Annotated[
        Optional[int], pydantic.Field(alias="transcoderActiveVideoSessions")
    ] = None

    transcoder_audio: Annotated[
        Optional[bool], pydantic.Field(alias="transcoderAudio")
    ] = None

    transcoder_lyrics: Annotated[
        Optional[bool], pydantic.Field(alias="transcoderLyrics")
    ] = None

    transcoder_photo: Annotated[
        Optional[bool], pydantic.Field(alias="transcoderPhoto")
    ] = None

    transcoder_subtitles: Annotated[
        Optional[bool], pydantic.Field(alias="transcoderSubtitles")
    ] = None

    transcoder_video: Annotated[
        Optional[bool], pydantic.Field(alias="transcoderVideo")
    ] = None

    transcoder_video_bitrates: Annotated[
        Optional[Any], pydantic.Field(alias="transcoderVideoBitrates")
    ] = None
    r"""The suggested video quality bitrates to present to the user"""

    transcoder_video_qualities: Annotated[
        Optional[str], pydantic.Field(alias="transcoderVideoQualities")
    ] = None

    transcoder_video_resolutions: Annotated[
        Optional[Any], pydantic.Field(alias="transcoderVideoResolutions")
    ] = None
    r"""The suggested video resolutions to the above quality bitrates"""

    updated_at: Annotated[Optional[int], pydantic.Field(alias="updatedAt")] = None

    updater: Optional[bool] = None

    version: Optional[str] = None

    voice_search: Annotated[Optional[bool], pydantic.Field(alias="voiceSearch")] = None

    bandwidths: Annotated[Optional[Bandwidths], pydantic.Field(alias="Bandwidths")] = (
        None
    )
    r"""A list of media times and bandwidths when trascoding is using with auto adjustment of bandwidth"""

    termination_code: Annotated[
        Optional[int], pydantic.Field(alias="terminationCode")
    ] = None
    r"""A code describing why the session was terminated by the server."""

    termination_text: Annotated[
        Optional[str], pydantic.Field(alias="terminationText")
    ] = None
    r"""A user friendly and localized text describing why the session was terminated by the server."""


class ReportResponseBodyTypedDict(TypedDict):
    r"""OK"""

    media_container: NotRequired[MediaContainerTypedDict]


class ReportResponseBody(BaseModel):
    r"""OK"""

    media_container: Annotated[
        Optional[MediaContainer], pydantic.Field(alias="MediaContainer")
    ] = None


class ReportResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[ReportResponseBodyTypedDict]
    r"""OK"""


class ReportResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[ReportResponseBody] = None
    r"""OK"""
