"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import httpx
from plex_api_client.models.components import (
    accepts as components_accepts,
    advancedsubtitles as components_advancedsubtitles,
    boolint as components_boolint,
    transcodetype as components_transcodetype,
)
from plex_api_client.types import BaseModel
from plex_api_client.utils import (
    FieldMetadata,
    HeaderMetadata,
    PathParamMetadata,
    QueryParamMetadata,
)
import pydantic
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class StartTranscodeSessionGlobalsTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""


class StartTranscodeSessionGlobals(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""


class Extension(str, Enum):
    r"""Extension"""

    M3U8 = "m3u8"
    MPD = "mpd"


class StartTranscodeSessionQueryParamLocation(str, Enum):
    r"""Network type of the client, can be used to help determine target bitrate."""

    LAN = "lan"
    WAN = "wan"
    CELLULAR = "cellular"


class StartTranscodeSessionQueryParamProtocol(str, Enum):
    r"""Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)"""

    HTTP = "http"
    HLS = "hls"
    DASH = "dash"


class StartTranscodeSessionQueryParamSubtitles(str, Enum):
    r"""Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream"""

    AUTO = "auto"
    BURN = "burn"
    NONE = "none"
    SIDECAR = "sidecar"
    EMBEDDED = "embedded"
    SEGMENTED = "segmented"
    UNKNOWN = "unknown"


class StartTranscodeSessionRequestTypedDict(TypedDict):
    transcode_type: components_transcodetype.TranscodeType
    r"""Type of transcode media"""
    extension: Extension
    r"""Extension

    """
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""
    transcode_session_id: NotRequired[str]
    r"""Transcode session UUID"""
    advanced_subtitles: NotRequired[components_advancedsubtitles.AdvancedSubtitles]
    r"""Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost

    """
    audio_boost: NotRequired[int]
    r"""Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)"""
    audio_channel_count: NotRequired[int]
    r"""Target video number of audio channels."""
    auto_adjust_quality: NotRequired[components_boolint.BoolInt]
    r"""Indicates the client supports ABR."""
    auto_adjust_subtitle: NotRequired[components_boolint.BoolInt]
    r"""Indicates if the server should adjust subtitles based on Voice Activity Data."""
    direct_play: NotRequired[components_boolint.BoolInt]
    r"""Indicates the client supports direct playing the indicated content."""
    direct_stream: NotRequired[components_boolint.BoolInt]
    r"""Indicates the client supports direct streaming the video of the indicated content."""
    direct_stream_audio: NotRequired[components_boolint.BoolInt]
    r"""Indicates the client supports direct streaming the audio of the indicated content."""
    disable_resolution_rotation: NotRequired[components_boolint.BoolInt]
    r"""Indicates if resolution should be adjusted for orientation."""
    has_mde: NotRequired[components_boolint.BoolInt]
    r"""Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1"""
    location: NotRequired[StartTranscodeSessionQueryParamLocation]
    r"""Network type of the client, can be used to help determine target bitrate."""
    media_buffer_size: NotRequired[int]
    r"""Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks."""
    media_index: NotRequired[int]
    r"""Index of the media to transcode. -1 or not specified indicates let the server choose."""
    music_bitrate: NotRequired[int]
    r"""Target bitrate for audio only files (in kbps, used to transcode)."""
    offset: NotRequired[float]
    r"""Offset from the start of the media (in seconds)."""
    part_index: NotRequired[int]
    r"""Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode"""
    path: NotRequired[str]
    r"""Internal PMS path of the media to transcode."""
    peak_bitrate: NotRequired[int]
    r"""Maximum bitrate (in kbps) to use in ABR."""
    photo_resolution: NotRequired[str]
    r"""Target photo resolution."""
    protocol: NotRequired[StartTranscodeSessionQueryParamProtocol]
    r"""Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)

    """
    seconds_per_segment: NotRequired[int]
    r"""Number of seconds to include in each transcoded segment"""
    subtitle_size: NotRequired[int]
    r"""Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)"""
    subtitles: NotRequired[StartTranscodeSessionQueryParamSubtitles]
    r"""Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream

    """
    video_bitrate: NotRequired[int]
    r"""Target video bitrate (in kbps)."""
    video_quality: NotRequired[int]
    r"""Target photo quality."""
    video_resolution: NotRequired[str]
    r"""Target maximum video resolution."""
    x_plex_client_profile_extra: NotRequired[str]
    r"""See [Profile Augmentations](#section/API-Info/Profile-Augmentations) ."""
    x_plex_client_profile_name: NotRequired[str]
    r"""Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile."""
    x_plex_session_identifier: NotRequired[str]
    r"""Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)"""


class StartTranscodeSessionRequest(BaseModel):
    transcode_type: Annotated[
        components_transcodetype.TranscodeType,
        pydantic.Field(alias="transcodeType"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Type of transcode media"""

    extension: Annotated[
        Extension, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""Extension

    """

    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""

    transcode_session_id: Annotated[
        Optional[str],
        pydantic.Field(alias="transcodeSessionId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Transcode session UUID"""

    advanced_subtitles: Annotated[
        Optional[components_advancedsubtitles.AdvancedSubtitles],
        pydantic.Field(alias="advancedSubtitles"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost

    """

    audio_boost: Annotated[
        Optional[int],
        pydantic.Field(alias="audioBoost"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)"""

    audio_channel_count: Annotated[
        Optional[int],
        pydantic.Field(alias="audioChannelCount"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Target video number of audio channels."""

    auto_adjust_quality: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="autoAdjustQuality"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates the client supports ABR."""

    auto_adjust_subtitle: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="autoAdjustSubtitle"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates if the server should adjust subtitles based on Voice Activity Data."""

    direct_play: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="directPlay"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates the client supports direct playing the indicated content."""

    direct_stream: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="directStream"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates the client supports direct streaming the video of the indicated content."""

    direct_stream_audio: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="directStreamAudio"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates the client supports direct streaming the audio of the indicated content."""

    disable_resolution_rotation: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="disableResolutionRotation"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates if resolution should be adjusted for orientation."""

    has_mde: Annotated[
        Optional[components_boolint.BoolInt],
        pydantic.Field(alias="hasMDE"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1"""

    location: Annotated[
        Optional[StartTranscodeSessionQueryParamLocation],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Network type of the client, can be used to help determine target bitrate."""

    media_buffer_size: Annotated[
        Optional[int],
        pydantic.Field(alias="mediaBufferSize"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks."""

    media_index: Annotated[
        Optional[int],
        pydantic.Field(alias="mediaIndex"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Index of the media to transcode. -1 or not specified indicates let the server choose."""

    music_bitrate: Annotated[
        Optional[int],
        pydantic.Field(alias="musicBitrate"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Target bitrate for audio only files (in kbps, used to transcode)."""

    offset: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Offset from the start of the media (in seconds)."""

    part_index: Annotated[
        Optional[int],
        pydantic.Field(alias="partIndex"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode"""

    path: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Internal PMS path of the media to transcode."""

    peak_bitrate: Annotated[
        Optional[int],
        pydantic.Field(alias="peakBitrate"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Maximum bitrate (in kbps) to use in ABR."""

    photo_resolution: Annotated[
        Optional[str],
        pydantic.Field(alias="photoResolution"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Target photo resolution."""

    protocol: Annotated[
        Optional[StartTranscodeSessionQueryParamProtocol],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)

    """

    seconds_per_segment: Annotated[
        Optional[int],
        pydantic.Field(alias="secondsPerSegment"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Number of seconds to include in each transcoded segment"""

    subtitle_size: Annotated[
        Optional[int],
        pydantic.Field(alias="subtitleSize"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)"""

    subtitles: Annotated[
        Optional[StartTranscodeSessionQueryParamSubtitles],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream

    """

    video_bitrate: Annotated[
        Optional[int],
        pydantic.Field(alias="videoBitrate"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Target video bitrate (in kbps)."""

    video_quality: Annotated[
        Optional[int],
        pydantic.Field(alias="videoQuality"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Target photo quality."""

    video_resolution: Annotated[
        Optional[str],
        pydantic.Field(alias="videoResolution"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Target maximum video resolution."""

    x_plex_client_profile_extra: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Profile-Extra"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""See [Profile Augmentations](#section/API-Info/Profile-Augmentations) ."""

    x_plex_client_profile_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Profile-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile."""

    x_plex_session_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Session-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)"""


class StartTranscodeSessionResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    response_stream: NotRequired[httpx.Response]
    r"""MPD file (see ISO/IEC 23009-1:2022), m3u8 file (see RFC 8216), or binary http stream"""


class StartTranscodeSessionResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    response_stream: Optional[httpx.Response] = None
    r"""MPD file (see ISO/IEC 23009-1:2022), m3u8 file (see RFC 8216), or binary http stream"""
