"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from plex_api_client import utils
from plex_api_client._hooks import HookContext
from plex_api_client.models import errors, operations
from plex_api_client.types import BaseModel, OptionalNullable, UNSET
from typing import Mapping, Optional, Union, cast


class Events(BaseSDK):
    r"""The server can notify clients in real-time of a wide range of events, from library scanning, to preferences being modified, to changes to media, and many other things. This is also the mechanism by which activity progress is reported.

    Two protocols for receiving the events are available: EventSource (also known as SSE), and WebSocket.

    """

    def get_notifications(
        self,
        *,
        request: Union[
            operations.GetNotificationsRequest,
            operations.GetNotificationsRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.GetNotificationsResponse:
        r"""Connect to Eventsource

        Connect to the event source to get a stream of events

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, operations.GetNotificationsRequest)
        request = cast(operations.GetNotificationsRequest, request)

        req = self._build_request(
            method="GET",
            path="/:/eventsource/notifications",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/octet-stream",
            http_headers=http_headers,
            _globals=operations.GetNotificationsGlobals(
                accepts=self.sdk_configuration.globals.accepts,
                client_identifier=self.sdk_configuration.globals.client_identifier,
                product=self.sdk_configuration.globals.product,
                version=self.sdk_configuration.globals.version,
                platform=self.sdk_configuration.globals.platform,
                platform_version=self.sdk_configuration.globals.platform_version,
                device=self.sdk_configuration.globals.device,
                model=self.sdk_configuration.globals.model,
                device_vendor=self.sdk_configuration.globals.device_vendor,
                device_name=self.sdk_configuration.globals.device_name,
                marketplace=self.sdk_configuration.globals.marketplace,
            ),
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getNotifications",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/octet-stream"):
            return operations.GetNotificationsResponse(
                response_stream=http_res,
                status_code=http_res.status_code,
                content_type=http_res.headers.get("Content-Type") or "",
                raw_response=http_res,
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)

    async def get_notifications_async(
        self,
        *,
        request: Union[
            operations.GetNotificationsRequest,
            operations.GetNotificationsRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.GetNotificationsResponse:
        r"""Connect to Eventsource

        Connect to the event source to get a stream of events

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, operations.GetNotificationsRequest)
        request = cast(operations.GetNotificationsRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/:/eventsource/notifications",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/octet-stream",
            http_headers=http_headers,
            _globals=operations.GetNotificationsGlobals(
                accepts=self.sdk_configuration.globals.accepts,
                client_identifier=self.sdk_configuration.globals.client_identifier,
                product=self.sdk_configuration.globals.product,
                version=self.sdk_configuration.globals.version,
                platform=self.sdk_configuration.globals.platform,
                platform_version=self.sdk_configuration.globals.platform_version,
                device=self.sdk_configuration.globals.device,
                model=self.sdk_configuration.globals.model,
                device_vendor=self.sdk_configuration.globals.device_vendor,
                device_name=self.sdk_configuration.globals.device_name,
                marketplace=self.sdk_configuration.globals.marketplace,
            ),
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getNotifications",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/octet-stream"):
            return operations.GetNotificationsResponse(
                response_stream=http_res,
                status_code=http_res.status_code,
                content_type=http_res.headers.get("Content-Type") or "",
                raw_response=http_res,
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)

    def connect_web_socket(
        self,
        *,
        request: Union[
            operations.ConnectWebSocketRequest,
            operations.ConnectWebSocketRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.ConnectWebSocketResponse:
        r"""Connect to WebSocket

        Connect to the web socket to get a stream of events

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, operations.ConnectWebSocketRequest)
        request = cast(operations.ConnectWebSocketRequest, request)

        req = self._build_request(
            method="GET",
            path="/:/websocket/notifications",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/octet-stream",
            http_headers=http_headers,
            _globals=operations.ConnectWebSocketGlobals(
                accepts=self.sdk_configuration.globals.accepts,
                client_identifier=self.sdk_configuration.globals.client_identifier,
                product=self.sdk_configuration.globals.product,
                version=self.sdk_configuration.globals.version,
                platform=self.sdk_configuration.globals.platform,
                platform_version=self.sdk_configuration.globals.platform_version,
                device=self.sdk_configuration.globals.device,
                model=self.sdk_configuration.globals.model,
                device_vendor=self.sdk_configuration.globals.device_vendor,
                device_name=self.sdk_configuration.globals.device_name,
                marketplace=self.sdk_configuration.globals.marketplace,
            ),
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="connectWebSocket",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/octet-stream"):
            return operations.ConnectWebSocketResponse(
                response_stream=http_res,
                status_code=http_res.status_code,
                content_type=http_res.headers.get("Content-Type") or "",
                raw_response=http_res,
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)

    async def connect_web_socket_async(
        self,
        *,
        request: Union[
            operations.ConnectWebSocketRequest,
            operations.ConnectWebSocketRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.ConnectWebSocketResponse:
        r"""Connect to WebSocket

        Connect to the web socket to get a stream of events

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, operations.ConnectWebSocketRequest)
        request = cast(operations.ConnectWebSocketRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/:/websocket/notifications",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/octet-stream",
            http_headers=http_headers,
            _globals=operations.ConnectWebSocketGlobals(
                accepts=self.sdk_configuration.globals.accepts,
                client_identifier=self.sdk_configuration.globals.client_identifier,
                product=self.sdk_configuration.globals.product,
                version=self.sdk_configuration.globals.version,
                platform=self.sdk_configuration.globals.platform,
                platform_version=self.sdk_configuration.globals.platform_version,
                device=self.sdk_configuration.globals.device,
                model=self.sdk_configuration.globals.model,
                device_vendor=self.sdk_configuration.globals.device_vendor,
                device_name=self.sdk_configuration.globals.device_name,
                marketplace=self.sdk_configuration.globals.marketplace,
            ),
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="connectWebSocket",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/octet-stream"):
            return operations.ConnectWebSocketResponse(
                response_stream=http_res,
                status_code=http_res.status_code,
                content_type=http_res.headers.get("Content-Type") or "",
                raw_response=http_res,
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)
