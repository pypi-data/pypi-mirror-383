# The PEP 484 type hints stub file for the arch_xt module.
#
# Generated by SIP 6.7.12


import enum
import typing

import yasimavr.lib._sip

from yasimavr.lib import core


class ArchXT_ACPConfig(yasimavr.lib._sip.wrapper):

    iv_cmp = ... # type: int
    neg_channels = ... # type: Vector
    pos_channels = ... # type: Vector
    reg_base = ... # type: core.reg_addr_t
    vref_channel = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_ACPConfig') -> None: ...


class ArchXT_ACP(core.ACP, core.Peripheral, core.SignalHook):

    def __init__(self, a0: int, a1: ArchXT_ACPConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def sleep(self, a0: bool, a1: core.SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_ADCConfig(yasimavr.lib._sip.wrapper):

    class reference_config_t(core.base_reg_config_t):

        source = ... # type: core.VREF.Source

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchXT_ADCConfig.reference_config_t') -> None: ...

    channels = ... # type: Vector
    clk_ps_factors = ... # type: Vector
    clk_ps_max = ... # type: int
    init_delays = ... # type: Vector
    iv_resready = ... # type: int
    iv_wincmp = ... # type: int
    references = ... # type: Vector
    reg_base = ... # type: core.reg_addr_t
    temp_cal_25C = ... # type: float
    temp_cal_coef = ... # type: float
    vref_channel = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_ADCConfig') -> None: ...


class ArchXT_ADC(core.ADC, core.Peripheral, core.SignalHook):

    def __init__(self, a0: int, a1: ArchXT_ADCConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def sleep(self, a0: bool, a1: core.SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_CoreConfig(core.CoreConfiguration):

    eepromend_ds = ... # type: int
    eepromsize = ... # type: int
    eepromstart_ds = ... # type: int
    flashend_ds = ... # type: int
    flashstart_ds = ... # type: int
    userrowsize = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_CoreConfig') -> None: ...


class ArchXT_DeviceConfig(core.DeviceConfiguration):

    def __init__(self, a0: core.CoreConfiguration) -> None: ...


class ArchXT_Core(core.Core):

    class ArchXT_NVM(enum.IntEnum):
        EEPROM = ... # type: ArchXT_Core.ArchXT_NVM
        USERROW = ... # type: ArchXT_Core.ArchXT_NVM

    def __init__(self, a0: ArchXT_CoreConfig) -> None: ...

    def cpu_write_data(self, a0: int, a1: int) -> None: ...
    def cpu_read_data(self, a0: int) -> int: ...


class ArchXT_Device(core.Device):

    class FlashSection(enum.IntEnum):
        Boot = ... # type: ArchXT_Device.FlashSection
        AppCode = ... # type: ArchXT_Device.FlashSection
        AppData = ... # type: ArchXT_Device.FlashSection

    def __init__(self, a0: ArchXT_DeviceConfig) -> None: ...


class ArchXT_VREFConfig(yasimavr.lib._sip.wrapper):

    class reference_config_t(core.base_reg_config_t):

        level = ... # type: float
        source = ... # type: core.VREF.Source

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchXT_VREFConfig.reference_config_t') -> None: ...

    class channel_t(yasimavr.lib._sip.wrapper):

        rb_select = ... # type: core.regbit_t
        references = ... # type: Vector

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchXT_VREFConfig.channel_t') -> None: ...

    channels = ... # type: Vector
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_VREFConfig') -> None: ...


class ArchXT_VREF(core.VREF):

    def __init__(self, a0: ArchXT_VREFConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_IntCtrlConfig(yasimavr.lib._sip.wrapper):

    reg_base = ... # type: core.reg_addr_t
    vector_count = ... # type: int
    vector_size = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_IntCtrlConfig') -> None: ...


class ArchXT_IntCtrl(core.InterruptController):

    def __init__(self, a0: ArchXT_IntCtrlConfig) -> None: ...

    def get_next_irq(self) -> core.InterruptController.IRQ_t: ...
    def cpu_ack_irq(self, a0: int) -> None: ...
    def cpu_reti(self) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_ResetCtrl(core.Peripheral):

    def __init__(self, a0: core.reg_addr_t) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_MiscConfig(yasimavr.lib._sip.wrapper):

    dev_id = ... # type: int
    gpior_count = ... # type: int
    reg_base_gpior = ... # type: core.reg_addr_t
    reg_base_sigrow = ... # type: core.reg_addr_t
    reg_revid = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_MiscConfig') -> None: ...


class ArchXT_MiscRegCtrl(core.Peripheral):

    def __init__(self, a0: ArchXT_MiscConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_PortMuxConfig(yasimavr.lib._sip.wrapper):

    class mux_map_entry_t(core.base_reg_config_t):

        mux_id = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchXT_PortMuxConfig.mux_map_entry_t') -> None: ...

    class mux_config_t(yasimavr.lib._sip.wrapper):

        drv_id = ... # type: int
        mux_map = ... # type: Vector
        pin_index = ... # type: int
        reg = ... # type: core.regbit_t

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchXT_PortMuxConfig.mux_config_t') -> None: ...

    mux_configs = ... # type: Vector

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_PortMuxConfig') -> None: ...


class ArchXT_PortMuxCtrl(core.Peripheral):

    def __init__(self, a0: ArchXT_PortMuxConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_USERROW(core.Peripheral):

    def __init__(self, a0: core.reg_addr_t) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_Fuses(core.Peripheral):

    def __init__(self, a0: core.reg_addr_t) -> None: ...

    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_NVMConfig(yasimavr.lib._sip.wrapper):

    buffer_erase_delay = ... # type: int
    chip_erase_delay = ... # type: int
    eeprom_erase_delay = ... # type: int
    eeprom_page_size = ... # type: int
    flash_page_size = ... # type: int
    iv_eeready = ... # type: int
    page_erase_delay = ... # type: int
    page_write_delay = ... # type: int
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_NVMConfig') -> None: ...


class ArchXT_NVM(core.Peripheral, core.SignalHook):

    def __init__(self, a0: ArchXT_NVMConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_PortConfig(yasimavr.lib._sip.wrapper):

    iv_port = ... # type: int
    reg_base_port = ... # type: core.reg_addr_t
    reg_base_vport = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_PortConfig') -> None: ...


class ArchXT_Port(core.Port):

    def __init__(self, a0: str, a1: ArchXT_PortConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_RTCConfig(yasimavr.lib._sip.wrapper):

    class RTC_ClockSource(enum.Enum):
        Clock_32kHz = ... # type: ArchXT_RTCConfig.RTC_ClockSource
        Clock_1kHz = ... # type: ArchXT_RTCConfig.RTC_ClockSource

    class clksel_config_t(core.base_reg_config_t):

        source = ... # type: 'ArchXT_RTCConfig.RTC_ClockSource'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchXT_RTCConfig.clksel_config_t') -> None: ...

    clocks = ... # type: Vector
    iv_pit = ... # type: int
    iv_rtc = ... # type: int
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_RTCConfig') -> None: ...


class ArchXT_RTC(core.Peripheral):

    def __init__(self, a0: ArchXT_RTCConfig) -> None: ...

    def sleep(self, a0: bool, a1: core.SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_SPIConfig(yasimavr.lib._sip.wrapper):

    iv_spi = ... # type: int
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_SPIConfig') -> None: ...


class ArchXT_SPI(core.Peripheral):

    def __init__(self, a0: int, a1: ArchXT_SPIConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_TimerAConfig(yasimavr.lib._sip.wrapper):

    class Version(enum.Enum):
        V1 = ... # type: ArchXT_TimerAConfig.Version
        V2 = ... # type: ArchXT_TimerAConfig.Version

    CompareChannelCount = ... # type: int
    iv_hunf = ... # type: int
    iv_ovf = ... # type: int
    ivs_cmp = ... # type: yasimavr.lib._sip.Buffer
    reg_base = ... # type: core.reg_addr_t
    version = ... # type: 'ArchXT_TimerAConfig.Version'

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_TimerAConfig') -> None: ...


class ArchXT_TimerA(core.Peripheral, core.SignalHook):

    class EventHookTag(enum.IntEnum):
        EventA = ... # type: ArchXT_TimerA.EventHookTag
        EventB = ... # type: ArchXT_TimerA.EventHookTag

    class SignalId(enum.IntEnum):
        CompareOutput = ... # type: ArchXT_TimerA.SignalId

    def __init__(self, a0: ArchXT_TimerAConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def sleep(self, a0: bool, a1: core.SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_TimerBConfig(yasimavr.lib._sip.wrapper):

    class Options(enum.IntFlag):
        EventCount = ... # type: ArchXT_TimerBConfig.Options
        OverflowFlag = ... # type: ArchXT_TimerBConfig.Options

    iv_capt = ... # type: int
    options = ... # type: int
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_TimerBConfig') -> None: ...


class ArchXT_TimerB(core.Peripheral, core.SignalHook):

    class CaptureHookTag(enum.IntEnum):
        Event = ... # type: ArchXT_TimerB.CaptureHookTag
        Count = ... # type: ArchXT_TimerB.CaptureHookTag

    class SignalId(enum.IntEnum):
        Capture = ... # type: ArchXT_TimerB.SignalId
        Output = ... # type: ArchXT_TimerB.SignalId

    def __init__(self, a0: int, a1: ArchXT_TimerBConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def sleep(self, a0: bool, a1: core.SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_TWIConfig(yasimavr.lib._sip.wrapper):

    dual_ctrl = ... # type: bool
    iv_client = ... # type: int
    iv_host = ... # type: int
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_TWIConfig') -> None: ...


class ArchXT_TWI(core.Peripheral):

    def __init__(self, a0: int, a1: ArchXT_TWIConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_USARTConfig(yasimavr.lib._sip.wrapper):

    iv_rxc = ... # type: int
    iv_txc = ... # type: int
    iv_txe = ... # type: int
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_USARTConfig') -> None: ...


class ArchXT_USART(core.Peripheral):

    def __init__(self, a0: int, a1: ArchXT_USARTConfig) -> None: ...

    def sleep(self, a0: bool, a1: core.SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchXT_WDTConfig(yasimavr.lib._sip.wrapper):

    clock_frequency = ... # type: int
    delays = ... # type: Vector
    reg_base = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchXT_WDTConfig') -> None: ...


class ArchXT_WDT(core.WatchdogTimer):

    def __init__(self, a0: ArchXT_WDTConfig) -> None: ...

    def timeout(self) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


CTLREQ_ACP_GET_DAC = ... # type: int
CTLREQ_TCA_GET_EVENT_HOOK = ... # type: int
CTLREQ_TCA_REGISTER_TCB = ... # type: int
CTLREQ_TCB_GET_EVENT_HOOK = ... # type: int
CTLREQ_WRITE_SIGROW = ... # type: int
