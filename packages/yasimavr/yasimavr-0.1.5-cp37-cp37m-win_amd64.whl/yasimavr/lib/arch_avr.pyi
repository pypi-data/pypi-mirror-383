# The PEP 484 type hints stub file for the arch_avr module.
#
# Generated by SIP 6.7.12


import enum
import typing

import yasimavr.lib._sip

from yasimavr.lib import core


class ArchAVR_ACPConfig(yasimavr.lib._sip.wrapper):

    class mux_config_t(core.base_reg_config_t):

        pin = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_ACPConfig.mux_config_t') -> None: ...

    iv_cmp = ... # type: int
    mux_pins = ... # type: Vector
    neg_pin = ... # type: int
    pos_pin = ... # type: int
    rb_adc_enable = ... # type: core.regbit_t
    rb_bandgap_select = ... # type: core.regbit_t
    rb_disable = ... # type: core.regbit_t
    rb_int_enable = ... # type: core.regbit_t
    rb_int_flag = ... # type: core.regbit_t
    rb_int_mode = ... # type: core.regbit_t
    rb_mux = ... # type: core.regbit_t
    rb_mux_enable = ... # type: core.regbit_t
    rb_output = ... # type: core.regbit_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_ACPConfig') -> None: ...


class ArchAVR_ACP(core.ACP, core.Peripheral, core.SignalHook):

    def __init__(self, a0: int, a1: ArchAVR_ACPConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_ADCConfig(yasimavr.lib._sip.wrapper):

    class Trigger(enum.Enum):
        Manual = ... # type: ArchAVR_ADCConfig.Trigger
        FreeRunning = ... # type: ArchAVR_ADCConfig.Trigger
        External = ... # type: ArchAVR_ADCConfig.Trigger

    class reference_config_t(core.base_reg_config_t):

        source = ... # type: core.VREF.Source

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_ADCConfig.reference_config_t') -> None: ...

    class trigger_config_t(core.base_reg_config_t):

        trigger = ... # type: 'ArchAVR_ADCConfig.Trigger'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_ADCConfig.trigger_config_t') -> None: ...

    channels = ... # type: Vector
    clk_ps_factors = ... # type: Vector
    int_vector = ... # type: int
    rb_auto_trig = ... # type: core.regbit_t
    rb_bipolar = ... # type: core.regbit_t
    rb_chan_mux = ... # type: core.regbit_t
    rb_enable = ... # type: core.regbit_t
    rb_int_enable = ... # type: core.regbit_t
    rb_int_flag = ... # type: core.regbit_t
    rb_left_adj = ... # type: core.regbit_t
    rb_prescaler = ... # type: core.regbit_t
    rb_ref_mux = ... # type: core.regbit_t
    rb_start = ... # type: core.regbit_t
    rb_trig_mux = ... # type: core.regbit_t
    references = ... # type: Vector
    reg_datah = ... # type: core.reg_addr_t
    reg_datal = ... # type: core.reg_addr_t
    temp_cal_25C = ... # type: float
    temp_cal_coef = ... # type: float
    triggers = ... # type: Vector
    vref_channel = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_ADCConfig') -> None: ...


class ArchAVR_ADC(core.ADC, core.Peripheral, core.SignalHook):

    def __init__(self, a0: int, a1: ArchAVR_ADCConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def sleep(self, a0: bool, a1: core.SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_CoreConfig(core.CoreConfiguration):

    eepromsize = ... # type: int
    flash_page_size = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_CoreConfig') -> None: ...

    def flash_page_count(self) -> int: ...


class ArchAVR_DeviceConfig(core.DeviceConfiguration):

    def __init__(self, a0: ArchAVR_CoreConfig) -> None: ...


class ArchAVR_Core(core.Core):

    class ArchAVR_NVM(enum.IntEnum):
        EEPROM = ... # type: ArchAVR_Core.ArchAVR_NVM
        Lockbit = ... # type: ArchAVR_Core.ArchAVR_NVM

    def __init__(self, a0: ArchAVR_CoreConfig) -> None: ...

    def cpu_write_data(self, a0: int, a1: int) -> None: ...
    def cpu_read_data(self, a0: int) -> int: ...


class ArchAVR_Device(core.Device):

    class FlashSectionFlags(enum.IntFlag):
        RWW = ... # type: ArchAVR_Device.FlashSectionFlags
        IntDisabled = ... # type: ArchAVR_Device.FlashSectionFlags

    class FlashSection(enum.IntEnum):
        AppRWW = ... # type: ArchAVR_Device.FlashSection
        AppNRWW = ... # type: ArchAVR_Device.FlashSection
        Boot = ... # type: ArchAVR_Device.FlashSection

    def __init__(self, a0: ArchAVR_DeviceConfig) -> None: ...

    def __str__(self) -> typing.Any: ...


class ArchAVR_ExtIntConfig(yasimavr.lib._sip.wrapper):

    class ext_int_t(yasimavr.lib._sip.wrapper):

        pin = ... # type: int
        vector = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_ExtIntConfig.ext_int_t') -> None: ...

    class pc_int_t(yasimavr.lib._sip.wrapper):

        pins = ... # type: yasimavr.lib._sip.Buffer
        reg_mask = ... # type: core.reg_addr_t
        vector = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_ExtIntConfig.pc_int_t') -> None: ...

    ext_ints = ... # type: Vector
    pc_ints = ... # type: Vector
    rb_extint_ctrl = ... # type: core.regbit_t
    rb_extint_flag = ... # type: core.regbit_t
    rb_extint_mask = ... # type: core.regbit_t
    rb_pcint_ctrl = ... # type: core.regbit_t
    rb_pcint_flag = ... # type: core.regbit_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_ExtIntConfig') -> None: ...


class ArchAVR_ExtInt(core.Peripheral, core.InterruptHandler):

    class SignalId(enum.IntEnum):
        ExtInt = ... # type: ArchAVR_ExtInt.SignalId
        PinChange = ... # type: ArchAVR_ExtInt.SignalId

    def __init__(self, a0: ArchAVR_ExtIntConfig) -> None: ...

    def interrupt_ack_handler(self, a0: int) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_VREF(core.VREF):

    def __init__(self, a0: float) -> None: ...


class ArchAVR_IntCtrl(core.InterruptController):

    def __init__(self, a0: int, a1: int) -> None: ...

    def get_next_irq(self) -> core.InterruptController.IRQ_t: ...
    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_MiscConfig(yasimavr.lib._sip.wrapper):

    gpior = ... # type: Vector

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_MiscConfig') -> None: ...


class ArchAVR_MiscRegCtrl(core.Peripheral):

    def __init__(self, a0: ArchAVR_MiscConfig) -> None: ...

    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_ResetCtrlConfig(yasimavr.lib._sip.wrapper):

    rb_BORF = ... # type: core.regbit_t
    rb_EXTRF = ... # type: core.regbit_t
    rb_PORF = ... # type: core.regbit_t
    rb_WDRF = ... # type: core.regbit_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_ResetCtrlConfig') -> None: ...


class ArchAVR_ResetCtrl(core.Peripheral):

    def __init__(self, a0: ArchAVR_ResetCtrlConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_NVMConfig(yasimavr.lib._sip.wrapper):

    bm_spm_cmd = ... # type: core.bitmask_t
    bm_spm_enable = ... # type: core.bitmask_t
    bm_spm_inten = ... # type: core.bitmask_t
    bm_spm_rww_busy = ... # type: core.bitmask_t
    dev_id = ... # type: int
    ee_erase_delay = ... # type: int
    ee_erase_write_delay = ... # type: int
    ee_write_delay = ... # type: int
    iv_ee_ready = ... # type: int
    iv_spm_ready = ... # type: int
    rb_ee_inten = ... # type: core.regbit_t
    rb_ee_mode = ... # type: core.regbit_t
    rb_ee_read = ... # type: core.regbit_t
    rb_ee_wren = ... # type: core.regbit_t
    rb_ee_write = ... # type: core.regbit_t
    rbc_ee_addr = ... # type: core.regbit_compound_t
    reg_ee_data = ... # type: core.reg_addr_t
    reg_spm_ctrl = ... # type: core.reg_addr_t
    spm_erase_delay = ... # type: int
    spm_write_delay = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_NVMConfig') -> None: ...


class ArchAVR_NVM(core.Peripheral, core.InterruptHandler):

    def __init__(self, a0: ArchAVR_NVMConfig) -> None: ...

    def interrupt_ack_handler(self, a0: int) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_FusesConfig(yasimavr.lib._sip.wrapper):

    class bootsize_config_t(core.base_reg_config_t):

        boot_size = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_FusesConfig.bootsize_config_t') -> None: ...

    bm_applockbit = ... # type: core.bitmask_t
    bm_bootlockbit = ... # type: core.bitmask_t
    boot_sizes = ... # type: Vector
    nrww_start = ... # type: int
    rb_bootrst = ... # type: core.regbit_t
    rb_bootsz = ... # type: core.regbit_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_FusesConfig') -> None: ...


class ArchAVR_Fuses(core.Peripheral):

    class Fuses(enum.IntEnum):
        BootRst = ... # type: ArchAVR_Fuses.Fuses

    def __init__(self, a0: ArchAVR_FusesConfig) -> None: ...

    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_PortConfig(yasimavr.lib._sip.wrapper):

    name = ... # type: str
    reg_dir = ... # type: core.reg_addr_t
    reg_pin = ... # type: core.reg_addr_t
    reg_port = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_PortConfig') -> None: ...


class ArchAVR_Port(core.Port):

    def __init__(self, a0: ArchAVR_PortConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_SPIConfig(yasimavr.lib._sip.wrapper):

    iv_spi = ... # type: int
    rb_clock = ... # type: core.regbit_t
    rb_clock2x = ... # type: core.regbit_t
    rb_cpha = ... # type: core.regbit_t
    rb_cpol = ... # type: core.regbit_t
    rb_dord = ... # type: core.regbit_t
    rb_enable = ... # type: core.regbit_t
    rb_int_enable = ... # type: core.regbit_t
    rb_int_flag = ... # type: core.regbit_t
    rb_mode = ... # type: core.regbit_t
    rb_wcol = ... # type: core.regbit_t
    reg_data = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_SPIConfig') -> None: ...


class ArchAVR_SPI(core.Peripheral):

    def __init__(self, a0: int, a1: ArchAVR_SPIConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_TimerConfig(yasimavr.lib._sip.wrapper):

    class OVF(enum.Enum):
        SetOnMax = ... # type: ArchAVR_TimerConfig.OVF
        SetOnTop = ... # type: ArchAVR_TimerConfig.OVF
        SetOnBottom = ... # type: ArchAVR_TimerConfig.OVF

    class OCR(enum.Enum):
        Unbuffered = ... # type: ArchAVR_TimerConfig.OCR
        UpdateOnTop = ... # type: ArchAVR_TimerConfig.OCR
        UpdateOnBottom = ... # type: ArchAVR_TimerConfig.OCR

    class Top(enum.Enum):
        OnMax = ... # type: ArchAVR_TimerConfig.Top
        OnFixed = ... # type: ArchAVR_TimerConfig.Top
        OnCompA = ... # type: ArchAVR_TimerConfig.Top
        OnIC = ... # type: ArchAVR_TimerConfig.Top

    class COM(enum.Enum):
        NoChange = ... # type: ArchAVR_TimerConfig.COM
        Toggle = ... # type: ArchAVR_TimerConfig.COM
        Clear = ... # type: ArchAVR_TimerConfig.COM
        Set = ... # type: ArchAVR_TimerConfig.COM
        ToggleA = ... # type: ArchAVR_TimerConfig.COM

    class clock_config_t(core.base_reg_config_t):

        div = ... # type: int
        source = ... # type: core.TimerCounter.TickSource

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_TimerConfig.clock_config_t') -> None: ...

    class vector_config_t(yasimavr.lib._sip.wrapper):

        bit = ... # type: int
        num = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_TimerConfig.vector_config_t') -> None: ...

    class OC_config_t(core.base_reg_config_t):

        rb_force = ... # type: core.regbit_t
        rb_mode = ... # type: core.regbit_t
        reg_oc = ... # type: core.reg_addr_t
        vector = ... # type: 'ArchAVR_TimerConfig.vector_config_t'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_TimerConfig.OC_config_t') -> None: ...

    class COM_config_t(core.base_reg_config_t):

        bottom = ... # type: 'ArchAVR_TimerConfig.COM'
        down = ... # type: 'ArchAVR_TimerConfig.COM'
        top = ... # type: 'ArchAVR_TimerConfig.COM'
        up = ... # type: 'ArchAVR_TimerConfig.COM'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_TimerConfig.COM_config_t') -> None: ...

    class mode_config_t(core.base_reg_config_t):

        com_variant = ... # type: int
        disable_foc = ... # type: bool
        double_slope = ... # type: bool
        fixed_top_exp = ... # type: int
        ocr = ... # type: 'ArchAVR_TimerConfig.OCR'
        ovf = ... # type: 'ArchAVR_TimerConfig.OVF'
        top = ... # type: 'ArchAVR_TimerConfig.Top'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ArchAVR_TimerConfig.mode_config_t') -> None: ...

    clocks = ... # type: Vector
    com_modes = ... # type: typing.List
    is_16bits = ... # type: bool
    modes = ... # type: Vector
    oc_channels = ... # type: Vector
    rb_clock = ... # type: core.regbit_t
    rbc_mode = ... # type: core.regbit_compound_t
    reg_cnt = ... # type: core.reg_addr_t
    reg_icr = ... # type: core.reg_addr_t
    reg_int_enable = ... # type: core.reg_addr_t
    reg_int_flag = ... # type: core.reg_addr_t
    vect_icr = ... # type: 'ArchAVR_TimerConfig.vector_config_t'
    vect_ovf = ... # type: 'ArchAVR_TimerConfig.vector_config_t'

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_TimerConfig') -> None: ...


class ArchAVR_Timer(core.Peripheral, core.SignalHook):

    class SignalId(enum.IntEnum):
        OVF = ... # type: ArchAVR_Timer.SignalId
        CompMatch = ... # type: ArchAVR_Timer.SignalId
        CompOutput = ... # type: ArchAVR_Timer.SignalId
        Capt = ... # type: ArchAVR_Timer.SignalId

    def __init__(self, a0: int, a1: ArchAVR_TimerConfig) -> None: ...

    def raised(self, a0: core.signal_data_t, a1: int) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_peek_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_TWIConfig(yasimavr.lib._sip.wrapper):

    bm_ack_enable = ... # type: core.bitmask_t
    bm_enable = ... # type: core.bitmask_t
    bm_int_enable = ... # type: core.bitmask_t
    bm_int_flag = ... # type: core.bitmask_t
    bm_start = ... # type: core.bitmask_t
    bm_stop = ... # type: core.bitmask_t
    iv_twi = ... # type: int
    ps_factors = ... # type: Vector
    rb_addr = ... # type: core.regbit_t
    rb_addr_mask = ... # type: core.regbit_t
    rb_gencall_enable = ... # type: core.regbit_t
    rb_prescaler = ... # type: core.regbit_t
    rb_status = ... # type: core.regbit_t
    reg_bitrate = ... # type: core.reg_addr_t
    reg_ctrl = ... # type: core.reg_addr_t
    reg_data = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_TWIConfig') -> None: ...


class ArchAVR_TWI(core.Peripheral):

    def __init__(self, a0: int, a1: ArchAVR_TWIConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_USARTConfig(yasimavr.lib._sip.wrapper):

    iv_rxc = ... # type: int
    iv_txc = ... # type: int
    iv_txe = ... # type: int
    rb_baud_2x = ... # type: core.regbit_t
    rb_clock_mode = ... # type: core.regbit_t
    rb_ferr = ... # type: core.regbit_t
    rb_overrun = ... # type: core.regbit_t
    rb_parity = ... # type: core.regbit_t
    rb_perr = ... # type: core.regbit_t
    rb_rx_enable = ... # type: core.regbit_t
    rb_rxc_flag = ... # type: core.regbit_t
    rb_rxc_inten = ... # type: core.regbit_t
    rb_stopbits = ... # type: core.regbit_t
    rb_tx_enable = ... # type: core.regbit_t
    rb_txc_flag = ... # type: core.regbit_t
    rb_txc_inten = ... # type: core.regbit_t
    rb_txe_flag = ... # type: core.regbit_t
    rb_txe_inten = ... # type: core.regbit_t
    rbc_baud = ... # type: core.regbit_compound_t
    rbc_chsize = ... # type: core.regbit_compound_t
    rbc_rx_data = ... # type: core.regbit_compound_t
    rbc_tx_data = ... # type: core.regbit_compound_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_USARTConfig') -> None: ...


class ArchAVR_USART(core.Peripheral):

    def __init__(self, a0: int, a1: ArchAVR_USARTConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ioreg_read_handler(self, a0: core.reg_addr_t, a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_USIConfig(yasimavr.lib._sip.wrapper):

    iv_ovf = ... # type: int
    iv_start = ... # type: int
    rb_clk_sel = ... # type: core.regbit_t
    rb_clk_strobe = ... # type: core.regbit_t
    rb_clk_toggle = ... # type: core.regbit_t
    rb_counter = ... # type: core.regbit_t
    rb_ovf_flag = ... # type: core.regbit_t
    rb_ovf_inten = ... # type: core.regbit_t
    rb_start_flag = ... # type: core.regbit_t
    rb_start_inten = ... # type: core.regbit_t
    rb_stop_flag = ... # type: core.regbit_t
    rb_wiremode = ... # type: core.regbit_t
    reg_buffer = ... # type: core.reg_addr_t
    reg_data = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_USIConfig') -> None: ...


class ArchAVR_USI(core.Peripheral):

    def __init__(self, a0: ArchAVR_USIConfig) -> None: ...

    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


class ArchAVR_WDTConfig(yasimavr.lib._sip.wrapper):

    bm_chg_enable = ... # type: core.bitmask_t
    bm_int_enable = ... # type: core.bitmask_t
    bm_int_flag = ... # type: core.bitmask_t
    bm_reset_enable = ... # type: core.bitmask_t
    clock_frequency = ... # type: int
    delays = ... # type: Vector
    iv_wdt = ... # type: int
    rb_reset_flag = ... # type: core.regbit_t
    rbc_delay = ... # type: core.regbit_compound_t
    reg_wdt = ... # type: core.reg_addr_t

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ArchAVR_WDTConfig') -> None: ...


class ArchAVR_WDT(core.Peripheral, core.InterruptHandler):

    def __init__(self, a0: ArchAVR_WDTConfig) -> None: ...

    def interrupt_ack_handler(self, a0: int) -> None: ...
    def ioreg_write_handler(self, a0: core.reg_addr_t, a1: core.ioreg_write_t) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[core.ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: core.Device) -> bool: ...


CTLREQ_FUSE_VALUE = ... # type: int
CTLREQ_TMR_GET_CAPT_HOOK = ... # type: int
CTLREQ_TMR_GET_EXTCLK_HOOK = ... # type: int
