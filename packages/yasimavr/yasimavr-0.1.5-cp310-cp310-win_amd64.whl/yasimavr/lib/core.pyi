# The PEP 484 type hints stub file for the core module.
#
# Generated by SIP 6.9.1


import collections, re, typing, enum

try:
    from warnings import deprecated
except ImportError:
    pass

import yasimavr.lib._sip


class SleepMode(enum.IntEnum):
    Invalid = ... # type: SleepMode
    Active = ... # type: SleepMode
    Pseudo = ... # type: SleepMode
    Idle = ... # type: SleepMode
    ADC = ... # type: SleepMode
    Standby = ... # type: SleepMode
    ExtStandby = ... # type: SleepMode
    PowerDown = ... # type: SleepMode
    PowerSave = ... # type: SleepMode


class CoreCrashCodes(enum.Enum):
    Crash_PC_Overflow = ... # type: CoreCrashCodes
    Crash_SP_Overflow = ... # type: CoreCrashCodes
    Crash_Bad_CPU_IO = ... # type: CoreCrashCodes
    Crash_Bad_CTL_IO = ... # type: CoreCrashCodes
    Crash_Invalid_Opcode = ... # type: CoreCrashCodes
    Crash_Invalid_Config = ... # type: CoreCrashCodes
    Crash_Flash_Addr_Overflow = ... # type: CoreCrashCodes
    Crash_Access_Refused = ... # type: CoreCrashCodes


class StdRegisters(enum.Enum):
    R_XL = ... # type: StdRegisters
    R_XH = ... # type: StdRegisters
    R_YL = ... # type: StdRegisters
    R_YH = ... # type: StdRegisters
    R_ZL = ... # type: StdRegisters
    R_ZH = ... # type: StdRegisters
    R_X = ... # type: StdRegisters
    R_Y = ... # type: StdRegisters
    R_Z = ... # type: StdRegisters
    R_SPL = ... # type: StdRegisters
    R_SPH = ... # type: StdRegisters
    R_SREG = ... # type: StdRegisters


class SREG_Bits(enum.Enum):
    SREG_C = ... # type: SREG_Bits
    SREG_Z = ... # type: SREG_Bits
    SREG_N = ... # type: SREG_Bits
    SREG_V = ... # type: SREG_Bits
    SREG_S = ... # type: SREG_Bits
    SREG_H = ... # type: SREG_Bits
    SREG_T = ... # type: SREG_Bits
    SREG_I = ... # type: SREG_Bits


class CoreConfiguration(yasimavr.lib._sip.wrapper):

    class Attributes(enum.IntFlag):
        ExtendedAddressing = ... # type: CoreConfiguration.Attributes
        ClearGIEOnInt = ... # type: CoreConfiguration.Attributes

    attributes = ... # type: int
    datasize = ... # type: int
    eind = ... # type: 'reg_addr_t'
    flashsize = ... # type: int
    fuses = ... # type: Vector
    fusesize = ... # type: int
    ioend = ... # type: int
    iostart = ... # type: int
    ramend = ... # type: int
    rampz = ... # type: 'reg_addr_t'
    ramstart = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CoreConfiguration') -> None: ...


class DeviceConfiguration(yasimavr.lib._sip.wrapper):

    core = ... # type: CoreConfiguration
    name = ... # type: str
    pins = ... # type: Vector

    def __init__(self, a0: CoreConfiguration) -> None: ...


class breakpoint_t(yasimavr.lib._sip.wrapper):

    addr = ... # type: int
    instr = ... # type: yasimavr.lib._sip.Buffer
    instr_len = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'breakpoint_t') -> None: ...


class Core(yasimavr.lib._sip.wrapper):

    class NVM(enum.IntEnum):
        Flash = ... # type: Core.NVM
        Fuses = ... # type: Core.NVM
        CommonCount = ... # type: Core.NVM
        ArchDefined = ... # type: Core.NVM
        GetCount = ... # type: Core.NVM

    @typing.overload
    def __init__(self, a0: CoreConfiguration) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Core') -> None: ...

    @staticmethod
    def data_space_map(a0: int, a1: int, a2: int, a3: int) -> typing.Tuple[bool, typing.Optional[int], typing.Optional[int], typing.Optional[int]]: ...
    def use_extended_addressing(self) -> bool: ...
    def cpu_read_flash(self, a0: int) -> int: ...
    def cpu_write_data(self, a0: int, a1: int) -> None: ...
    def cpu_read_data(self, a0: int) -> int: ...
    def cpu_write_gpreg(self, a0: int, a1: int) -> None: ...
    def cpu_read_gpreg(self, a0: int) -> int: ...
    def cpu_write_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    def cpu_read_ioreg(self, a0: 'reg_addr_t') -> int: ...
    def set_direct_LPM_enabled(self, a0: bool) -> None: ...
    def set_console_register(self, a0: 'reg_addr_t') -> None: ...
    def start_interrupt_inhibit(self, a0: int) -> None: ...
    def ioctl_write_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    def ioctl_read_ioreg(self, a0: 'reg_addr_t') -> int: ...
    def get_ioreg(self, a0: 'reg_addr_t') -> typing.Optional['IO_Register']: ...
    def exec_cycle(self) -> int: ...
    def reset(self) -> None: ...
    def init(self, a0: 'Device') -> bool: ...


class CycleTimer(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CycleTimer') -> None: ...

    def next(self, when: int) -> int: ...
    def remaining_delay(self) -> int: ...
    def paused(self) -> bool: ...
    def scheduled(self) -> bool: ...


class CallableCycleTimer(CycleTimer):

    @typing.overload
    def __init__(self, a0: typing.Callable[..., None]) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CallableCycleTimer') -> None: ...

    def next(self, when: int) -> int: ...


class CycleManager(yasimavr.lib._sip.wrapper):

    def __init__(self) -> None: ...

    def next_when(self) -> int: ...
    def process_timers(self) -> None: ...
    def resume(self, a0: CycleTimer) -> None: ...
    def pause(self, a0: CycleTimer) -> None: ...
    def cancel(self, a0: CycleTimer) -> None: ...
    def delay(self, a0: CycleTimer, a1: int) -> None: ...
    def schedule(self, a0: CycleTimer, a1: int) -> None: ...
    def increment_cycle(self, a0: int) -> None: ...
    def cycle(self) -> int: ...


class DeviceDebugProbe(yasimavr.lib._sip.wrapper):

    class WatchpointFlags(enum.IntFlag):
        Write = ... # type: DeviceDebugProbe.WatchpointFlags
        Read = ... # type: DeviceDebugProbe.WatchpointFlags
        Signal = ... # type: DeviceDebugProbe.WatchpointFlags
        Break = ... # type: DeviceDebugProbe.WatchpointFlags

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Device') -> None: ...
    @typing.overload
    def __init__(self, a0: 'DeviceDebugProbe') -> None: ...

    def watchpoint_signal(self) -> 'Signal': ...
    def remove_watchpoint(self, a0: int, a1: int) -> None: ...
    def insert_watchpoint(self, a0: int, a1: int, a2: int) -> None: ...
    def remove_breakpoint(self, a0: int) -> None: ...
    def insert_breakpoint(self, a0: int) -> None: ...
    def read_data(self, a0: int, a1: int) -> yasimavr.lib._sip.Buffer: ...
    def write_data(self, a0: int, a1: yasimavr.lib._sip.Buffer) -> None: ...
    def read_flash(self, a0: int, a1: int) -> yasimavr.lib._sip.Buffer: ...
    def write_flash(self, a0: int, a1: yasimavr.lib._sip.Buffer) -> None: ...
    def has_ioreg(self, a0: 'reg_addr_t') -> bool: ...
    def read_ioreg(self, a0: 'reg_addr_t', a1: bool = ...) -> int: ...
    def write_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    def read_pc(self) -> int: ...
    def write_pc(self, a0: int) -> None: ...
    def read_sp(self) -> int: ...
    def write_sp(self, a0: int) -> None: ...
    def read_sreg(self) -> int: ...
    def write_sreg(self, a0: int) -> None: ...
    def read_gpreg(self, a0: int) -> int: ...
    def write_gpreg(self, a0: int, a1: int) -> None: ...
    def set_device_state(self, a0: 'Device.State') -> None: ...
    def reset_device(self) -> None: ...
    def attached(self) -> bool: ...
    def detach(self) -> None: ...
    @typing.overload
    def attach(self, a0: 'Device') -> None: ...
    @typing.overload
    def attach(self, a0: 'DeviceDebugProbe') -> None: ...
    def device(self) -> typing.Optional['Device']: ...


class Device(yasimavr.lib._sip.wrapper):

    class Option(enum.IntFlag):
        ResetOnPinShorting = ... # type: Device.Option
        IgnoreBadCpuIO = ... # type: Device.Option
        IgnoreBadCpuLPM = ... # type: Device.Option
        DisablePseudoSleep = ... # type: Device.Option
        InfiniteLoopDetect = ... # type: Device.Option

    class ResetFlag(enum.IntFlag):
        PowerOn = ... # type: Device.ResetFlag
        WDT = ... # type: Device.ResetFlag
        BOD = ... # type: Device.ResetFlag
        SW = ... # type: Device.ResetFlag
        Ext = ... # type: Device.ResetFlag
        Halt = ... # type: Device.ResetFlag

    class State(enum.Enum):
        Limbo = ... # type: Device.State
        Ready = ... # type: Device.State
        Running = ... # type: Device.State
        Sleeping = ... # type: Device.State
        Halted = ... # type: Device.State
        Reset = ... # type: Device.State
        Break = ... # type: Device.State
        Done = ... # type: Device.State
        Crashed = ... # type: Device.State
        Destroying = ... # type: Device.State

    def __init__(self, a0: Core, a1: DeviceConfiguration) -> None: ...

    def arch_init(self) -> bool: ...
    def crash(self, a0: int, a1: typing.Optional[str]) -> None: ...
    def logger(self) -> 'Logger': ...
    def log_handler(self) -> 'LogHandler': ...
    def pin_manager(self) -> 'PinManager': ...
    @typing.overload
    def find_pin(self, a0: typing.Optional[str]) -> typing.Optional['Pin']: ...
    @typing.overload
    def find_pin(self, a0: int) -> typing.Optional['Pin']: ...
    def cycle_manager(self) -> typing.Optional[CycleManager]: ...
    def ctlreq(self, a0: int, a1: int, a2: typing.Optional['ctlreq_data_t'] = ...) -> tuple[bool, 'ctlreq_data_t']: ...
    @typing.overload
    def find_peripheral(self, a0: typing.Optional[str]) -> typing.Optional['Peripheral']: ...
    @typing.overload
    def find_peripheral(self, a0: int) -> typing.Optional['Peripheral']: ...
    @typing.overload
    def add_ioreg_handler(self, a0: 'reg_addr_t', a1: 'IO_RegHandler', a2: int = ...) -> None: ...
    @typing.overload
    def add_ioreg_handler(self, a0: 'regbit_t', a1: 'IO_RegHandler', a2: bool = ...) -> None: ...
    def attach_peripheral(self, a0: 'Peripheral') -> None: ...
    def exec_cycle(self) -> int: ...
    def reset(self, a0: int = ...) -> None: ...
    def load_firmware(self, a0: 'Firmware') -> None: ...
    def init(self, a0: CycleManager) -> None: ...
    def frequency(self) -> int: ...
    def sleep_mode(self) -> SleepMode: ...
    def cycle(self) -> int: ...
    def state(self) -> 'Device.State': ...
    def config(self) -> DeviceConfiguration: ...
    def test_option(self, a0: 'Device.Option') -> bool: ...
    def set_option(self, a0: 'Device.Option', a1: bool) -> None: ...
    def core(self) -> Core: ...


class Firmware(yasimavr.lib._sip.wrapper):

    class Area(enum.Enum):
        Flash = ... # type: Firmware.Area
        Data = ... # type: Firmware.Area
        EEPROM = ... # type: Firmware.Area
        Fuses = ... # type: Firmware.Area
        Lock = ... # type: Firmware.Area
        Signature = ... # type: Firmware.Area
        UserSignatures = ... # type: Firmware.Area

    class Block(yasimavr.lib._sip.wrapper):

        base = ... # type: int
        buf = ... # type: bytes

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Firmware.Block') -> None: ...

    class Symbol(yasimavr.lib._sip.wrapper):

        addr = ... # type: int
        area = ... # type: 'Firmware.Area'
        name = ... # type: str
        size = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Firmware.Symbol') -> None: ...

    aref = ... # type: float
    console_register = ... # type: 'reg_addr_t'
    frequency = ... # type: int
    vcc = ... # type: float

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Firmware') -> None: ...

    def symbols(self) -> list['Firmware.Symbol']: ...
    def add_symbol(self, a0: 'Firmware.Symbol') -> None: ...
    def bsssize(self) -> int: ...
    def datasize(self) -> int: ...
    def load_memory(self, a0: 'Firmware.Area', a1: 'NonVolatileMemory') -> bool: ...
    def blocks(self, a0: 'Firmware.Area') -> list['Firmware.Block']: ...
    def memories(self) -> list['Firmware.Area']: ...
    def memory_size(self, a0: 'Firmware.Area') -> int: ...
    def has_memory(self, a0: 'Firmware.Area') -> bool: ...
    def add_block(self, a0: 'Firmware.Area', a1: yasimavr.lib._sip.Buffer, a2: int = ...) -> None: ...
    @staticmethod
    def read_elf(a0: str) -> typing.Optional['Firmware']: ...


class LogWriter(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'LogWriter') -> None: ...

    @staticmethod
    def default_writer() -> typing.Optional['LogWriter']: ...
    def write(self, a0: int, a1: int, a2: int, a3: typing.Optional[str], a4: 'va_list') -> None: ...


class LogHandler(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'LogHandler') -> None: ...

    def writer(self) -> LogWriter: ...
    def set_writer(self, a0: LogWriter) -> None: ...
    def init(self, a0: CycleManager) -> None: ...


class Logger(yasimavr.lib._sip.wrapper):

    class Level(enum.IntEnum):
        Silent = ... # type: Logger.Level
        Output = ... # type: Logger.Level
        Error = ... # type: Logger.Level
        Warning = ... # type: Logger.Level
        Debug = ... # type: Logger.Level
        Trace = ... # type: Logger.Level

    @typing.overload
    def __init__(self, a0: int, a1: LogHandler) -> None: ...
    @typing.overload
    def __init__(self, a0: int, a1: typing.Optional['Logger'] = ...) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Logger') -> None: ...

    def write(self, a0: int, a1: int, a2: typing.Optional[str], a3: 'va_list') -> None: ...
    def filtered_write(self, a0: int, a1: typing.Optional[str], a2: 'va_list') -> None: ...
    def id(self) -> int: ...
    def dbg(self, a0: typing.Optional[str], *args: typing.Any) -> None: ...
    def wng(self, a0: typing.Optional[str], *args: typing.Any) -> None: ...
    def err(self, a0: typing.Optional[str], *args: typing.Any) -> None: ...
    def log(self, a0: int, a1: typing.Optional[str], *args: typing.Any) -> None: ...
    def parent(self) -> typing.Optional['Logger']: ...
    def set_parent(self, a0: typing.Optional['Logger']) -> None: ...
    def level(self) -> int: ...
    def set_level(self, a0: int) -> None: ...


class va_list(yasimavr.lib._sip.wrapper): ...


class IO_RegHandler(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'IO_RegHandler') -> None: ...

    def ioreg_write_handler(self, a0: 'reg_addr_t', a1: 'ioreg_write_t') -> None: ...
    def ioreg_peek_handler(self, a0: 'reg_addr_t', a1: int) -> int: ...
    def ioreg_read_handler(self, a0: 'reg_addr_t', a1: int) -> int: ...


class Peripheral(IO_RegHandler):

    def __init__(self, a0: int) -> None: ...

    @typing.overload
    def get_signal(self, a0: int) -> typing.Optional['Signal']: ...
    @typing.overload
    def get_signal(self, a0: typing.Optional[str]) -> typing.Optional['Signal']: ...
    def register_interrupt(self, a0: int, a1: 'InterruptHandler') -> bool: ...
    @typing.overload
    def clear_ioreg(self, a0: 'regbit_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'regbit_compound_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'reg_addr_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'regbit_t') -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'regbit_compound_t') -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    @typing.overload
    def test_ioreg(self, a0: 'reg_addr_t', a1: int) -> bool: ...
    @typing.overload
    def test_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> bool: ...
    @typing.overload
    def test_ioreg(self, a0: 'regbit_t', a1: int = ...) -> bool: ...
    @typing.overload
    def write_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'regbit_compound_t', a1: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'reg_addr_t', a1: int, a2: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t', a2: int) -> None: ...
    @typing.overload
    def read_ioreg(self, a0: 'reg_addr_t') -> int: ...
    @typing.overload
    def read_ioreg(self, a0: 'regbit_t') -> int: ...
    @typing.overload
    def read_ioreg(self, a0: 'regbit_compound_t') -> int: ...
    @typing.overload
    def read_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> int: ...
    @typing.overload
    def add_ioreg(self, a0: 'regbit_t', a1: bool = ...) -> None: ...
    @typing.overload
    def add_ioreg(self, a0: 'regbit_compound_t', a1: bool = ...) -> None: ...
    @typing.overload
    def add_ioreg(self, a0: 'reg_addr_t', a1: int = ..., a2: bool = ...) -> None: ...
    def logger(self) -> Logger: ...
    def device(self) -> typing.Optional[Device]: ...
    def sleep(self, on: bool, mode: SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: 'reg_addr_t', a1: 'ioreg_write_t') -> None: ...
    def ioreg_peek_handler(self, a0: 'reg_addr_t', a1: int) -> int: ...
    def ioreg_read_handler(self, a0: 'reg_addr_t', a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional['ctlreq_data_t']) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: Device) -> bool: ...
    def name(self) -> str: ...
    def id(self) -> int: ...


class InterruptController(Peripheral):

    class State(enum.IntEnum):
        Raised = ... # type: InterruptController.State
        Cancelled = ... # type: InterruptController.State
        Acknowledged = ... # type: InterruptController.State
        Returned = ... # type: InterruptController.State
        RaisedFromSleep = ... # type: InterruptController.State
        Reset = ... # type: InterruptController.State

    class SignalId(enum.IntEnum):
        StateChange = ... # type: InterruptController.SignalId

    class IRQ_t(yasimavr.lib._sip.wrapper):

        address = ... # type: int
        nmi = ... # type: bool
        vector = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'InterruptController.IRQ_t') -> None: ...

    NO_INTERRUPT = ... # type: 'InterruptController.IRQ_t'

    @typing.overload
    def __init__(self, a0: int) -> None: ...
    @typing.overload
    def __init__(self, a0: 'InterruptController') -> None: ...

    def sleep(self, a0: bool, a1: SleepMode) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional['ctlreq_data_t']) -> bool: ...
    def reset(self) -> None: ...


class InterruptHandler(yasimavr.lib._sip.wrapper):

    def __init__(self) -> None: ...

    def interrupt_ack_handler(self, a0: int) -> None: ...
    def interrupt_raised(self, a0: int) -> bool: ...
    def cancel_interrupt(self, a0: int) -> None: ...
    def raise_interrupt(self, a0: int) -> None: ...


class InterruptFlag(InterruptHandler):

    def __init__(self, a0: bool = ...) -> None: ...

    def interrupt_ack_handler(self, a0: int) -> None: ...
    def raised(self) -> bool: ...
    def clear_flag(self, a0: int = ...) -> bool: ...
    def set_flag(self, a0: int = ...) -> bool: ...
    def set_clear_on_ack(self, a0: bool) -> None: ...
    def update_from_ioreg(self) -> int: ...
    def init(self, a0: Device, a1: 'regbit_t', a2: 'regbit_t', a3: int) -> bool: ...


class NonVolatileMemory(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self, a0: int) -> None: ...
    @typing.overload
    def __init__(self, a0: 'NonVolatileMemory') -> None: ...

    @typing.overload
    def spm_write(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def spm_write(self, a0: yasimavr.lib._sip.Buffer, a1: yasimavr.lib._sip.Buffer, a2: int) -> None: ...
    @typing.overload
    def write(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def write(self, a0: yasimavr.lib._sip.Buffer, a1: int) -> None: ...
    @typing.overload
    def read(self, a0: int) -> int: ...
    @typing.overload
    def read(self, a0: int, a1: int) -> bytes: ...
    @typing.overload
    def erase(self) -> None: ...
    @typing.overload
    def erase(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def erase(self, a0: yasimavr.lib._sip.Buffer, a1: int) -> None: ...
    def program(self, a0: yasimavr.lib._sip.Buffer, a1: int = ...) -> bool: ...
    @typing.overload
    def block(self) -> bytes: ...
    @typing.overload
    def block(self, a0: int, a1: int) -> bytes: ...
    def __getitem__(self, a0: int) -> int: ...
    @typing.overload
    def programmed(self, a0: int) -> bool: ...
    @typing.overload
    def programmed(self, a0: int, a1: int) -> bytes: ...
    def size(self) -> int: ...


class MemorySectionManager(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        Leave = ... # type: MemorySectionManager.SignalId
        Enter = ... # type: MemorySectionManager.SignalId

    class AccessFlag(enum.IntFlag):
        Read = ... # type: MemorySectionManager.AccessFlag
        Write = ... # type: MemorySectionManager.AccessFlag

    def __init__(self, a0: int, a1: int, a2: int) -> None: ...

    def signal(self) -> 'Signal': ...
    def fetch_address(self, a0: int) -> bool: ...
    def set_fetch_allowed(self, a0: int, a1: bool) -> None: ...
    def address_access_flags(self, a0: int) -> int: ...
    def can_write(self, a0: int) -> bool: ...
    def can_read(self, a0: int) -> bool: ...
    @typing.overload
    def access_flags(self, a0: int, a1: int) -> int: ...
    @typing.overload
    def access_flags(self, a0: int) -> int: ...
    @typing.overload
    def set_access_flags(self, a0: int, a1: int, a2: int) -> None: ...
    @typing.overload
    def set_access_flags(self, a0: int, a1: int) -> None: ...
    def address_to_section(self, a0: int) -> int: ...
    def page_to_section(self, a0: int) -> int: ...
    def section_size(self, a0: int) -> int: ...
    def section_end(self, a0: int) -> int: ...
    def section_start(self, a0: int) -> int: ...
    def set_section_limits(self, a0: Vector) -> None: ...
    def current_section(self) -> int: ...
    def section_count(self) -> int: ...
    def page_size(self) -> int: ...
    def page_count(self) -> int: ...


class NVM_request_t(yasimavr.lib._sip.wrapper):

    addr = ... # type: int
    cycles = ... # type: int
    data = ... # type: int
    kind = ... # type: int
    nvm = ... # type: int
    result = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'NVM_request_t') -> None: ...


class ctlreq_data_t(yasimavr.lib._sip.wrapper):

    data = ... # type: 'vardata_t'
    index = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ctlreq_data_t') -> None: ...


class base_reg_config_t(yasimavr.lib._sip.wrapper):

    reg_value = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'base_reg_config_t') -> None: ...


class DummyController(Peripheral):

    class dummy_register_t(yasimavr.lib._sip.wrapper):

        reg = ... # type: 'regbit_t'
        reset = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'DummyController.dummy_register_t') -> None: ...

    def __init__(self, a0: int, a1: Vector) -> None: ...

    def reset(self) -> None: ...
    def init(self, a0: Device) -> bool: ...


class ioreg_write_t(yasimavr.lib._sip.wrapper):

    old = ... # type: int
    value = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ioreg_write_t') -> None: ...

    def anyedge(self) -> int: ...
    def negedge(self) -> int: ...
    def posedge(self) -> int: ...


class IO_Register(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self, a0: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, a0: 'IO_Register') -> None: ...

    def dbg_peek(self, a0: 'reg_addr_t') -> int: ...
    def ioctl_write(self, a0: 'reg_addr_t', a1: int) -> None: ...
    def ioctl_read(self, a0: 'reg_addr_t') -> int: ...
    def cpu_write(self, a0: 'reg_addr_t', a1: int) -> bool: ...
    def cpu_read(self, a0: 'reg_addr_t') -> int: ...
    def set_handler(self, a0: IO_RegHandler, a1: int, a2: int) -> None: ...
    def set(self, a0: int) -> None: ...
    def value(self) -> int: ...


class Wire(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        StateChange = ... # type: Wire.SignalId
        DigitalChange = ... # type: Wire.SignalId
        VoltageChange = ... # type: Wire.SignalId

    class StateEnum(enum.IntEnum):
        Floating = ... # type: Wire.StateEnum
        PullUp = ... # type: Wire.StateEnum
        PullDown = ... # type: Wire.StateEnum
        Analog = ... # type: Wire.StateEnum
        High = ... # type: Wire.StateEnum
        Low = ... # type: Wire.StateEnum
        Shorted = ... # type: Wire.StateEnum
        Error = ... # type: Wire.StateEnum

    class state_t(yasimavr.lib._sip.wrapper):

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Wire.StateEnum', a1: float = ...) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Wire.state_t') -> None: ...

        def level(self) -> float: ...
        def value(self) -> 'Wire.StateEnum': ...
        def __ne__(self, other: object): ...
        def __eq__(self, other: object): ...
        def __repr__(self) -> typing.Optional[str]: ...
        def digital_value(self) -> bool: ...
        def is_driven(self) -> bool: ...
        def is_digital(self) -> bool: ...

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Wire') -> None: ...

    @staticmethod
    def resolve_two_states(a0: 'Wire.state_t', a1: 'Wire.state_t') -> 'Wire.state_t': ...
    def siblings(self) -> list['Wire']: ...
    @typing.overload
    def attached(self, a0: 'Wire') -> bool: ...
    @typing.overload
    def attached(self) -> bool: ...
    def detach(self) -> None: ...
    def attach(self, a0: 'Wire') -> None: ...
    @typing.overload
    def set_state(self, a0: 'Wire.state_t') -> None: ...
    @typing.overload
    def set_state(self, a0: 'Wire.StateEnum', a1: float = ...) -> None: ...
    @typing.overload
    def set_state(self, a0: str, a1: float = ...) -> None: ...
    def voltage(self) -> float: ...
    def digital_state(self) -> bool: ...
    def state(self) -> 'Wire.state_t': ...
    def signal(self) -> 'DataSignal': ...
    @staticmethod
    def char2state(a0: str) -> 'Wire.StateEnum': ...


class Pin(Wire):

    class controls_t(yasimavr.lib._sip.wrapper):

        dir = ... # type: int
        drive = ... # type: int
        inverted = ... # type: bool
        pull_up = ... # type: bool

        @typing.overload
        def __init__(self, a0: int = ..., a1: int = ..., a2: bool = ..., a3: bool = ...) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Pin.controls_t') -> None: ...

    def __init__(self, a0: int) -> None: ...

    def gpio_controls(self) -> 'Pin.controls_t': ...
    def set_gpio_controls(self, a0: 'Pin.controls_t') -> None: ...
    @typing.overload
    def set_external_state(self, a0: Wire.state_t) -> None: ...
    @typing.overload
    def set_external_state(self, a0: Wire.StateEnum, a1: float = ...) -> None: ...
    @typing.overload
    def set_external_state(self, a0: str, a1: float = ...) -> None: ...
    def id(self) -> int: ...


class PinDriver(yasimavr.lib._sip.wrapper):

    def __init__(self, a0: int, a1: int) -> None: ...

    def digital_state_changed(self, a0: int, a1: bool) -> None: ...
    def override_gpio(self, a0: int, a1: Pin.controls_t) -> Pin.controls_t: ...
    def gpio_controls(self, a0: int) -> Pin.controls_t: ...
    def pin_state(self, a0: int) -> Wire.state_t: ...
    def update_pin_states(self) -> None: ...
    def update_pin_state(self, a0: int) -> None: ...
    def enabled(self, a0: int) -> bool: ...
    @typing.overload
    def set_enabled(self, a0: bool) -> None: ...
    @typing.overload
    def set_enabled(self, a0: int, a1: bool) -> None: ...


class PinManager(yasimavr.lib._sip.wrapper):

    default_mux_id = ... # type: int

    def __init__(self, a0: Vector) -> None: ...

    def pin(self, a0: int) -> typing.Optional[Pin]: ...
    def current_mux_pins(self, a0: int) -> list[unsigned long]: ...
    def current_mux(self, a0: int, a1: int) -> int: ...
    @typing.overload
    def set_current_mux(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def set_current_mux(self, a0: int, a1: int, a2: int) -> None: ...
    def add_mux_config(self, a0: int, a1: Vector, a2: int = ...) -> bool: ...
    def register_driver(self, a0: PinDriver) -> bool: ...


class signal_data_t(yasimavr.lib._sip.wrapper):

    data = ... # type: 'vardata_t'
    index = ... # type: int
    sigid = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'signal_data_t') -> None: ...


class SignalHook(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'SignalHook') -> None: ...

    def raised(self, a0: signal_data_t, a1: int) -> None: ...


class Signal(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Signal') -> None: ...

    @typing.overload
    def raise_(self, a0: signal_data_t) -> None: ...
    @typing.overload
    def raise_(self, a0: int = ..., a1: typing.Any = ..., a2: int = ...) -> None: ...
    def disconnect(self, a0: SignalHook) -> None: ...
    def connect(self, a0: SignalHook, a1: int = ...) -> None: ...


class DataSignal(Signal):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'DataSignal') -> None: ...

    @typing.overload
    def raise_(self, a0: signal_data_t) -> None: ...
    @typing.overload
    def raise_(self, a0: int = ..., a1: typing.Any = ..., a2: int = ...) -> None: ...
    def clear(self) -> None: ...
    def set_data(self, a0: int, a1: typing.Any = ..., a2: int = ...) -> None: ...
    def has_data(self, a0: int, a1: int = ...) -> bool: ...
    def data(self, a0: int, a1: int = ...) -> 'vardata_t': ...


class CallableSignalHook(SignalHook):

    @typing.overload
    def __init__(self, a0: typing.Callable[..., None]) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CallableSignalHook') -> None: ...

    def raised(self, a0: signal_data_t, a1: int) -> None: ...


class DataSignalMux(SignalHook):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'DataSignalMux') -> None: ...

    def connected(self) -> bool: ...
    def selected_index(self) -> int: ...
    def set_selection(self, a0: int) -> None: ...
    def signal(self) -> DataSignal: ...
    @typing.overload
    def add_mux(self) -> int: ...
    @typing.overload
    def add_mux(self, a0: DataSignal) -> int: ...
    @typing.overload
    def add_mux(self, a0: DataSignal, a1: int) -> int: ...
    @typing.overload
    def add_mux(self, a0: DataSignal, a1: int, a2: int) -> int: ...
    def raised(self, a0: signal_data_t, a1: int) -> None: ...


class SleepConfig(yasimavr.lib._sip.wrapper):

    class mode_config_t(base_reg_config_t):

        int_mask = ... # type: yasimavr.lib._sip.Buffer
        mode = ... # type: SleepMode

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'SleepConfig.mode_config_t') -> None: ...

    modes = ... # type: Vector
    rb_enable = ... # type: 'regbit_t'
    rb_mode = ... # type: 'regbit_t'

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'SleepConfig') -> None: ...


class SleepController(Peripheral, SignalHook):

    def __init__(self, a0: SleepConfig) -> None: ...

    def raised(self, a0: signal_data_t, a1: int) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def init(self, a0: Device) -> bool: ...


class reg_addr_t(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self, a0: int = ...) -> None: ...
    @typing.overload
    def __init__(self, a0: 'reg_addr_t') -> None: ...

    def __ge__(self, a0: 'reg_addr_t') -> bool: ...
    def __gt__(self, a0: 'reg_addr_t') -> bool: ...
    def __le__(self, a0: 'reg_addr_t') -> bool: ...
    def __lt__(self, a0: 'reg_addr_t') -> bool: ...
    def __ne__(self, other: object): ...
    def __eq__(self, other: object): ...
    def __repr__(self) -> typing.Optional[str]: ...
    def __int__(self) -> int: ...
    def __index__(self) -> int: ...
    def valid(self) -> bool: ...


class bitmask_t(yasimavr.lib._sip.wrapper):

    bit = ... # type: int
    mask = ... # type: int

    @typing.overload
    def __init__(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def __init__(self, a0: int) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'bitmask_t') -> None: ...
    @typing.overload
    def __init__(self, a0: 'regbit_t') -> None: ...

    def __repr__(self) -> typing.Optional[str]: ...
    def bitcount(self) -> int: ...
    def extract(self, a0: int) -> int: ...


class regbit_t(yasimavr.lib._sip.wrapper):

    addr = ... # type: reg_addr_t
    bit = ... # type: int
    mask = ... # type: int

    @typing.overload
    def __init__(self, a0: reg_addr_t, a1: int, a2: int) -> None: ...
    @typing.overload
    def __init__(self, a0: reg_addr_t, a1: int) -> None: ...
    @typing.overload
    def __init__(self, a0: reg_addr_t, a1: bitmask_t) -> None: ...
    @typing.overload
    def __init__(self, a0: reg_addr_t) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'regbit_t') -> None: ...

    def __repr__(self) -> typing.Optional[str]: ...
    def bitcount(self) -> int: ...
    def replace(self, a0: int, a1: int) -> int: ...
    def clear_from(self, a0: int, a1: int = ...) -> int: ...
    def set_to(self, a0: int, a1: int = ...) -> int: ...
    def extract(self, a0: int) -> int: ...
    def valid(self) -> bool: ...


class regbit_compound_t(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: regbit_t) -> None: ...
    @typing.overload
    def __init__(self, a0: Vector) -> None: ...
    @typing.overload
    def __init__(self, a0: 'regbit_compound_t') -> None: ...

    def bitcount(self) -> int: ...
    def extract(self, a0: int, a1: int) -> int: ...
    def compound(self, a0: int, a1: int) -> int: ...
    def addr_match(self, a0: reg_addr_t) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, a0: int) -> regbit_t: ...
    def add(self, a0: regbit_t) -> None: ...


class vardata_t(yasimavr.lib._sip.wrapper):

    class Type(enum.Enum):
        Invalid = ... # type: vardata_t.Type
        Pointer = ... # type: vardata_t.Type
        Double = ... # type: vardata_t.Type
        Uinteger = ... # type: vardata_t.Type
        Integer = ... # type: vardata_t.Type
        String = ... # type: vardata_t.Type
        Bytes = ... # type: vardata_t.Type

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'vardata_t') -> None: ...
    @typing.overload
    def __init__(self, a0: typing.Any) -> None: ...

    def __ne__(self, other: object): ...
    def __eq__(self, other: object): ...
    def value(self, a0: type = ...) -> typing.Any: ...
    def set(self, a0: typing.Any) -> None: ...
    def as_int(self) -> int: ...
    def as_uint(self) -> int: ...
    def as_double(self) -> float: ...
    def as_str(self) -> typing.Optional[str]: ...
    def as_ptr(self, a0: type = ...) -> typing.Any: ...
    def type(self) -> 'vardata_t.Type': ...


class ACP(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        Output = ... # type: ACP.SignalId
        DAC = ... # type: ACP.SignalId

    class Channel(enum.Enum):
        Pin = ... # type: ACP.Channel
        AcompRef = ... # type: ACP.Channel
        IntRef = ... # type: ACP.Channel

    class channel_config_t(base_reg_config_t):

        pin = ... # type: int
        type = ... # type: 'ACP.Channel'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ACP.channel_config_t') -> None: ...

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ACP') -> None: ...


class ADC(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        ConversionStarted = ... # type: ADC.SignalId
        AboutToSample = ... # type: ADC.SignalId
        ConversionComplete = ... # type: ADC.SignalId

    class Channel(enum.Enum):
        SingleEnded = ... # type: ADC.Channel
        Differential = ... # type: ADC.Channel
        Zero = ... # type: ADC.Channel
        IntRef = ... # type: ADC.Channel
        Temperature = ... # type: ADC.Channel
        AcompRef = ... # type: ADC.Channel

    class channel_config_t(base_reg_config_t):

        gain = ... # type: int
        per_num = ... # type: str
        pin_n = ... # type: int
        pin_p = ... # type: int
        type = ... # type: 'ADC.Channel'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ADC.channel_config_t') -> None: ...

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ADC') -> None: ...


class Port(Peripheral):

    def __init__(self, name: str) -> None: ...

    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: Device) -> bool: ...


class SPI(yasimavr.lib._sip.simplewrapper):

    class Line(enum.IntEnum):
        Clock = ... # type: SPI.Line
        MISO = ... # type: SPI.Line
        MOSI = ... # type: SPI.Line
        Select = ... # type: SPI.Line

    class BitOrder(enum.Enum):
        MSBFirst = ... # type: SPI.BitOrder
        LSBFirst = ... # type: SPI.BitOrder

    class SerialMode(enum.Enum):
        Mode0 = ... # type: SPI.SerialMode
        Mode1 = ... # type: SPI.SerialMode
        Mode2 = ... # type: SPI.SerialMode
        Mode3 = ... # type: SPI.SerialMode

    class EndPoint(yasimavr.lib._sip.wrapper):

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'SPI.EndPoint') -> None: ...

        def shift_clock(self) -> bool: ...
        def set_shift_clock(self, a0: bool) -> None: ...
        def read_data_input(self) -> bool: ...
        def write_data_output(self, a0: bool) -> None: ...
        def frame_completed(self) -> None: ...
        def active(self) -> bool: ...
        def set_active(self, a0: bool) -> None: ...
        def complete_frame(self) -> bool: ...
        def shift_data(self) -> int: ...
        def set_shift_data(self, a0: int) -> None: ...
        def bit_order(self) -> 'SPI.BitOrder': ...
        def set_bit_order(self, a0: 'SPI.BitOrder') -> None: ...
        def serial_mode(self) -> 'SPI.SerialMode': ...
        def set_serial_mode(self, a0: 'SPI.SerialMode') -> None: ...


class PrescaledTimer(CycleTimer):

    def __init__(self) -> None: ...

    @staticmethod
    def ticks_to_event(a0: int, a1: int, a2: int) -> int: ...
    def unregister_chained_timer(self, a0: 'PrescaledTimer') -> None: ...
    def register_chained_timer(self, a0: 'PrescaledTimer') -> None: ...
    def signal(self) -> Signal: ...
    def next(self, a0: int) -> int: ...
    def update(self) -> None: ...
    def timer_delay(self) -> int: ...
    def set_timer_delay(self, a0: int) -> None: ...
    def set_paused(self, a0: bool) -> None: ...
    def prescaler_factor(self) -> int: ...
    def set_prescaler(self, a0: int, a1: int) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: CycleManager, a1: Logger) -> None: ...


class TimerCounter(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        Event = ... # type: TimerCounter.SignalId
        CompMatch = ... # type: TimerCounter.SignalId

    class EventType(enum.IntFlag):
        Max = ... # type: TimerCounter.EventType
        Top = ... # type: TimerCounter.EventType
        Bottom = ... # type: TimerCounter.EventType
        Compare = ... # type: TimerCounter.EventType

    class SlopeMode(enum.Enum):
        Up = ... # type: TimerCounter.SlopeMode
        Down = ... # type: TimerCounter.SlopeMode
        Double = ... # type: TimerCounter.SlopeMode

    class TickSource(enum.Enum):
        Stopped = ... # type: TimerCounter.TickSource
        Timer = ... # type: TimerCounter.TickSource
        External = ... # type: TimerCounter.TickSource

    def __init__(self, a0: int, a1: int) -> None: ...

    def prescaler(self) -> PrescaledTimer: ...
    def ext_tick_hook(self) -> SignalHook: ...
    def signal(self) -> Signal: ...
    def set_countdown(self, a0: bool) -> None: ...
    def countdown(self) -> bool: ...
    def comp_enabled(self, a0: int) -> bool: ...
    def set_comp_enabled(self, a0: int, a1: bool) -> None: ...
    def comp_value(self, a0: int) -> int: ...
    def set_comp_value(self, a0: int, a1: int) -> None: ...
    def counter(self) -> int: ...
    def set_counter(self, a0: int) -> None: ...
    def slope_mode(self) -> 'TimerCounter.SlopeMode': ...
    def set_slope_mode(self, a0: 'TimerCounter.SlopeMode') -> None: ...
    def top(self) -> int: ...
    def set_top(self, a0: int) -> None: ...
    def tick(self) -> None: ...
    def tick_source(self) -> 'TimerCounter.TickSource': ...
    def set_tick_source(self, a0: 'TimerCounter.TickSource') -> None: ...
    def wrap(self) -> int: ...
    def update(self) -> None: ...
    def reschedule(self) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: CycleManager, a1: Logger) -> None: ...


class TWI(yasimavr.lib._sip.simplewrapper):

    class SignalId(enum.IntEnum):
        StateChanged = ... # type: TWI.SignalId
        BusStateChanged = ... # type: TWI.SignalId
        Start = ... # type: TWI.SignalId
        AddressStandby = ... # type: TWI.SignalId
        AddressSent = ... # type: TWI.SignalId
        AddressReceived = ... # type: TWI.SignalId
        DataStandby = ... # type: TWI.SignalId
        DataSent = ... # type: TWI.SignalId
        DataAckReceived = ... # type: TWI.SignalId
        DataReceived = ... # type: TWI.SignalId
        DataAckSent = ... # type: TWI.SignalId
        ArbitrationLost = ... # type: TWI.SignalId
        BusCollision = ... # type: TWI.SignalId
        Stop = ... # type: TWI.SignalId

    class BusState(enum.IntEnum):
        Idle = ... # type: TWI.BusState
        Busy = ... # type: TWI.BusState
        Owned = ... # type: TWI.BusState

    class Line(enum.IntEnum):
        Clock = ... # type: TWI.Line
        Data = ... # type: TWI.Line

    class EndPoint(yasimavr.lib._sip.wrapper):

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'TWI.EndPoint') -> None: ...

        def get_data_level(self) -> bool: ...
        def set_data_drive(self, a0: bool) -> None: ...
        def get_clock_level(self) -> bool: ...
        def set_clock_drive(self, a0: bool) -> None: ...
        def set_line_state(self, a0: 'TWI.Line', a1: bool) -> None: ...
        def data_level_changed(self, a0: bool) -> None: ...
        def clock_level_changed(self, a0: bool) -> None: ...
        def get_data_drive(self) -> bool: ...
        def get_clock_drive(self) -> bool: ...
        def line_state_changed(self, a0: 'TWI.Line', a1: bool) -> None: ...

    class Client('TWI.EndPoint', CycleTimer):

        class State(enum.IntEnum):
            Disabled = ... # type: TWI.Client.State
            Idle = ... # type: TWI.Client.State
            Start = ... # type: TWI.Client.State
            AddressRx = ... # type: TWI.Client.State
            AddressRAck = ... # type: TWI.Client.State
            AddressWAck = ... # type: TWI.Client.State
            DataTx = ... # type: TWI.Client.State
            DataTxAck = ... # type: TWI.Client.State
            DataRx = ... # type: TWI.Client.State
            DataRxAck = ... # type: TWI.Client.State

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'TWI.Client') -> None: ...

        def data_level_changed(self, a0: bool) -> None: ...
        def clock_level_changed(self, a0: bool) -> None: ...
        def next(self, a0: int) -> int: ...
        def signal(self) -> Signal: ...
        def start_data_rx(self) -> None: ...
        def start_data_tx(self, a0: int) -> None: ...
        def set_ack(self, a0: bool) -> None: ...
        def ack(self) -> bool: ...
        def rw(self) -> int: ...
        def clock_hold(self) -> bool: ...
        def active(self) -> bool: ...
        def reset(self) -> None: ...
        def enabled(self) -> bool: ...
        def set_enabled(self, a0: bool) -> None: ...
        def state(self) -> 'TWI.Client.State': ...
        def init(self, a0: CycleManager) -> None: ...

    class Host('TWI.EndPoint', CycleTimer):

        class State(enum.IntEnum):
            Disabled = ... # type: TWI.Host.State
            Idle = ... # type: TWI.Host.State
            Start = ... # type: TWI.Host.State
            AddressTx = ... # type: TWI.Host.State
            AddressAck = ... # type: TWI.Host.State
            DataTx = ... # type: TWI.Host.State
            DataTxAck = ... # type: TWI.Host.State
            DataRx = ... # type: TWI.Host.State
            DataRxAck = ... # type: TWI.Host.State
            Stop = ... # type: TWI.Host.State
            BusBusy = ... # type: TWI.Host.State
            ArbLost = ... # type: TWI.Host.State

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'TWI.Host') -> None: ...

        def data_level_changed(self, a0: bool) -> None: ...
        def clock_level_changed(self, a0: bool) -> None: ...
        def next(self, a0: int) -> int: ...
        def signal(self) -> Signal: ...
        def stop_transfer(self) -> bool: ...
        def start_data_rx(self) -> None: ...
        def start_data_tx(self, a0: int) -> bool: ...
        def set_ack(self, a0: bool) -> bool: ...
        def set_address(self, a0: int) -> bool: ...
        def start_transfer(self) -> bool: ...
        def ack(self) -> bool: ...
        def rw(self) -> int: ...
        def clock_stretched(self) -> bool: ...
        def clock_hold(self) -> bool: ...
        def active(self) -> bool: ...
        def bus_busy(self) -> bool: ...
        def set_bit_delay(self, a0: int) -> None: ...
        def reset(self) -> None: ...
        def enabled(self) -> bool: ...
        def set_enabled(self, a0: bool) -> None: ...
        def state(self) -> 'TWI.Host.State': ...
        def init(self, a0: CycleManager) -> None: ...


class UART(yasimavr.lib._sip.simplewrapper):

    class Parity(enum.Enum):
        No = ... # type: UART.Parity
        Odd = ... # type: UART.Parity
        Even = ... # type: UART.Parity

    class Line(enum.IntEnum):
        TXD = ... # type: UART.Line
        RXD = ... # type: UART.Line
        XCK = ... # type: UART.Line
        DIR = ... # type: UART.Line

    class ClockMode(enum.Enum):
        Async = ... # type: UART.ClockMode
        Emitter = ... # type: UART.ClockMode
        Receiver = ... # type: UART.ClockMode

    class SignalId(enum.IntEnum):
        TX_Start = ... # type: UART.SignalId
        TX_Complete = ... # type: UART.SignalId
        RX_Start = ... # type: UART.SignalId
        RX_Complete = ... # type: UART.SignalId
        TX_Frame = ... # type: UART.SignalId
        TX_Data = ... # type: UART.SignalId
        RX_Overflow = ... # type: UART.SignalId
        TX_Collision = ... # type: UART.SignalId

    class USART(yasimavr.lib._sip.wrapper):

        def __init__(self) -> None: ...

        def get_line_state(self, a0: 'UART.Line') -> bool: ...
        def set_line_state(self, a0: 'UART.Line', a1: bool) -> None: ...
        def line_state_changed(self, a0: 'UART.Line', a1: bool) -> None: ...
        def parse_frame(self, a0: int) -> int: ...
        def build_frame(self, a0: int) -> int: ...
        def set_paused(self, a0: bool) -> None: ...
        def push_rx_frame(self, a0: int) -> None: ...
        def rx_in_progress(self) -> bool: ...
        def has_rx_overrun(self) -> bool: ...
        def has_parity_error(self) -> bool: ...
        def has_frame_error(self) -> bool: ...
        def read_rx(self) -> int: ...
        def pop_rx(self) -> None: ...
        def rx_available(self) -> int: ...
        def set_rx_enabled(self, a0: bool) -> None: ...
        def set_rx_buffer_limit(self, a0: int) -> None: ...
        def tx_in_progress(self) -> bool: ...
        def set_tx_dir_enabled(self, a0: bool) -> None: ...
        def tx_pending(self) -> int: ...
        def cancel_tx_pending(self) -> None: ...
        def push_tx(self, a0: int) -> None: ...
        def set_tx_buffer_limit(self, a0: int) -> None: ...
        def set_parity(self, a0: 'UART.Parity') -> None: ...
        def set_databits(self, a0: int) -> None: ...
        def set_stopbits(self, a0: int) -> None: ...
        def set_bit_delay(self, a0: int) -> None: ...
        def set_clock_mode(self, a0: 'UART.ClockMode') -> None: ...
        def signal(self) -> Signal: ...
        def reset(self) -> None: ...
        def init(self, a0: CycleManager, a1: typing.Optional[Logger] = ...) -> None: ...


class VREF(Peripheral):

    class SignalId(enum.IntEnum):
        ARefChange = ... # type: VREF.SignalId
        IntRefChange = ... # type: VREF.SignalId
        VCCChange = ... # type: VREF.SignalId

    class Source(enum.IntEnum):
        VCC = ... # type: VREF.Source
        AVCC = ... # type: VREF.Source
        AREF = ... # type: VREF.Source
        Internal = ... # type: VREF.Source

    @typing.overload
    def __init__(self, ref_count: int) -> None: ...
    @typing.overload
    def __init__(self, a0: 'VREF') -> None: ...

    def reference(self, a0: int) -> float: ...
    def set_reference(self, a0: int, a1: 'VREF.Source', a2: float = ...) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def active(self) -> bool: ...


class WatchdogTimer(Peripheral):

    def __init__(self) -> None: ...

    def timeout(self) -> None: ...
    def set_timer(self, a0: int, a1: int, a2: int) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...


class AbstractSimLoop(yasimavr.lib._sip.wrapper):

    class State(enum.Enum):
        Running = ... # type: AbstractSimLoop.State
        Step = ... # type: AbstractSimLoop.State
        Standby = ... # type: AbstractSimLoop.State
        Stopped = ... # type: AbstractSimLoop.State
        Done = ... # type: AbstractSimLoop.State

    def __init__(self, a0: Device) -> None: ...

    def device(self) -> Device: ...
    def cycle_manager(self) -> CycleManager: ...
    def cycle(self) -> int: ...
    def state(self) -> 'AbstractSimLoop.State': ...


class SimLoop(AbstractSimLoop):

    def __init__(self, a0: Device) -> None: ...

    def run(self, a0: int = ...) -> None: ...
    def set_fast_mode(self, a0: bool) -> None: ...


class AsyncSimLoop(AbstractSimLoop):

    def __init__(self, a0: Device) -> None: ...

    def __exit__(self, a0: typing.Any, a1: typing.Any, a2: typing.Any) -> None: ...
    def __enter__(self) -> typing.Any: ...
    def loop_kill(self) -> None: ...
    def loop_pause(self) -> None: ...
    def loop_step(self) -> None: ...
    def loop_continue(self) -> None: ...
    def end_transaction(self) -> None: ...
    def start_transaction(self) -> bool: ...
    def run(self) -> None: ...
    def set_fast_mode(self, a0: bool) -> None: ...


CTLREQ_ADC_SET_TEMP = ... # type: int
CTLREQ_ADC_TRIGGER = ... # type: int
CTLREQ_BASE = ... # type: int
CTLREQ_CORE_BREAK = ... # type: int
CTLREQ_CORE_CRASH = ... # type: int
CTLREQ_CORE_HALT = ... # type: int
CTLREQ_CORE_NVM = ... # type: int
CTLREQ_CORE_RESET = ... # type: int
CTLREQ_CORE_RESET_FLAG = ... # type: int
CTLREQ_CORE_SECTIONS = ... # type: int
CTLREQ_CORE_SHORTING = ... # type: int
CTLREQ_CORE_SLEEP = ... # type: int
CTLREQ_CORE_WAKEUP = ... # type: int
CTLREQ_GET_SIGNAL = ... # type: int
CTLREQ_INTR_RAISE = ... # type: int
CTLREQ_INTR_REGISTER = ... # type: int
CTLREQ_NVM_REQUEST = ... # type: int
CTLREQ_SLEEP_CALL = ... # type: int
CTLREQ_SLEEP_PSEUDO = ... # type: int
CTLREQ_SPI_TRANSFER = ... # type: int
CTLREQ_TWI_BUS_ERROR = ... # type: int
CTLREQ_USART_BYTES = ... # type: int
CTLREQ_VREF_GET = ... # type: int
CTLREQ_VREF_SET = ... # type: int
CTLREQ_WATCHDOG_RESET = ... # type: int
INTERRUPT_NONE = ... # type: int
INVALID_CYCLE = ... # type: int
INVALID_REGISTER = ... # type: reg_addr_t
IOCTL_CLOCK = ... # type: int
IOCTL_CORE = ... # type: int
IOCTL_EEPROM = ... # type: int
IOCTL_EXTINT = ... # type: int
IOCTL_INTR = ... # type: int
IOCTL_NVM = ... # type: int
IOCTL_PORTMUX = ... # type: int
IOCTL_RST = ... # type: int
IOCTL_RTC = ... # type: int
IOCTL_SLEEP = ... # type: int
IOCTL_VREF = ... # type: int
IOCTL_WDT = ... # type: int
LIB_VERSION = ... # type: int
LIB_VERSION_STR = ... # type: str


def str_to_id(a0: typing.Optional[str]) -> int: ...
def id_to_str(a0: int) -> typing.Optional[str]: ...
def SleepModeName(a0: SleepMode) -> typing.Optional[str]: ...
def IOCTL_TWI(a0: str) -> int: ...
def IOCTL_SPI(a0: str) -> int: ...
def IOCTL_UART(a0: str) -> int: ...
def IOCTL_TIMER(a0: str, a1: str) -> int: ...
def IOCTL_ACP(a0: str) -> int: ...
def IOCTL_ADC(a0: str) -> int: ...
def IOCTL_PORT(a0: str) -> int: ...
def global_logger() -> Logger: ...
