"""
mEstimator submodule
"""
from __future__ import annotations
import typing
__all__: list[str] = ['AsymmetricCauchy', 'AsymmetricTukey', 'Base', 'Cauchy', 'Custom', 'DCS', 'Fair', 'GemanMcClure', 'Huber', 'L2WithDeadZone', 'Null', 'Tukey', 'Welsch']
M = typing.TypeVar("M", bound=int)
N = typing.TypeVar("N", bound=int)
class AsymmetricCauchy(Base):
    @staticmethod
    def Create(k: float) -> AsymmetricCauchy:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: float) -> None:
        ...
    @typing.overload
    def __init__(self, k: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class AsymmetricTukey(Base):
    @staticmethod
    def Create(k: float) -> AsymmetricTukey:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: float) -> None:
        ...
    @typing.overload
    def __init__(self, k: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Base:
    class ReweightScheme:
        """
        Members:
        
          Scalar
        
          Block
        """
        Block: typing.ClassVar[Base.ReweightScheme]  # value = <ReweightScheme.Block: 1>
        Scalar: typing.ClassVar[Base.ReweightScheme]  # value = <ReweightScheme.Scalar: 0>
        __members__: typing.ClassVar[dict[str, Base.ReweightScheme]]  # value = {'Scalar': <ReweightScheme.Scalar: 0>, 'Block': <ReweightScheme.Block: 1>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __repr__(self, s: str = '') -> str:
        ...
    def print(self, s: str = '') -> None:
        ...
class Cauchy(Base):
    @staticmethod
    def Create(k: float) -> Cauchy:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: float) -> None:
        ...
    @typing.overload
    def __init__(self, k: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Custom(Base):
    @staticmethod
    def Create(weight: typing.Callable[[float], float], loss: typing.Callable[[float], float], reweight: Base.ReweightScheme, name: str) -> Custom:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, weight: typing.Callable[[float], float], loss: typing.Callable[[float], float], reweight: Base.ReweightScheme, name: str) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class DCS(Base):
    @staticmethod
    def Create(c: float) -> DCS:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, c: float) -> None:
        ...
    @typing.overload
    def __init__(self, c: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Fair(Base):
    @staticmethod
    def Create(c: float) -> Fair:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, c: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class GemanMcClure(Base):
    @staticmethod
    def Create(c: float) -> GemanMcClure:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, c: float) -> None:
        ...
    @typing.overload
    def __init__(self, c: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Huber(Base):
    @staticmethod
    def Create(k: float) -> Huber:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, k: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class L2WithDeadZone(Base):
    @staticmethod
    def Create(k: float) -> L2WithDeadZone:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: float) -> None:
        ...
    @typing.overload
    def __init__(self, k: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Null(Base):
    @staticmethod
    def Create() -> Null:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Tukey(Base):
    @staticmethod
    def Create(k: float) -> Tukey:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: float) -> None:
        ...
    @typing.overload
    def __init__(self, k: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Welsch(Base):
    @staticmethod
    def Create(k: float) -> Welsch:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: float) -> None:
        ...
    @typing.overload
    def __init__(self, k: float, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: float) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: float) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
