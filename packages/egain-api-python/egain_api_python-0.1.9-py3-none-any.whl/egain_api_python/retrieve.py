"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from egain_api_python import errors, models, utils
from egain_api_python._hooks import HookContext
from egain_api_python.types import OptionalNullable, UNSET
from egain_api_python.utils import get_security_from_env
from egain_api_python.utils.unmarshal_json_response import unmarshal_json_response
from typing import Dict, List, Mapping, Optional, Union


class Retrieve(BaseSDK):
    def retrieve_chunks(
        self,
        *,
        q: str,
        portal_id: str,
        filter_user_profile_id: Optional[str] = None,
        language: Optional[models.LanguageCodeParameter] = None,
        filter_tags: Optional[Dict[str, List[str]]] = None,
        filter_topic_ids: Optional[List[str]] = None,
        channel: Optional[
            Union[models.RetrieveRequestChannel, models.RetrieveRequestChannelTypedDict]
        ] = None,
        event_id: Optional[str] = None,
        session_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RetrieveResponse:
        r"""Retrieve Chunks

        The Retrieve API enables enterprises to directly access relevant content chunks from their organizational knowledge sources. It is designed for scenarios where developers want granular control over retrieved information, such as powering custom search, analytics, or retrieval-augmented generation (RAG) pipelines.

        The Retrieve API's response will either be a Certified Answer or a list of chunks.
        - **Certified Answers Response**: This response is observed when there's a matching certified answer to the user's query.
        - **Chunk List Response**: This response is observed, if there is no matched Certified Answer.

        Responses for both chunks and certified answers include relevance scores and metadata. By leveraging the Retrieve API, organizations can build tailored experiences while retaining confidence in the source material.


        :param q: The search query string. The string must be escaped as required by the URL syntax rules.
        :param portal_id: The ID of the portal being accessed.<br><br>A portal ID is composed of a 2-4 letter prefix, followed by a dash and 4-15 digits.
        :param filter_user_profile_id:
        :param language: The language that describes the details of a resource. Resources available in different languages may differ from each other. <br><br> If lang is not passed, then the portal's default language is used.
        :param filter_tags: An object where each key is a **Category Tag ID** (numeric string),   and each value is an array of **Tag IDs** for that category.
        :param filter_topic_ids: An array of topic IDs. It is used to restrict search results to specific topics.
        :param channel:
        :param event_id: Unique ID for this specific API call or event.
        :param session_id: ID that ties multiple API calls to the same user session. Will be used as part of to tie events back to a session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.RETRIEVE_CHUNKS_OP_SERVERS[0]

        request = models.RetrieveChunksRequest(
            q=q,
            portal_id=portal_id,
            filter_user_profile_id=filter_user_profile_id,
            language=language,
            filter_tags=filter_tags,
            filter_topic_ids=filter_topic_ids,
            retrieve_request=models.RetrieveRequest(
                channel=utils.get_pydantic_model(
                    channel, Optional[models.RetrieveRequestChannel]
                ),
                event_id=event_id,
                session_id=session_id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/{portalID}/retrieve",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.retrieve_request,
                False,
                True,
                "json",
                Optional[models.RetrieveRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="retrieveChunks",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RetrieveResponse, http_res)
        if utils.match_response(http_res, ["400", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.EgainDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.EgainDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.EgainDefaultError("Unexpected response received", http_res)

    async def retrieve_chunks_async(
        self,
        *,
        q: str,
        portal_id: str,
        filter_user_profile_id: Optional[str] = None,
        language: Optional[models.LanguageCodeParameter] = None,
        filter_tags: Optional[Dict[str, List[str]]] = None,
        filter_topic_ids: Optional[List[str]] = None,
        channel: Optional[
            Union[models.RetrieveRequestChannel, models.RetrieveRequestChannelTypedDict]
        ] = None,
        event_id: Optional[str] = None,
        session_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RetrieveResponse:
        r"""Retrieve Chunks

        The Retrieve API enables enterprises to directly access relevant content chunks from their organizational knowledge sources. It is designed for scenarios where developers want granular control over retrieved information, such as powering custom search, analytics, or retrieval-augmented generation (RAG) pipelines.

        The Retrieve API's response will either be a Certified Answer or a list of chunks.
        - **Certified Answers Response**: This response is observed when there's a matching certified answer to the user's query.
        - **Chunk List Response**: This response is observed, if there is no matched Certified Answer.

        Responses for both chunks and certified answers include relevance scores and metadata. By leveraging the Retrieve API, organizations can build tailored experiences while retaining confidence in the source material.


        :param q: The search query string. The string must be escaped as required by the URL syntax rules.
        :param portal_id: The ID of the portal being accessed.<br><br>A portal ID is composed of a 2-4 letter prefix, followed by a dash and 4-15 digits.
        :param filter_user_profile_id:
        :param language: The language that describes the details of a resource. Resources available in different languages may differ from each other. <br><br> If lang is not passed, then the portal's default language is used.
        :param filter_tags: An object where each key is a **Category Tag ID** (numeric string),   and each value is an array of **Tag IDs** for that category.
        :param filter_topic_ids: An array of topic IDs. It is used to restrict search results to specific topics.
        :param channel:
        :param event_id: Unique ID for this specific API call or event.
        :param session_id: ID that ties multiple API calls to the same user session. Will be used as part of to tie events back to a session.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.RETRIEVE_CHUNKS_OP_SERVERS[0]

        request = models.RetrieveChunksRequest(
            q=q,
            portal_id=portal_id,
            filter_user_profile_id=filter_user_profile_id,
            language=language,
            filter_tags=filter_tags,
            filter_topic_ids=filter_topic_ids,
            retrieve_request=models.RetrieveRequest(
                channel=utils.get_pydantic_model(
                    channel, Optional[models.RetrieveRequestChannel]
                ),
                event_id=event_id,
                session_id=session_id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/{portalID}/retrieve",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.retrieve_request,
                False,
                True,
                "json",
                Optional[models.RetrieveRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="retrieveChunks",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.RetrieveResponse, http_res)
        if utils.match_response(http_res, ["400", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.EgainDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.EgainDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.EgainDefaultError("Unexpected response received", http_res)
