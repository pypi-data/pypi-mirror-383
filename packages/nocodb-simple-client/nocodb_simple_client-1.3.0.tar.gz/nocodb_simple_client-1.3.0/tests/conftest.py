"""
Shared test configuration and fixtures for NocoDB Simple Client tests.
"""

import os
import sys
from pathlib import Path
from typing import Any
from unittest.mock import Mock

import pytest
from dotenv import load_dotenv

# Add src to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))

from nocodb_simple_client.client import NocoDBClient
from nocodb_simple_client.table import NocoDBTable

# Load environment variables from .env file if it exists
env_file = Path(__file__).parent / ".env"
if env_file.exists():
    load_dotenv(env_file)


class TestConfig:
    """Test configuration class."""

    def __init__(self):
        self.base_url = os.getenv("NOCODB_BASE_URL", "http://localhost:8080")
        self.token = os.getenv("NOCODB_TOKEN")
        self.project_id = os.getenv("NOCODB_PROJECT_ID")
        self.database_id = os.getenv("NOCODB_DATABASE_ID")
        self.table_prefix = os.getenv("TEST_TABLE_PREFIX", "test_")
        self.cleanup_data = os.getenv("CLEANUP_TEST_DATA", "true").lower() == "true"
        self.run_integration = os.getenv("RUN_INTEGRATION_TESTS", "true").lower() == "true"
        self.skip_slow = os.getenv("SKIP_SLOW_TESTS", "false").lower() == "true"
        self.timeout = int(os.getenv("TEST_TIMEOUT", "30"))
        self.upload_dir = os.getenv("TEST_UPLOAD_DIR", "./test_uploads")
        self.max_file_size = int(os.getenv("MAX_FILE_SIZE_MB", "10"))
        self.performance_records = int(os.getenv("PERFORMANCE_TEST_RECORDS", "1000"))
        self.bulk_batch_size = int(os.getenv("BULK_TEST_BATCH_SIZE", "100"))

        if not self.token:
            raise ValueError(
                "NOCODB_TOKEN environment variable is required. "
                "Please set it or create a .env file in the tests directory."
            )


@pytest.fixture(scope="session")
def test_config():
    """Test configuration fixture."""
    return TestConfig()


@pytest.fixture(scope="session")
def nocodb_client(test_config):
    """NocoDB client fixture."""
    return NocoDBClient(base_url=test_config.base_url, token=test_config.token)


@pytest.fixture(scope="session")
def test_project_id(nocodb_client, test_config):
    """Get or create a test project."""
    # Check if project ID is provided via environment (GitHub Actions)
    if test_config.project_id:
        return test_config.project_id

    # Check for pre-created project from GitHub Actions
    github_project_id = os.getenv("NOCODB_PROJECT_ID")
    if github_project_id:
        return github_project_id

    # Try to get existing project or create a new one
    try:
        projects = nocodb_client.list_projects()
        test_project = next((p for p in projects if p["title"].startswith("Test_")), None)

        if test_project:
            return test_project["id"]
        else:
            # Create a new test project
            project_data = {
                "title": "Test_Project_AutoGenerated",
                "description": "Automated test project for NocoDB Simple Client",
            }
            new_project = nocodb_client.create_project(project_data)
            return new_project["id"]
    except Exception as e:
        pytest.skip(f"Could not access or create test project: {e}")


@pytest.fixture
def test_table_name(test_config):
    """Generate a unique test table name."""
    import uuid

    return f"{test_config.table_prefix}table_{uuid.uuid4().hex[:8]}"


@pytest.fixture
def test_table(nocodb_client, test_project_id, test_table_name, test_config):
    """Create a test table and clean it up after tests."""
    # Check if we have a pre-created table from GitHub Actions
    github_table_id = os.getenv("TEST_TABLE_ID")
    if github_table_id:
        # Use the pre-created table
        try:
            table_info = nocodb_client.get_table_info(github_table_id)
            yield table_info
            return
        except Exception:
            # If pre-created table doesn't work, create a new one
            pass

    table_data = {
        "title": test_table_name,
        "columns": [
            {"title": "id", "uidt": "ID", "pk": True, "ai": True, "rqd": True},
            {"title": "name", "uidt": "SingleLineText", "rqd": False},
            {"title": "email", "uidt": "Email", "rqd": False},
            {"title": "age", "uidt": "Number", "rqd": False},
            {
                "title": "status",
                "uidt": "SingleSelect",
                "dtxp": "active,inactive,pending",
                "rqd": False,
            },
            {"title": "created_at", "uidt": "DateTime", "rqd": False},
            {"title": "notes", "uidt": "LongText", "rqd": False},
        ],
    }

    try:
        # Create the table
        table = nocodb_client.create_table(test_project_id, table_data)
        table_id = table["id"]

        # Yield the table for tests
        yield table

    except Exception as e:
        pytest.fail(f"Failed to create test table: {e}")
    finally:
        # Cleanup: Delete the table if cleanup is enabled
        if test_config.cleanup_data and not github_table_id:
            try:
                nocodb_client.delete_table(table_id)
            except Exception as cleanup_error:
                print(f"Warning: Failed to cleanup test table {test_table_name}: {cleanup_error}")


@pytest.fixture
def test_table_with_data(test_table, nocodb_client):
    """Create a test table with sample data."""
    table_id = test_table["id"]

    # Sample test data
    sample_records = [
        {
            "name": "John Doe",
            "email": "john.doe@example.com",
            "age": 30,
            "status": "active",
            "notes": "Test user 1",
        },
        {
            "name": "Jane Smith",
            "email": "jane.smith@example.com",
            "age": 25,
            "status": "active",
            "notes": "Test user 2",
        },
        {
            "name": "Bob Johnson",
            "email": "bob.johnson@example.com",
            "age": 35,
            "status": "inactive",
            "notes": "Test user 3",
        },
        {
            "name": "Alice Brown",
            "email": "alice.brown@example.com",
            "age": 28,
            "status": "pending",
            "notes": "Test user 4",
        },
    ]

    # Insert sample data
    created_records = []
    for record in sample_records:
        try:
            created_record = nocodb_client.create_record(table_id, record)
            created_records.append(created_record)
        except Exception as e:
            print(f"Warning: Failed to create sample record: {e}")

    # Return table info with the created records
    table["sample_records"] = created_records
    return table


@pytest.fixture
def nocodb_table(nocodb_client, test_table):
    """NocoDBTable instance fixture."""
    return NocoDBTable(nocodb_client, test_table["id"])


@pytest.fixture
def skip_if_no_integration(test_config):
    """Skip test if integration tests are disabled."""
    if not test_config.run_integration:
        pytest.skip("Integration tests are disabled")


@pytest.fixture
def skip_if_slow(test_config):
    """Skip test if slow tests should be skipped."""
    if test_config.skip_slow:
        pytest.skip("Slow tests are disabled")


@pytest.fixture(scope="session")
def test_file_uploads_dir(test_config):
    """Create and provide test uploads directory."""
    upload_dir = Path(test_config.upload_dir)
    upload_dir.mkdir(parents=True, exist_ok=True)

    yield upload_dir

    # Cleanup entire upload directory
    try:
        if upload_dir.exists():
            import shutil

            shutil.rmtree(upload_dir)
    except Exception as e:
        print(f"Warning: Failed to cleanup test upload directory: {e}")


@pytest.fixture
def test_files(test_file_uploads_dir):
    """Generate test files dynamically during test execution."""
    import os
    import random
    import string
    from datetime import datetime

    created_files = {}

    def create_test_file(filename, size_kb=None, content_type="binary"):
        """Create a test file with specified size and type."""
        if size_kb is None:
            size_kb = random.randint(1, 1024)  # Random size up to 1MB

        file_path = test_file_uploads_dir / filename

        if content_type == "text":
            # Generate text content
            content = generate_text_content(size_kb * 1024)
        elif content_type == "image":
            # Generate fake image content (JPEG-like)
            content = generate_image_content(size_kb * 1024)
        elif content_type == "csv":
            # Generate CSV content
            content = generate_csv_content(size_kb * 1024)
        elif content_type == "json":
            # Generate JSON content
            content = generate_json_content(size_kb * 1024)
        else:
            # Generate random binary content
            content = os.urandom(size_kb * 1024)

        with open(file_path, "wb") as f:
            f.write(content)

        created_files[filename] = file_path
        return file_path

    def generate_text_content(size_bytes):
        """Generate text content of specified size."""
        text = (
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit. "
            "Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
            "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris. "
        )

        # Repeat text to reach desired size
        content = ""
        while len(content.encode("utf-8")) < size_bytes:
            content += text + f" Line {len(content) // len(text) + 1}\n"

        return content.encode("utf-8")[:size_bytes]

    def generate_image_content(size_bytes):
        """Generate fake JPEG image content."""
        # JPEG file header
        jpeg_header = b"\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00"
        # Fill with random data but keep it looking like image data
        remaining = size_bytes - len(jpeg_header) - 2  # Reserve 2 bytes for end marker
        random_data = bytes([random.randint(0, 255) for _ in range(remaining)])
        # JPEG end marker
        jpeg_end = b"\xff\xd9"

        return jpeg_header + random_data + jpeg_end

    def generate_csv_content(size_bytes):
        """Generate CSV content with random data."""
        import csv
        import io

        output = io.StringIO()
        writer = csv.writer(output)

        # Write header
        writer.writerow(["id", "name", "email", "age", "city", "country", "notes"])

        row_count = 0
        while output.tell() < size_bytes:
            row_count += 1
            writer.writerow(
                [
                    row_count,
                    f"User_{row_count}",
                    f"user{row_count}@example.com",
                    random.randint(18, 80),
                    random.choice(["Berlin", "Munich", "Hamburg", "Cologne", "Frankfurt"]),
                    random.choice(["Germany", "Austria", "Switzerland"]),
                    f"Notes for user {row_count} - "
                    + "".join(random.choices(string.ascii_letters, k=50)),
                ]
            )

        content = output.getvalue()
        return content.encode("utf-8")[:size_bytes]

    def generate_json_content(size_bytes):
        """Generate JSON content with nested structures."""
        import json

        data = {
            "metadata": {
                "generated_at": datetime.now().isoformat(),
                "version": "1.0",
                "type": "test_data",
            },
            "records": [],
        }

        record_count = 0
        while len(json.dumps(data).encode("utf-8")) < size_bytes:
            record_count += 1
            record = {
                "id": record_count,
                "name": f"Record {record_count}",
                "properties": {
                    "active": random.choice([True, False]),
                    "score": random.uniform(0.0, 100.0),
                    "tags": random.choices(
                        ["important", "test", "demo", "sample"], k=random.randint(1, 3)
                    ),
                    "description": "".join(random.choices(string.ascii_letters + " ", k=100)),
                },
                "timestamps": {
                    "created": datetime.now().isoformat(),
                    "updated": datetime.now().isoformat(),
                },
            }
            data["records"].append(record)

        content = json.dumps(data, indent=2)
        return content.encode("utf-8")[:size_bytes]

    # Create helper object with file creation method
    class TestFileManager:
        def __init__(self):
            self.create_file = create_test_file
            self.created_files = created_files

        def get_test_files(self):
            """Get a set of predefined test files."""
            files = {}

            # Small text file
            files["small_text.txt"] = self.create_file("small_text.txt", 1, "text")

            # Medium CSV file
            files["data.csv"] = self.create_file("data.csv", 50, "csv")

            # Large JSON file
            files["config.json"] = self.create_file("config.json", 200, "json")

            # Fake image file
            files["photo.jpg"] = self.create_file("photo.jpg", 100, "image")

            # Binary file
            files["binary_data.bin"] = self.create_file("binary_data.bin", 300)

            # Maximum size file (1MB)
            files["large_file.dat"] = self.create_file("large_file.dat", 1024)

            return files

    manager = TestFileManager()

    yield manager

    # Cleanup created files
    for file_path in created_files.values():
        try:
            if file_path.exists():
                file_path.unlink()
        except Exception as e:
            print(f"Warning: Failed to cleanup test file {file_path}: {e}")


def pytest_configure(config):
    """Configure pytest with custom markers."""
    config.addinivalue_line(
        "markers", "integration: marks tests as integration tests (requiring real NocoDB instance)"
    )
    config.addinivalue_line("markers", "slow: marks tests as slow (may take longer to execute)")
    config.addinivalue_line("markers", "performance: marks tests as performance tests")


def pytest_collection_modifyitems(config, items):
    """Modify test collection to add markers automatically."""
    for item in items:
        # Add integration marker to tests that use real client fixtures
        if any(
            fixture in item.fixturenames
            for fixture in ["nocodb_client", "test_table", "test_table_with_data"]
        ):
            item.add_marker(pytest.mark.integration)

        # Add slow marker to performance tests
        if "performance" in item.name.lower() or "bulk" in item.name.lower():
            item.add_marker(pytest.mark.slow)

        # Add performance marker for performance tests (optional by default)
        if "performance" in item.name.lower():
            item.add_marker(pytest.mark.performance)


class TestDataManager:
    """Helper class for managing test data."""

    def __init__(self, client: NocoDBClient, table_id: str):
        self.client = client
        self.table_id = table_id
        self.created_records = []

    def create_test_record(self, data: dict[str, Any]) -> dict[str, Any]:
        """Create a test record and track it for cleanup."""
        record = self.client.create_record(self.table_id, data)
        self.created_records.append(record)
        return record

    def create_test_records(self, records_data: list) -> list:
        """Create multiple test records and track them for cleanup."""
        created = []
        for data in records_data:
            record = self.create_test_record(data)
            created.append(record)
        return created

    def cleanup(self):
        """Clean up all created test records."""
        for record in reversed(self.created_records):  # Delete in reverse order
            try:
                self.client.delete_record(self.table_id, record["id"])
            except Exception as e:
                print(f"Warning: Failed to cleanup record {record.get('id')}: {e}")
        self.created_records.clear()


@pytest.fixture
def test_data_manager(nocodb_client, test_table):
    """Test data manager fixture for easy record creation and cleanup."""
    manager = TestDataManager(nocodb_client, test_table["id"])
    yield manager
    manager.cleanup()


# Helper functions for common test operations
def wait_for_condition(condition_func, timeout=10, interval=0.5):
    """Wait for a condition to be true."""
    import time

    end_time = time.time() + timeout
    while time.time() < end_time:
        if condition_func():
            return True
        time.sleep(interval)
    return False


def assert_record_equals(actual, expected, ignore_fields=None):
    """Assert that two records are equal, ignoring specified fields."""
    if ignore_fields is None:
        ignore_fields = ["id", "created_at", "updated_at"]

    for key, value in expected.items():
        if key not in ignore_fields:
            assert key in actual, f"Field {key} missing from actual record"
            assert actual[key] == value, f"Field {key}: expected {value}, got {actual[key]}"


# Legacy fixtures for backwards compatibility with existing tests
@pytest.fixture
def mock_response():
    """Create a mock HTTP response."""
    response = Mock()
    response.status_code = 200
    response.json.return_value = {"list": [], "pageInfo": {"isLastPage": True}}
    return response


@pytest.fixture
def mock_session(mock_response):
    """Create a mock requests session."""
    session = Mock()
    session.get.return_value = mock_response
    session.post.return_value = mock_response
    session.patch.return_value = mock_response
    session.put.return_value = mock_response
    session.delete.return_value = mock_response
    return session


@pytest.fixture
def client(mock_session, monkeypatch):
    """Create a NocoDBClient instance with mocked session."""

    def mock_session_init(*args, **kwargs):
        return mock_session

    monkeypatch.setattr("requests.Session", mock_session_init)

    return NocoDBClient(base_url="https://test.nocodb.com", db_auth_token="test-token")


@pytest.fixture
def table(client):
    """Create a NocoDBTable instance."""
    return NocoDBTable(client, table_id="test-table-id")


@pytest.fixture
def sample_record():
    """Sample record data for testing."""
    return {"Id": 1, "Name": "Test Record", "Email": "test@example.com", "Age": 25, "Active": True}


@pytest.fixture
def sample_records(sample_record):
    """Sample list of records for testing."""
    return [
        sample_record,
        {
            "Id": 2,
            "Name": "Test Record 2",
            "Email": "test2@example.com",
            "Age": 30,
            "Active": False,
        },
    ]
