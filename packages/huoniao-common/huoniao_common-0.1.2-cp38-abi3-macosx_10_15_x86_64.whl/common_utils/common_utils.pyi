import argparse
import collections
import datetime
import enum
import logging
import yaml
from _typeshed import Incomplete
from collections.abc import Generator
from html.parser import HTMLParser
from types import ModuleType
from typing import Any, Callable, Final, Literal, NamedTuple

BIN_FILE: str
BIN_ROOT: str
__version__: str

def get_compile_version() -> str: ...
def get_logger(name: str) -> logging.Logger: ...
def logger_append_file(logger: logging.Logger, file_name: str) -> logging.Logger: ...
def get_file_logger(name: str, file_name) -> logging.Logger: ...
def deprecated(func): ...

logger: logging.Logger
today_time: datetime.datetime
today_date: str
today_date_hour: str
yesterday_time: datetime.datetime
yesterday_date: str
yesterday_date_hour: str
two_days_ago_times: datetime.datetime
two_days_ago_date: str
TIME_KEY: Final[Literal['time_cost']]
SEP_VERTICAL_BAR: Final[Literal['|']]
SEP_SEMICOLON: Final[Literal[';']]
SEP_COLON: Final[Literal[':']]
SEP_COMMA: Final[Literal[',']]
SEP_TAB: Final[Literal['\t']]
SEP_AND: Final[Literal['&']]
SEP_EQUAL: Final[Literal['=']]
SEP_DOLLAR: Final[Literal['$']]
SEP_POUND_SIGN: Final[Literal['#']]
SEP_PLUS: Final[Literal['+']]
SEP_MINUS: Final[Literal['-']]
SEP_UNDERSCORE: Final[Literal['_']]
SEP_SOH: Final[Literal['\x01']]
SEP_DOT: Final[Literal['.']]

def set_logger_level(log_level=...) -> None: ...
def add_logger_file(file_name: str = './main.log') -> None: ...

class _EnhanceSafeLoader(yaml.SafeLoader):
    def __init__(self, stream) -> None: ...
    def include_udf(self, node: yaml.nodes.Node): ...
    def find_alias(self, node, tokens): ...
    def alias_udf(self, node: yaml.nodes.Node): ...

class list_to_keyvalue(argparse.Action):
    def __call__(self, parser, namespace, values, option_string: Incomplete | None = None) -> None: ...

class list_to_keyvalue2(argparse.Action):
    def __call__(self, parser, namespace, values, option_string: Incomplete | None = None) -> None: ...

def str_to_bool(v): ...
def parser_add_bool(given_parser, key, default: bool = False) -> None: ...
def init_default_parser(description: str = 'ARGS', task_name: str = 'default', change_config_name: bool = False): ...
def parse_args_and_yaml_argument(given_parser, cfg): ...
def parse_args_and_yaml(given_parser, parser_args, task_name: str = 'default', change_config_name: bool = False): ...
def callback_fn_demo(parser): ...
def init_parser(description: str = 'ARGS', task_name: str = 'default', callback_fn: Incomplete | None = None, parser_args: Incomplete | None = None, change_config_name: bool = False, **kwargs): ...
def is_ipython(): ...
def is_async_context(): ...
def is_async_callable(obj: Any) -> bool: ...
async def run_in_threadpool(func: Callable, *args, **kwargs): ...
def get_except_info() -> tuple[str, str]: ...
def print_to_string(*args, **kwargs): ...

class MLStripper(HTMLParser):
    strict: bool
    convert_charrefs: bool
    text: Incomplete
    def __init__(self) -> None: ...
    def handle_data(self, d) -> None: ...
    def get_data(self): ...

def strip_tags(html): ...
def retry(num: int = 3, check_data: Incomplete | None = None, sleep: float = 0.5, catch_except: bool = False): ...
def call_report(interval: int = 1000): ...

class _CacheInfo(NamedTuple):
    hits: Incomplete
    misses: Incomplete
    maxsize: Incomplete
    currsize: Incomplete

class LRUCache(collections.OrderedDict):
    maxsize: Incomplete
    hits: int
    misses: int
    report_times: Incomplete
    def __init__(self, maxsize: int = 128, report_times: int = 1000) -> None: ...
    def __call__(self, user_function): ...
    def get(self, key: Any) -> Any: ...
    def put(self, key: Any, value: Any) -> None: ...
    def cache_info(self): ...

class FileCache:
    hits: int
    misses: int
    def __init__(self, filename, **kwargs) -> None: ...
    def __del__(self) -> None: ...
    def __call__(self, user_function): ...
    def get(self, key: Any) -> Any: ...
    def put(self, key: Any, value: Any) -> None: ...
    def cache_info(self): ...

class ProcessorBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def __del__(self) -> None: ...
    def as_dict(self): ...
    def set_ready(self, ready: bool): ...
    def is_ready(self) -> bool: ...
    def name(self) -> str: ...
    def init(self) -> bool: ...
    def process(self, *args, **kwargs) -> Any: ...
    def __call__(self, *args, **kwargs) -> Any: ...

class FunctionProcessor(ProcessorBase):
    def __init__(self, user_function: Incomplete | None = None) -> None: ...
    def __call__(self, user_function): ...
    def process(self, *args, **kwargs) -> Any: ...
    def as_dict(self): ...

class ARG_TYPE(enum.Enum):
    DEFAULT = None
    FIXED = 'fixed'
    DISABLE = 'disable'

class StopRunError(Exception):
    message: Incomplete
    out_data: Incomplete
    def __init__(self, message: str = 'Stop the execution and return directly', out_data: Incomplete | None = None) -> None: ...

class Processor(ProcessorBase):
    def __init__(self, processors: ProcessorBase | Callable | list | dict | str, /, module: ModuleType = ..., input_arg_type: ARG_TYPE = None, update_global_kwargs: bool = False, use_aysnc_run: bool = False, return_exceptions: bool = False, *args, **kwargs) -> None: ...
    def as_dict(self): ...
    def init(self) -> bool: ...
    def process(self, in_data: Incomplete | None = None, /, g_kwargs={}, **kwargs) -> Any: ...

class ConditionalProcessor(ProcessorBase):
    def __init__(self, selector: ProcessorBase | Callable | dict | str, true_processors: ProcessorBase | Callable | list | dict | str, false_processors: ProcessorBase | Callable | list | dict | str, *args, **kwargs) -> None: ...
    def as_dict(self): ...
    def init(self) -> bool: ...
    def process(self, *args, **kwargs) -> Any: ...

class FunctionSelector(ConditionalProcessor):
    def __init__(self, user_function: Incomplete | None = None) -> None: ...
    def __call__(self, user_function: ProcessorBase | Callable): ...
    def init_function_object(self, *args, **kwargs) -> None: ...

class LoopProcessor(ProcessorBase):
    def __init__(self, looper: ProcessorBase | Callable | dict | str, processors: ProcessorBase | Callable | list | dict | str, merge_output: bool = True, use_aysnc_run: bool = False, *args, **kwargs) -> None: ...
    def as_dict(self): ...
    def init(self) -> bool: ...
    def process(self, in_data: Incomplete | None = None, *args, **kwargs) -> Any: ...

class FunctionLooper(LoopProcessor):
    def __init__(self, user_function: Incomplete | None = None) -> None: ...
    def __call__(self, user_function: ProcessorBase | Callable): ...
    def init_function_object(self, *args, **kwargs) -> None: ...

class ContextProcessor(Processor):
    def __init__(self, processors: ProcessorBase | Callable | list | dict | str = None, module: ModuleType = ..., model_args: Any = None, processors_ref: str = None, module_ref: str = None, model_args_ref: str = None, *args, **kwargs) -> None: ...

class StopRunProcessor(ProcessorBase):
    def process(self, in_data: Incomplete | None = None, **kwargs) -> Any: ...

class SimpleSelector(ConditionalProcessor):
    def __init__(self, selector: Incomplete | None = None, *args, **kwargs) -> None: ...

class SimpleLooper(LoopProcessor):
    def __init__(self, looper: Incomplete | None = None, *args, **kwargs) -> None: ...

class LRUCacheProcessor(ContextProcessor):
    def __init__(self, cache_keys: list[str] | str | int = 'in_data', cache_size: int = 128, *args, **kwargs) -> None: ...
    def as_dict(self): ...
    def process(self, in_data: Incomplete | None = None, *args, **kwargs) -> Any: ...

class SQLiteDB:
    db_file_path: Incomplete
    conn: Incomplete
    def __init__(self, db_file_path) -> None: ...
    def __del__(self) -> None: ...
    def open(self) -> None: ...
    def close(self) -> None: ...
    def query(self, sql): ...
    def execute(self, sql) -> None: ...

def send_notice(content, url) -> None: ...
def send_notice_markdown(content: str, url): ...
def send_notice_kv(data: list | dict, url, begin_info: str = '', end_info: str = ''): ...
def cmd_process_return_data(cmd_arr) -> Generator[Incomplete, Incomplete]: ...
def cmd_process(cmd_arr) -> None: ...
def install_and_import(module: str, package_name: str = None, target_path: str = None, *args): ...
