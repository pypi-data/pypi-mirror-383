{"version":3,"file":"tools-xmMdAE4-.js","sources":["../../src/utils/tools.ts"],"sourcesContent":["import {  ElLoading } from 'element-plus'\r\nimport { PREDEFINED_COLORS } from './const'\r\n\r\n/**\r\n * 金额格式化\r\n * @param num 金额\r\n * @param symbol 金额前面修饰符号，如$,￥\r\n */\r\nexport function format(num: number | string, symbol = '￥'): string {\r\n    if (Number.isNaN(Number(num))) return `${symbol}0.00`\r\n    return symbol + (Number(num).toFixed(2))\r\n        .replace(/(\\d)(?=(\\d{3})+\\.)/g, '$1,')\r\n}\r\n/**\r\n * 取消金额格式化\r\n * @param str 金额\r\n */\r\nexport function unformat(str: string): number | string {\r\n    const s = str.substr(1).replace(/\\,/g, '')\r\n    return Number.isNaN(Number(s)) || Number(s) === 0 ? '' : Number(s)\r\n}\r\n\r\n\r\nexport function isInput(el: HTMLElement): boolean {\r\n    return el.nodeName.toLocaleLowerCase() === 'input'\r\n}\r\nexport function isTextarea(el: HTMLElement): boolean {\r\n    return el.nodeName.toLocaleLowerCase() === 'textarea'\r\n}\r\n\r\n/**\r\n * localStorage设置有效期\r\n * @param name localStorage设置名称\r\n * @param data 数据对象\r\n * @param pExpires 有效期(默认100年)\r\n */\r\nexport function setLocal(name: string, data: IObject<any>, pExpires = 1000 * 60 * 60 * 24 * 365 * 100): void {\r\n    const d = data as ILocalStore\r\n    d.startTime = Date.now()\r\n    d.expires = pExpires\r\n    localStorage.setItem(name, JSON.stringify(data))\r\n}\r\n/**\r\n * 判断localStorage有效期是否失效\r\n * @param name localStorage设置名称\r\n */\r\nexport async function useLocal(name: string): Promise<ILocalStore> {\r\n    return new Promise((resolve, reject) => {\r\n        const local = getLocal<ILocalStore>(name)\r\n        if (local.startTime + local.expires < Date.now()) reject(`${name}已超过有效期`)\r\n        resolve(local)\r\n    })\r\n}\r\n/**\r\n * 获取localStorage对象并转成对应的类型\r\n * @param name localStorage设置名称\r\n */\r\nexport function getLocal<T>(name: string): T {\r\n    const l = localStorage.getItem(name)\r\n    const local = JSON.parse(l !== null ? l : '{}') as unknown as T\r\n    return local\r\n}\r\n\r\n/**\r\n * 函数节流\r\n * @param time 间隔时间\r\n */\r\nexport function throttle(time = 500): () => Promise<void> {\r\n    let timer: NodeJS.Timeout | null = null\r\n    let firstTime = true\r\n    return () => {\r\n        return new Promise(resolve => {\r\n            if (firstTime) {\r\n                resolve()\r\n                return firstTime = false\r\n            }\r\n            if (timer) return false\r\n            timer = setTimeout(() => {\r\n                if (timer) clearTimeout(timer)\r\n                timer = null\r\n                resolve()\r\n            }, time)\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * list结构转tree\r\n * @param data list原始数据\r\n * @param pid 最外层pid\r\n */\r\nexport function listToTree(data: Array<IMenubarList>, pid: string | number = 1, isChildNull = false): Array<IMenubarList> {\r\n    const d: Array<IMenubarList> = []\r\n    data.forEach(val => {\r\n        if (val.parentId == pid) {\r\n            const list = listToTree(data, val.id, isChildNull)\r\n            const obj: IMenubarList = { ...val }\r\n            if (!isChildNull || list.length !== 0) {\r\n                obj.children = list\r\n            }\r\n            d.push(obj)\r\n        }\r\n    })\r\n    return d\r\n}\r\n\r\n/**\r\n * 两次编码url\r\n * @param url \r\n * @returns \r\n */\r\nexport function decode(url: string): string {\r\n    return decodeURIComponent(decodeURIComponent(url))\r\n}\r\n\r\n/**\r\n * 两次解码url\r\n * @param url \r\n * @returns \r\n */\r\nexport function encode(url: string): string {\r\n    return encodeURIComponent(encodeURIComponent(url))\r\n}\r\n\r\nexport type PositionType = 'pixel-corner' | 'pixel-center';\r\n\r\nexport const getScoreFromFloat=(value) =>{\r\n    if(value){\r\n        return Math.floor(value * 100) / 100\r\n    }else {\r\n        return '暂无'\r\n    }\r\n}\r\n\r\nexport const calcAccurateOffset = (\r\n    e: Konva.KonvaEventObject<MouseEvent>,\r\n    positionType: PositionType = 'pixel-corner',\r\n): Position => {\r\n    const { currentTarget, evt } = e;\r\n    const roundFunction = positionType === 'pixel-corner' ? Math.round : Math.floor;\r\n    return {\r\n        x: roundFunction((evt.offsetX - (currentTarget.attrs.x ?? 0)) / currentTarget.attrs.scaleX),\r\n        y: roundFunction((evt.offsetY - (currentTarget.attrs.y ?? 0)) / currentTarget.attrs.scaleY),\r\n    };\r\n};\r\n\r\nexport const isAboutSameColor = (color1: RGB, color2: RGB) => {\r\n    if (Math.abs(color1[0] - color2[0]) + Math.abs(color1[1] - color2[1]) + Math.abs(color1[2] - color2[2]) < 8) {\r\n    // if (color1[0] == color2[0] && color1[1] == color2[1] && color1[2] == color2[2]) {\r\n        return true\r\n    } else {\r\n        return false\r\n    }\r\n}\r\n\r\n// 主要用于实例标注，因为实例标注的色块是纯色，所以需要使用颜色完全相同来判断\r\nexport const isAboutSameColorIns = (color1: RGB, color2: RGB) => {\r\n    if (color1[0] == color2[0] && color1[1] == color2[1] && color1[2] == color2[2]) {\r\n        return true\r\n    } else {\r\n        return false\r\n    }\r\n}\r\n\r\nexport const hexToRgb = (hex: string) => {\r\n    const fallback = { r: 0, g: 0, b: 0 };\r\n    if (!hex) return fallback;\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    return result\r\n        ? {\r\n            r: parseInt(result[1], 16),\r\n            g: parseInt(result[2], 16),\r\n            b: parseInt(result[3], 16),\r\n        }\r\n        : fallback;\r\n};\r\n\r\n/**\r\n * 将十六进制颜色转换为RGB颜色\r\n * @param hex 十六进制颜色字符串\r\n * @returns RGBA 颜色数组\r\n */\r\nexport const newHexToRgb = (hex: string) => {\r\n  const fallback = [0, 0, 0];\r\n  if (!hex) return fallback;\r\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n  return result\r\n      ? [\r\n           parseInt(result[1], 16),\r\n           parseInt(result[2], 16),\r\n           parseInt(result[3], 16),\r\n           255\r\n      ]\r\n      : fallback;\r\n}\r\n\r\nexport const rgbToHex = (color) => {\r\n    if(!color){\r\n        return \"#ffffff\"\r\n    }\r\n    if(Array.isArray(color)){\r\n        const [r, g, b] = color\r\n        const toHex = num => {\r\n            const hex = num.toString(16);\r\n            return hex.length === 1 ? `0${hex}` : hex;\r\n        };\r\n        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\r\n    }\r\n   return color\r\n};\r\n\r\nexport const rgbToReversColor = (color:any) => {\r\n    const [r, g, b] = color\r\n    if((r+g+b)/3>128){\r\n        return \"#000000\"\r\n    }else {\r\n        return \"#ffffff\"\r\n    }\r\n};\r\n\r\nexport const hexToRgbArray = (hex: string) => {\r\n    const fallback = [0, 0, 0];\r\n    if (!hex) return fallback;\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    return result\r\n        ? [\r\n            parseInt(result[1], 16),\r\n            parseInt(result[2], 16),\r\n            parseInt(result[3], 16),\r\n            255\r\n        ]\r\n        : fallback;\r\n};\r\nexport const  rgbArrayToHex = (color) => {\r\n    const [r, g, b] = color\r\n    const toHex = num => {\r\n      const hex = num.toString(16);\r\n      return hex.length === 1 ? `0${hex}` : hex;\r\n    };\r\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\r\n  };\r\n/**\r\n * Invert map of key,value map given that key,value are one to one\r\n * ex:\r\n * map:     { a: 1, b: 2 }\r\n * output:  { 1: a, 2: b }\r\n */\r\nexport const reverseMap = <K extends Key, V extends Key>(map: {\r\n    [K: string]: V;\r\n}): { [V: string]: K } => {\r\n    const init = {} as { [V: string]: K };\r\n    return Object.entries(map).reduce((obj, [k, v]) => {\r\n        // @ts-ignore\r\n        obj[v] = k;\r\n        return obj;\r\n    }, init);\r\n};\r\nexport const RLE_OPTIONS = { map: { Z: '0', N: '1' } };\r\n\r\nconst rleEncodeMap: Record<string, string> = reverseMap(RLE_OPTIONS.map);\r\nconst rleDecodeMap: Record<string, string> = RLE_OPTIONS.map;\r\n\r\nexport const runLengthEncode = (text: string | string[]) => {\r\n    if (!text) return text;\r\n    let result = '';\r\n\r\n    // Note: We are NOT using RegExp solution like text.match(/(.)\\1*/g) as it does not work for large\r\n    // consecutive similar chars.\r\n    // e.g. input Array(5e6).fill('1').join('') will cause RangeError: Maximum call stack size exceeded\r\n    // because String.match implementation is recursive.\r\n\r\n    // text[i, j) is a consecutive sub string.\r\n    let i = 0;\r\n    let j = 0;\r\n    const len = text.length;\r\n    while (j < len) {\r\n        const ch = text[i];\r\n        // find a different letter\r\n        while (j < len && text[j] == ch) {\r\n            ++j;\r\n        }\r\n        // add encoded string for this sub string\r\n        const substrLen = j - i;\r\n        result += substrLen + rleEncodeMap[ch];\r\n        i = j;\r\n    }\r\n\r\n    return result;\r\n};\r\nexport const runLengthDecode = (text: string) => {\r\n    if (!text) return text;\r\n    /**\r\n     * Groups all encoded pieces together\r\n     * 1N2Z1N3Z1N5Z1N2Z1N3Z1N3Z1N =>\r\n     * [\"12Z\", \"1N\", \"3Z\", \"1N\", \"5Z\", \"1N\", \"2Z\", \"1N\", \"3Z\", \"1N\", \"3Z\", \"1N\"]\r\n     */\r\n    const matches = text.match(/(\\d+)(\\w|\\s)/g);\r\n    /**\r\n     * Repeat each piece's last char with number\r\n     * 3Z = 000 1N = 1\r\n     */\r\n    return matches!.reduce((acc, str) => {\r\n        const decodedKey = rleDecodeMap[str.slice(-1)];\r\n        const times = Number(str.slice(0, str.length - 1));\r\n        return `${acc}${decodedKey.repeat(times)}`;\r\n    }, '');\r\n};\r\nexport const imageDataToCanvas = (imageData: ImageData) => {\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d', {\r\n        desynchronized: true,\r\n    });\r\n    canvas.width = imageData.width;\r\n    canvas.height = imageData.height;\r\n    ctx?.putImageData(imageData, 0, 0);\r\n    return canvas;\r\n};\r\n\r\nexport const canvasToBitMap = (canvas, Labels) => {\r\n    const annotationObj = { segmentations: [] }\r\n    const canvasWidth = canvas.width;\r\n    const canvasHeight = canvas.height;\r\n    const resizedContext = canvas.getContext('2d')!;\r\n    const annotationData = resizedContext.getImageData(0, 0, canvasWidth, canvasHeight).data;\r\n    Labels.forEach((item) => {\r\n\r\n        let hasDefect = false\r\n        const defectRgb = item.color;\r\n        const rangeBox = {\r\n            xmin: canvasWidth,\r\n            xmax: -1,\r\n            ymin: canvasHeight,\r\n            ymax: -1,\r\n        };\r\n\r\n        // first pass, create range boxes\r\n        for (let y = 0; y < canvasHeight; ++y) {\r\n            for (let x = 0; x < canvasWidth; ++x) {\r\n                const index = (y * canvasWidth + x) * 4;\r\n                const dataRgb = [annotationData[index], annotationData[index + 1], annotationData[index + 2]]\r\n                const alpha = annotationData[index + 3];\r\n                if (alpha && isAboutSameColor(dataRgb, defectRgb)) {\r\n                    hasDefect = true;\r\n                    rangeBox.xmin = Math.min(rangeBox.xmin, x);\r\n                    rangeBox.xmax = Math.max(rangeBox.xmax, x);\r\n                    rangeBox.ymin = Math.min(rangeBox.ymin, y);\r\n                    rangeBox.ymax = Math.max(rangeBox.ymax, y);\r\n                }\r\n            }\r\n        }\r\n        if (!hasDefect) {\r\n            return\r\n        }\r\n        // second pass, generate bit map string\r\n        const { xmin, ymin, xmax, ymax } = rangeBox;\r\n        // instead of directly concatenating a single string, use char array to\r\n        // avoid multiple memory allocations for large bitmap\r\n        const width = xmax - xmin + 1, height = ymax - ymin + 1\r\n        const bitMapArr = Array((width) * (height)).fill('0');\r\n        let bitMapIndex = 0;\r\n\r\n        for (let y = ymin; y <= ymax; ++y) {\r\n            for (let x = xmin; x <= xmax; ++x) {\r\n                const index = (y * canvasWidth + x) * 4;\r\n                const dataRgb = [annotationData[index], annotationData[index + 1], annotationData[index + 2]]\r\n\r\n                const alpha = annotationData[index + 3];\r\n                if (alpha && isAboutSameColor(dataRgb, defectRgb)) {\r\n                    bitMapArr[bitMapIndex++] = '1';\r\n                } else {\r\n                    bitMapArr[bitMapIndex++] = '0';\r\n                }\r\n            }\r\n        }\r\n\r\n        // item['bitmap'] = bitMapArr,\r\n        // item['rangeBox'] = rangeBox\r\n        const annotationItem = {\r\n            rangeBox: [xmin, ymin, width, height],\r\n            segmentationMap: runLengthEncode(bitMapArr),\r\n            labelName: item.name,\r\n            labelId: item.id,\r\n            // labelIndex: item.index\r\n        }\r\n        annotationObj.segmentations.push(annotationItem)\r\n    });\r\n    return annotationObj\r\n}\r\n\r\nexport const instanceCanvasToBitMap = (canvas: any, instanceImages: any) => {\r\n    const annotationObj = { instances: [] }\r\n    const canvasWidth = canvas.width;\r\n    const canvasHeight = canvas.height;\r\n    const resizedContext = canvas.getContext('2d')!;\r\n    const annotationData = resizedContext.getImageData(0, 0, canvasWidth, canvasHeight).data;\r\n    instanceImages.forEach((instance: any) => {\r\n\r\n        let hasDefect = false\r\n        const instanceColor = hexToRgb(instance.color) || null;\r\n        if (!instanceColor) return;\r\n\r\n        const defectRgb = [instanceColor.r, instanceColor.g, instanceColor.b];\r\n        const rangeBox = {\r\n            xmin: canvasWidth,\r\n            xmax: -1,\r\n            ymin: canvasHeight,\r\n            ymax: -1,\r\n        };\r\n\r\n        // first pass, create range boxes\r\n        for (let y = 0; y < canvasHeight; ++y) {\r\n            for (let x = 0; x < canvasWidth; ++x) {\r\n                const index = (y * canvasWidth + x) * 4;\r\n                const dataRgb = [annotationData[index], annotationData[index + 1], annotationData[index + 2]]\r\n                const alpha = annotationData[index + 3];\r\n                if (alpha && isAboutSameColorIns(dataRgb, defectRgb)) {\r\n                    hasDefect = true;\r\n                    rangeBox.xmin = Math.min(rangeBox.xmin, x);\r\n                    rangeBox.xmax = Math.max(rangeBox.xmax, x);\r\n                    rangeBox.ymin = Math.min(rangeBox.ymin, y);\r\n                    rangeBox.ymax = Math.max(rangeBox.ymax, y);\r\n                }\r\n            }\r\n        }\r\n        if (!hasDefect) {\r\n            return\r\n        }\r\n\r\n        const { xmin, ymin, xmax, ymax } = rangeBox;\r\n        const width = xmax - xmin + 1, height = ymax - ymin + 1\r\n        const bitMapArr = Array((width) * (height)).fill('0');\r\n        let bitMapIndex = 0;\r\n\r\n        for (let y = ymin; y <= ymax; ++y) {\r\n            for (let x = xmin; x <= xmax; ++x) {\r\n                const index = (y * canvasWidth + x) * 4;\r\n                const dataRgb = [annotationData[index], annotationData[index + 1], annotationData[index + 2]]\r\n\r\n                const alpha = annotationData[index + 3];\r\n                if (alpha && isAboutSameColorIns(dataRgb, defectRgb)) {\r\n                    bitMapArr[bitMapIndex++] = '1';\r\n                } else {\r\n                    bitMapArr[bitMapIndex++] = '0';\r\n                }\r\n            }\r\n        }\r\n\r\n        const annotationItem = {\r\n            rangeBox: [xmin, ymin, width, height],\r\n            segmentationMap: runLengthEncode(bitMapArr),\r\n            labelName: instance.name.split(' - 实例')[0],\r\n            boundingBox: [xmin, ymin, width, height]\r\n        }\r\n        annotationObj.instances.push(annotationItem)\r\n    });\r\n    return annotationObj\r\n}\r\n\r\nexport const getRangeBoxFromLinePoints = (\r\n    points: number[],\r\n    strokeWidth: number,\r\n    isPolygon?: boolean,\r\n) => {\r\n    const padding = isPolygon ? 1 : strokeWidth;\r\n    const rangeBox = points.reduce((acc, x, index) => {\r\n        if (index % 2 !== 0) return acc;\r\n        const y = points[index + 1];\r\n        return {\r\n            xmin: Math.min(x - padding, acc?.xmin ?? Infinity),\r\n            xmax: Math.max(x + padding, acc?.xmax ?? 0),\r\n            ymin: Math.min(y - padding, acc?.ymin ?? Infinity),\r\n            ymax: Math.max(y + padding, acc?.ymax ?? 0),\r\n        };\r\n    }, {} as RangeBox);\r\n    return rangeBox;\r\n};\r\n/**\r\n * return Euclidean distance between two points\r\n */\r\nexport function distance(x1: number, y1: number, x2: number, y2: number) {\r\n    return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\r\n}\r\n\r\n\r\nexport const getBase64ByData = async (item: any, yheight: any, yWidth: any, labelColor: any) => {\r\n    let x = 0, y = 0, width = yWidth, height = yheight;\r\n    if (item.rangeBox) {\r\n        x = item.rangeBox[0]\r\n        y = item.rangeBox[1]\r\n        width = item.rangeBox[2]\r\n        height = item.rangeBox[3]\r\n    }\r\n\r\n    const offscreen = new OffscreenCanvas(yWidth, yheight);\r\n    const context = offscreen.getContext('2d', {\r\n        desynchronized: true,\r\n    });\r\n    context.imageSmoothingEnabled = false\r\n    context.webkitImageSmoothingEnabled = false\r\n\r\n    var imagedata = context.createImageData(width, height)\r\n    var array = imagedata.data;\r\n    imagedata.data.fill(0)\r\n    const segmentationBitmap = runLengthDecode(item.segmentationMap)\r\n\r\n    for (let index = 0, mapIndex = 0; index < array.length; index += 4, mapIndex++) {\r\n        if (segmentationBitmap[mapIndex] == \"1\") {\r\n            imagedata.data[index] = labelColor[0]\r\n            imagedata.data[index + 1] = labelColor[1]\r\n            imagedata.data[index + 2] = labelColor[2]//item.color[2]\r\n            imagedata.data[index + 3] = 255 * 0.6\r\n        }\r\n    }\r\n    context.putImageData(imagedata, x, y)\r\n    const blob = await offscreen.convertToBlob();\r\n    return blob\r\n}\r\n\r\n\r\n\r\nexport const imageToAvailableArray = (\r\n    image?: HTMLImageElement,\r\n    { width, height }: Dimensions = { width: 0, height: 0 }\r\n) => {\r\n    if (image) {\r\n        const offscreen = new OffscreenCanvas(width, height);\r\n        const context = offscreen.getContext('2d', {\r\n            desynchronized: true,\r\n        })!;\r\n        context.imageSmoothingEnabled = false;\r\n        context.drawImage(image, 0, 0);\r\n        let imageData=context.getImageData(0, 0, width, height).data\r\n        let result=[];\r\n        let result1=[];\r\n        let region=false\r\n        for (let i = 0; i < imageData.length; i += 4) {\r\n            let regionScore = imageData[i+1] ;\r\n            if(regionScore!=0){\r\n                region=true\r\n                result1.push([i,regionScore,imageData[i + 2]-1])\r\n            }\r\n            let pixedScore = imageData[i] ;\r\n            if(pixedScore!=0){\r\n                result.push([i,pixedScore,imageData[i + 2]-1])\r\n            }\r\n        }\r\n        return region?result1:result\r\n    } else {\r\n        return [];\r\n    }\r\n};\r\n\r\n\r\n// Calculating point to line distance - https://gist.github.com/mattdesl/47412d930dcd8cd765c871a65532ffac\r\nfunction distanceToLine(point: Position, line: { sx: number; sy: number; ex: number; ey: number }) {\r\n    const dx = line.ex - line.sx;\r\n    const dy = line.ey - line.sy;\r\n    const l2 = dx * dx + dy * dy;\r\n\r\n    if (l2 == 0) return distance(point.x, point.y, line.sx, line.sy);\r\n\r\n    let t = ((point.x - line.sx) * dx + (point.y - line.sy) * dy) / l2;\r\n    t = Math.max(0, Math.min(1, t));\r\n\r\n    return distance(point.x, point.y, line.sx + t * dx, line.sy + t * dy);\r\n}\r\n\r\n/**\r\n * when line, pixel has to be within `strokeWidth` of the joint line of 2 adjacent points\r\n */\r\nexport const pixelBelongToLine =\r\n    (pts: number[], strokeWidth: number) =>\r\n        (pixel: [number, number]): boolean => {\r\n            // console.log(pts);\r\n            return pts.some((thisPt, index) => {\r\n                if (index === pts.length - 3 || index % 2 !== 0) {\r\n                    return false;\r\n                }\r\n                const curPt = [thisPt, pts[index + 1]];\r\n                const nextPt = [pts[index + 2], pts[index + 3]];\r\n                const distance = distanceToLine(\r\n                    { x: pixel[0], y: pixel[1] },\r\n                    { sx: curPt[0], sy: curPt[1], ex: nextPt[0], ey: nextPt[1] },\r\n                );\r\n                // if(distance<strokeWidth)console.log(curPt);\r\n                return distance < strokeWidth;//这里比较重要<和<=画出来有不同效果\r\n            });\r\n        };\r\nexport function createPixelCanvas(canvas: HTMLCanvasElement, color: Array): HTMLCanvasElement {\r\n    const ctx = canvas.getContext(\"2d\");\r\n    const imageData = ctx?.getImageData(0, 0, canvas.width, canvas.height);\r\n    const array = imageData?.data\r\n    ctx.imageSmoothingEnabled = false\r\n    ctx.webkitImageSmoothingEnabled = false\r\n    // const putData = ctx?.createImageData(canvas.width,canvas.height)\r\n    for (let index = 0; index < array.length; index += 4) {\r\n        const dataRgb = [array[index], array[index + 1], array[index + 2]];\r\n        if (isAboutSameColor(dataRgb, color)) {\r\n            // console.log('========')\r\n            imageData.data[index] = color[0]\r\n            imageData.data[index + 1] = color[1]\r\n            imageData.data[index + 2] = color[2]\r\n            imageData.data[index + 3] = 255 * 1//0.6\r\n        } else {\r\n            // imageData.data[index+3]=0\r\n        }\r\n    }\r\n    ctx?.putImageData(imageData, 0, 0)\r\n    return canvas\r\n}\r\nexport type Position = { x: number; y: number };\r\nexport type Dimensions = { width: number; height: number };\r\nexport type Box = Position & Dimensions;\r\nexport const createPixelatedCanvas = (//数据详情标注页笔刷点击鼠标抬起触发mouseup\r\n    canvasDimensions: Dimensions,\r\n    pixelBelongFunction: (index: { x: number; y: number; i: number }) => boolean,\r\n    color: string | ((index: { x: number; y: number; i: number }) => RGB),\r\n    opacity: number = 1,\r\n    compressOptions?: { baseWidth: number; baseHeight: number },\r\n): OffscreenCanvas => {\r\n    const { width, height } = canvasDimensions;\r\n    const { baseWidth, baseHeight } = compressOptions ?? { baseWidth: width, baseHeight: height };\r\n    const scaleX = width < baseWidth ? 1 : width / baseWidth;\r\n    const scaleY = height < baseHeight ? 1 : height / baseHeight;\r\n    const scaledWidth = Math.floor(width / scaleX);\r\n    const scaledHeight = Math.floor(height / scaleY);\r\n\r\n    const rgb = typeof color === 'string' ? hexToRgb(color) : color//{ r: 0, g: 0, b: 0 };\r\n    const offscreen = new OffscreenCanvas(scaledWidth, scaledHeight);\r\n    const context = offscreen.getContext('2d', {\r\n        desynchronized: true,\r\n    })!;\r\n    context.imageSmoothingEnabled = false;\r\n    const imageData = context.createImageData(scaledWidth, scaledHeight);\r\n    for (let y = 0; y < scaledHeight; y++) {\r\n        for (let x = 0; x < scaledWidth; x++) {\r\n            const index = {\r\n                x: x * scaleX,\r\n                y: y * scaleY,\r\n                i: Math.floor(y * scaleY) * width + Math.floor(x * scaleX),\r\n            };\r\n            if (pixelBelongFunction(index)) {\r\n                const imageDataIndex = 4 * (y * scaledWidth + x);\r\n                const { r, g, b } = typeof color === 'function' ? color(index) : rgb;\r\n                // console.log(r,g,b)\r\n                imageData.data[imageDataIndex + 0] = r; // R value\r\n                imageData.data[imageDataIndex + 1] = g; // G value\r\n                imageData.data[imageDataIndex + 2] = b; // B value\r\n                imageData.data[imageDataIndex + 3] = 255 * opacity; // A value\r\n                // imageData.data[imageDataIndex + 0] = 0; // R value\r\n                // imageData.data[imageDataIndex + 1] = 0; // G value\r\n                // imageData.data[imageDataIndex + 2] = 0; // B value\r\n                // imageData.data[imageDataIndex + 3] = 0; // A value\r\n            }\r\n        }\r\n    }\r\n\r\n    context.scale(scaleX, scaleY);\r\n    context.putImageData(imageData, 0, 0);\r\n    return offscreen;\r\n};\r\nexport const resizeCanvas = (\r\n    inputCanvas: HTMLCanvasElement | OffscreenCanvas,\r\n    targetDimension: Dimensions,\r\n): OffscreenCanvas => {\r\n    if (\r\n        inputCanvas.width === targetDimension.width &&\r\n        inputCanvas.height === targetDimension.height\r\n    ) {\r\n        return inputCanvas as OffscreenCanvas;\r\n    }\r\n    const resizedCanvas = new OffscreenCanvas(targetDimension.width, targetDimension.height);\r\n    const resizedContext = resizedCanvas.getContext('2d', {\r\n        desynchronized: true,\r\n    })!;\r\n    resizedContext.imageSmoothingEnabled = false;\r\n    resizedContext.scale(\r\n        targetDimension.width / inputCanvas.width,\r\n        targetDimension.height / inputCanvas.height,\r\n    );\r\n    resizedContext.drawImage(inputCanvas, 0, 0);\r\n    return resizedCanvas;\r\n};\r\n\r\nexport const pixelBelongInsidePolygon =\r\n  (pts: number[]) =>\r\n  (pixel: [number, number]): boolean => {\r\n    let [x, y] = pixel;\r\n    // we should check if the center point of a pixel locates in the polygon, not the top-left point.\r\n    x += 0.5;\r\n    y += 0.5;\r\n\r\n    let inside = false;\r\n    for (let i = 0, j = pts.length - 2; i < pts.length; j = i, i += 2) {\r\n      const xi = pts[i];\r\n      const yi = pts[i + 1];\r\n      const xj = pts[j];\r\n      const yj = pts[j + 1];\r\n\r\n      const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\r\n      if (intersect) inside = !inside;\r\n    }\r\n\r\n    return inside;\r\n  };\r\n\r\n  export const bitmapToBoxCanvas = (bitmap, width, height, color) => {\r\n    // var { x, y, width, height } = { x: rangeBox[0], y: rangeBox[1], width: rangeBox[2], height: rangeBox[3] }\r\n    const offscreen = new OffscreenCanvas(width, height);\r\n    const context = offscreen.getContext('2d', {\r\n      desynchronized: true,\r\n    });\r\n    context.imageSmoothingEnabled = false;\r\n    context.webkitImageSmoothingEnabled = false;\r\n    \r\n    var imagedata = context.createImageData(width, height);\r\n    var array = imagedata.data;\r\n    imagedata.data.fill(0);\r\n    const segmentationBitmap = runLengthDecode(bitmap);\r\n    \r\n    // 处理各种颜色格式\r\n    let labelColor;\r\n    \r\n    // 如果是字符串格式的颜色（如 \"#FF0000\" 或 \"rgba(255,0,0,1)\"）\r\n    if (typeof color === 'string') {\r\n      // 处理hex颜色格式\r\n      if (color.startsWith('#')) {\r\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(color);\r\n        if (result) {\r\n          labelColor = [\r\n            parseInt(result[1], 16),\r\n            parseInt(result[2], 16),\r\n            parseInt(result[3], 16)\r\n          ];\r\n        }\r\n      } \r\n      // 处理rgba颜色格式\r\n      else if (color.startsWith('rgba')) {\r\n        const rgbaMatch = color.match(/rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*[\\d.]+\\s*\\)/);\r\n        if (rgbaMatch) {\r\n          labelColor = [\r\n            parseInt(rgbaMatch[1]),\r\n            parseInt(rgbaMatch[2]),\r\n            parseInt(rgbaMatch[3])\r\n          ];\r\n        }\r\n      }\r\n      // 处理rgb颜色格式\r\n      else if (color.startsWith('rgb')) {\r\n        const rgbMatch = color.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\r\n        if (rgbMatch) {\r\n          labelColor = [\r\n            parseInt(rgbMatch[1]),\r\n            parseInt(rgbMatch[2]),\r\n            parseInt(rgbMatch[3])\r\n          ];\r\n        }\r\n      }\r\n    } \r\n    // 如果是数组格式（如 [255, 0, 0, 255]）\r\n    else if (Array.isArray(color)) {\r\n      labelColor = color;\r\n    }\r\n    \r\n    // 如果无法解析颜色，使用默认红色\r\n    if (!labelColor) {\r\n      labelColor = [255, 0, 0];\r\n    }\r\n    labelColor = [255, 255, 0];\r\n    for (let index = 0, mapIndex = 0; index < array.length; index += 4, mapIndex++) {\r\n      if (segmentationBitmap[mapIndex] == \"1\") {\r\n        imagedata.data[index] = labelColor[0];\r\n        imagedata.data[index + 1] = labelColor[1];\r\n        imagedata.data[index + 2] = labelColor[2]; //item.color[2]\r\n        imagedata.data[index + 3] = 255;\r\n      } else {\r\n        // 透明像素保持不变\r\n      }\r\n    }\r\n    context.putImageData(imagedata, 0, 0);\r\n    return offscreen;\r\n  }\r\nexport const clickDownloadUrl = (url,filename) => {\r\n\r\n\r\n    // var x = new XMLHttpRequest();\r\n    // x.open(\"GET\", url, false);\r\n    // x.responseType = 'blob';\r\n    // x.onload=function(e) {\r\n    //     //会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。\r\n    //     var url = window.URL.createObjectURL(x.response)\r\n    //     var a = document.createElement('a');\r\n    //     a.href = url\r\n    //     a.download = filename;\r\n    //     a.click()\r\n    // }\r\n    // x.send();\r\n    const a = document.createElement('a'); // 创建一个HTML 元素\r\n    // let url = url;\r\n    a.setAttribute('download', filename); //download属性\r\n    a.setAttribute('href', url); // href链接\r\n    a.click(); // 自执行点击事件\r\n\r\n  }\r\n\r\nexport const  downloadStr=(filename:string, text:string) =>{\r\n    var element = document.createElement('a');\r\n    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\r\n    element.setAttribute('download', filename);\r\n    element.style.display = 'none';\r\n    document.body.appendChild(element);\r\n\r\n    element.click();\r\n\r\n    document.body.removeChild(element);\r\n}\r\nexport const rateFormat=(value: number) =>{\r\n    return (100*value).toFixed(2)+\"%\"\r\n}\r\n\r\nexport const formatTimeDifference=(startTime,endTime) =>{\r\n    let timeDiff = Math.abs(new Date(startTime) - new Date(endTime));\r\n\r\n    let hours = Math.floor(timeDiff / 3600000); // 计算小时数\r\n    let minutes = Math.floor((timeDiff % 3600000) / 60000); // 计算分钟数\r\n    let seconds = Math.floor((timeDiff % 60000) / 1000); // 计算秒数\r\n\r\n    let result = \"\";\r\n\r\n    if (hours > 0) {\r\n        result += hours + \"小时 \";\r\n    }\r\n\r\n    if (minutes > 0) {\r\n        result += minutes + \"分钟 \";\r\n    }\r\n    if (seconds > 0) {\r\n        result += seconds + \"秒 \";\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport const sumFn = (sum: number, { count }: { count: number }) => sum + count;\r\n\r\n/**\r\n * 获取最后一个/后的字符\r\n * 'test/test1/test2'\r\n *  return test2\r\n * */\r\nexport const getLastStr=(path:any) =>{\r\n    let lastIndex = path.lastIndexOf('/');\r\n    if (lastIndex !== -1) {\r\n        return path.substring(lastIndex + 1);\r\n    } else {\r\n        return path; // 如果没有斜杠，则返回原字符串\r\n    }\r\n}\r\n// function dddd(){\r\n\r\n// }\r\nexport const cacheLoading = (param, callback) => {\r\n    const loading = ElLoading.service({\r\n        lock: true,\r\n        text: 'Loading',\r\n        background: 'rgba(0, 0, 0, 0.7)',\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n        let intv = setInterval(async () => {\r\n            try {\r\n                const res1 = await callback(param);\r\n                // 循环逐条显示数据\r\n                for (let i = 0; i < res1.data.data.samples.length; i++) {\r\n                    loading.setText(res1.data.data.samples[i]); // 更新加载框中的文本\r\n                    await new Promise(resolve => setTimeout(resolve, 50)); // 等待 500 毫秒后显示下一条数据\r\n                }\r\n\r\n                if (res1.data.data.samples.length == 0) {\r\n                    loading.close();\r\n                    clearInterval(intv);\r\n                    resolve();\r\n                }\r\n            } catch (error) {\r\n                console.error('Error:', error);\r\n                loading.close();\r\n                reject(error);\r\n            }\r\n        }, 2000);\r\n    });\r\n};\r\n\r\n\r\nexport const isNullOrUndefined = (val: any) => {\r\n    if (typeof (val) === 'undefined') {\r\n        return true\r\n    }\r\n    if (val == null) {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n/**\r\n * 给url加时间,戳防止缓存\r\n* */\r\nexport const addUrlDate=(url:string): string =>{\r\n   if(url){\r\n       if(url.includes(\"?\")){\r\n           return url + '&t=' + Date.now()\r\n       }else {\r\n          return url + '?t=' + Date.now()\r\n       }\r\n   }\r\n   return ''\r\n}\r\n\r\n/**\r\n * 给url加token,资源鉴权\r\n * */\r\nexport const addUrlToken=(url:string,token:string): string =>{\r\n    if(url){\r\n        if(url.includes(\"?\")){\r\n            return url + '&token=' + token\r\n        }else {\r\n            return url + '?token=' + token\r\n        }\r\n    }\r\n    return ''\r\n}\r\n\r\nexport const getRatio=()=>\r\n{\r\n    var ratio=0;\r\n    var screen=window.screen;\r\n    // var ua=navigator.userAgent.toLowerCase();\r\n    var ua=navigator.userAgent;\r\n\r\n    if(window.devicePixelRatio !== undefined)\r\n    {\r\n        ratio=window.devicePixelRatio;\r\n    }\r\n    else if(~ua.indexOf('msie'))\r\n    {\r\n        if(screen.deviceXDPI && screen.logicalXDPI)\r\n        {\r\n            ratio=screen.deviceXDPI/screen.logicalXDPI;\r\n        }\r\n\r\n    }\r\n    else if(window.outerWidth !== undefined && window.innerWidth !== undefined)\r\n    {\r\n        ratio=window.outerWidth/window.innerWidth;\r\n    }\r\n\r\n    if(ratio)\r\n    {\r\n        ratio=Math.round(ratio*100);\r\n    }\r\n    return ratio/100;\r\n}\r\n\r\nexport const bytesToSize = (size,unit) => {\r\n    if (unit == 'GB') {\r\n      // 其他转化成GB\r\n      size = (parseFloat(size) / (1024 * 1024 * 1024)).toFixed(2) + 'GB'\r\n    }\r\n   \r\n    // 转成字符串\r\n    let sizeStr = size + '',\r\n      // 获取小数点处的索引\r\n      index = sizeStr.indexOf('.'),\r\n      // 获取小数点后两位的值\r\n      dou = sizeStr.substr(index + 1, 2)\r\n   \r\n    // 判断后两位是否为00，如果是则删除00\r\n    if (dou == '00')\r\n      return sizeStr.substring(0, index) + sizeStr.substr(index + 3, 2)\r\n   \r\n    return size\r\n  }\r\n\r\n// 根据index获取颜色, 输出 rgb 格式\r\nexport const getColorByIndex = (index: number) => {\r\n    if (index >= 0 && index <= PREDEFINED_COLORS.length) {\r\n        return newHexToRgb(PREDEFINED_COLORS[index]);\r\n    } else {\r\n        return [\r\n            Math.floor(Math.random() * 255),\r\n            Math.floor(Math.random() * 255),\r\n            Math.floor(Math.random() * 255),\r\n            255\r\n        ];\r\n    }\r\n}\r\n"],"names":["isAboutSameColor","color1","color2","isAboutSameColorIns","hexToRgb","hex","fallback","result","newHexToRgb","rgbToHex","color","r","g","b","toHex","num","hexToRgbArray","reverseMap","map","init","obj","k","v","RLE_OPTIONS","rleEncodeMap","rleDecodeMap","runLengthEncode","text","i","j","len","ch","substrLen","runLengthDecode","acc","str","decodedKey","times","canvasToBitMap","canvas","Labels","annotationObj","canvasWidth","canvasHeight","annotationData","item","hasDefect","defectRgb","rangeBox","y","x","index","dataRgb","xmin","ymin","xmax","ymax","width","height","bitMapArr","bitMapIndex","annotationItem","instanceCanvasToBitMap","instanceImages","instance","instanceColor","getRangeBoxFromLinePoints","points","strokeWidth","isPolygon","padding","distance","x1","y1","x2","y2","imageToAvailableArray","image","context","imageData","result1","region","regionScore","pixedScore","distanceToLine","point","line","dx","dy","l2","t","pixelBelongToLine","pts","pixel","thisPt","curPt","nextPt","createPixelatedCanvas","canvasDimensions","pixelBelongFunction","opacity","compressOptions","baseWidth","baseHeight","scaleX","scaleY","scaledWidth","scaledHeight","rgb","offscreen","imageDataIndex","pixelBelongInsidePolygon","inside","xi","yi","xj","yj","clickDownloadUrl","url","filename","a","rateFormat","value","addUrlDate","getColorByIndex","PREDEFINED_COLORS"],"mappings":"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"}