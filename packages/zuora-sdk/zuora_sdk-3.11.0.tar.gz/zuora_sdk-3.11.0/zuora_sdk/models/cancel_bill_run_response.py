# coding: utf-8

"""
    Zuora API Reference

    REST API reference for the Zuora Billing, Payments, and Central Platform! Check out the [REST API Overview](https://www.zuora.com/developer/api-references/api/overview/).

    The version of the OpenAPI document: 2025-08-12
    Contact: docs@zuora.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import field_validator
from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from zuora_sdk.models.bill_run import BillRun
from zuora_sdk.models.bill_run_filter import BillRunFilter
from zuora_sdk.models.bill_run_schedule import BillRunSchedule
from zuora_sdk.models.bill_run_status import BillRunStatus
from zuora_sdk.models.charge_type import ChargeType
from zuora_sdk.models.failed_reason import FailedReason
from typing import Optional, Set
from typing_extensions import Self

class CancelBillRunResponse(BaseModel):
    """
    CancelBillRunResponse
    """ # noqa: E501
    # avoid validation
    def __init__(self, **kwargs):
        # Directly assign values without validation using `construct()`
        model = self.construct(**kwargs)
        self.__dict__.update(model.__dict__)

        _dict_all = convert_snake_dict_to_camel(kwargs, self.model_fields, self.__properties)

        _dict = self.to_alias_dict(_dict_all)
        for field_name, field_info in self.model_fields.items():
            alias = field_info.alias or field_name
            if alias in _dict:
                self.__dict__[field_name] = _dict.get(alias)
        self.update_additional_properties(self, _dict_all)
        pass

    def __setattr__(self, name, value):
        # Override setattr to bypass validation when setting attributes
        object.__setattr__(self, name, value)

    process_id: Optional[StrictStr] = Field(default=None, description="The Id of the process that handle the operation. ", alias="processId")
    request_id: Optional[StrictStr] = Field(default=None, description="Unique request identifier. If you need to contact us about a specific request, providing the request identifier will ensure the fastest possible resolution. ", alias="requestId")
    reasons: Optional[List[FailedReason]] = None
    success: Optional[StrictBool] = Field(default=True, description="Indicates whether the call succeeded. ")
    id: Optional[StrictStr] = Field(default=None, description="The unique ID of the bill run. ")
    name: Optional[StrictStr] = Field(default=None, description="The name of the bill run. ")
    bill_run_number: Optional[StrictStr] = Field(default=None, description="The number of the bill run. ", alias="billRunNumber")
    batches: Optional[List[StrictStr]] = Field(default=None, description="The batch of accounts for this bill run, this field can not exist with `billRunFilters` together.   **Values:** `AllBatches` or an array of `Batch`*n* where *n* is a number between 1 and 50, for example, `Batch7`.")
    bill_cycle_day: Optional[StrictStr] = Field(default=None, description="The day of the bill cycle, this field is only valid when `batches` is specified.   **Values:**   - `AllBillCycleDays` or one of numbers 1 - 31 for an ad-hoc bill run  - `AllBillCycleDays`, one of numbers 1 - 31, or `AsRunDay` for a scheduled bill run", alias="billCycleDay")
    bill_run_filters: Optional[List[BillRunFilter]] = Field(default=None, description="The target account or subscriptions for this bill run. ", alias="billRunFilters")
    charge_type_to_exclude: Optional[List[ChargeType]] = Field(default=None, description="The types of the charges to be excluded from the generation of billing documents.", alias="chargeTypeToExclude")
    auto_email: Optional[StrictBool] = Field(default=None, description="Whether to automatically send emails after Auto-Post is complete. ", alias="autoEmail")
    auto_post: Optional[StrictBool] = Field(default=None, description="Whether to automatically post the bill run after the bill run is created.", alias="autoPost")
    auto_renewal: Optional[StrictBool] = Field(default=None, description="Whether to automatically renew auto-renew subscriptions that are up for renewal.", alias="autoRenewal")
    no_email_for_zero_amount_invoice: Optional[StrictBool] = Field(default=None, description="Whether to suppress emails for invoices with zero total amount generated in this bill run after the bill run is complete.", alias="noEmailForZeroAmountInvoice")
    schedule: Optional[BillRunSchedule] = None
    scheduled_execution_time: Optional[StrictStr] = Field(default=None, description="The scheduled execution time for a bill run. ", alias="scheduledExecutionTime")
    status: Optional[StrictStr] = None
    invoice_date: Optional[date] = Field(default=None, description="The invoice date for this bill run, only valid for ad-hoc bill runs. ", alias="invoiceDate")
    invoice_date_offset: Optional[StrictInt] = Field(default=None, description="The offset compared to bill run execution date, only valid for scheduled bill runs.", alias="invoiceDateOffset")
    invoice_date_month_offset: Optional[StrictInt] = Field(default=None, description="The month offset of invoice date for this bill run based on run date, only valid for monthly scheduled bill runs. invoiceDateOffset and invoiceDateMonthOffset/invoiceDateDayOfMonth are mutually exclusive. invoiceDateMonthOffset and invoiceDateDayOfMonth coexist. ", alias="invoiceDateMonthOffset")
    invoice_date_day_of_month: Optional[Annotated[int, Field(le=31, strict=True, ge=1)]] = Field(default=None, description="The day of month of invoice date for this bill run, only valid for monthly scheduled bill runs. The value is between 1 and 31, where 31 = end-of-month. invoiceDateOffset and invoiceDateMonthOffset/invoiceDateDayOfMonth are mutually exclusive. invoiceDateMonthOffset and invoiceDateDayOfMonth coexist. ", alias="invoiceDateDayOfMonth")
    target_date: Optional[date] = Field(default=None, description="The target date for this bill run, only valid for ad-hoc bill runs. ", alias="targetDate")
    target_date_offset: Optional[StrictInt] = Field(default=None, description="The offset compared to bill run execution date, only valid for scheduled bill runs.", alias="targetDateOffset")
    target_date_month_offset: Optional[StrictInt] = Field(default=None, description="The month offset of target date for this bill run based on run date, only valid for monthly scheduled bill runs. targetDateOffset and targetDateMonthOffset/targetDateDayOfMonth are mutually exclusive. targetDateMonthOffset and targetDateDayOfMonth coexist. ", alias="targetDateMonthOffset")
    target_date_day_of_month: Optional[Annotated[int, Field(le=31, strict=True, ge=1)]] = Field(default=None, description="The day of month of target date for this bill run, only valid for monthly scheduled bill runs. The value is between 1 and 31, where 31 = end-of-month. targetDateOffset and targetDateMonthOffset/targetDateDayOfMonth are mutually exclusive. targetDateMonthOffset and targetDateDayOfMonth coexist. ", alias="targetDateDayOfMonth")
    include_subscriptions: Optional[StrictBool] = Field(default=None, description="Whether to bill subscriptions. ", alias="includeSubscriptions")
    include_order_line_items: Optional[StrictBool] = Field(default=None, description="Whether to bill order line items. ", alias="includeOrderLineItems")
    created_by_id: Optional[StrictStr] = Field(default=None, description="The ID of the user who created the bill run. ", alias="createdById")
    created_date: Optional[StrictStr] = Field(default=None, description="The date and time when the bill run was created. ", alias="createdDate")
    updated_by_id: Optional[StrictStr] = Field(default=None, description="The ID of the user who last updated the bill run. ", alias="updatedById")
    updated_date: Optional[StrictStr] = Field(default=None, description="The date and time when the bill run was last updated. ", alias="updatedDate")
    next_run: Optional[BillRun] = Field(default=None, alias="nextRun")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["processId", "requestId", "reasons", "success", "id", "name", "billRunNumber", "batches", "billCycleDay", "billRunFilters", "chargeTypeToExclude", "autoEmail", "autoPost", "autoRenewal", "noEmailForZeroAmountInvoice", "schedule", "scheduledExecutionTime", "status", "invoiceDate", "invoiceDateOffset", "invoiceDateMonthOffset", "invoiceDateDayOfMonth", "targetDate", "targetDateOffset", "targetDateMonthOffset", "targetDateDayOfMonth", "includeSubscriptions", "includeOrderLineItems", "createdById", "createdDate", "updatedById", "updatedDate", "nextRun"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CancelBillRunResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in reasons (list)
        _items = []
        if self.reasons:
            for _item_reasons in self.reasons:
                if _item_reasons:
                    _items.append(_item_reasons.to_dict())
            _dict['reasons'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bill_run_filters (list)
        _items = []
        if self.bill_run_filters:
            for _item_bill_run_filters in self.bill_run_filters:
                if _item_bill_run_filters:
                    _items.append(_item_bill_run_filters.to_dict())
            _dict['billRunFilters'] = _items
        # override the default output from pydantic by calling `to_dict()` of schedule
        if self.schedule:
            _dict['schedule'] = self.schedule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of next_run
        if self.next_run:
            _dict['nextRun'] = self.next_run.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CancelBillRunResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        obj = convert_snake_dict_to_camel(obj, cls.model_fields, cls.__properties)

        _obj = cls.model_validate(cls.to_alias_dict(obj))
        return cls.update_additional_properties(_obj, obj)

    @classmethod
    def update_additional_properties(cls, obj, _dict: Optional[Dict[str, Any]]):
        # store additional fields in additional_properties

        # store additional fields in additional_properties
        for _key in _dict.keys():
            if _key not in cls.__properties:
                obj.additional_properties[_key] = _dict.get(_key)


        return obj
        pass

    @classmethod
    def to_alias_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        return {
            "processId": obj.get("processId"),
            "requestId": obj.get("requestId"),
            "reasons": [FailedReason.from_dict(_item) for _item in obj["reasons"]] if obj.get("reasons") is not None else None,
            "success": obj.get("success") if obj.get("success") is not None else True,
            "id": obj.get("id"),
            "name": obj.get("name"),
            "billRunNumber": obj.get("billRunNumber"),
            "batches": obj.get("batches"),
            "billCycleDay": obj.get("billCycleDay"),
            "billRunFilters": [BillRunFilter.from_dict(_item) for _item in obj["billRunFilters"]] if obj.get("billRunFilters") is not None else None,
            "chargeTypeToExclude": obj.get("chargeTypeToExclude"),
            "autoEmail": obj.get("autoEmail"),
            "autoPost": obj.get("autoPost"),
            "autoRenewal": obj.get("autoRenewal"),
            "noEmailForZeroAmountInvoice": obj.get("noEmailForZeroAmountInvoice"),
            "schedule": BillRunSchedule.from_dict(obj["schedule"]) if obj.get("schedule") is not None else None,
            "scheduledExecutionTime": obj.get("scheduledExecutionTime"),
            "status": obj.get("status"),
            "invoiceDate": obj.get("invoiceDate"),
            "invoiceDateOffset": obj.get("invoiceDateOffset"),
            "invoiceDateMonthOffset": obj.get("invoiceDateMonthOffset"),
            "invoiceDateDayOfMonth": obj.get("invoiceDateDayOfMonth"),
            "targetDate": obj.get("targetDate"),
            "targetDateOffset": obj.get("targetDateOffset"),
            "targetDateMonthOffset": obj.get("targetDateMonthOffset"),
            "targetDateDayOfMonth": obj.get("targetDateDayOfMonth"),
            "includeSubscriptions": obj.get("includeSubscriptions"),
            "includeOrderLineItems": obj.get("includeOrderLineItems"),
            "createdById": obj.get("createdById"),
            "createdDate": obj.get("createdDate"),
            "updatedById": obj.get("updatedById"),
            "updatedDate": obj.get("updatedDate"),
            "nextRun": BillRun.from_dict(obj["nextRun"]) if obj.get("nextRun") is not None else None
        }
        return _obj


def convert_snake_dict_to_camel(_dict: dict, model_fields, properties):
    if not isinstance(_dict, dict):
        return _dict
    new_dict = {}
    for k, v in _dict.items():
        if k in model_fields:
            # model_fields: key is attribute name like bill_to_contact,
            alias = model_fields.get(k).alias or k
            new_dict[alias] = v
            pass
        else:
            new_key = snake_to_camel(k)
            if properties is not None and isinstance(properties, list) and new_key in properties:
                new_dict[new_key] = v
            else:
                new_dict[k] = v
    return new_dict
    pass


def snake_to_camel(name):
    if name is None or '_' not in name:
        return name
    components = name.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])
