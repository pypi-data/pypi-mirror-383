from fractions import Fraction
from typing import Generic, Literal, Self, TypeVar, overload

from .dimension import Dimension

try:
    import numpy as np  # type: ignore
except ImportError:
    from .utils import numpy_phony as np



__all__ = ['Unit', 'UNITLESS', 'Quantity', 'Constant']


T = TypeVar('T')


class Unit:
    """
    Physical unit class.

    """

    def __init__(self, symbol: str = ''):
        """
        construct a unit from symbol (str).

        Rules for unit symbol
        ---
        - unit can be single or multiple.
        - single unit = base unit + prefix + exponent.
          - base unit examples: meter (m), kilogram (kg), second (s), etc.
          - prefix examples: kilo (k), mega (M), giga (G), etc.
          - exponent: integer or superscript.
        - multiple units are combined with single units using separators.
          - multiplication separator: `.`, `·`, ` ` (space).
          - division separator: `/`.

        Example
        ---
        >>> Unit()          # dimensionless unit
        Unit()
        >>> Unit('Pa')      # pascal, pressure unit
        Unit('Pa')
        >>> Unit('kg/m.s2') # pascal in SI base units
        Unit('kg/m·s²')
        >>> Unit('kg/m/s2') # only the first '/' matters
        Unit('kg/m·s²')
        >>> Unit('kPa')     # pascal with prefix kilo-
        Unit('kPa')
        >>> Unit('kilopascal')  # fullname of kPa
        Unit('kPa')
        >>> Unit('x')       # UnitSymbolError: 'x' is not a valid unit.
        >>> Unit('m+m')     # UnitSymbolError: 'm+m' is not a valid unit.
        """
    
    @property
    def dimension(self) -> Dimension: ...
    @property
    def factor(self) -> float: ...
    @property
    def symbol(self) -> str: ...
    @property
    def name(self) -> str: ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def sameas(self, other: Self) -> bool: ...
    def isdimensionless(self) -> bool: ...
    def deprefix(self) -> Self: ...
    def toSIbase(self) -> Self: ...
    def simplify(self) -> Self: ...
    @property
    def inv(self) -> Self: ...
    def __mul__(self, other: Self) -> Self: ...
    def __truediv__(self, other: Self) -> Self: ...
    def __imul__(self, other: Self) -> Self: ...
    def __itruediv__(self, other: Self) -> Self: ...
    def __pow__(self, n: int | Fraction) -> Self: ...
    def __ipow__(self, n: int | Fraction) -> Self: ...
    def root(self, n: int | Fraction) -> Self: ...
    def __rmul__(self, other: T) -> Quantity[T]: ...
    def __rtruediv__(self, other: T) -> Quantity[T]: ...
    def __array_ufunc__(self, ufunc, method, *inputs: tuple[T, ...], **kwargs) -> Quantity[T]: ...


UNITLESS: Unit


class Constant(Generic[T]):
    '''Constant objects are just immutable Quantity objects.'''
    @overload
    def __new__(cls, value: float, /, unit: str | Unit) -> Constant[float]: ...
    @overload
    def __new__(cls, value: T, /, unit: str | Unit) -> Constant[T]: ...
    @property
    def value(self) -> T: ...
    @property
    def unit(self) -> Unit: ...
    @property
    def dimension(self) -> Dimension: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __format__(self, format_spec: str) -> str: ...
    def __getitem__(self, i) -> Quantity[T]: ...
    def is_dimensionless(self) -> bool: ...
    def copy(self) -> Constant: ...
    def to(self, new_unit: str | Unit, *, strict=True) -> Constant[T]: ...
    def deprefix_unit(self) -> Quantity[T]: ...
    def toSIbase(self) -> Quantity[T]: ...
    def simplify_unit(self) -> Quantity[T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Constant[T]) -> bool: ...
    def __lt__(self, other: Constant[T]) -> bool: ...
    def __ge__(self, other: Constant[T]) -> bool: ...
    def __le__(self, other: Constant[T]) -> bool: ...
    def __pos__(self) -> Constant[T]: ...
    def __neg__(self) -> Constant[T]: ...
    def __add__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __sub__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, unit: Unit) -> Quantity[T]: ...
    def __matmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, unit: Unit) -> Quantity[T]: ...
    def __pow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __iadd__(self, other: T | Constant[T]) -> Constant[T]: ...
    def __isub__(self, other: T | Constant[T]) -> Constant[T]: ...
    @overload
    def __imul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __imul__(self, unit: Unit) -> Quantity[T]: ...
    def __imatmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, unit: Unit) -> Quantity[T]: ...
    def __ipow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __radd__(self, other: T) -> Quantity[T]: ...
    def __rsub__(self, other: T) -> Quantity[T]: ...
    def __rmul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    def __rmatmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __rtruediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    def __rpow__(self, other: int | Fraction) -> Quantity[T]: ...
    def root(self, n: int | Fraction) -> Quantity[T]: ...
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs) -> Quantity[T]: ...
    def __array__(self, dtype=None): ...


class Quantity(Constant[T]):
    @overload
    def __new__(cls, value: float, /, unit: str | Unit) -> Quantity[float]: ...
    @overload
    def __new__(cls, value: T, /, unit: str | Unit) -> Quantity[T]: ...
    @property
    def value(self) -> T: ...
    @value.setter
    def value(self, value: T) -> None: ...
    @property
    def unit(self) -> Unit: ...
    @unit.setter
    def unit(self, unit: str | Unit) -> None: ...
    @property
    def dimension(self) -> Dimension: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __format__(self, format_spec: str) -> str: ...
    def isdimensionless(self) -> bool: ...
    def copy(self) -> Quantity[T]: ...
    def to(self, new_unit: str | Unit, *, inplace=False, strict=True) -> Quantity[T]: ...
    def deprefix_unit(self, *, inplace=False) -> Quantity[T]: ...
    def toSIbase(self, *, inplace=False) -> Quantity[T]: ...
    def simplify_unit(self, *, inplace=False) -> Quantity[T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Constant[T]) -> bool: ...
    def __lt__(self, other: Constant[T]) -> bool: ...
    def __ge__(self, other: Constant[T]) -> bool: ...
    def __le__(self, other: Constant[T]) -> bool: ...
    def __pos__(self) -> Constant[T]: ...
    def __neg__(self) -> Constant[T]: ...
    def __add__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __sub__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, unit: Unit) -> Quantity[T]: ...
    def __matmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, unit: Unit) -> Quantity[T]: ...
    def __pow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __iadd__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __isub__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __imul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __imul__(self, unit: Unit) -> Quantity[T]: ...
    def __imatmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    @overload
    def __itruediv__(self, unit: Unit) -> Quantity[T]: ...
    def __ipow__(self, other: int | Fraction) -> Quantity[T]: ...
    def __radd__(self, other: T) -> Quantity[T]: ...
    def __rsub__(self, other: T) -> Quantity[T]: ...
    def __rmul__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    def __rmatmul__(self, other: T | Constant[T]) -> Quantity[T]: ...
    def __rtruediv__(self, other: float | T | Constant[float] | Constant[T]) -> Quantity[T]: ...
    def __rpow__(self, other: int | Fraction) -> Quantity[T]: ...
    def root(self, n: int | Fraction) -> Quantity[T]: ...
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs) -> Quantity[T]: ...
    def __array__(self, dtype=None): ...


@overload
def constant(quantity: Quantity[T], /, *, simplify=False) -> Constant[T]: ...
@overload
def constant(quantity: Quantity[T], /, unit: str | Unit) -> Constant[T]: ...

