/*
cgo stubs for package extractor.
File is generated by gopy. Do not edit.
gopy build -no-make -dynamic-link=True -rename=True -output /project/build/lib.linux-aarch64-cpython-312/py_excel_form_extractor -vm /opt/python/cp312-cp312/bin/python ./pkg/extractor ./pkg/utils
*/

package main

/*

#cgo CFLAGS: "-I/opt/python/cp312-cp312/include/python3.12" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -pthread -shared

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"github.com/adhadse/excelFormExtractor/pkg/extractor"
	"github.com/adhadse/excelFormExtractor/pkg/utils"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: extractor below: ---

// ---- External Types Outside of Targeted Packages ---

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: extractor ---

// ---- Types ---

// Converters for pointer handles for type: *extractor.BoolCheckBoxExtractor
func ptrFromHandle_Ptr_extractor_BoolCheckBoxExtractor(h CGoHandle) *extractor.BoolCheckBoxExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.BoolCheckBoxExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BoolCheckBoxExtractor{})).(*extractor.BoolCheckBoxExtractor)
}
func handleFromPtr_Ptr_extractor_BoolCheckBoxExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.BoolCheckBoxExtractor", p))
}

// Converters for pointer handles for type: *extractor.BoolClassificationCriteria
func ptrFromHandle_Ptr_extractor_BoolClassificationCriteria(h CGoHandle) *extractor.BoolClassificationCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.BoolClassificationCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BoolClassificationCriteria{})).(*extractor.BoolClassificationCriteria)
}
func handleFromPtr_Ptr_extractor_BoolClassificationCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.BoolClassificationCriteria", p))
}

// Converters for pointer handles for type: *extractor.BoolContainsImageExtractor
func ptrFromHandle_Ptr_extractor_BoolContainsImageExtractor(h CGoHandle) *extractor.BoolContainsImageExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.BoolContainsImageExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BoolContainsImageExtractor{})).(*extractor.BoolContainsImageExtractor)
}
func handleFromPtr_Ptr_extractor_BoolContainsImageExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.BoolContainsImageExtractor", p))
}

// Converters for pointer handles for type: *extractor.BuyerDetails
func ptrFromHandle_Ptr_extractor_BuyerDetails(h CGoHandle) *extractor.BuyerDetails {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.BuyerDetails")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BuyerDetails{})).(*extractor.BuyerDetails)
}
func handleFromPtr_Ptr_extractor_BuyerDetails(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.BuyerDetails", p))
}

// Converters for pointer handles for type: *extractor.CellRange
func ptrFromHandle_Ptr_extractor_CellRange(h CGoHandle) *extractor.CellRange {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.CellRange")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.CellRange{})).(*extractor.CellRange)
}
func handleFromPtr_Ptr_extractor_CellRange(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.CellRange", p))
}

// Converters for pointer handles for type: *extractor.ClassificationCriteria
func ptrFromHandle_Ptr_extractor_ClassificationCriteria(h CGoHandle) *extractor.ClassificationCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.ClassificationCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ClassificationCriteria{})).(*extractor.ClassificationCriteria)
}
func handleFromPtr_Ptr_extractor_ClassificationCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.ClassificationCriteria", p))
}

// Converters for pointer handles for type: *extractor.ColumnMapping
func ptrFromHandle_Ptr_extractor_ColumnMapping(h CGoHandle) *extractor.ColumnMapping {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.ColumnMapping")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ColumnMapping{})).(*extractor.ColumnMapping)
}
func handleFromPtr_Ptr_extractor_ColumnMapping(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.ColumnMapping", p))
}

// Converters for pointer handles for type: *extractor.ControlCotent
func ptrFromHandle_Ptr_extractor_ControlCotent(h CGoHandle) *extractor.ControlCotent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.ControlCotent")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ControlCotent{})).(*extractor.ControlCotent)
}
func handleFromPtr_Ptr_extractor_ControlCotent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.ControlCotent", p))
}

// Converters for pointer handles for type: *extractor.DivideByZeroError
func ptrFromHandle_Ptr_extractor_DivideByZeroError(h CGoHandle) *extractor.DivideByZeroError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.DivideByZeroError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.DivideByZeroError{})).(*extractor.DivideByZeroError)
}
func handleFromPtr_Ptr_extractor_DivideByZeroError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.DivideByZeroError", p))
}

// Converters for pointer handles for type: *extractor.DualClassificationCriteria
func ptrFromHandle_Ptr_extractor_DualClassificationCriteria(h CGoHandle) *extractor.DualClassificationCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.DualClassificationCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.DualClassificationCriteria{})).(*extractor.DualClassificationCriteria)
}
func handleFromPtr_Ptr_extractor_DualClassificationCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.DualClassificationCriteria", p))
}

// Converters for pointer handles for type: *extractor.DualColumnClfExtractor
func ptrFromHandle_Ptr_extractor_DualColumnClfExtractor(h CGoHandle) *extractor.DualColumnClfExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.DualColumnClfExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.DualColumnClfExtractor{})).(*extractor.DualColumnClfExtractor)
}
func handleFromPtr_Ptr_extractor_DualColumnClfExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.DualColumnClfExtractor", p))
}

// Converters for pointer handles for type: *extractor.ExcelExtractor
func ptrFromHandle_Ptr_extractor_ExcelExtractor(h CGoHandle) *extractor.ExcelExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.ExcelExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor)
}
func handleFromPtr_Ptr_extractor_ExcelExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.ExcelExtractor", p))
}

// Converters for pointer handles for type: *extractor.ProductDetails
func ptrFromHandle_Ptr_extractor_ProductDetails(h CGoHandle) *extractor.ProductDetails {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.ProductDetails")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ProductDetails{})).(*extractor.ProductDetails)
}
func handleFromPtr_Ptr_extractor_ProductDetails(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.ProductDetails", p))
}

// Converters for pointer handles for type: *extractor.Response
func ptrFromHandle_Ptr_extractor_Response(h CGoHandle) *extractor.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.Response{})).(*extractor.Response)
}
func handleFromPtr_Ptr_extractor_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.Response", p))
}

// Converters for pointer handles for type: *extractor.SECCFExtraction
func ptrFromHandle_Ptr_extractor_SECCFExtraction(h CGoHandle) *extractor.SECCFExtraction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.SECCFExtraction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SECCFExtraction{})).(*extractor.SECCFExtraction)
}
func handleFromPtr_Ptr_extractor_SECCFExtraction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.SECCFExtraction", p))
}

// Converters for pointer handles for type: *extractor.SearchCriteria
func ptrFromHandle_Ptr_extractor_SearchCriteria(h CGoHandle) *extractor.SearchCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.SearchCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SearchCriteria{})).(*extractor.SearchCriteria)
}
func handleFromPtr_Ptr_extractor_SearchCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.SearchCriteria", p))
}

// Converters for pointer handles for type: *extractor.SheetNotFoundError
func ptrFromHandle_Ptr_extractor_SheetNotFoundError(h CGoHandle) *extractor.SheetNotFoundError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.SheetNotFoundError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SheetNotFoundError{})).(*extractor.SheetNotFoundError)
}
func handleFromPtr_Ptr_extractor_SheetNotFoundError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.SheetNotFoundError", p))
}

// Converters for pointer handles for type: *extractor.SimpleValueExtractor
func ptrFromHandle_Ptr_extractor_SimpleValueExtractor(h CGoHandle) *extractor.SimpleValueExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.SimpleValueExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SimpleValueExtractor{})).(*extractor.SimpleValueExtractor)
}
func handleFromPtr_Ptr_extractor_SimpleValueExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.SimpleValueExtractor", p))
}

// Converters for pointer handles for type: *extractor.TriClassificationCritera
func ptrFromHandle_Ptr_extractor_TriClassificationCritera(h CGoHandle) *extractor.TriClassificationCritera {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.TriClassificationCritera")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.TriClassificationCritera{})).(*extractor.TriClassificationCritera)
}
func handleFromPtr_Ptr_extractor_TriClassificationCritera(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.TriClassificationCritera", p))
}

// Converters for pointer handles for type: *extractor.TriColumnClfExtractor
func ptrFromHandle_Ptr_extractor_TriColumnClfExtractor(h CGoHandle) *extractor.TriColumnClfExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*extractor.TriColumnClfExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.TriColumnClfExtractor{})).(*extractor.TriColumnClfExtractor)
}
func handleFromPtr_Ptr_extractor_TriColumnClfExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*extractor.TriColumnClfExtractor", p))
}

// Converters for implicit pointer handles for type: []extractor.CellRange
func ptrFromHandle_Slice_extractor_CellRange(h CGoHandle) *[]extractor.CellRange {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]extractor.CellRange")
	if p == nil {
		return nil
	}
	return p.(*[]extractor.CellRange)
}
func deptrFromHandle_Slice_extractor_CellRange(h CGoHandle) []extractor.CellRange {
	p := ptrFromHandle_Slice_extractor_CellRange(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_extractor_CellRange(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]extractor.CellRange", p))
}

// --- wrapping slice: []extractor.CellRange ---
//
//export Slice_extractor_CellRange_CTor
func Slice_extractor_CellRange_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_extractor_CellRange(&[]extractor.CellRange{}))
}

//export Slice_extractor_CellRange_len
func Slice_extractor_CellRange_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_extractor_CellRange(handle))
}

//export Slice_extractor_CellRange_elem
func Slice_extractor_CellRange_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_extractor_CellRange(handle)
	return handleFromPtr_extractor_CellRange(&(s[_idx]))
}

//export Slice_extractor_CellRange_subslice
func Slice_extractor_CellRange_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_extractor_CellRange(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_extractor_CellRange(&ss))
}

//export Slice_extractor_CellRange_set
func Slice_extractor_CellRange_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_extractor_CellRange(handle)
	s[_idx] = *ptrFromHandle_extractor_CellRange(_vl)
}

//export Slice_extractor_CellRange_append
func Slice_extractor_CellRange_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_extractor_CellRange(handle)
	*s = append(*s, *ptrFromHandle_extractor_CellRange(_vl))
}

// Converters for implicit pointer handles for type: []extractor.ControlCotent
func ptrFromHandle_Slice_extractor_ControlCotent(h CGoHandle) *[]extractor.ControlCotent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]extractor.ControlCotent")
	if p == nil {
		return nil
	}
	return p.(*[]extractor.ControlCotent)
}
func deptrFromHandle_Slice_extractor_ControlCotent(h CGoHandle) []extractor.ControlCotent {
	p := ptrFromHandle_Slice_extractor_ControlCotent(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_extractor_ControlCotent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]extractor.ControlCotent", p))
}

// --- wrapping slice: []extractor.ControlCotent ---
//
//export Slice_extractor_ControlCotent_CTor
func Slice_extractor_ControlCotent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_extractor_ControlCotent(&[]extractor.ControlCotent{}))
}

//export Slice_extractor_ControlCotent_len
func Slice_extractor_ControlCotent_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_extractor_ControlCotent(handle))
}

//export Slice_extractor_ControlCotent_elem
func Slice_extractor_ControlCotent_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_extractor_ControlCotent(handle)
	return handleFromPtr_extractor_ControlCotent(&(s[_idx]))
}

//export Slice_extractor_ControlCotent_subslice
func Slice_extractor_ControlCotent_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_extractor_ControlCotent(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_extractor_ControlCotent(&ss))
}

//export Slice_extractor_ControlCotent_set
func Slice_extractor_ControlCotent_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_extractor_ControlCotent(handle)
	s[_idx] = *ptrFromHandle_extractor_ControlCotent(_vl)
}

//export Slice_extractor_ControlCotent_append
func Slice_extractor_ControlCotent_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_extractor_ControlCotent(handle)
	*s = append(*s, *ptrFromHandle_extractor_ControlCotent(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: extractor.BoolCheckBoxExtractor
func ptrFromHandle_extractor_BoolCheckBoxExtractor(h CGoHandle) *extractor.BoolCheckBoxExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.BoolCheckBoxExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BoolCheckBoxExtractor{})).(*extractor.BoolCheckBoxExtractor)
}
func handleFromPtr_extractor_BoolCheckBoxExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.BoolCheckBoxExtractor", p))
}

// Converters for non-pointer handles for type: extractor.BoolClassificationCriteria
func ptrFromHandle_extractor_BoolClassificationCriteria(h CGoHandle) *extractor.BoolClassificationCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.BoolClassificationCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BoolClassificationCriteria{})).(*extractor.BoolClassificationCriteria)
}
func handleFromPtr_extractor_BoolClassificationCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.BoolClassificationCriteria", p))
}

// Converters for non-pointer handles for type: extractor.BoolContainsImageExtractor
func ptrFromHandle_extractor_BoolContainsImageExtractor(h CGoHandle) *extractor.BoolContainsImageExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.BoolContainsImageExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BoolContainsImageExtractor{})).(*extractor.BoolContainsImageExtractor)
}
func handleFromPtr_extractor_BoolContainsImageExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.BoolContainsImageExtractor", p))
}

// Converters for non-pointer handles for type: extractor.BuyerDetails
func ptrFromHandle_extractor_BuyerDetails(h CGoHandle) *extractor.BuyerDetails {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.BuyerDetails")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.BuyerDetails{})).(*extractor.BuyerDetails)
}
func handleFromPtr_extractor_BuyerDetails(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.BuyerDetails", p))
}

// Converters for non-pointer handles for type: extractor.CellRange
func ptrFromHandle_extractor_CellRange(h CGoHandle) *extractor.CellRange {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.CellRange")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.CellRange{})).(*extractor.CellRange)
}
func handleFromPtr_extractor_CellRange(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.CellRange", p))
}

// Converters for non-pointer handles for type: extractor.ClassificationCriteria
func ptrFromHandle_extractor_ClassificationCriteria(h CGoHandle) *extractor.ClassificationCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.ClassificationCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ClassificationCriteria{})).(*extractor.ClassificationCriteria)
}
func handleFromPtr_extractor_ClassificationCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.ClassificationCriteria", p))
}

// Converters for non-pointer handles for type: extractor.ColumnMapping
func ptrFromHandle_extractor_ColumnMapping(h CGoHandle) *extractor.ColumnMapping {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.ColumnMapping")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ColumnMapping{})).(*extractor.ColumnMapping)
}
func handleFromPtr_extractor_ColumnMapping(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.ColumnMapping", p))
}

// Converters for implicit pointer handles for type: extractor.CompanyNameList
func ptrFromHandle_extractor_CompanyNameList(h CGoHandle) *extractor.CompanyNameList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.CompanyNameList")
	if p == nil {
		return nil
	}
	return p.(*extractor.CompanyNameList)
}
func deptrFromHandle_extractor_CompanyNameList(h CGoHandle) extractor.CompanyNameList {
	p := ptrFromHandle_extractor_CompanyNameList(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_extractor_CompanyNameList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.CompanyNameList", p))
}

// Converters for non-pointer handles for type: extractor.ControlCotent
func ptrFromHandle_extractor_ControlCotent(h CGoHandle) *extractor.ControlCotent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.ControlCotent")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ControlCotent{})).(*extractor.ControlCotent)
}
func handleFromPtr_extractor_ControlCotent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.ControlCotent", p))
}

// Converters for non-pointer handles for type: extractor.DivideByZeroError
func ptrFromHandle_extractor_DivideByZeroError(h CGoHandle) *extractor.DivideByZeroError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.DivideByZeroError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.DivideByZeroError{})).(*extractor.DivideByZeroError)
}
func handleFromPtr_extractor_DivideByZeroError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.DivideByZeroError", p))
}

// Converters for non-pointer handles for type: extractor.DualClassificationCriteria
func ptrFromHandle_extractor_DualClassificationCriteria(h CGoHandle) *extractor.DualClassificationCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.DualClassificationCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.DualClassificationCriteria{})).(*extractor.DualClassificationCriteria)
}
func handleFromPtr_extractor_DualClassificationCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.DualClassificationCriteria", p))
}

// Converters for non-pointer handles for type: extractor.DualColumnClfExtractor
func ptrFromHandle_extractor_DualColumnClfExtractor(h CGoHandle) *extractor.DualColumnClfExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.DualColumnClfExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.DualColumnClfExtractor{})).(*extractor.DualColumnClfExtractor)
}
func handleFromPtr_extractor_DualColumnClfExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.DualColumnClfExtractor", p))
}

// Converters for non-pointer handles for type: extractor.ExcelExtractor
func ptrFromHandle_extractor_ExcelExtractor(h CGoHandle) *extractor.ExcelExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.ExcelExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor)
}
func handleFromPtr_extractor_ExcelExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.ExcelExtractor", p))
}

// Converters for non-pointer handles for type: extractor.ProductDetails
func ptrFromHandle_extractor_ProductDetails(h CGoHandle) *extractor.ProductDetails {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.ProductDetails")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.ProductDetails{})).(*extractor.ProductDetails)
}
func handleFromPtr_extractor_ProductDetails(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.ProductDetails", p))
}

// Converters for non-pointer handles for type: extractor.Response
func ptrFromHandle_extractor_Response(h CGoHandle) *extractor.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.Response{})).(*extractor.Response)
}
func handleFromPtr_extractor_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.Response", p))
}

// Converters for non-pointer handles for type: extractor.SECCFExtraction
func ptrFromHandle_extractor_SECCFExtraction(h CGoHandle) *extractor.SECCFExtraction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.SECCFExtraction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SECCFExtraction{})).(*extractor.SECCFExtraction)
}
func handleFromPtr_extractor_SECCFExtraction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.SECCFExtraction", p))
}

// Converters for non-pointer handles for type: extractor.SearchCriteria
func ptrFromHandle_extractor_SearchCriteria(h CGoHandle) *extractor.SearchCriteria {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.SearchCriteria")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SearchCriteria{})).(*extractor.SearchCriteria)
}
func handleFromPtr_extractor_SearchCriteria(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.SearchCriteria", p))
}

// Converters for pointer handles for type: extractor.SheetNameGetter
func ptrFromHandle_extractor_SheetNameGetter(h CGoHandle) extractor.SheetNameGetter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.SheetNameGetter")
	if p == nil {
		return nil
	}
	return p.(extractor.SheetNameGetter)
}
func handleFromPtr_extractor_SheetNameGetter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.SheetNameGetter", p))
}

// Converters for non-pointer handles for type: extractor.SheetNotFoundError
func ptrFromHandle_extractor_SheetNotFoundError(h CGoHandle) *extractor.SheetNotFoundError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.SheetNotFoundError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SheetNotFoundError{})).(*extractor.SheetNotFoundError)
}
func handleFromPtr_extractor_SheetNotFoundError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.SheetNotFoundError", p))
}

// Converters for non-pointer handles for type: extractor.SimpleValueExtractor
func ptrFromHandle_extractor_SimpleValueExtractor(h CGoHandle) *extractor.SimpleValueExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.SimpleValueExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.SimpleValueExtractor{})).(*extractor.SimpleValueExtractor)
}
func handleFromPtr_extractor_SimpleValueExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.SimpleValueExtractor", p))
}

// Converters for non-pointer handles for type: extractor.TriClassificationCritera
func ptrFromHandle_extractor_TriClassificationCritera(h CGoHandle) *extractor.TriClassificationCritera {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.TriClassificationCritera")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.TriClassificationCritera{})).(*extractor.TriClassificationCritera)
}
func handleFromPtr_extractor_TriClassificationCritera(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.TriClassificationCritera", p))
}

// Converters for non-pointer handles for type: extractor.TriColumnClfExtractor
func ptrFromHandle_extractor_TriColumnClfExtractor(h CGoHandle) *extractor.TriColumnClfExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.TriColumnClfExtractor")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(extractor.TriColumnClfExtractor{})).(*extractor.TriColumnClfExtractor)
}
func handleFromPtr_extractor_TriColumnClfExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.TriColumnClfExtractor", p))
}

// Converters for pointer handles for type: extractor.ValueExtractor
func ptrFromHandle_extractor_ValueExtractor(h CGoHandle) extractor.ValueExtractor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "extractor.ValueExtractor")
	if p == nil {
		return nil
	}
	return p.(extractor.ValueExtractor)
}
func handleFromPtr_extractor_ValueExtractor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("extractor.ValueExtractor", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export extractor_SheetNameGetter_GetSheetName
func extractor_SheetNameGetter_GetSheetName(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "extractor.SheetNameGetter")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(extractor.SheetNameGetter).GetSheetName())

}

// ---- Structs ---

// --- wrapping struct: extractor.ControlCotent ---
//
//export extractor_ControlCotent_CTor
func extractor_ControlCotent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_ControlCotent(&extractor.ControlCotent{}))
}

//export extractor_ControlCotent_SheetName_Get
func extractor_ControlCotent_SheetName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.SheetName)
}

//export extractor_ControlCotent_SheetName_Set
func extractor_ControlCotent_SheetName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.SheetName = C.GoString(val)
}

//export extractor_ControlCotent_ItemNum_Get
func extractor_ControlCotent_ItemNum_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.ItemNum)
}

//export extractor_ControlCotent_ItemNum_Set
func extractor_ControlCotent_ItemNum_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.ItemNum = C.GoString(val)
}

//export extractor_ControlCotent_PartNumber_Get
func extractor_ControlCotent_PartNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.PartNumber)
}

//export extractor_ControlCotent_PartNumber_Set
func extractor_ControlCotent_PartNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.PartNumber = C.GoString(val)
}

//export extractor_ControlCotent_ComponentManufacturerPartNumber_Get
func extractor_ControlCotent_ComponentManufacturerPartNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.ComponentManufacturerPartNumber)
}

//export extractor_ControlCotent_ComponentManufacturerPartNumber_Set
func extractor_ControlCotent_ComponentManufacturerPartNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.ComponentManufacturerPartNumber = C.GoString(val)
}

//export extractor_ControlCotent_PartDescription_Get
func extractor_ControlCotent_PartDescription_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.PartDescription)
}

//export extractor_ControlCotent_PartDescription_Set
func extractor_ControlCotent_PartDescription_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.PartDescription = C.GoString(val)
}

//export extractor_ControlCotent_ManufacturerOfComponent_Get
func extractor_ControlCotent_ManufacturerOfComponent_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.ManufacturerOfComponent)
}

//export extractor_ControlCotent_ManufacturerOfComponent_Set
func extractor_ControlCotent_ManufacturerOfComponent_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.ManufacturerOfComponent = C.GoString(val)
}

//export extractor_ControlCotent_ExportRegulationCountry_Get
func extractor_ControlCotent_ExportRegulationCountry_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.ExportRegulationCountry)
}

//export extractor_ControlCotent_ExportRegulationCountry_Set
func extractor_ControlCotent_ExportRegulationCountry_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.ExportRegulationCountry = C.GoString(val)
}

//export extractor_ControlCotent_DualControlListClfNum_Get
func extractor_ControlCotent_DualControlListClfNum_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.DualControlListClfNum)
}

//export extractor_ControlCotent_DualControlListClfNum_Set
func extractor_ControlCotent_DualControlListClfNum_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.DualControlListClfNum = C.GoString(val)
}

//export extractor_ControlCotent_MilitaryControlListClfNum_Get
func extractor_ControlCotent_MilitaryControlListClfNum_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.MilitaryControlListClfNum)
}

//export extractor_ControlCotent_MilitaryControlListClfNum_Set
func extractor_ControlCotent_MilitaryControlListClfNum_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.MilitaryControlListClfNum = C.GoString(val)
}

//export extractor_ControlCotent_IndicateLicenseApplication_Get
func extractor_ControlCotent_IndicateLicenseApplication_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.IndicateLicenseApplication)
}

//export extractor_ControlCotent_IndicateLicenseApplication_Set
func extractor_ControlCotent_IndicateLicenseApplication_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.IndicateLicenseApplication = C.GoString(val)
}

//export extractor_ControlCotent_TopLevelDeliverableItem_Get
func extractor_ControlCotent_TopLevelDeliverableItem_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.TopLevelDeliverableItem)
}

//export extractor_ControlCotent_TopLevelDeliverableItem_Set
func extractor_ControlCotent_TopLevelDeliverableItem_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.TopLevelDeliverableItem = C.GoString(val)
}

//export extractor_ControlCotent_USML_N_Get
func extractor_ControlCotent_USML_N_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.USML_N)
}

//export extractor_ControlCotent_USML_N_Set
func extractor_ControlCotent_USML_N_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.USML_N = C.GoString(val)
}

//export extractor_ControlCotent_ECCN_N_Get
func extractor_ControlCotent_ECCN_N_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.ECCN_N)
}

//export extractor_ControlCotent_ECCN_N_Set
func extractor_ControlCotent_ECCN_N_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.ECCN_N = C.GoString(val)
}

//export extractor_ControlCotent_US_EA_CONTENT_RATIO_Get
func extractor_ControlCotent_US_EA_CONTENT_RATIO_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	return C.CString(op.US_EA_CONTENT_RATIO)
}

//export extractor_ControlCotent_US_EA_CONTENT_RATIO_Set
func extractor_ControlCotent_US_EA_CONTENT_RATIO_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ControlCotent(handle)
	op.US_EA_CONTENT_RATIO = C.GoString(val)
}

// --- wrapping struct: extractor.ColumnMapping ---
//
//export extractor_ColumnMapping_CTor
func extractor_ColumnMapping_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_ColumnMapping(&extractor.ColumnMapping{}))
}

//export extractor_ColumnMapping_FieldName_Get
func extractor_ColumnMapping_FieldName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ColumnMapping(handle)
	return C.CString(op.FieldName)
}

//export extractor_ColumnMapping_FieldName_Set
func extractor_ColumnMapping_FieldName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ColumnMapping(handle)
	op.FieldName = C.GoString(val)
}

//export extractor_ColumnMapping_SearchTerms_Get
func extractor_ColumnMapping_SearchTerms_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_ColumnMapping(handle)
	return handleFromPtr_Slice_string(&op.SearchTerms)
}

//export extractor_ColumnMapping_SearchTerms_Set
func extractor_ColumnMapping_SearchTerms_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_ColumnMapping(handle)
	op.SearchTerms = deptrFromHandle_Slice_string(val)
}

//export extractor_ColumnMapping_FoundColumn_Get
func extractor_ColumnMapping_FoundColumn_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ColumnMapping(handle)
	return C.CString(op.FoundColumn)
}

//export extractor_ColumnMapping_FoundColumn_Set
func extractor_ColumnMapping_FoundColumn_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ColumnMapping(handle)
	op.FoundColumn = C.GoString(val)
}

// --- wrapping struct: extractor.ClassificationCriteria ---
//
//export extractor_ClassificationCriteria_CTor
func extractor_ClassificationCriteria_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_ClassificationCriteria(&extractor.ClassificationCriteria{}))
}

//export extractor_ClassificationCriteria_Label_Get
func extractor_ClassificationCriteria_Label_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ClassificationCriteria(handle)
	return C.CString(op.Label)
}

//export extractor_ClassificationCriteria_Label_Set
func extractor_ClassificationCriteria_Label_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ClassificationCriteria(handle)
	op.Label = C.GoString(val)
}

//export extractor_ClassificationCriteria_SearchTerms_Get
func extractor_ClassificationCriteria_SearchTerms_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_ClassificationCriteria(handle)
	return handleFromPtr_Slice_string(&op.SearchTerms)
}

//export extractor_ClassificationCriteria_SearchTerms_Set
func extractor_ClassificationCriteria_SearchTerms_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_ClassificationCriteria(handle)
	op.SearchTerms = deptrFromHandle_Slice_string(val)
}

//export extractor_ClassificationCriteria_Offset_Get
func extractor_ClassificationCriteria_Offset_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_extractor_ClassificationCriteria(handle)
	return C.longlong(op.Offset)
}

//export extractor_ClassificationCriteria_Offset_Set
func extractor_ClassificationCriteria_Offset_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_extractor_ClassificationCriteria(handle)
	op.Offset = int(val)
}

// --- wrapping struct: extractor.DualColumnClfExtractor ---
//
//export extractor_DualColumnClfExtractor_CTor
func extractor_DualColumnClfExtractor_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_DualColumnClfExtractor(&extractor.DualColumnClfExtractor{}))
}

// --- wrapping struct: extractor.Response ---
//
//export extractor_Response_CTor
func extractor_Response_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_Response(&extractor.Response{}))
}

//export extractor_Response_Status_Get
func extractor_Response_Status_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_Response(handle)
	return C.CString(op.Status)
}

//export extractor_Response_Status_Set
func extractor_Response_Status_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_Response(handle)
	op.Status = C.GoString(val)
}

//export extractor_Response_Message_Get
func extractor_Response_Message_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_Response(handle)
	return C.CString(op.Message)
}

//export extractor_Response_Message_Set
func extractor_Response_Message_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_Response(handle)
	op.Message = C.GoString(val)
}

//export extractor_Response_Data_Get
func extractor_Response_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_Response(handle)
	return handleFromPtr_any(op.Data)
}

//export extractor_Response_Data_Set
func extractor_Response_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_Response(handle)
	op.Data = ptrFromHandle_any(val)
}

// --- wrapping struct: extractor.SheetNotFoundError ---
//
//export extractor_SheetNotFoundError_CTor
func extractor_SheetNotFoundError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_SheetNotFoundError(&extractor.SheetNotFoundError{}))
}

//export extractor_SheetNotFoundError_Error
func extractor_SheetNotFoundError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.SheetNotFoundError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(extractor.SheetNotFoundError{})).(*extractor.SheetNotFoundError).Error())

}

// --- wrapping struct: extractor.BuyerDetails ---
//
//export extractor_BuyerDetails_CTor
func extractor_BuyerDetails_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_BuyerDetails(&extractor.BuyerDetails{}))
}

//export extractor_BuyerDetails_SheetName_Get
func extractor_BuyerDetails_SheetName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return C.CString(op.SheetName)
}

//export extractor_BuyerDetails_SheetName_Set
func extractor_BuyerDetails_SheetName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.SheetName = C.GoString(val)
}

//export extractor_BuyerDetails_PartNumber_Get
func extractor_BuyerDetails_PartNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return C.CString(op.PartNumber)
}

//export extractor_BuyerDetails_PartNumber_Set
func extractor_BuyerDetails_PartNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.PartNumber = C.GoString(val)
}

//export extractor_BuyerDetails_PartDescription_Get
func extractor_BuyerDetails_PartDescription_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return C.CString(op.PartDescription)
}

//export extractor_BuyerDetails_PartDescription_Set
func extractor_BuyerDetails_PartDescription_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.PartDescription = C.GoString(val)
}

//export extractor_BuyerDetails_ClassificationOfItem_Get
func extractor_BuyerDetails_ClassificationOfItem_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return C.CString(op.ClassificationOfItem)
}

//export extractor_BuyerDetails_ClassificationOfItem_Set
func extractor_BuyerDetails_ClassificationOfItem_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.ClassificationOfItem = C.GoString(val)
}

//export extractor_BuyerDetails_ControlListClassificationNumber_Get
func extractor_BuyerDetails_ControlListClassificationNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return C.CString(op.ControlListClassificationNumber)
}

//export extractor_BuyerDetails_ControlListClassificationNumber_Set
func extractor_BuyerDetails_ControlListClassificationNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.ControlListClassificationNumber = C.GoString(val)
}

//export extractor_BuyerDetails_RFQ_Get
func extractor_BuyerDetails_RFQ_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return C.CString(op.RFQ)
}

//export extractor_BuyerDetails_RFQ_Set
func extractor_BuyerDetails_RFQ_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.RFQ = C.GoString(val)
}

//export extractor_BuyerDetails_BuildToPrint_Get
func extractor_BuyerDetails_BuildToPrint_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return boolGoToPy(op.BuildToPrint)
}

//export extractor_BuyerDetails_BuildToPrint_Set
func extractor_BuyerDetails_BuildToPrint_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.BuildToPrint = boolPyToGo(val)
}

//export extractor_BuyerDetails_ManufacturedToSpecification_Get
func extractor_BuyerDetails_ManufacturedToSpecification_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return boolGoToPy(op.ManufacturedToSpecification)
}

//export extractor_BuyerDetails_ManufacturedToSpecification_Set
func extractor_BuyerDetails_ManufacturedToSpecification_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.ManufacturedToSpecification = boolPyToGo(val)
}

//export extractor_BuyerDetails_OriginalEquipmentManufacturer_Get
func extractor_BuyerDetails_OriginalEquipmentManufacturer_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return boolGoToPy(op.OriginalEquipmentManufacturer)
}

//export extractor_BuyerDetails_OriginalEquipmentManufacturer_Set
func extractor_BuyerDetails_OriginalEquipmentManufacturer_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.OriginalEquipmentManufacturer = boolPyToGo(val)
}

//export extractor_BuyerDetails_Modified_Get
func extractor_BuyerDetails_Modified_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	return boolGoToPy(op.Modified)
}

//export extractor_BuyerDetails_Modified_Set
func extractor_BuyerDetails_Modified_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_BuyerDetails(handle)
	op.Modified = boolPyToGo(val)
}

//export extractor_BuyerDetails_GetSheetName
func extractor_BuyerDetails_GetSheetName(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.BuyerDetails")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(extractor.BuyerDetails{})).(*extractor.BuyerDetails).GetSheetName())

}

// --- wrapping struct: extractor.BoolContainsImageExtractor ---
//
//export extractor_BoolContainsImageExtractor_CTor
func extractor_BoolContainsImageExtractor_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_BoolContainsImageExtractor(&extractor.BoolContainsImageExtractor{}))
}

// --- wrapping struct: extractor.CellRange ---
//
//export extractor_CellRange_CTor
func extractor_CellRange_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_CellRange(&extractor.CellRange{}))
}

//export extractor_CellRange_StartCell_Get
func extractor_CellRange_StartCell_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_CellRange(handle)
	return C.CString(op.StartCell)
}

//export extractor_CellRange_StartCell_Set
func extractor_CellRange_StartCell_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_CellRange(handle)
	op.StartCell = C.GoString(val)
}

//export extractor_CellRange_EndCell_Get
func extractor_CellRange_EndCell_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_CellRange(handle)
	return C.CString(op.EndCell)
}

//export extractor_CellRange_EndCell_Set
func extractor_CellRange_EndCell_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_CellRange(handle)
	op.EndCell = C.GoString(val)
}

// --- wrapping struct: extractor.DualClassificationCriteria ---
//
//export extractor_DualClassificationCriteria_CTor
func extractor_DualClassificationCriteria_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_DualClassificationCriteria(&extractor.DualClassificationCriteria{}))
}

//export extractor_DualClassificationCriteria_TYPE_1_Get
func extractor_DualClassificationCriteria_TYPE_1_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_DualClassificationCriteria(handle)
	return handleFromPtr_extractor_ClassificationCriteria(&op.TYPE_1)
}

//export extractor_DualClassificationCriteria_TYPE_1_Set
func extractor_DualClassificationCriteria_TYPE_1_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_DualClassificationCriteria(handle)
	op.TYPE_1 = *ptrFromHandle_extractor_ClassificationCriteria(val)
}

//export extractor_DualClassificationCriteria_TYPE_2_Get
func extractor_DualClassificationCriteria_TYPE_2_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_DualClassificationCriteria(handle)
	return handleFromPtr_extractor_ClassificationCriteria(&op.TYPE_2)
}

//export extractor_DualClassificationCriteria_TYPE_2_Set
func extractor_DualClassificationCriteria_TYPE_2_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_DualClassificationCriteria(handle)
	op.TYPE_2 = *ptrFromHandle_extractor_ClassificationCriteria(val)
}

// --- wrapping struct: extractor.ExcelExtractor ---
//
//export extractor_ExcelExtractor_CTor
func extractor_ExcelExtractor_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_ExcelExtractor(&extractor.ExcelExtractor{}))
}

//export extractor_ExcelExtractor_Extraction_Get
func extractor_ExcelExtractor_Extraction_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_ExcelExtractor(handle)
	return handleFromPtr_Ptr_extractor_SECCFExtraction(op.Extraction)
}

//export extractor_ExcelExtractor_Extraction_Set
func extractor_ExcelExtractor_Extraction_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_ExcelExtractor(handle)
	op.Extraction = ptrFromHandle_Ptr_extractor_SECCFExtraction(val)
}

//export extractor_ExcelExtractor_ReplaceCompanyNames
func extractor_ExcelExtractor_ReplaceCompanyNames(_handle CGoHandle, items CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.ExcelExtractor")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor).ReplaceCompanyNames(deptrFromHandle_Slice_string(items))

	return handleFromPtr_Slice_string(&cret)
}

//export extractor_ExcelExtractor_GetCellValue
func extractor_ExcelExtractor_GetCellValue(_handle CGoHandle, cellRange CGoHandle, sheetName *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.ExcelExtractor")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor).GetCellValue(*ptrFromHandle_extractor_CellRange(cellRange), C.GoString(sheetName))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export extractor_ExcelExtractor_ToJson
func extractor_ExcelExtractor_ToJson(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.ExcelExtractor")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor).ToJson())

}

//export extractor_ExcelExtractor_ReadFormControls
func extractor_ExcelExtractor_ReadFormControls(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.ExcelExtractor")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor).ReadFormControls()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor).ReadFormControls()
	}
}

//export extractor_ExcelExtractor_Extract
func extractor_ExcelExtractor_Extract(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.ExcelExtractor")
	if __err != nil {
		return handleFromPtr_extractor_SECCFExtraction(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor).Extract()

	return handleFromPtr_extractor_SECCFExtraction(&cret)
}

//export extractor_ExcelExtractor_Close
func extractor_ExcelExtractor_Close(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.ExcelExtractor")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(extractor.ExcelExtractor{})).(*extractor.ExcelExtractor).Close()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: extractor.SECCFExtraction ---
//
//export extractor_SECCFExtraction_CTor
func extractor_SECCFExtraction_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_SECCFExtraction(&extractor.SECCFExtraction{}))
}

//export extractor_SECCFExtraction_BuyerDetails_Get
func extractor_SECCFExtraction_BuyerDetails_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SECCFExtraction(handle)
	return handleFromPtr_Ptr_extractor_BuyerDetails(op.BuyerDetails)
}

//export extractor_SECCFExtraction_BuyerDetails_Set
func extractor_SECCFExtraction_BuyerDetails_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SECCFExtraction(handle)
	op.BuyerDetails = ptrFromHandle_Ptr_extractor_BuyerDetails(val)
}

//export extractor_SECCFExtraction_ProductDetails_Get
func extractor_SECCFExtraction_ProductDetails_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SECCFExtraction(handle)
	return handleFromPtr_Ptr_extractor_ProductDetails(op.ProductDetails)
}

//export extractor_SECCFExtraction_ProductDetails_Set
func extractor_SECCFExtraction_ProductDetails_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SECCFExtraction(handle)
	op.ProductDetails = ptrFromHandle_Ptr_extractor_ProductDetails(val)
}

//export extractor_SECCFExtraction_ControlledContent_Get
func extractor_SECCFExtraction_ControlledContent_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SECCFExtraction(handle)
	return handleFromPtr_Slice_extractor_ControlCotent(&op.ControlledContent)
}

//export extractor_SECCFExtraction_ControlledContent_Set
func extractor_SECCFExtraction_ControlledContent_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SECCFExtraction(handle)
	op.ControlledContent = deptrFromHandle_Slice_extractor_ControlCotent(val)
}

// --- wrapping struct: extractor.TriColumnClfExtractor ---
//
//export extractor_TriColumnClfExtractor_CTor
func extractor_TriColumnClfExtractor_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_TriColumnClfExtractor(&extractor.TriColumnClfExtractor{}))
}

// --- wrapping struct: extractor.BoolClassificationCriteria ---
//
//export extractor_BoolClassificationCriteria_CTor
func extractor_BoolClassificationCriteria_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_BoolClassificationCriteria(&extractor.BoolClassificationCriteria{}))
}

//export extractor_BoolClassificationCriteria_Offset_Get
func extractor_BoolClassificationCriteria_Offset_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_extractor_BoolClassificationCriteria(handle)
	return C.longlong(op.Offset)
}

//export extractor_BoolClassificationCriteria_Offset_Set
func extractor_BoolClassificationCriteria_Offset_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_extractor_BoolClassificationCriteria(handle)
	op.Offset = int(val)
}

//export extractor_BoolClassificationCriteria_SearchTerms_Get
func extractor_BoolClassificationCriteria_SearchTerms_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_BoolClassificationCriteria(handle)
	return handleFromPtr_Slice_string(&op.SearchTerms)
}

//export extractor_BoolClassificationCriteria_SearchTerms_Set
func extractor_BoolClassificationCriteria_SearchTerms_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_BoolClassificationCriteria(handle)
	op.SearchTerms = deptrFromHandle_Slice_string(val)
}

// --- wrapping struct: extractor.DivideByZeroError ---
//
//export extractor_DivideByZeroError_CTor
func extractor_DivideByZeroError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_DivideByZeroError(&extractor.DivideByZeroError{}))
}

// --- wrapping struct: extractor.ProductDetails ---
//
//export extractor_ProductDetails_CTor
func extractor_ProductDetails_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_ProductDetails(&extractor.ProductDetails{}))
}

//export extractor_ProductDetails_SheetName_Get
func extractor_ProductDetails_SheetName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SheetName)
}

//export extractor_ProductDetails_SheetName_Set
func extractor_ProductDetails_SheetName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SheetName = C.GoString(val)
}

//export extractor_ProductDetails_SupplierPartNumber_Get
func extractor_ProductDetails_SupplierPartNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SupplierPartNumber)
}

//export extractor_ProductDetails_SupplierPartNumber_Set
func extractor_ProductDetails_SupplierPartNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SupplierPartNumber = C.GoString(val)
}

//export extractor_ProductDetails_SupplierCompanyName_Get
func extractor_ProductDetails_SupplierCompanyName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SupplierCompanyName)
}

//export extractor_ProductDetails_SupplierCompanyName_Set
func extractor_ProductDetails_SupplierCompanyName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SupplierCompanyName = C.GoString(val)
}

//export extractor_ProductDetails_SupplierFullAddress_Get
func extractor_ProductDetails_SupplierFullAddress_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SupplierFullAddress)
}

//export extractor_ProductDetails_SupplierFullAddress_Set
func extractor_ProductDetails_SupplierFullAddress_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SupplierFullAddress = C.GoString(val)
}

//export extractor_ProductDetails_SupplierCountry_Get
func extractor_ProductDetails_SupplierCountry_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SupplierCountry)
}

//export extractor_ProductDetails_SupplierCountry_Set
func extractor_ProductDetails_SupplierCountry_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SupplierCountry = C.GoString(val)
}

//export extractor_ProductDetails_SupplierCompanyNumber_Get
func extractor_ProductDetails_SupplierCompanyNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SupplierCompanyNumber)
}

//export extractor_ProductDetails_SupplierCompanyNumber_Set
func extractor_ProductDetails_SupplierCompanyNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SupplierCompanyNumber = C.GoString(val)
}

//export extractor_ProductDetails_ManufacturerPartNumber_Get
func extractor_ProductDetails_ManufacturerPartNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ManufacturerPartNumber)
}

//export extractor_ProductDetails_ManufacturerPartNumber_Set
func extractor_ProductDetails_ManufacturerPartNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ManufacturerPartNumber = C.GoString(val)
}

//export extractor_ProductDetails_ManufacturerCompanyName_Get
func extractor_ProductDetails_ManufacturerCompanyName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ManufacturerCompanyName)
}

//export extractor_ProductDetails_ManufacturerCompanyName_Set
func extractor_ProductDetails_ManufacturerCompanyName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ManufacturerCompanyName = C.GoString(val)
}

//export extractor_ProductDetails_ManufacturerFullAddress_Get
func extractor_ProductDetails_ManufacturerFullAddress_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ManufacturerFullAddress)
}

//export extractor_ProductDetails_ManufacturerFullAddress_Set
func extractor_ProductDetails_ManufacturerFullAddress_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ManufacturerFullAddress = C.GoString(val)
}

//export extractor_ProductDetails_ManufacturerCountry_Get
func extractor_ProductDetails_ManufacturerCountry_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ManufacturerCountry)
}

//export extractor_ProductDetails_ManufacturerCountry_Set
func extractor_ProductDetails_ManufacturerCountry_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ManufacturerCountry = C.GoString(val)
}

//export extractor_ProductDetails_ManufacturerCompanyNumber_Get
func extractor_ProductDetails_ManufacturerCompanyNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ManufacturerCompanyNumber)
}

//export extractor_ProductDetails_ManufacturerCompanyNumber_Set
func extractor_ProductDetails_ManufacturerCompanyNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ManufacturerCompanyNumber = C.GoString(val)
}

//export extractor_ProductDetails_CountryOfOrigin_Get
func extractor_ProductDetails_CountryOfOrigin_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.CountryOfOrigin)
}

//export extractor_ProductDetails_CountryOfOrigin_Set
func extractor_ProductDetails_CountryOfOrigin_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.CountryOfOrigin = C.GoString(val)
}

//export extractor_ProductDetails_CustomsTariffCode_Get
func extractor_ProductDetails_CustomsTariffCode_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.CustomsTariffCode)
}

//export extractor_ProductDetails_CustomsTariffCode_Set
func extractor_ProductDetails_CustomsTariffCode_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.CustomsTariffCode = C.GoString(val)
}

//export extractor_ProductDetails_ExportControlRegulated_Get
func extractor_ProductDetails_ExportControlRegulated_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ExportControlRegulated)
}

//export extractor_ProductDetails_ExportControlRegulated_Set
func extractor_ProductDetails_ExportControlRegulated_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ExportControlRegulated = C.GoString(val)
}

//export extractor_ProductDetails_PartClassification_Get
func extractor_ProductDetails_PartClassification_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.PartClassification)
}

//export extractor_ProductDetails_PartClassification_Set
func extractor_ProductDetails_PartClassification_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.PartClassification = C.GoString(val)
}

//export extractor_ProductDetails_ControlListClassificationNumber_Get
func extractor_ProductDetails_ControlListClassificationNumber_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ControlListClassificationNumber)
}

//export extractor_ProductDetails_ControlListClassificationNumber_Set
func extractor_ProductDetails_ControlListClassificationNumber_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ControlListClassificationNumber = C.GoString(val)
}

//export extractor_ProductDetails_ThirdCountryControlledContent_Get
func extractor_ProductDetails_ThirdCountryControlledContent_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ThirdCountryControlledContent)
}

//export extractor_ProductDetails_ThirdCountryControlledContent_Set
func extractor_ProductDetails_ThirdCountryControlledContent_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ThirdCountryControlledContent = C.GoString(val)
}

//export extractor_ProductDetails_EndUserStatementRequired_Get
func extractor_ProductDetails_EndUserStatementRequired_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.EndUserStatementRequired)
}

//export extractor_ProductDetails_EndUserStatementRequired_Set
func extractor_ProductDetails_EndUserStatementRequired_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.EndUserStatementRequired = C.GoString(val)
}

//export extractor_ProductDetails_ExportLicenceShipmentRequired_Get
func extractor_ProductDetails_ExportLicenceShipmentRequired_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ExportLicenceShipmentRequired)
}

//export extractor_ProductDetails_ExportLicenceShipmentRequired_Set
func extractor_ProductDetails_ExportLicenceShipmentRequired_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ExportLicenceShipmentRequired = C.GoString(val)
}

//export extractor_ProductDetails_ExportLicenceEndUserRequired_Get
func extractor_ProductDetails_ExportLicenceEndUserRequired_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.ExportLicenceEndUserRequired)
}

//export extractor_ProductDetails_ExportLicenceEndUserRequired_Set
func extractor_ProductDetails_ExportLicenceEndUserRequired_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.ExportLicenceEndUserRequired = C.GoString(val)
}

//export extractor_ProductDetails_AdditionalExportDocsRequired_Get
func extractor_ProductDetails_AdditionalExportDocsRequired_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.AdditionalExportDocsRequired)
}

//export extractor_ProductDetails_AdditionalExportDocsRequired_Set
func extractor_ProductDetails_AdditionalExportDocsRequired_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.AdditionalExportDocsRequired = C.GoString(val)
}

//export extractor_ProductDetails_TransferReexportConditions_Get
func extractor_ProductDetails_TransferReexportConditions_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.TransferReexportConditions)
}

//export extractor_ProductDetails_TransferReexportConditions_Set
func extractor_ProductDetails_TransferReexportConditions_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.TransferReexportConditions = C.GoString(val)
}

//export extractor_ProductDetails_RepresentativeName_Get
func extractor_ProductDetails_RepresentativeName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.RepresentativeName)
}

//export extractor_ProductDetails_RepresentativeName_Set
func extractor_ProductDetails_RepresentativeName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.RepresentativeName = C.GoString(val)
}

//export extractor_ProductDetails_RepresentativePosition_Get
func extractor_ProductDetails_RepresentativePosition_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.RepresentativePosition)
}

//export extractor_ProductDetails_RepresentativePosition_Set
func extractor_ProductDetails_RepresentativePosition_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.RepresentativePosition = C.GoString(val)
}

//export extractor_ProductDetails_RepresentativeSignature_Get
func extractor_ProductDetails_RepresentativeSignature_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return boolGoToPy(op.RepresentativeSignature)
}

//export extractor_ProductDetails_RepresentativeSignature_Set
func extractor_ProductDetails_RepresentativeSignature_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.RepresentativeSignature = boolPyToGo(val)
}

//export extractor_ProductDetails_SupplierCompanySeal_Get
func extractor_ProductDetails_SupplierCompanySeal_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SupplierCompanySeal)
}

//export extractor_ProductDetails_SupplierCompanySeal_Set
func extractor_ProductDetails_SupplierCompanySeal_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SupplierCompanySeal = C.GoString(val)
}

//export extractor_ProductDetails_SignatureDate_Get
func extractor_ProductDetails_SignatureDate_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	return C.CString(op.SignatureDate)
}

//export extractor_ProductDetails_SignatureDate_Set
func extractor_ProductDetails_SignatureDate_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_extractor_ProductDetails(handle)
	op.SignatureDate = C.GoString(val)
}

//export extractor_ProductDetails_GetSheetName
func extractor_ProductDetails_GetSheetName(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*extractor.ProductDetails")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(extractor.ProductDetails{})).(*extractor.ProductDetails).GetSheetName())

}

// --- wrapping struct: extractor.SearchCriteria ---
//
//export extractor_SearchCriteria_CTor
func extractor_SearchCriteria_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_SearchCriteria(&extractor.SearchCriteria{}))
}

//export extractor_SearchCriteria_SearchTerms_Get
func extractor_SearchCriteria_SearchTerms_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return handleFromPtr_Slice_string(&op.SearchTerms)
}

//export extractor_SearchCriteria_SearchTerms_Set
func extractor_SearchCriteria_SearchTerms_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.SearchTerms = deptrFromHandle_Slice_string(val)
}

//export extractor_SearchCriteria_CellRanges_Get
func extractor_SearchCriteria_CellRanges_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return handleFromPtr_Slice_extractor_CellRange(&op.CellRanges)
}

//export extractor_SearchCriteria_CellRanges_Set
func extractor_SearchCriteria_CellRanges_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.CellRanges = deptrFromHandle_Slice_extractor_CellRange(val)
}

//export extractor_SearchCriteria_DualColumnCheckBoxClf_Get
func extractor_SearchCriteria_DualColumnCheckBoxClf_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return boolGoToPy(op.DualColumnCheckBoxClf)
}

//export extractor_SearchCriteria_DualColumnCheckBoxClf_Set
func extractor_SearchCriteria_DualColumnCheckBoxClf_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.DualColumnCheckBoxClf = boolPyToGo(val)
}

//export extractor_SearchCriteria_DualColumnClfCriteria_Get
func extractor_SearchCriteria_DualColumnClfCriteria_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return handleFromPtr_extractor_DualClassificationCriteria(&op.DualColumnClfCriteria)
}

//export extractor_SearchCriteria_DualColumnClfCriteria_Set
func extractor_SearchCriteria_DualColumnClfCriteria_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.DualColumnClfCriteria = *ptrFromHandle_extractor_DualClassificationCriteria(val)
}

//export extractor_SearchCriteria_TriColumnCheckBoxClf_Get
func extractor_SearchCriteria_TriColumnCheckBoxClf_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return boolGoToPy(op.TriColumnCheckBoxClf)
}

//export extractor_SearchCriteria_TriColumnCheckBoxClf_Set
func extractor_SearchCriteria_TriColumnCheckBoxClf_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.TriColumnCheckBoxClf = boolPyToGo(val)
}

//export extractor_SearchCriteria_TriColumnClfCriteria_Get
func extractor_SearchCriteria_TriColumnClfCriteria_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return handleFromPtr_extractor_TriClassificationCritera(&op.TriColumnClfCriteria)
}

//export extractor_SearchCriteria_TriColumnClfCriteria_Set
func extractor_SearchCriteria_TriColumnClfCriteria_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.TriColumnClfCriteria = *ptrFromHandle_extractor_TriClassificationCritera(val)
}

//export extractor_SearchCriteria_BoolCheckBox_Get
func extractor_SearchCriteria_BoolCheckBox_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return boolGoToPy(op.BoolCheckBox)
}

//export extractor_SearchCriteria_BoolCheckBox_Set
func extractor_SearchCriteria_BoolCheckBox_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.BoolCheckBox = boolPyToGo(val)
}

//export extractor_SearchCriteria_BoolClfCriteria_Get
func extractor_SearchCriteria_BoolClfCriteria_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return handleFromPtr_extractor_BoolClassificationCriteria(&op.BoolClfCriteria)
}

//export extractor_SearchCriteria_BoolClfCriteria_Set
func extractor_SearchCriteria_BoolClfCriteria_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.BoolClfCriteria = *ptrFromHandle_extractor_BoolClassificationCriteria(val)
}

//export extractor_SearchCriteria_BoolContainsImage_Get
func extractor_SearchCriteria_BoolContainsImage_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return boolGoToPy(op.BoolContainsImage)
}

//export extractor_SearchCriteria_BoolContainsImage_Set
func extractor_SearchCriteria_BoolContainsImage_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.BoolContainsImage = boolPyToGo(val)
}

//export extractor_SearchCriteria_BoolClfContainsImage_Get
func extractor_SearchCriteria_BoolClfContainsImage_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return handleFromPtr_extractor_BoolClassificationCriteria(&op.BoolClfContainsImage)
}

//export extractor_SearchCriteria_BoolClfContainsImage_Set
func extractor_SearchCriteria_BoolClfContainsImage_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.BoolClfContainsImage = *ptrFromHandle_extractor_BoolClassificationCriteria(val)
}

//export extractor_SearchCriteria_Offset_Get
func extractor_SearchCriteria_Offset_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	return C.longlong(op.Offset)
}

//export extractor_SearchCriteria_Offset_Set
func extractor_SearchCriteria_Offset_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_extractor_SearchCriteria(handle)
	op.Offset = int(val)
}

// --- wrapping struct: extractor.SimpleValueExtractor ---
//
//export extractor_SimpleValueExtractor_CTor
func extractor_SimpleValueExtractor_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_SimpleValueExtractor(&extractor.SimpleValueExtractor{}))
}

// --- wrapping struct: extractor.TriClassificationCritera ---
//
//export extractor_TriClassificationCritera_CTor
func extractor_TriClassificationCritera_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_TriClassificationCritera(&extractor.TriClassificationCritera{}))
}

//export extractor_TriClassificationCritera_TYPE_1_Get
func extractor_TriClassificationCritera_TYPE_1_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_TriClassificationCritera(handle)
	return handleFromPtr_extractor_ClassificationCriteria(&op.TYPE_1)
}

//export extractor_TriClassificationCritera_TYPE_1_Set
func extractor_TriClassificationCritera_TYPE_1_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_TriClassificationCritera(handle)
	op.TYPE_1 = *ptrFromHandle_extractor_ClassificationCriteria(val)
}

//export extractor_TriClassificationCritera_TYPE_2_Get
func extractor_TriClassificationCritera_TYPE_2_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_TriClassificationCritera(handle)
	return handleFromPtr_extractor_ClassificationCriteria(&op.TYPE_2)
}

//export extractor_TriClassificationCritera_TYPE_2_Set
func extractor_TriClassificationCritera_TYPE_2_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_TriClassificationCritera(handle)
	op.TYPE_2 = *ptrFromHandle_extractor_ClassificationCriteria(val)
}

//export extractor_TriClassificationCritera_TYPE_3_Get
func extractor_TriClassificationCritera_TYPE_3_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_extractor_TriClassificationCritera(handle)
	return handleFromPtr_extractor_ClassificationCriteria(&op.TYPE_3)
}

//export extractor_TriClassificationCritera_TYPE_3_Set
func extractor_TriClassificationCritera_TYPE_3_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_extractor_TriClassificationCritera(handle)
	op.TYPE_3 = *ptrFromHandle_extractor_ClassificationCriteria(val)
}

// --- wrapping struct: extractor.BoolCheckBoxExtractor ---
//
//export extractor_BoolCheckBoxExtractor_CTor
func extractor_BoolCheckBoxExtractor_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_BoolCheckBoxExtractor(&extractor.BoolCheckBoxExtractor{}))
}

// ---- Slices ---

// --- wrapping slice: extractor.CompanyNameList ---
//
//export extractor_CompanyNameList_CTor
func extractor_CompanyNameList_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_extractor_CompanyNameList(&extractor.CompanyNameList{}))
}

//export extractor_CompanyNameList_len
func extractor_CompanyNameList_len(handle CGoHandle) int {
	return len(deptrFromHandle_extractor_CompanyNameList(handle))
}

//export extractor_CompanyNameList_elem
func extractor_CompanyNameList_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_extractor_CompanyNameList(handle)
	return C.CString(s[_idx])
}

//export extractor_CompanyNameList_subslice
func extractor_CompanyNameList_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_extractor_CompanyNameList(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_extractor_CompanyNameList(&ss))
}

//export extractor_CompanyNameList_set
func extractor_CompanyNameList_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_extractor_CompanyNameList(handle)
	s[_idx] = C.GoString(_vl)
}

//export extractor_CompanyNameList_append
func extractor_CompanyNameList_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_extractor_CompanyNameList(handle)
	*s = append(*s, C.GoString(_vl))
}

// ---- Maps ---

// ---- Constructors ---

//export extractor_MakeSECCFExtractor
func extractor_MakeSECCFExtractor(filePath *C.char, companyNames CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := extractor.MakeSECCFExtractor(C.GoString(filePath), deptrFromHandle_extractor_CompanyNameList(companyNames))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_extractor_ExcelExtractor(nil)
	}
	return handleFromPtr_Ptr_extractor_ExcelExtractor(cret)
}

// ---- Functions ---

// ---- Package: utils ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export utils_RemoveExtraSpaces
func utils_RemoveExtraSpaces(value *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(utils.RemoveExtraSpaces(C.GoString(value)))

}
