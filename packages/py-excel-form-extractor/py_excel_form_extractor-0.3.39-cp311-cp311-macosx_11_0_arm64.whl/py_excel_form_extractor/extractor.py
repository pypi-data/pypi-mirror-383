
# python wrapper for package github.com/adhadse/excelFormExtractor/pkg/extractor within overall package extractor
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -no-make -dynamic-link=True -rename=True -output /Users/runner/work/excelFormExtractor/excelFormExtractor/build/lib.macosx-11.0-arm64-cpython-311/py_excel_form_extractor -vm /private/var/folders/y6/nj790rtn62lfktb1sh__79hc0000gn/T/cibw-run-bgug6guv/cp311-macosx_arm64/build/venv/bin/python ./pkg/extractor ./pkg/utils

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _extractor
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from extractor import extractor
# and then refer to everything using extractor. prefix
# packages imported by this package listed below:

from . import utils



# ---- Types ---

# Python type for slice []extractor.CellRange
class Slice_extractor_CellRange(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.Slice_extractor_CellRange_CTor()
			_extractor.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_extractor_CellRange.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		s = 'extractor.Slice_extractor_CellRange len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'extractor.Slice_extractor_CellRange([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _extractor.Slice_extractor_CellRange_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _extractor.Slice_extractor_CellRange_len(self.handle)
				return Slice_extractor_CellRange(handle=_extractor.Slice_extractor_CellRange_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return CellRange(handle=_extractor.Slice_extractor_CellRange_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_extractor.Slice_extractor_CellRange_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_extractor_CellRange.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = CellRange(handle=_extractor.Slice_extractor_CellRange_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_extractor.Slice_extractor_CellRange_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []extractor.ControlCotent
class Slice_extractor_ControlCotent(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.Slice_extractor_ControlCotent_CTor()
			_extractor.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_extractor_ControlCotent.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		s = 'extractor.Slice_extractor_ControlCotent len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'extractor.Slice_extractor_ControlCotent([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _extractor.Slice_extractor_ControlCotent_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _extractor.Slice_extractor_ControlCotent_len(self.handle)
				return Slice_extractor_ControlCotent(handle=_extractor.Slice_extractor_ControlCotent_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ControlCotent(handle=_extractor.Slice_extractor_ControlCotent_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_extractor.Slice_extractor_ControlCotent_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_extractor_ControlCotent.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = ControlCotent(handle=_extractor.Slice_extractor_ControlCotent_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_extractor.Slice_extractor_ControlCotent_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface extractor.SheetNameGetter
class SheetNameGetter(go.GoClass):
	"""Generic interface for structures with SheetName\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = 0
	def get_sheet_name(self):
		"""GetSheetName() str"""
		return _extractor.extractor_SheetNameGetter_GetSheetName(self.handle)

# Python type for interface extractor.ValueExtractor
class ValueExtractor(go.GoClass):
	"""Add a method to handle value extraction based on criteria type\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = 0


# ---- Structs ---

# Python type for struct extractor.BuyerDetails
class BuyerDetails(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_BuyerDetails_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SheetName = args[0]
			if "SheetName" in kwargs:
				self.SheetName = kwargs["SheetName"]
			if  1 < len(args):
				self.PartNumber = args[1]
			if "PartNumber" in kwargs:
				self.PartNumber = kwargs["PartNumber"]
			if  2 < len(args):
				self.PartDescription = args[2]
			if "PartDescription" in kwargs:
				self.PartDescription = kwargs["PartDescription"]
			if  3 < len(args):
				self.ClassificationOfItem = args[3]
			if "ClassificationOfItem" in kwargs:
				self.ClassificationOfItem = kwargs["ClassificationOfItem"]
			if  4 < len(args):
				self.ControlListClassificationNumber = args[4]
			if "ControlListClassificationNumber" in kwargs:
				self.ControlListClassificationNumber = kwargs["ControlListClassificationNumber"]
			if  5 < len(args):
				self.RFQ = args[5]
			if "RFQ" in kwargs:
				self.RFQ = kwargs["RFQ"]
			if  6 < len(args):
				self.BuildToPrint = args[6]
			if "BuildToPrint" in kwargs:
				self.BuildToPrint = kwargs["BuildToPrint"]
			if  7 < len(args):
				self.ManufacturedToSpecification = args[7]
			if "ManufacturedToSpecification" in kwargs:
				self.ManufacturedToSpecification = kwargs["ManufacturedToSpecification"]
			if  8 < len(args):
				self.OriginalEquipmentManufacturer = args[8]
			if "OriginalEquipmentManufacturer" in kwargs:
				self.OriginalEquipmentManufacturer = kwargs["OriginalEquipmentManufacturer"]
			if  9 < len(args):
				self.Modified = args[9]
			if "Modified" in kwargs:
				self.Modified = kwargs["Modified"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BuyerDetails{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BuyerDetails ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def sheet_name(self):
		return _extractor.extractor_BuyerDetails_SheetName_Get(self.handle)
	@sheet_name.setter
	def sheet_name(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_SheetName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_SheetName_Set(self.handle, value)
	@property
	def part_number(self):
		return _extractor.extractor_BuyerDetails_PartNumber_Get(self.handle)
	@part_number.setter
	def part_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_PartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_PartNumber_Set(self.handle, value)
	@property
	def part_description(self):
		return _extractor.extractor_BuyerDetails_PartDescription_Get(self.handle)
	@part_description.setter
	def part_description(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_PartDescription_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_PartDescription_Set(self.handle, value)
	@property
	def classification_of_item(self):
		return _extractor.extractor_BuyerDetails_ClassificationOfItem_Get(self.handle)
	@classification_of_item.setter
	def classification_of_item(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_ClassificationOfItem_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_ClassificationOfItem_Set(self.handle, value)
	@property
	def control_list_classification_number(self):
		return _extractor.extractor_BuyerDetails_ControlListClassificationNumber_Get(self.handle)
	@control_list_classification_number.setter
	def control_list_classification_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_ControlListClassificationNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_ControlListClassificationNumber_Set(self.handle, value)
	@property
	def rfq(self):
		return _extractor.extractor_BuyerDetails_RFQ_Get(self.handle)
	@rfq.setter
	def rfq(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_RFQ_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_RFQ_Set(self.handle, value)
	@property
	def build_to_print(self):
		return _extractor.extractor_BuyerDetails_BuildToPrint_Get(self.handle)
	@build_to_print.setter
	def build_to_print(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_BuildToPrint_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_BuildToPrint_Set(self.handle, value)
	@property
	def manufactured_to_specification(self):
		return _extractor.extractor_BuyerDetails_ManufacturedToSpecification_Get(self.handle)
	@manufactured_to_specification.setter
	def manufactured_to_specification(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_ManufacturedToSpecification_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_ManufacturedToSpecification_Set(self.handle, value)
	@property
	def original_equipment_manufacturer(self):
		return _extractor.extractor_BuyerDetails_OriginalEquipmentManufacturer_Get(self.handle)
	@original_equipment_manufacturer.setter
	def original_equipment_manufacturer(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_OriginalEquipmentManufacturer_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_OriginalEquipmentManufacturer_Set(self.handle, value)
	@property
	def modified(self):
		return _extractor.extractor_BuyerDetails_Modified_Get(self.handle)
	@modified.setter
	def modified(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_Modified_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_Modified_Set(self.handle, value)
	def get_sheet_name(self):
		"""GetSheetName() str
		
		Add methods to both structs to implement SheetNameGetter
		"""
		return _extractor.extractor_BuyerDetails_GetSheetName(self.handle)

# Python type for struct extractor.ClassificationCriteria
class ClassificationCriteria(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ClassificationCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.Label = args[0]
			if "Label" in kwargs:
				self.Label = kwargs["Label"]
			if  1 < len(args):
				self.SearchTerms = args[1]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
			if  2 < len(args):
				self.Offset = args[2]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ClassificationCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ClassificationCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def label(self):
		return _extractor.extractor_ClassificationCriteria_Label_Get(self.handle)
	@label.setter
	def label(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ClassificationCriteria_Label_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ClassificationCriteria_Label_Set(self.handle, value)
	@property
	def search_terms(self):
		return go.Slice_string(handle=_extractor.extractor_ClassificationCriteria_SearchTerms_Get(self.handle))
	@search_terms.setter
	def search_terms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ClassificationCriteria_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def offset(self):
		return _extractor.extractor_ClassificationCriteria_Offset_Get(self.handle)
	@offset.setter
	def offset(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ClassificationCriteria_Offset_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ClassificationCriteria_Offset_Set(self.handle, value)

# Python type for struct extractor.SECCFExtraction
class SECCFExtraction(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SECCFExtraction_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.BuyerDetails = args[0]
			if "BuyerDetails" in kwargs:
				self.BuyerDetails = kwargs["BuyerDetails"]
			if  1 < len(args):
				self.ProductDetails = args[1]
			if "ProductDetails" in kwargs:
				self.ProductDetails = kwargs["ProductDetails"]
			if  2 < len(args):
				self.ControlledContent = args[2]
			if "ControlledContent" in kwargs:
				self.ControlledContent = kwargs["ControlledContent"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SECCFExtraction{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SECCFExtraction ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def buyer_details(self):
		return BuyerDetails(handle=_extractor.extractor_SECCFExtraction_BuyerDetails_Get(self.handle))
	@buyer_details.setter
	def buyer_details(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SECCFExtraction_BuyerDetails_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def product_details(self):
		return ProductDetails(handle=_extractor.extractor_SECCFExtraction_ProductDetails_Get(self.handle))
	@product_details.setter
	def product_details(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SECCFExtraction_ProductDetails_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def controlled_content(self):
		return Slice_extractor_ControlCotent(handle=_extractor.extractor_SECCFExtraction_ControlledContent_Get(self.handle))
	@controlled_content.setter
	def controlled_content(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SECCFExtraction_ControlledContent_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.TriClassificationCritera
class TriClassificationCritera(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_TriClassificationCritera_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.TYPE_1 = args[0]
			if "TYPE_1" in kwargs:
				self.TYPE_1 = kwargs["TYPE_1"]
			if  1 < len(args):
				self.TYPE_2 = args[1]
			if "TYPE_2" in kwargs:
				self.TYPE_2 = kwargs["TYPE_2"]
			if  2 < len(args):
				self.TYPE_3 = args[2]
			if "TYPE_3" in kwargs:
				self.TYPE_3 = kwargs["TYPE_3"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriClassificationCritera{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriClassificationCritera ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def type_1(self):
		return ClassificationCriteria(handle=_extractor.extractor_TriClassificationCritera_TYPE_1_Get(self.handle))
	@type_1.setter
	def type_1(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_TriClassificationCritera_TYPE_1_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def type_2(self):
		return ClassificationCriteria(handle=_extractor.extractor_TriClassificationCritera_TYPE_2_Get(self.handle))
	@type_2.setter
	def type_2(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_TriClassificationCritera_TYPE_2_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def type_3(self):
		return ClassificationCriteria(handle=_extractor.extractor_TriClassificationCritera_TYPE_3_Get(self.handle))
	@type_3.setter
	def type_3(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_TriClassificationCritera_TYPE_3_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.TriColumnClfExtractor
class TriColumnClfExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_TriColumnClfExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriColumnClfExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriColumnClfExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.BoolClassificationCriteria
class BoolClassificationCriteria(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_BoolClassificationCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.Offset = args[0]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
			if  1 < len(args):
				self.SearchTerms = args[1]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolClassificationCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolClassificationCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def offset(self):
		return _extractor.extractor_BoolClassificationCriteria_Offset_Get(self.handle)
	@offset.setter
	def offset(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BoolClassificationCriteria_Offset_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BoolClassificationCriteria_Offset_Set(self.handle, value)
	@property
	def search_terms(self):
		return go.Slice_string(handle=_extractor.extractor_BoolClassificationCriteria_SearchTerms_Get(self.handle))
	@search_terms.setter
	def search_terms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BoolClassificationCriteria_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.BoolContainsImageExtractor
class BoolContainsImageExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_BoolContainsImageExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolContainsImageExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolContainsImageExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.ColumnMapping
class ColumnMapping(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ColumnMapping_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.FieldName = args[0]
			if "FieldName" in kwargs:
				self.FieldName = kwargs["FieldName"]
			if  1 < len(args):
				self.SearchTerms = args[1]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
			if  2 < len(args):
				self.FoundColumn = args[2]
			if "FoundColumn" in kwargs:
				self.FoundColumn = kwargs["FoundColumn"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ColumnMapping{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ColumnMapping ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def field_name(self):
		return _extractor.extractor_ColumnMapping_FieldName_Get(self.handle)
	@field_name.setter
	def field_name(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ColumnMapping_FieldName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ColumnMapping_FieldName_Set(self.handle, value)
	@property
	def search_terms(self):
		return go.Slice_string(handle=_extractor.extractor_ColumnMapping_SearchTerms_Get(self.handle))
	@search_terms.setter
	def search_terms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ColumnMapping_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def found_column(self):
		return _extractor.extractor_ColumnMapping_FoundColumn_Get(self.handle)
	@found_column.setter
	def found_column(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ColumnMapping_FoundColumn_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ColumnMapping_FoundColumn_Set(self.handle, value)

# Python type for struct extractor.DivideByZeroError
class DivideByZeroError(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_DivideByZeroError_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DivideByZeroError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DivideByZeroError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.DualColumnClfExtractor
class DualColumnClfExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_DualColumnClfExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualColumnClfExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualColumnClfExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.SimpleValueExtractor
class SimpleValueExtractor(go.GoClass):
	"""Implement different extractors for different types of fields\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SimpleValueExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SimpleValueExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SimpleValueExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.CellRange
class CellRange(go.GoClass):
	"""CellRange represents an Excel cell range\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_CellRange_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.StartCell = args[0]
			if "StartCell" in kwargs:
				self.StartCell = kwargs["StartCell"]
			if  1 < len(args):
				self.EndCell = args[1]
			if "EndCell" in kwargs:
				self.EndCell = kwargs["EndCell"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.CellRange{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.CellRange ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def start_cell(self):
		return _extractor.extractor_CellRange_StartCell_Get(self.handle)
	@start_cell.setter
	def start_cell(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_CellRange_StartCell_Set(self.handle, value.handle)
		else:
			_extractor.extractor_CellRange_StartCell_Set(self.handle, value)
	@property
	def end_cell(self):
		return _extractor.extractor_CellRange_EndCell_Get(self.handle)
	@end_cell.setter
	def end_cell(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_CellRange_EndCell_Set(self.handle, value.handle)
		else:
			_extractor.extractor_CellRange_EndCell_Set(self.handle, value)

# Python type for struct extractor.ControlCotent
class ControlCotent(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ControlCotent_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SheetName = args[0]
			if "SheetName" in kwargs:
				self.SheetName = kwargs["SheetName"]
			if  1 < len(args):
				self.ItemNum = args[1]
			if "ItemNum" in kwargs:
				self.ItemNum = kwargs["ItemNum"]
			if  2 < len(args):
				self.PartNumber = args[2]
			if "PartNumber" in kwargs:
				self.PartNumber = kwargs["PartNumber"]
			if  3 < len(args):
				self.ComponentManufacturerPartNumber = args[3]
			if "ComponentManufacturerPartNumber" in kwargs:
				self.ComponentManufacturerPartNumber = kwargs["ComponentManufacturerPartNumber"]
			if  4 < len(args):
				self.PartDescription = args[4]
			if "PartDescription" in kwargs:
				self.PartDescription = kwargs["PartDescription"]
			if  5 < len(args):
				self.ManufacturerOfComponent = args[5]
			if "ManufacturerOfComponent" in kwargs:
				self.ManufacturerOfComponent = kwargs["ManufacturerOfComponent"]
			if  6 < len(args):
				self.ExportRegulationCountry = args[6]
			if "ExportRegulationCountry" in kwargs:
				self.ExportRegulationCountry = kwargs["ExportRegulationCountry"]
			if  7 < len(args):
				self.DualControlListClfNum = args[7]
			if "DualControlListClfNum" in kwargs:
				self.DualControlListClfNum = kwargs["DualControlListClfNum"]
			if  8 < len(args):
				self.MilitaryControlListClfNum = args[8]
			if "MilitaryControlListClfNum" in kwargs:
				self.MilitaryControlListClfNum = kwargs["MilitaryControlListClfNum"]
			if  9 < len(args):
				self.IndicateLicenseApplication = args[9]
			if "IndicateLicenseApplication" in kwargs:
				self.IndicateLicenseApplication = kwargs["IndicateLicenseApplication"]
			if  10 < len(args):
				self.TopLevelDeliverableItem = args[10]
			if "TopLevelDeliverableItem" in kwargs:
				self.TopLevelDeliverableItem = kwargs["TopLevelDeliverableItem"]
			if  11 < len(args):
				self.USML_N = args[11]
			if "USML_N" in kwargs:
				self.USML_N = kwargs["USML_N"]
			if  12 < len(args):
				self.ECCN_N = args[12]
			if "ECCN_N" in kwargs:
				self.ECCN_N = kwargs["ECCN_N"]
			if  13 < len(args):
				self.US_EA_CONTENT_RATIO = args[13]
			if "US_EA_CONTENT_RATIO" in kwargs:
				self.US_EA_CONTENT_RATIO = kwargs["US_EA_CONTENT_RATIO"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ControlCotent{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ControlCotent ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def sheet_name(self):
		return _extractor.extractor_ControlCotent_SheetName_Get(self.handle)
	@sheet_name.setter
	def sheet_name(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_SheetName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_SheetName_Set(self.handle, value)
	@property
	def item_num(self):
		return _extractor.extractor_ControlCotent_ItemNum_Get(self.handle)
	@item_num.setter
	def item_num(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ItemNum_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ItemNum_Set(self.handle, value)
	@property
	def part_number(self):
		return _extractor.extractor_ControlCotent_PartNumber_Get(self.handle)
	@part_number.setter
	def part_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_PartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_PartNumber_Set(self.handle, value)
	@property
	def component_manufacturer_part_number(self):
		return _extractor.extractor_ControlCotent_ComponentManufacturerPartNumber_Get(self.handle)
	@component_manufacturer_part_number.setter
	def component_manufacturer_part_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ComponentManufacturerPartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ComponentManufacturerPartNumber_Set(self.handle, value)
	@property
	def part_description(self):
		return _extractor.extractor_ControlCotent_PartDescription_Get(self.handle)
	@part_description.setter
	def part_description(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_PartDescription_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_PartDescription_Set(self.handle, value)
	@property
	def manufacturer_of_component(self):
		return _extractor.extractor_ControlCotent_ManufacturerOfComponent_Get(self.handle)
	@manufacturer_of_component.setter
	def manufacturer_of_component(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ManufacturerOfComponent_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ManufacturerOfComponent_Set(self.handle, value)
	@property
	def export_regulation_country(self):
		return _extractor.extractor_ControlCotent_ExportRegulationCountry_Get(self.handle)
	@export_regulation_country.setter
	def export_regulation_country(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ExportRegulationCountry_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ExportRegulationCountry_Set(self.handle, value)
	@property
	def dual_control_list_clf_num(self):
		return _extractor.extractor_ControlCotent_DualControlListClfNum_Get(self.handle)
	@dual_control_list_clf_num.setter
	def dual_control_list_clf_num(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_DualControlListClfNum_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_DualControlListClfNum_Set(self.handle, value)
	@property
	def military_control_list_clf_num(self):
		return _extractor.extractor_ControlCotent_MilitaryControlListClfNum_Get(self.handle)
	@military_control_list_clf_num.setter
	def military_control_list_clf_num(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_MilitaryControlListClfNum_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_MilitaryControlListClfNum_Set(self.handle, value)
	@property
	def indicate_license_application(self):
		return _extractor.extractor_ControlCotent_IndicateLicenseApplication_Get(self.handle)
	@indicate_license_application.setter
	def indicate_license_application(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_IndicateLicenseApplication_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_IndicateLicenseApplication_Set(self.handle, value)
	@property
	def top_level_deliverable_item(self):
		return _extractor.extractor_ControlCotent_TopLevelDeliverableItem_Get(self.handle)
	@top_level_deliverable_item.setter
	def top_level_deliverable_item(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_TopLevelDeliverableItem_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_TopLevelDeliverableItem_Set(self.handle, value)
	@property
	def usml_n(self):
		return _extractor.extractor_ControlCotent_USML_N_Get(self.handle)
	@usml_n.setter
	def usml_n(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_USML_N_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_USML_N_Set(self.handle, value)
	@property
	def eccn_n(self):
		return _extractor.extractor_ControlCotent_ECCN_N_Get(self.handle)
	@eccn_n.setter
	def eccn_n(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ECCN_N_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ECCN_N_Set(self.handle, value)
	@property
	def us_ea_content_ratio(self):
		return _extractor.extractor_ControlCotent_US_EA_CONTENT_RATIO_Get(self.handle)
	@us_ea_content_ratio.setter
	def us_ea_content_ratio(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_US_EA_CONTENT_RATIO_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_US_EA_CONTENT_RATIO_Set(self.handle, value)

# Python type for struct extractor.ProductDetails
class ProductDetails(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ProductDetails_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SheetName = args[0]
			if "SheetName" in kwargs:
				self.SheetName = kwargs["SheetName"]
			if  1 < len(args):
				self.SupplierPartNumber = args[1]
			if "SupplierPartNumber" in kwargs:
				self.SupplierPartNumber = kwargs["SupplierPartNumber"]
			if  2 < len(args):
				self.SupplierCompanyName = args[2]
			if "SupplierCompanyName" in kwargs:
				self.SupplierCompanyName = kwargs["SupplierCompanyName"]
			if  3 < len(args):
				self.SupplierFullAddress = args[3]
			if "SupplierFullAddress" in kwargs:
				self.SupplierFullAddress = kwargs["SupplierFullAddress"]
			if  4 < len(args):
				self.SupplierCountry = args[4]
			if "SupplierCountry" in kwargs:
				self.SupplierCountry = kwargs["SupplierCountry"]
			if  5 < len(args):
				self.SupplierCompanyNumber = args[5]
			if "SupplierCompanyNumber" in kwargs:
				self.SupplierCompanyNumber = kwargs["SupplierCompanyNumber"]
			if  6 < len(args):
				self.ManufacturerPartNumber = args[6]
			if "ManufacturerPartNumber" in kwargs:
				self.ManufacturerPartNumber = kwargs["ManufacturerPartNumber"]
			if  7 < len(args):
				self.ManufacturerCompanyName = args[7]
			if "ManufacturerCompanyName" in kwargs:
				self.ManufacturerCompanyName = kwargs["ManufacturerCompanyName"]
			if  8 < len(args):
				self.ManufacturerFullAddress = args[8]
			if "ManufacturerFullAddress" in kwargs:
				self.ManufacturerFullAddress = kwargs["ManufacturerFullAddress"]
			if  9 < len(args):
				self.ManufacturerCountry = args[9]
			if "ManufacturerCountry" in kwargs:
				self.ManufacturerCountry = kwargs["ManufacturerCountry"]
			if  10 < len(args):
				self.ManufacturerCompanyNumber = args[10]
			if "ManufacturerCompanyNumber" in kwargs:
				self.ManufacturerCompanyNumber = kwargs["ManufacturerCompanyNumber"]
			if  11 < len(args):
				self.CountryOfOrigin = args[11]
			if "CountryOfOrigin" in kwargs:
				self.CountryOfOrigin = kwargs["CountryOfOrigin"]
			if  12 < len(args):
				self.CustomsTariffCode = args[12]
			if "CustomsTariffCode" in kwargs:
				self.CustomsTariffCode = kwargs["CustomsTariffCode"]
			if  13 < len(args):
				self.ExportControlRegulated = args[13]
			if "ExportControlRegulated" in kwargs:
				self.ExportControlRegulated = kwargs["ExportControlRegulated"]
			if  14 < len(args):
				self.PartClassification = args[14]
			if "PartClassification" in kwargs:
				self.PartClassification = kwargs["PartClassification"]
			if  15 < len(args):
				self.ControlListClassificationNumber = args[15]
			if "ControlListClassificationNumber" in kwargs:
				self.ControlListClassificationNumber = kwargs["ControlListClassificationNumber"]
			if  16 < len(args):
				self.ThirdCountryControlledContent = args[16]
			if "ThirdCountryControlledContent" in kwargs:
				self.ThirdCountryControlledContent = kwargs["ThirdCountryControlledContent"]
			if  17 < len(args):
				self.EndUserStatementRequired = args[17]
			if "EndUserStatementRequired" in kwargs:
				self.EndUserStatementRequired = kwargs["EndUserStatementRequired"]
			if  18 < len(args):
				self.ExportLicenceShipmentRequired = args[18]
			if "ExportLicenceShipmentRequired" in kwargs:
				self.ExportLicenceShipmentRequired = kwargs["ExportLicenceShipmentRequired"]
			if  19 < len(args):
				self.ExportLicenceEndUserRequired = args[19]
			if "ExportLicenceEndUserRequired" in kwargs:
				self.ExportLicenceEndUserRequired = kwargs["ExportLicenceEndUserRequired"]
			if  20 < len(args):
				self.AdditionalExportDocsRequired = args[20]
			if "AdditionalExportDocsRequired" in kwargs:
				self.AdditionalExportDocsRequired = kwargs["AdditionalExportDocsRequired"]
			if  21 < len(args):
				self.TransferReexportConditions = args[21]
			if "TransferReexportConditions" in kwargs:
				self.TransferReexportConditions = kwargs["TransferReexportConditions"]
			if  22 < len(args):
				self.RepresentativeName = args[22]
			if "RepresentativeName" in kwargs:
				self.RepresentativeName = kwargs["RepresentativeName"]
			if  23 < len(args):
				self.RepresentativePosition = args[23]
			if "RepresentativePosition" in kwargs:
				self.RepresentativePosition = kwargs["RepresentativePosition"]
			if  24 < len(args):
				self.RepresentativeSignature = args[24]
			if "RepresentativeSignature" in kwargs:
				self.RepresentativeSignature = kwargs["RepresentativeSignature"]
			if  25 < len(args):
				self.SupplierCompanySeal = args[25]
			if "SupplierCompanySeal" in kwargs:
				self.SupplierCompanySeal = kwargs["SupplierCompanySeal"]
			if  26 < len(args):
				self.SignatureDate = args[26]
			if "SignatureDate" in kwargs:
				self.SignatureDate = kwargs["SignatureDate"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ProductDetails{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ProductDetails ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def sheet_name(self):
		"""Sheet Metadata
		"""
		return _extractor.extractor_ProductDetails_SheetName_Get(self.handle)
	@sheet_name.setter
	def sheet_name(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SheetName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SheetName_Set(self.handle, value)
	@property
	def supplier_part_number(self):
		"""Supplier Details
		"""
		return _extractor.extractor_ProductDetails_SupplierPartNumber_Get(self.handle)
	@supplier_part_number.setter
	def supplier_part_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierPartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierPartNumber_Set(self.handle, value)
	@property
	def supplier_company_name(self):
		return _extractor.extractor_ProductDetails_SupplierCompanyName_Get(self.handle)
	@supplier_company_name.setter
	def supplier_company_name(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCompanyName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCompanyName_Set(self.handle, value)
	@property
	def supplier_full_address(self):
		return _extractor.extractor_ProductDetails_SupplierFullAddress_Get(self.handle)
	@supplier_full_address.setter
	def supplier_full_address(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierFullAddress_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierFullAddress_Set(self.handle, value)
	@property
	def supplier_country(self):
		return _extractor.extractor_ProductDetails_SupplierCountry_Get(self.handle)
	@supplier_country.setter
	def supplier_country(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCountry_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCountry_Set(self.handle, value)
	@property
	def supplier_company_number(self):
		return _extractor.extractor_ProductDetails_SupplierCompanyNumber_Get(self.handle)
	@supplier_company_number.setter
	def supplier_company_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCompanyNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCompanyNumber_Set(self.handle, value)
	@property
	def manufacturer_part_number(self):
		"""Manufacturer Details
		"""
		return _extractor.extractor_ProductDetails_ManufacturerPartNumber_Get(self.handle)
	@manufacturer_part_number.setter
	def manufacturer_part_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerPartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerPartNumber_Set(self.handle, value)
	@property
	def manufacturer_company_name(self):
		return _extractor.extractor_ProductDetails_ManufacturerCompanyName_Get(self.handle)
	@manufacturer_company_name.setter
	def manufacturer_company_name(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerCompanyName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerCompanyName_Set(self.handle, value)
	@property
	def manufacturer_full_address(self):
		return _extractor.extractor_ProductDetails_ManufacturerFullAddress_Get(self.handle)
	@manufacturer_full_address.setter
	def manufacturer_full_address(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerFullAddress_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerFullAddress_Set(self.handle, value)
	@property
	def manufacturer_country(self):
		return _extractor.extractor_ProductDetails_ManufacturerCountry_Get(self.handle)
	@manufacturer_country.setter
	def manufacturer_country(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerCountry_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerCountry_Set(self.handle, value)
	@property
	def manufacturer_company_number(self):
		return _extractor.extractor_ProductDetails_ManufacturerCompanyNumber_Get(self.handle)
	@manufacturer_company_number.setter
	def manufacturer_company_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerCompanyNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerCompanyNumber_Set(self.handle, value)
	@property
	def country_of_origin(self):
		"""Product Details
		"""
		return _extractor.extractor_ProductDetails_CountryOfOrigin_Get(self.handle)
	@country_of_origin.setter
	def country_of_origin(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_CountryOfOrigin_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_CountryOfOrigin_Set(self.handle, value)
	@property
	def customs_tariff_code(self):
		return _extractor.extractor_ProductDetails_CustomsTariffCode_Get(self.handle)
	@customs_tariff_code.setter
	def customs_tariff_code(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_CustomsTariffCode_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_CustomsTariffCode_Set(self.handle, value)
	@property
	def export_control_regulated(self):
		return _extractor.extractor_ProductDetails_ExportControlRegulated_Get(self.handle)
	@export_control_regulated.setter
	def export_control_regulated(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ExportControlRegulated_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ExportControlRegulated_Set(self.handle, value)
	@property
	def part_classification(self):
		return _extractor.extractor_ProductDetails_PartClassification_Get(self.handle)
	@part_classification.setter
	def part_classification(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_PartClassification_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_PartClassification_Set(self.handle, value)
	@property
	def control_list_classification_number(self):
		return _extractor.extractor_ProductDetails_ControlListClassificationNumber_Get(self.handle)
	@control_list_classification_number.setter
	def control_list_classification_number(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ControlListClassificationNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ControlListClassificationNumber_Set(self.handle, value)
	@property
	def third_country_controlled_content(self):
		return _extractor.extractor_ProductDetails_ThirdCountryControlledContent_Get(self.handle)
	@third_country_controlled_content.setter
	def third_country_controlled_content(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ThirdCountryControlledContent_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ThirdCountryControlledContent_Set(self.handle, value)
	@property
	def end_user_statement_required(self):
		return _extractor.extractor_ProductDetails_EndUserStatementRequired_Get(self.handle)
	@end_user_statement_required.setter
	def end_user_statement_required(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_EndUserStatementRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_EndUserStatementRequired_Set(self.handle, value)
	@property
	def export_licence_shipment_required(self):
		return _extractor.extractor_ProductDetails_ExportLicenceShipmentRequired_Get(self.handle)
	@export_licence_shipment_required.setter
	def export_licence_shipment_required(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ExportLicenceShipmentRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ExportLicenceShipmentRequired_Set(self.handle, value)
	@property
	def export_licence_end_user_required(self):
		return _extractor.extractor_ProductDetails_ExportLicenceEndUserRequired_Get(self.handle)
	@export_licence_end_user_required.setter
	def export_licence_end_user_required(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ExportLicenceEndUserRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ExportLicenceEndUserRequired_Set(self.handle, value)
	@property
	def additional_export_docs_required(self):
		return _extractor.extractor_ProductDetails_AdditionalExportDocsRequired_Get(self.handle)
	@additional_export_docs_required.setter
	def additional_export_docs_required(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_AdditionalExportDocsRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_AdditionalExportDocsRequired_Set(self.handle, value)
	@property
	def transfer_reexport_conditions(self):
		"""Mandatory
		"""
		return _extractor.extractor_ProductDetails_TransferReexportConditions_Get(self.handle)
	@transfer_reexport_conditions.setter
	def transfer_reexport_conditions(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_TransferReexportConditions_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_TransferReexportConditions_Set(self.handle, value)
	@property
	def representative_name(self):
		"""Supplier Representative
		"""
		return _extractor.extractor_ProductDetails_RepresentativeName_Get(self.handle)
	@representative_name.setter
	def representative_name(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_RepresentativeName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_RepresentativeName_Set(self.handle, value)
	@property
	def representative_position(self):
		return _extractor.extractor_ProductDetails_RepresentativePosition_Get(self.handle)
	@representative_position.setter
	def representative_position(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_RepresentativePosition_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_RepresentativePosition_Set(self.handle, value)
	@property
	def representative_signature(self):
		return _extractor.extractor_ProductDetails_RepresentativeSignature_Get(self.handle)
	@representative_signature.setter
	def representative_signature(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_RepresentativeSignature_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_RepresentativeSignature_Set(self.handle, value)
	@property
	def supplier_company_seal(self):
		return _extractor.extractor_ProductDetails_SupplierCompanySeal_Get(self.handle)
	@supplier_company_seal.setter
	def supplier_company_seal(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCompanySeal_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCompanySeal_Set(self.handle, value)
	@property
	def signature_date(self):
		return _extractor.extractor_ProductDetails_SignatureDate_Get(self.handle)
	@signature_date.setter
	def signature_date(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SignatureDate_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SignatureDate_Set(self.handle, value)
	def get_sheet_name(self):
		"""GetSheetName() str"""
		return _extractor.extractor_ProductDetails_GetSheetName(self.handle)

# Python type for struct extractor.Response
class Response(go.GoClass):
	"""Response struct for structured output\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_Response_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.Status = args[0]
			if "Status" in kwargs:
				self.Status = kwargs["Status"]
			if  1 < len(args):
				self.Message = args[1]
			if "Message" in kwargs:
				self.Message = kwargs["Message"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.Response{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.Response ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def status(self):
		return _extractor.extractor_Response_Status_Get(self.handle)
	@status.setter
	def status(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_Response_Status_Set(self.handle, value.handle)
		else:
			_extractor.extractor_Response_Status_Set(self.handle, value)
	@property
	def message(self):
		return _extractor.extractor_Response_Message_Get(self.handle)
	@message.setter
	def message(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_Response_Message_Set(self.handle, value.handle)
		else:
			_extractor.extractor_Response_Message_Set(self.handle, value)
	@property
	def data(self):
		return any(handle=_extractor.extractor_Response_Data_Get(self.handle))
	@data.setter
	def data(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_Response_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.SheetNotFoundError
class SheetNotFoundError(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SheetNotFoundError_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SheetNotFoundError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SheetNotFoundError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def error(self):
		"""Error() str"""
		return _extractor.extractor_SheetNotFoundError_Error(self.handle)

# Python type for struct extractor.BoolCheckBoxExtractor
class BoolCheckBoxExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_BoolCheckBoxExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolCheckBoxExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolCheckBoxExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.DualClassificationCriteria
class DualClassificationCriteria(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_DualClassificationCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.TYPE_1 = args[0]
			if "TYPE_1" in kwargs:
				self.TYPE_1 = kwargs["TYPE_1"]
			if  1 < len(args):
				self.TYPE_2 = args[1]
			if "TYPE_2" in kwargs:
				self.TYPE_2 = kwargs["TYPE_2"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualClassificationCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualClassificationCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def type_1(self):
		return ClassificationCriteria(handle=_extractor.extractor_DualClassificationCriteria_TYPE_1_Get(self.handle))
	@type_1.setter
	def type_1(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_DualClassificationCriteria_TYPE_1_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def type_2(self):
		return ClassificationCriteria(handle=_extractor.extractor_DualClassificationCriteria_TYPE_2_Get(self.handle))
	@type_2.setter
	def type_2(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_DualClassificationCriteria_TYPE_2_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.ExcelExtractor
class ExcelExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ExcelExtractor_CTor()
			_extractor.IncRef(self.handle)
			if  2 < len(args):
				self.Extraction = args[2]
			if "Extraction" in kwargs:
				self.Extraction = kwargs["Extraction"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ExcelExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ExcelExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def extraction(self):
		return SECCFExtraction(handle=_extractor.extractor_ExcelExtractor_Extraction_Get(self.handle))
	@extraction.setter
	def extraction(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ExcelExtractor_Extraction_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def replace_company_names(self, items):
		"""ReplaceCompanyNames([]str items) []str"""
		return go.Slice_string(handle=_extractor.extractor_ExcelExtractor_ReplaceCompanyNames(self.handle, items.handle))
	def get_cell_value(self, cellRange, sheetName):
		"""GetCellValue(object cellRange, str sheetName) str, str"""
		return _extractor.extractor_ExcelExtractor_GetCellValue(self.handle, cellRange.handle, sheetName)
	def to_json(self):
		"""ToJson() str"""
		return _extractor.extractor_ExcelExtractor_ToJson(self.handle)
	def read_form_controls(self, goRun=False):
		"""ReadFormControls() """
		_extractor.extractor_ExcelExtractor_ReadFormControls(self.handle, goRun)
	def extract(self):
		"""Extract() object"""
		return SECCFExtraction(handle=_extractor.extractor_ExcelExtractor_Extract(self.handle))
	def close(self):
		"""Close() str"""
		return _extractor.extractor_ExcelExtractor_Close(self.handle)

# Python type for struct extractor.SearchCriteria
class SearchCriteria(go.GoClass):
	"""SearchCriteria defines what to look for and where\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SearchCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SearchTerms = args[0]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
			if  1 < len(args):
				self.CellRanges = args[1]
			if "CellRanges" in kwargs:
				self.CellRanges = kwargs["CellRanges"]
			if  2 < len(args):
				self.DualColumnCheckBoxClf = args[2]
			if "DualColumnCheckBoxClf" in kwargs:
				self.DualColumnCheckBoxClf = kwargs["DualColumnCheckBoxClf"]
			if  3 < len(args):
				self.DualColumnClfCriteria = args[3]
			if "DualColumnClfCriteria" in kwargs:
				self.DualColumnClfCriteria = kwargs["DualColumnClfCriteria"]
			if  4 < len(args):
				self.TriColumnCheckBoxClf = args[4]
			if "TriColumnCheckBoxClf" in kwargs:
				self.TriColumnCheckBoxClf = kwargs["TriColumnCheckBoxClf"]
			if  5 < len(args):
				self.TriColumnClfCriteria = args[5]
			if "TriColumnClfCriteria" in kwargs:
				self.TriColumnClfCriteria = kwargs["TriColumnClfCriteria"]
			if  6 < len(args):
				self.BoolCheckBox = args[6]
			if "BoolCheckBox" in kwargs:
				self.BoolCheckBox = kwargs["BoolCheckBox"]
			if  7 < len(args):
				self.BoolClfCriteria = args[7]
			if "BoolClfCriteria" in kwargs:
				self.BoolClfCriteria = kwargs["BoolClfCriteria"]
			if  8 < len(args):
				self.BoolContainsImage = args[8]
			if "BoolContainsImage" in kwargs:
				self.BoolContainsImage = kwargs["BoolContainsImage"]
			if  9 < len(args):
				self.BoolClfContainsImage = args[9]
			if "BoolClfContainsImage" in kwargs:
				self.BoolClfContainsImage = kwargs["BoolClfContainsImage"]
			if  10 < len(args):
				self.Offset = args[10]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SearchCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SearchCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def search_terms(self):
		return go.Slice_string(handle=_extractor.extractor_SearchCriteria_SearchTerms_Get(self.handle))
	@search_terms.setter
	def search_terms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def cell_ranges(self):
		return Slice_extractor_CellRange(handle=_extractor.extractor_SearchCriteria_CellRanges_Get(self.handle))
	@cell_ranges.setter
	def cell_ranges(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_CellRanges_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def dual_column_check_box_clf(self):
		return _extractor.extractor_SearchCriteria_DualColumnCheckBoxClf_Get(self.handle)
	@dual_column_check_box_clf.setter
	def dual_column_check_box_clf(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_DualColumnCheckBoxClf_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_DualColumnCheckBoxClf_Set(self.handle, value)
	@property
	def dual_column_clf_criteria(self):
		return DualClassificationCriteria(handle=_extractor.extractor_SearchCriteria_DualColumnClfCriteria_Get(self.handle))
	@dual_column_clf_criteria.setter
	def dual_column_clf_criteria(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_DualColumnClfCriteria_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def tri_column_check_box_clf(self):
		return _extractor.extractor_SearchCriteria_TriColumnCheckBoxClf_Get(self.handle)
	@tri_column_check_box_clf.setter
	def tri_column_check_box_clf(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_TriColumnCheckBoxClf_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_TriColumnCheckBoxClf_Set(self.handle, value)
	@property
	def tri_column_clf_criteria(self):
		return TriClassificationCritera(handle=_extractor.extractor_SearchCriteria_TriColumnClfCriteria_Get(self.handle))
	@tri_column_clf_criteria.setter
	def tri_column_clf_criteria(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_TriColumnClfCriteria_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def bool_check_box(self):
		return _extractor.extractor_SearchCriteria_BoolCheckBox_Get(self.handle)
	@bool_check_box.setter
	def bool_check_box(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_BoolCheckBox_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_BoolCheckBox_Set(self.handle, value)
	@property
	def bool_clf_criteria(self):
		return BoolClassificationCriteria(handle=_extractor.extractor_SearchCriteria_BoolClfCriteria_Get(self.handle))
	@bool_clf_criteria.setter
	def bool_clf_criteria(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_BoolClfCriteria_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def bool_contains_image(self):
		return _extractor.extractor_SearchCriteria_BoolContainsImage_Get(self.handle)
	@bool_contains_image.setter
	def bool_contains_image(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_BoolContainsImage_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_BoolContainsImage_Set(self.handle, value)
	@property
	def bool_clf_contains_image(self):
		return BoolClassificationCriteria(handle=_extractor.extractor_SearchCriteria_BoolClfContainsImage_Get(self.handle))
	@bool_clf_contains_image.setter
	def bool_clf_contains_image(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_BoolClfContainsImage_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def offset(self):
		return _extractor.extractor_SearchCriteria_Offset_Get(self.handle)
	@offset.setter
	def offset(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_Offset_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_Offset_Set(self.handle, value)


# ---- Slices ---

# Python type for slice extractor.CompanyNameList
class CompanyNameList(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_CompanyNameList_CTor()
			_extractor.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('extractor_CompanyNameList.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		s = 'extractor.extractor_CompanyNameList len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'extractor.extractor_CompanyNameList([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _extractor.extractor_CompanyNameList_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _extractor.extractor_CompanyNameList_len(self.handle)
				return CompanyNameList(handle=_extractor.extractor_CompanyNameList_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _extractor.extractor_CompanyNameList_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_extractor.extractor_CompanyNameList_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('extractor_CompanyNameList.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _extractor.extractor_CompanyNameList_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_extractor.extractor_CompanyNameList_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


# ---- Maps ---


# ---- Constructors ---
def make_seccf_extractor(filePath, companyNames):
	"""MakeSECCFExtractor(str filePath, []str companyNames) object, str"""
	return ExcelExtractor(handle=_extractor.extractor_MakeSECCFExtractor(filePath, companyNames.handle))


# ---- Functions ---


