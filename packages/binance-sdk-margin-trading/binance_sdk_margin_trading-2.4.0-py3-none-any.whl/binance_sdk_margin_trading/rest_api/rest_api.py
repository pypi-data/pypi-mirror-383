"""
Binance Margin Trading REST API

OpenAPI Specification for the Binance Margin Trading REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import requests
from typing import Optional, List, TypeVar, Union
from binance_common.configuration import ConfigurationRestAPI
from binance_common.models import ApiResponse
from binance_common.signature import Signers
from binance_common.utils import send_request
from .api.account_api import AccountApi
from .api.borrow_repay_api import BorrowRepayApi
from .api.market_data_api import MarketDataApi
from .api.risk_data_stream_api import RiskDataStreamApi
from .api.trade_api import TradeApi
from .api.trade_data_stream_api import TradeDataStreamApi
from .api.transfer_api import TransferApi

from .models import AdjustCrossMarginMaxLeverageResponse
from .models import DisableIsolatedMarginAccountResponse
from .models import EnableIsolatedMarginAccountResponse
from .models import GetBnbBurnStatusResponse
from .models import GetSummaryOfMarginAccountResponse
from .models import QueryCrossIsolatedMarginCapitalFlowResponse
from .models import QueryCrossMarginAccountDetailsResponse
from .models import QueryCrossMarginFeeDataResponse
from .models import QueryEnabledIsolatedMarginAccountLimitResponse
from .models import QueryIsolatedMarginAccountInfoResponse
from .models import QueryIsolatedMarginFeeDataResponse
from .models import GetFutureHourlyInterestRateResponse
from .models import GetInterestHistoryResponse
from .models import MarginAccountBorrowRepayResponse
from .models import QueryBorrowRepayRecordsInMarginAccountResponse
from .models import QueryMarginInterestRateHistoryResponse
from .models import QueryMaxBorrowResponse
from .models import CrossMarginCollateralRatioResponse
from .models import GetAllCrossMarginPairsResponse
from .models import GetAllIsolatedMarginSymbolResponse
from .models import GetAllMarginAssetsResponse
from .models import GetDelistScheduleResponse
from .models import GetLimitPricePairsResponse
from .models import GetListScheduleResponse
from .models import QueryIsolatedMarginTierDataResponse
from .models import QueryLiabilityCoinLeverageBracketInCrossMarginProModeResponse
from .models import QueryMarginAvailableInventoryResponse
from .models import QueryMarginPriceindexResponse


from .models import StartUserDataStreamResponse
from .models import CreateSpecialKeyResponse


from .models import GetForceLiquidationRecordResponse
from .models import GetSmallLiabilityExchangeCoinListResponse
from .models import GetSmallLiabilityExchangeHistoryResponse
from .models import MarginAccountCancelAllOpenOrdersOnASymbolResponse
from .models import MarginAccountCancelOcoResponse
from .models import MarginAccountCancelOrderResponse
from .models import MarginAccountNewOcoResponse
from .models import MarginAccountNewOrderResponse
from .models import MarginAccountNewOtoResponse
from .models import MarginAccountNewOtocoResponse
from .models import MarginManualLiquidationResponse
from .models import QueryCurrentMarginOrderCountUsageResponse
from .models import QueryMarginAccountsAllOcoResponse
from .models import QueryMarginAccountsAllOrdersResponse
from .models import QueryMarginAccountsOcoResponse
from .models import QueryMarginAccountsOpenOcoResponse
from .models import QueryMarginAccountsOpenOrdersResponse
from .models import QueryMarginAccountsOrderResponse
from .models import QueryMarginAccountsTradeListResponse
from .models import QuerySpecialKeyResponse
from .models import QuerySpecialKeyListResponse


from .models import StartIsolatedMarginUserDataStreamResponse
from .models import StartMarginUserDataStreamResponse
from .models import GetCrossMarginTransferHistoryResponse
from .models import QueryMaxTransferOutAmountResponse


from .models import MarginAccountNewOcoSideEnum
from .models import MarginAccountNewOcoNewOrderRespTypeEnum
from .models import MarginAccountNewOrderSideEnum
from .models import MarginAccountNewOrderNewOrderRespTypeEnum
from .models import MarginAccountNewOrderTimeInForceEnum
from .models import MarginAccountNewOtoNewOrderRespTypeEnum
from .models import MarginAccountNewOtocoNewOrderRespTypeEnum


T = TypeVar("T")


class MarginTradingRestAPI:
    def __init__(
        self,
        configuration: ConfigurationRestAPI,
    ) -> None:
        self.configuration = configuration
        self._session = requests.Session()
        self._signer = (
            Signers.get_signer(
                configuration.private_key, configuration.private_key_passphrase
            )
            if configuration.private_key is not None
            else None
        )

        self._accountApi = AccountApi(self.configuration, self._session, self._signer)
        self._borrowRepayApi = BorrowRepayApi(
            self.configuration, self._session, self._signer
        )
        self._marketDataApi = MarketDataApi(
            self.configuration, self._session, self._signer
        )
        self._riskDataStreamApi = RiskDataStreamApi(
            self.configuration, self._session, self._signer
        )
        self._tradeApi = TradeApi(self.configuration, self._session, self._signer)
        self._tradeDataStreamApi = TradeDataStreamApi(
            self.configuration, self._session, self._signer
        )
        self._transferApi = TransferApi(self.configuration, self._session, self._signer)

    def send_request(
        self, endpoint: str, method: str, params: Optional[dict] = None
    ) -> ApiResponse[T]:
        """
        Sends an request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session, self.configuration, method, endpoint, params
        )

    def send_signed_request(
        self, endpoint: str, method: str, params: Optional[dict] = None
    ) -> ApiResponse[T]:
        """
        Sends a signed request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session,
            self.configuration,
            method,
            endpoint,
            params,
            is_signed=True,
            signer=self._signer,
        )

    def adjust_cross_margin_max_leverage(
        self,
        max_leverage: Union[int, None],
    ) -> ApiResponse[AdjustCrossMarginMaxLeverageResponse]:
        """
                Adjust cross margin max leverage (USER_DATA)

                Adjust cross margin max leverage

        * The margin level need higher than the initial risk ratio of adjusted leverage, the initial risk ratio of 3x is 1.5 , the initial risk ratio of 5x is 1.25;  The detail conditions on how to switch between Cross Margin Classic and Cross Margin Pro can refer to [the FAQ](https://www.binance.com/en/support/faq/how-to-activate-the-cross-margin-pro-mode-on-binance-e27786da05e743a694b8c625b3bc475d).

        Weight: 3000

                Args:
                    max_leverage (Union[int, None]): Can only adjust 3 , 5 or 10，Example: maxLeverage = 5 or 3 for Cross Margin Classic; maxLeverage=10 for Cross Margin Pro 10x leverage or 20x if compliance allows.

                Returns:
                    ApiResponse[AdjustCrossMarginMaxLeverageResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.adjust_cross_margin_max_leverage(max_leverage)

    def disable_isolated_margin_account(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[DisableIsolatedMarginAccountResponse]:
        """
                Disable Isolated Margin Account (TRADE)

                Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24
        hours.

        Weight: 300(UID)

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[DisableIsolatedMarginAccountResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.disable_isolated_margin_account(symbol, recv_window)

    def enable_isolated_margin_account(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[EnableIsolatedMarginAccountResponse]:
        """
                Enable Isolated Margin Account (TRADE)

                Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).

        Weight: 300(UID)

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[EnableIsolatedMarginAccountResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.enable_isolated_margin_account(symbol, recv_window)

    def get_bnb_burn_status(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetBnbBurnStatusResponse]:
        """
                Get BNB Burn Status (USER_DATA)

                Get BNB Burn Status

        Weight: 1(IP)

                Args:
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetBnbBurnStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_bnb_burn_status(recv_window)

    def get_summary_of_margin_account(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetSummaryOfMarginAccountResponse]:
        """
                Get Summary of Margin account (USER_DATA)

                Get personal margin level information

        Weight: 10(IP)

                Args:
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetSummaryOfMarginAccountResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_summary_of_margin_account(recv_window)

    def query_cross_isolated_margin_capital_flow(
        self,
        asset: Optional[str] = None,
        symbol: Optional[str] = None,
        type: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCrossIsolatedMarginCapitalFlowResponse]:
        """
                Query Cross Isolated Margin Capital Flow (USER_DATA)

                Query Cross Isolated Margin Capital Flow

        Weight: 100(IP)

                Args:
                    asset (Optional[str] = None):
                    symbol (Optional[str] = None): isolated margin pair
                    type (Optional[str] = None): Transfer Type: ROLL_IN, ROLL_OUT
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    from_id (Optional[int] = None): 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
                    limit (Optional[int] = None): Default Value: 500; Max Value: 1000
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryCrossIsolatedMarginCapitalFlowResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_cross_isolated_margin_capital_flow(
            asset, symbol, type, start_time, end_time, from_id, limit, recv_window
        )

    def query_cross_margin_account_details(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCrossMarginAccountDetailsResponse]:
        """
                Query Cross Margin Account Details (USER_DATA)

                Query Cross Margin Account Details

        Weight: 10(IP)

                Args:
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryCrossMarginAccountDetailsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_cross_margin_account_details(recv_window)

    def query_cross_margin_fee_data(
        self,
        vip_level: Optional[int] = None,
        coin: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCrossMarginFeeDataResponse]:
        """
                Query Cross Margin Fee Data (USER_DATA)

                Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee

        Weight: 1 when coin is specified;(IP)

                Args:
                    vip_level (Optional[int] = None): User's current specific margin data will be returned if vipLevel is omitted
                    coin (Optional[str] = None):
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryCrossMarginFeeDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_cross_margin_fee_data(
            vip_level, coin, recv_window
        )

    def query_enabled_isolated_margin_account_limit(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryEnabledIsolatedMarginAccountLimitResponse]:
        """
                Query Enabled Isolated Margin Account Limit (USER_DATA)

                Query enabled isolated margin account limit.

        Weight: 1(IP)

                Args:
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryEnabledIsolatedMarginAccountLimitResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_enabled_isolated_margin_account_limit(recv_window)

    def query_isolated_margin_account_info(
        self,
        symbols: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryIsolatedMarginAccountInfoResponse]:
        """
                Query Isolated Margin Account Info (USER_DATA)

                Query Isolated Margin Account Info

        * If "symbols" is not sent, all isolated assets will be returned.
        * If "symbols" is sent, only the isolated assets of the sent symbols will be returned.

        Weight: 10(IP)

                Args:
                    symbols (Optional[str] = None): Max 5 symbols can be sent; separated by ",". e.g. "BTCUSDT,BNBUSDT,ADAUSDT"
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryIsolatedMarginAccountInfoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_isolated_margin_account_info(symbols, recv_window)

    def query_isolated_margin_fee_data(
        self,
        vip_level: Optional[int] = None,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryIsolatedMarginFeeDataResponse]:
        """
                Query Isolated Margin Fee Data (USER_DATA)

                Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee

        Weight: 1 when a single is specified;(IP)

                Args:
                    vip_level (Optional[int] = None): User's current specific margin data will be returned if vipLevel is omitted
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryIsolatedMarginFeeDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_isolated_margin_fee_data(
            vip_level, symbol, recv_window
        )

    def get_future_hourly_interest_rate(
        self,
        assets: Union[str, None],
        is_isolated: Union[bool, None],
    ) -> ApiResponse[GetFutureHourlyInterestRateResponse]:
        """
                Get future hourly interest rate (USER_DATA)

                Get future hourly interest rate

        Weight: 100

                Args:
                    assets (Union[str, None]): List of assets, separated by commas, up to 20
                    is_isolated (Union[bool, None]): for isolated margin or not, "TRUE", "FALSE"

                Returns:
                    ApiResponse[GetFutureHourlyInterestRateResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._borrowRepayApi.get_future_hourly_interest_rate(assets, is_isolated)

    def get_interest_history(
        self,
        asset: Optional[str] = None,
        isolated_symbol: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetInterestHistoryResponse]:
        """
                Get Interest History (USER_DATA)

                Get Interest History

        * Response in descending order
        * If isolatedSymbol is not sent, crossed margin data will be returned
        * The max interval between `startTime` and `endTime` is 30 days.  It is a MUST to ensure data correctness.
        * If `startTime`and `endTime` not sent, return records of the last 7 days by default.
        * If `startTime` is sent and `endTime` is not sent, return records of [max(`startTime`, now-30d), now].
        * If `startTime` is not sent and `endTime` is sent, return records of [`endTime`-7, `endTime`]
        * `type` in response has 4 enums:
        * `PERIODIC` interest charged per hour
        * `ON_BORROW` first interest charged on borrow
        * `PERIODIC_CONVERTED` interest charged per hour converted into BNB
        * `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB
        * `PORTFOLIO` interest charged daily on the portfolio margin negative balance

        Weight: 1(IP)

                Args:
                    asset (Optional[str] = None):
                    isolated_symbol (Optional[str] = None): isolated symbol
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetInterestHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._borrowRepayApi.get_interest_history(
            asset, isolated_symbol, start_time, end_time, current, size, recv_window
        )

    def margin_account_borrow_repay(
        self,
        asset: Union[str, None],
        is_isolated: Union[str, None],
        symbol: Union[str, None],
        amount: Union[str, None],
        type: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountBorrowRepayResponse]:
        """
                Margin account borrow/repay(MARGIN)

                Margin account borrow/repay(MARGIN)

        Weight: 1500

                Args:
                    asset (Union[str, None]):
                    is_isolated (Union[str, None]): `TRUE` for Isolated Margin, `FALSE` for Cross Margin, Default `FALSE`
                    symbol (Union[str, None]):
                    amount (Union[str, None]):
                    type (Union[str, None]): `MARGIN`,`ISOLATED`
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[MarginAccountBorrowRepayResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._borrowRepayApi.margin_account_borrow_repay(
            asset, is_isolated, symbol, amount, type, recv_window
        )

    def query_borrow_repay_records_in_margin_account(
        self,
        type: Union[str, None],
        asset: Optional[str] = None,
        isolated_symbol: Optional[str] = None,
        tx_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryBorrowRepayRecordsInMarginAccountResponse]:
        """
                Query borrow/repay records in Margin account(USER_DATA)

                Query borrow/repay records in Margin account

        * `txId` or `startTime` must be sent. `txId` takes precedence.
        * If an asset is sent, data within 30 days before `endTime`; If an asset is not sent, data within 7 days before `endTime`
        * If neither `startTime` nor `endTime` is sent, the recent 7-day data will be returned.
        * `startTime` set as `endTime` - 7days by default, `endTime` set as current time by default

        Weight: 10(IP)

                Args:
                    type (Union[str, None]): `MARGIN`,`ISOLATED`
                    asset (Optional[str] = None):
                    isolated_symbol (Optional[str] = None): isolated symbol
                    tx_id (Optional[int] = None): `tranId` in `POST /sapi/v1/margin/loan`
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryBorrowRepayRecordsInMarginAccountResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._borrowRepayApi.query_borrow_repay_records_in_margin_account(
            type,
            asset,
            isolated_symbol,
            tx_id,
            start_time,
            end_time,
            current,
            size,
            recv_window,
        )

    def query_margin_interest_rate_history(
        self,
        asset: Union[str, None],
        vip_level: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginInterestRateHistoryResponse]:
        """
                Query Margin Interest Rate History (USER_DATA)

                Query Margin Interest Rate History

        Weight: 1(IP)

                Args:
                    asset (Union[str, None]):
                    vip_level (Optional[int] = None): User's current specific margin data will be returned if vipLevel is omitted
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginInterestRateHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._borrowRepayApi.query_margin_interest_rate_history(
            asset, vip_level, start_time, end_time, recv_window
        )

    def query_max_borrow(
        self,
        asset: Union[str, None],
        isolated_symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMaxBorrowResponse]:
        """
                Query Max Borrow (USER_DATA)

                Query Max Borrow

        * If isolatedSymbol is not sent, crossed margin data will be sent.
        * `borrowLimit` is also available from [https://www.binance.com/en/margin-fee](https://www.binance.com/en/margin-fee)

        Weight: 50(IP)

                Args:
                    asset (Union[str, None]):
                    isolated_symbol (Optional[str] = None): isolated symbol
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMaxBorrowResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._borrowRepayApi.query_max_borrow(
            asset, isolated_symbol, recv_window
        )

    def cross_margin_collateral_ratio(
        self,
    ) -> ApiResponse[CrossMarginCollateralRatioResponse]:
        """
                Cross margin collateral ratio (MARKET_DATA)

                Cross margin collateral ratio

        Weight: 100(IP)

                Args:

                Returns:
                    ApiResponse[CrossMarginCollateralRatioResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.cross_margin_collateral_ratio()

    def get_all_cross_margin_pairs(
        self,
        symbol: Optional[str] = None,
    ) -> ApiResponse[GetAllCrossMarginPairsResponse]:
        """
                Get All Cross Margin Pairs (MARKET_DATA)

                Get All Cross Margin Pairs

        Weight: 1(IP)

                Args:
                    symbol (Optional[str] = None): isolated margin pair

                Returns:
                    ApiResponse[GetAllCrossMarginPairsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_all_cross_margin_pairs(symbol)

    def get_all_isolated_margin_symbol(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetAllIsolatedMarginSymbolResponse]:
        """
                Get All Isolated Margin Symbol(MARKET_DATA)

                Get All Isolated Margin Symbol

        Weight: 10(IP)

                Args:
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetAllIsolatedMarginSymbolResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_all_isolated_margin_symbol(symbol, recv_window)

    def get_all_margin_assets(
        self,
        asset: Optional[str] = None,
    ) -> ApiResponse[GetAllMarginAssetsResponse]:
        """
                Get All Margin Assets (MARKET_DATA)

                Get All Margin Assets.

        Weight: 1(IP)

                Args:
                    asset (Optional[str] = None):

                Returns:
                    ApiResponse[GetAllMarginAssetsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_all_margin_assets(asset)

    def get_delist_schedule(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetDelistScheduleResponse]:
        """
                Get Delist Schedule (MARKET_DATA)

                Get tokens or symbols delist schedule for cross margin and isolated margin

        Weight: 100

                Args:
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetDelistScheduleResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_delist_schedule(recv_window)

    def get_limit_price_pairs(
        self,
    ) -> ApiResponse[GetLimitPricePairsResponse]:
        """
                Get Limit Price Pairs(MARKET_DATA)

                Query trading pairs with restriction on limit price range.
        In margin trading, you can place orders with limit price. Limit price should be within (-15%, 15%) of current index price for a list of margin trading pairs. This rule only impacts limit sell orders with limit price that is lower than current index price and limit buy orders with limit price that is higher than current index price.

        - Buy order: Your order will be rejected with an error message notification if the limit price is 15% above the index price.
        - Sell order: Your order will be rejected with an error message notification if the limit price is 15% below the index price.
        Please review the limit price order placing strategy, backtest and calibrate the planned order size with the trading volume and order book depth to prevent trading loss.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[GetLimitPricePairsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_limit_price_pairs()

    def get_list_schedule(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetListScheduleResponse]:
        """
                Get list Schedule (MARKET_DATA)

                Get the upcoming tokens or symbols listing schedule for Cross Margin and Isolated Margin.

        Weight: 100

                Args:
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetListScheduleResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.get_list_schedule(recv_window)

    def query_isolated_margin_tier_data(
        self,
        symbol: Union[str, None],
        tier: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryIsolatedMarginTierDataResponse]:
        """
                Query Isolated Margin Tier Data (USER_DATA)

                Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data

        Weight: 1(IP)

                Args:
                    symbol (Union[str, None]):
                    tier (Optional[int] = None): All margin tier data will be returned if tier is omitted
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryIsolatedMarginTierDataResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.query_isolated_margin_tier_data(
            symbol, tier, recv_window
        )

    def query_liability_coin_leverage_bracket_in_cross_margin_pro_mode(
        self,
    ) -> ApiResponse[QueryLiabilityCoinLeverageBracketInCrossMarginProModeResponse]:
        """
                Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)

                Liability Coin Leverage Bracket in Cross Margin Pro Mode

        Weight: 1

                Args:

                Returns:
                    ApiResponse[QueryLiabilityCoinLeverageBracketInCrossMarginProModeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return (
            self._marketDataApi.query_liability_coin_leverage_bracket_in_cross_margin_pro_mode()
        )

    def query_margin_available_inventory(
        self,
        type: Union[str, None],
    ) -> ApiResponse[QueryMarginAvailableInventoryResponse]:
        """
                Query Margin Available Inventory(USER_DATA)

                Margin available Inventory query

        Weight: 50

                Args:
                    type (Union[str, None]): `MARGIN`,`ISOLATED`

                Returns:
                    ApiResponse[QueryMarginAvailableInventoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.query_margin_available_inventory(type)

    def query_margin_priceindex(
        self,
        symbol: Union[str, None],
    ) -> ApiResponse[QueryMarginPriceindexResponse]:
        """
                Query Margin PriceIndex (MARKET_DATA)

                Query Margin PriceIndex

        Weight: 10(IP)

                Args:
                    symbol (Union[str, None]):

                Returns:
                    ApiResponse[QueryMarginPriceindexResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.query_margin_priceindex(symbol)

    def close_user_data_stream(
        self,
    ) -> ApiResponse[None]:
        """
                Close User Data Stream (USER_STREAM)

                Close out a user data stream.

        Weight: 3000

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._riskDataStreamApi.close_user_data_stream()

    def keepalive_user_data_stream(
        self,
        listen_key: Union[str, None],
    ) -> ApiResponse[None]:
        """
                Keepalive User Data Stream (USER_STREAM)

                Keepalive a user data stream to prevent a time out.

        Weight: 1

                Args:
                    listen_key (Union[str, None]):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._riskDataStreamApi.keepalive_user_data_stream(listen_key)

    def start_user_data_stream(
        self,
    ) -> ApiResponse[StartUserDataStreamResponse]:
        """
                Start User Data Stream (USER_STREAM)

                Start a new user data stream.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[StartUserDataStreamResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._riskDataStreamApi.start_user_data_stream()

    def create_special_key(
        self,
        api_name: Union[str, None],
        symbol: Optional[str] = None,
        ip: Optional[str] = None,
        public_key: Optional[str] = None,
        permission_mode: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CreateSpecialKeyResponse]:
        """
                Create Special Key(Low-Latency Trading)(TRADE)

                **Binance Margin offers low-latency trading through a [special key](https://www.binance.com/en/support/faq/frequently-asked-questions-on-margin-special-api-key-3208663e900d4d2e9fec4140e1832f4e), available exclusively to users with VIP level 4 or higher. **

        **If you are VIP level 3 or below, please contact your VIP manager for eligibility criterias.**

        **Supported Products:**

        - Cross Margin
        - Isolated Margin
        - Portfolio Margin Pro
        - Cross Margin Pro (Additional agreement required and subject to meeting eligibility criteria)

        **Unsupported Products:**

        - Portfolio Margin

        We support several types of API keys:

        * Ed25519 (recommended)
        * HMAC
        * RSA

        We recommend to **use Ed25519 API keys** as it should provide the best performance and security out of all supported key types. We accept PKCS#8 (BEGIN PUBLIC KEY). For how to generate an RSA key pair to send API requests on Binance. Please refer to the document below [FAQ](https://www.binance.com/en/support/faq/how-to-generate-an-rsa-key-pair-to-send-api-requests-on-binance-2b79728f331e43079b27440d9d15c5db) .

        Read [REST API](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#signed-trade-and-user_data-endpoint-security) or [WebSocket API](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md#request-security) documentation to learn how to use different API keys

        You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.

        Weight: 1(UID)

                Args:
                    api_name (Union[str, None]):
                    symbol (Optional[str] = None): isolated margin pair
                    ip (Optional[str] = None): Can be added in batches, separated by commas. Max 30 for an API key
                    public_key (Optional[str] = None): 1. If publicKey is inputted it will create an RSA or Ed25519 key. <br />2. Need to be encoded to URL-encoded format
                    permission_mode (Optional[str] = None): This parameter is only for the Ed25519 API key, and does not effact for other encryption methods. The value can be TRADE (TRADE for all permissions) or READ (READ for USER_DATA, FIX_API_READ_ONLY). The default value is TRADE.
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[CreateSpecialKeyResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.create_special_key(
            api_name, symbol, ip, public_key, permission_mode, recv_window
        )

    def delete_special_key(
        self,
        api_name: Optional[str] = None,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[None]:
        """
                Delete Special Key(Low-Latency Trading)(TRADE)

                This only applies to Special Key for Low Latency Trading.

        If apiKey is given, apiName will be ignored. If apiName is given with no apiKey, all apikeys with given apiName will be deleted.

        You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.

        Weight: 1(UID)

                Args:
                    api_name (Optional[str] = None):
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.delete_special_key(api_name, symbol, recv_window)

    def edit_ip_for_special_key(
        self,
        ip: Union[str, None],
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[None]:
        """
                Edit ip for Special Key(Low-Latency Trading)(TRADE)

                Edit ip restriction. This only applies to Special Key for Low Latency Trading.

        You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.

        Weight: 1(UID)

                Args:
                    ip (Union[str, None]): Can be added in batches, separated by commas. Max 30 for an API key
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.edit_ip_for_special_key(ip, symbol, recv_window)

    def get_force_liquidation_record(
        self,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        isolated_symbol: Optional[str] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetForceLiquidationRecordResponse]:
        """
                Get Force Liquidation Record (USER_DATA)

                Get Force Liquidation Record

        * Response in descending order

        Weight: 1(IP)

                Args:
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    isolated_symbol (Optional[str] = None): isolated symbol
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetForceLiquidationRecordResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.get_force_liquidation_record(
            start_time, end_time, isolated_symbol, current, size, recv_window
        )

    def get_small_liability_exchange_coin_list(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetSmallLiabilityExchangeCoinListResponse]:
        """
                Get Small Liability Exchange Coin List (USER_DATA)

                Query the coins which can be small liability exchange

        Weight: 100

                Args:
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetSmallLiabilityExchangeCoinListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.get_small_liability_exchange_coin_list(recv_window)

    def get_small_liability_exchange_history(
        self,
        current: Union[int, None],
        size: Union[int, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetSmallLiabilityExchangeHistoryResponse]:
        """
                Get Small Liability Exchange History (USER_DATA)

                Get Small liability Exchange History

        Weight: 100(UID)

                Args:
                    current (Union[int, None]): Currently querying page. Start from 1. Default:1
                    size (Union[int, None]): Default:10, Max:100
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetSmallLiabilityExchangeHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.get_small_liability_exchange_history(
            current, size, start_time, end_time, recv_window
        )

    def margin_account_cancel_all_open_orders_on_a_symbol(
        self,
        symbol: Union[str, None],
        is_isolated: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountCancelAllOpenOrdersOnASymbolResponse]:
        """
                Margin Account Cancel all Open Orders on a Symbol (TRADE)

                Cancels all active orders on a symbol for margin account.<br></br>
        This includes OCO orders.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[MarginAccountCancelAllOpenOrdersOnASymbolResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_cancel_all_open_orders_on_a_symbol(
            symbol, is_isolated, recv_window
        )

    def margin_account_cancel_oco(
        self,
        symbol: Union[str, None],
        is_isolated: Optional[str] = None,
        order_list_id: Optional[int] = None,
        list_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountCancelOcoResponse]:
        """
                Margin Account Cancel OCO (TRADE)

                Cancel an entire Order List for a margin account.

        * Canceling an individual leg will cancel the entire OCO

        Weight: 1(UID)

                Args:
                    symbol (Union[str, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    order_list_id (Optional[int] = None): Either `orderListId` or `listClientOrderId` must be provided
                    list_client_order_id (Optional[str] = None): Either `orderListId` or `listClientOrderId` must be provided
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[MarginAccountCancelOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_cancel_oco(
            symbol,
            is_isolated,
            order_list_id,
            list_client_order_id,
            new_client_order_id,
            recv_window,
        )

    def margin_account_cancel_order(
        self,
        symbol: Union[str, None],
        is_isolated: Optional[str] = None,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountCancelOrderResponse]:
        """
                Margin Account Cancel Order (TRADE)

                Cancel an active order for margin account.

        * Either orderId or origClientOrderId must be sent.

        Weight: 10(IP)

                Args:
                    symbol (Union[str, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[MarginAccountCancelOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_cancel_order(
            symbol,
            is_isolated,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            recv_window,
        )

    def margin_account_new_oco(
        self,
        symbol: Union[str, None],
        side: Union[MarginAccountNewOcoSideEnum, None],
        quantity: Union[float, None],
        price: Union[float, None],
        stop_price: Union[float, None],
        is_isolated: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        limit_client_order_id: Optional[str] = None,
        limit_iceberg_qty: Optional[float] = None,
        stop_client_order_id: Optional[str] = None,
        stop_limit_price: Optional[float] = None,
        stop_iceberg_qty: Optional[float] = None,
        stop_limit_time_in_force: Optional[str] = None,
        new_order_resp_type: Optional[MarginAccountNewOcoNewOrderRespTypeEnum] = None,
        side_effect_type: Optional[str] = None,
        self_trade_prevention_mode: Optional[str] = None,
        auto_repay_at_cancel: Optional[bool] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountNewOcoResponse]:
        """
                Margin Account New OCO (TRADE)

                Send in a new OCO for a margin account

        * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution

        Weight: 6(UID)

                Args:
                    symbol (Union[str, None]):
                    side (Union[MarginAccountNewOcoSideEnum, None]):
                    quantity (Union[float, None]):
                    price (Union[float, None]):
                    stop_price (Union[float, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    list_client_order_id (Optional[str] = None): Either `orderListId` or `listClientOrderId` must be provided
                    limit_client_order_id (Optional[str] = None): A unique Id for the limit order
                    limit_iceberg_qty (Optional[float] = None):
                    stop_client_order_id (Optional[str] = None): A unique Id for the stop loss/stop loss limit leg
                    stop_limit_price (Optional[float] = None): If provided, `stopLimitTimeInForce` is required.
                    stop_iceberg_qty (Optional[float] = None):
                    stop_limit_time_in_force (Optional[str] = None): Valid values are `GTC`/`FOK`/`IOC`
                    new_order_resp_type (Optional[MarginAccountNewOcoNewOrderRespTypeEnum] = None): Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
                    side_effect_type (Optional[str] = None): NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
                    self_trade_prevention_mode (Optional[str] = None): The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
                    auto_repay_at_cancel (Optional[bool] = None): Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[MarginAccountNewOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_new_oco(
            symbol,
            side,
            quantity,
            price,
            stop_price,
            is_isolated,
            list_client_order_id,
            limit_client_order_id,
            limit_iceberg_qty,
            stop_client_order_id,
            stop_limit_price,
            stop_iceberg_qty,
            stop_limit_time_in_force,
            new_order_resp_type,
            side_effect_type,
            self_trade_prevention_mode,
            auto_repay_at_cancel,
            recv_window,
        )

    def margin_account_new_order(
        self,
        symbol: Union[str, None],
        side: Union[MarginAccountNewOrderSideEnum, None],
        type: Union[str, None],
        is_isolated: Optional[str] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        price: Optional[float] = None,
        stop_price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        iceberg_qty: Optional[float] = None,
        new_order_resp_type: Optional[MarginAccountNewOrderNewOrderRespTypeEnum] = None,
        side_effect_type: Optional[str] = None,
        time_in_force: Optional[MarginAccountNewOrderTimeInForceEnum] = None,
        self_trade_prevention_mode: Optional[str] = None,
        auto_repay_at_cancel: Optional[bool] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountNewOrderResponse]:
        """
                Margin Account New Order (TRADE)

                Post a new order for margin account.

        * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution

        Weight: 6(UID)

                Args:
                    symbol (Union[str, None]):
                    side (Union[MarginAccountNewOrderSideEnum, None]):
                    type (Union[str, None]): `MARGIN`,`ISOLATED`
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    price (Optional[float] = None):
                    stop_price (Optional[float] = None): Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    iceberg_qty (Optional[float] = None): Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
                    new_order_resp_type (Optional[MarginAccountNewOrderNewOrderRespTypeEnum] = None): Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
                    side_effect_type (Optional[str] = None): NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
                    time_in_force (Optional[MarginAccountNewOrderTimeInForceEnum] = None): GTC,IOC,FOK
                    self_trade_prevention_mode (Optional[str] = None): The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
                    auto_repay_at_cancel (Optional[bool] = None): Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[MarginAccountNewOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_new_order(
            symbol,
            side,
            type,
            is_isolated,
            quantity,
            quote_order_qty,
            price,
            stop_price,
            new_client_order_id,
            iceberg_qty,
            new_order_resp_type,
            side_effect_type,
            time_in_force,
            self_trade_prevention_mode,
            auto_repay_at_cancel,
            recv_window,
        )

    def margin_account_new_oto(
        self,
        symbol: Union[str, None],
        working_type: Union[str, None],
        working_side: Union[str, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        working_iceberg_qty: Union[float, None],
        pending_type: Union[str, None],
        pending_side: Union[str, None],
        pending_quantity: Union[float, None],
        is_isolated: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[MarginAccountNewOtoNewOrderRespTypeEnum] = None,
        side_effect_type: Optional[str] = None,
        self_trade_prevention_mode: Optional[str] = None,
        auto_repay_at_cancel: Optional[bool] = None,
        working_client_order_id: Optional[str] = None,
        working_time_in_force: Optional[str] = None,
        pending_client_order_id: Optional[str] = None,
        pending_price: Optional[float] = None,
        pending_stop_price: Optional[float] = None,
        pending_trailing_delta: Optional[float] = None,
        pending_iceberg_qty: Optional[float] = None,
        pending_time_in_force: Optional[str] = None,
    ) -> ApiResponse[MarginAccountNewOtoResponse]:
        """
                Margin Account New OTO (TRADE)

                Post a new OTO order for margin account:

        - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
        - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
        - The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
        - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
        - When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
        - OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.

        * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
        * Depending on the `pendingType` or `workingType`, some optional parameters will become mandatory:

        Weight: 6(UID)

                Args:
                    symbol (Union[str, None]):
                    working_type (Union[str, None]): Supported values: `LIMIT`, `LIMIT_MAKER`
                    working_side (Union[str, None]): BUY, SELL
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]):
                    working_iceberg_qty (Union[float, None]): This can only be used if `workingTimeInForce` is `GTC`.
                    pending_type (Union[str, None]): Supported values: [Order Types](https://developers.binance.com/docs/binance-spot-api-docs/enums#order-types-ordertypes-type) Note that `MARKET` orders using `quoteOrderQty` are not supported.
                    pending_side (Union[str, None]): BUY, SELL
                    pending_quantity (Union[float, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    list_client_order_id (Optional[str] = None): Either `orderListId` or `listClientOrderId` must be provided
                    new_order_resp_type (Optional[MarginAccountNewOtoNewOrderRespTypeEnum] = None): Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
                    side_effect_type (Optional[str] = None): NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
                    self_trade_prevention_mode (Optional[str] = None): The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
                    auto_repay_at_cancel (Optional[bool] = None): Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
                    working_time_in_force (Optional[str] = None): GTC,IOC,FOK
                    pending_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending order. Automatically generated if not sent.
                    pending_price (Optional[float] = None):
                    pending_stop_price (Optional[float] = None):
                    pending_trailing_delta (Optional[float] = None):
                    pending_iceberg_qty (Optional[float] = None): This can only be used if `pendingTimeInForce` is `GTC`.
                    pending_time_in_force (Optional[str] = None): GTC,IOC,FOK

                Returns:
                    ApiResponse[MarginAccountNewOtoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_new_oto(
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            working_iceberg_qty,
            pending_type,
            pending_side,
            pending_quantity,
            is_isolated,
            list_client_order_id,
            new_order_resp_type,
            side_effect_type,
            self_trade_prevention_mode,
            auto_repay_at_cancel,
            working_client_order_id,
            working_time_in_force,
            pending_client_order_id,
            pending_price,
            pending_stop_price,
            pending_trailing_delta,
            pending_iceberg_qty,
            pending_time_in_force,
        )

    def margin_account_new_otoco(
        self,
        symbol: Union[str, None],
        working_type: Union[str, None],
        working_side: Union[str, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        pending_side: Union[str, None],
        pending_quantity: Union[float, None],
        pending_above_type: Union[str, None],
        is_isolated: Optional[str] = None,
        side_effect_type: Optional[str] = None,
        auto_repay_at_cancel: Optional[bool] = None,
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[MarginAccountNewOtocoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[str] = None,
        working_client_order_id: Optional[str] = None,
        working_iceberg_qty: Optional[float] = None,
        working_time_in_force: Optional[str] = None,
        pending_above_client_order_id: Optional[str] = None,
        pending_above_price: Optional[float] = None,
        pending_above_stop_price: Optional[float] = None,
        pending_above_trailing_delta: Optional[float] = None,
        pending_above_iceberg_qty: Optional[float] = None,
        pending_above_time_in_force: Optional[str] = None,
        pending_below_type: Optional[str] = None,
        pending_below_client_order_id: Optional[str] = None,
        pending_below_price: Optional[float] = None,
        pending_below_stop_price: Optional[float] = None,
        pending_below_trailing_delta: Optional[float] = None,
        pending_below_iceberg_qty: Optional[float] = None,
        pending_below_time_in_force: Optional[str] = None,
    ) -> ApiResponse[MarginAccountNewOtocoResponse]:
        """
                Margin Account New OTOCO (TRADE)

                Post a new OTOCO order for margin account：

        - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
        - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
        - The behavior of the working order is the same as the OTO.
        - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
        - The rules of the pending above and pending below follow the same rules as the [Order List OCO](https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO).
        - OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.

        * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
        * Depending on the `pendingAboveType`/`pendingBelowType` or `workingType`, some optional parameters will become mandatory:

        Weight: 6(UID)

                Args:
                    symbol (Union[str, None]):
                    working_type (Union[str, None]): Supported values: `LIMIT`, `LIMIT_MAKER`
                    working_side (Union[str, None]): BUY, SELL
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]):
                    pending_side (Union[str, None]): BUY, SELL
                    pending_quantity (Union[float, None]):
                    pending_above_type (Union[str, None]): Supported values: `LIMIT_MAKER`, `STOP_LOSS`, and `STOP_LOSS_LIMIT`
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    side_effect_type (Optional[str] = None): NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
                    auto_repay_at_cancel (Optional[bool] = None): Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
                    list_client_order_id (Optional[str] = None): Either `orderListId` or `listClientOrderId` must be provided
                    new_order_resp_type (Optional[MarginAccountNewOtocoNewOrderRespTypeEnum] = None): Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
                    self_trade_prevention_mode (Optional[str] = None): The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
                    working_iceberg_qty (Optional[float] = None): This can only be used if `workingTimeInForce` is `GTC`.
                    working_time_in_force (Optional[str] = None): GTC,IOC,FOK
                    pending_above_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending above order. Automatically generated if not sent.
                    pending_above_price (Optional[float] = None):
                    pending_above_stop_price (Optional[float] = None):
                    pending_above_trailing_delta (Optional[float] = None):
                    pending_above_iceberg_qty (Optional[float] = None): This can only be used if `pendingAboveTimeInForce` is `GTC`.
                    pending_above_time_in_force (Optional[str] = None):
                    pending_below_type (Optional[str] = None): Supported values: `LIMIT_MAKER`, `STOP_LOSS`, and `STOP_LOSS_LIMIT`
                    pending_below_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending below order. Automatically generated if not sent.
                    pending_below_price (Optional[float] = None):
                    pending_below_stop_price (Optional[float] = None):
                    pending_below_trailing_delta (Optional[float] = None):
                    pending_below_iceberg_qty (Optional[float] = None): This can only be used if `pendingBelowTimeInForce` is `GTC`.
                    pending_below_time_in_force (Optional[str] = None):

                Returns:
                    ApiResponse[MarginAccountNewOtocoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_new_otoco(
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_side,
            pending_quantity,
            pending_above_type,
            is_isolated,
            side_effect_type,
            auto_repay_at_cancel,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            pending_above_client_order_id,
            pending_above_price,
            pending_above_stop_price,
            pending_above_trailing_delta,
            pending_above_iceberg_qty,
            pending_above_time_in_force,
            pending_below_type,
            pending_below_client_order_id,
            pending_below_price,
            pending_below_stop_price,
            pending_below_trailing_delta,
            pending_below_iceberg_qty,
            pending_below_time_in_force,
        )

    def margin_manual_liquidation(
        self,
        type: Union[str, None],
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginManualLiquidationResponse]:
        """
                Margin Manual Liquidation(MARGIN)

                Margin Manual Liquidation

        * This endpoint can support Cross Margin Classic Mode and Pro Mode.
        * And only support Isolated Margin for restricted region.

        Weight: 3000

                Args:
                    type (Union[str, None]): `MARGIN`,`ISOLATED`
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[MarginManualLiquidationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_manual_liquidation(type, symbol, recv_window)

    def query_current_margin_order_count_usage(
        self,
        is_isolated: Optional[str] = None,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCurrentMarginOrderCountUsageResponse]:
        """
                Query Current Margin Order Count Usage (TRADE)

                Displays the user's current margin order count usage for all intervals.

        Weight: 20(IP)

                Args:
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryCurrentMarginOrderCountUsageResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_current_margin_order_count_usage(
            is_isolated, symbol, recv_window
        )

    def query_margin_accounts_all_oco(
        self,
        is_isolated: Optional[str] = None,
        symbol: Optional[str] = None,
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsAllOcoResponse]:
        """
                Query Margin Account's all OCO (USER_DATA)

                Retrieves all OCO for a specific margin account based on provided optional parameters

        Weight: 200(IP)

                Args:
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    symbol (Optional[str] = None): isolated margin pair
                    from_id (Optional[int] = None): 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default Value: 500; Max Value: 1000
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginAccountsAllOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_all_oco(
            is_isolated, symbol, from_id, start_time, end_time, limit, recv_window
        )

    def query_margin_accounts_all_orders(
        self,
        symbol: Union[str, None],
        is_isolated: Optional[str] = None,
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsAllOrdersResponse]:
        """
                Query Margin Account's All Orders (USER_DATA)

                Query Margin Account's All Orders

        * If orderId is set, it will get orders >= that orderId. Otherwise the orders within 24 hours are returned.
        * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.
        * Less than 24 hours between startTime and endTime.

        Weight: 200(IP)

                Args:
                    symbol (Union[str, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default Value: 500; Max Value: 1000
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginAccountsAllOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_all_orders(
            symbol, is_isolated, order_id, start_time, end_time, limit, recv_window
        )

    def query_margin_accounts_oco(
        self,
        is_isolated: Optional[str] = None,
        symbol: Optional[str] = None,
        order_list_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsOcoResponse]:
        """
                Query Margin Account's OCO (USER_DATA)

                Retrieves a specific OCO based on provided optional parameters

        Weight: 10(IP)

                Args:
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    symbol (Optional[str] = None): isolated margin pair
                    order_list_id (Optional[int] = None): Either `orderListId` or `listClientOrderId` must be provided
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginAccountsOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_oco(
            is_isolated, symbol, order_list_id, orig_client_order_id, recv_window
        )

    def query_margin_accounts_open_oco(
        self,
        is_isolated: Optional[str] = None,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsOpenOcoResponse]:
        """
                Query Margin Account's Open OCO (USER_DATA)

                Query Margin Account's Open OCO

        Weight: 10(IP)

                Args:
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginAccountsOpenOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_open_oco(
            is_isolated, symbol, recv_window
        )

    def query_margin_accounts_open_orders(
        self,
        symbol: Optional[str] = None,
        is_isolated: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsOpenOrdersResponse]:
        """
                Query Margin Account's Open Orders (USER_DATA)

                Query Margin Account's Open Orders

        * If the symbol is not sent, orders for all symbols will be returned in an array.
        * When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange.
        * If isIsolated ="TRUE", symbol must be sent.

        Weight: 10(IP)

                Args:
                    symbol (Optional[str] = None): isolated margin pair
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginAccountsOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_open_orders(
            symbol, is_isolated, recv_window
        )

    def query_margin_accounts_order(
        self,
        symbol: Union[str, None],
        is_isolated: Optional[str] = None,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsOrderResponse]:
        """
                Query Margin Account's Order (USER_DATA)

                Query Margin Account's Order

        * Either orderId or origClientOrderId must be sent.
        * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.

        Weight: 10(IP)

                Args:
                    symbol (Union[str, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginAccountsOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_order(
            symbol, is_isolated, order_id, orig_client_order_id, recv_window
        )

    def query_margin_accounts_trade_list(
        self,
        symbol: Union[str, None],
        is_isolated: Optional[str] = None,
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsTradeListResponse]:
        """
                Query Margin Account's Trade List (USER_DATA)

                Query Margin Account's Trade List

        * If fromId is set, it will get trades >= that fromId. Otherwise the trades within 24 hours are returned.
        * Less than 24 hours between startTime and endTime.

        Weight: 10(IP)

                Args:
                    symbol (Union[str, None]):
                    is_isolated (Optional[str] = None): for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    from_id (Optional[int] = None): 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
                    limit (Optional[int] = None): Default Value: 500; Max Value: 1000
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMarginAccountsTradeListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_trade_list(
            symbol,
            is_isolated,
            order_id,
            start_time,
            end_time,
            from_id,
            limit,
            recv_window,
        )

    def query_special_key(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QuerySpecialKeyResponse]:
        """
                Query Special key(Low Latency Trading)(TRADE)

                Query Special Key Information.

        This only applies to Special Key for Low Latency Trading.

        Weight: 1(UID)

                Args:
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QuerySpecialKeyResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_special_key(symbol, recv_window)

    def query_special_key_list(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QuerySpecialKeyListResponse]:
        """
                Query Special key List(Low Latency Trading)(TRADE)

                This only applies to Special Key for Low Latency Trading.

        Weight: 1(UID)

                Args:
                    symbol (Optional[str] = None): isolated margin pair
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QuerySpecialKeyListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_special_key_list(symbol, recv_window)

    def small_liability_exchange(
        self,
        asset_names: Union[List[str], None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[None]:
        """
                Small Liability Exchange (MARGIN)

                Small Liability Exchange

        * Only convert once within 6 hours
        * Only liability valuation less than 10 USDT are supported
        * The maximum number of coin is 10

        Weight: 3000(UID)

                Args:
                    asset_names (Union[List[str], None]): The assets list of small liability exchange， Example: assetNames = BTC,ETH
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.small_liability_exchange(asset_names, recv_window)

    def close_isolated_margin_user_data_stream(
        self,
        symbol: Union[str, None],
        listenkey: Union[str, None],
    ) -> ApiResponse[None]:
        """
                Close Isolated Margin User Data Stream (USER_STREAM)

                Close out a isolated margin user data stream.

        Weight: 3000

                Args:
                    symbol (Union[str, None]):
                    listenkey (Union[str, None]):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeDataStreamApi.close_isolated_margin_user_data_stream(
            symbol, listenkey
        )

    def close_margin_user_data_stream(
        self,
        listenkey: Union[str, None],
    ) -> ApiResponse[None]:
        """
                Close Margin User Data Stream (USER_STREAM)

                Close out a Margin user data stream.

        Weight: 3000

                Args:
                    listenkey (Union[str, None]):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeDataStreamApi.close_margin_user_data_stream(listenkey)

    def keepalive_isolated_margin_user_data_stream(
        self,
        symbol: Union[str, None],
        listen_key: Union[str, None],
    ) -> ApiResponse[None]:
        """
                Keepalive Isolated Margin User Data Stream (USER_STREAM)

                Keepalive an isolated margin user data stream to prevent a time out.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    listen_key (Union[str, None]):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeDataStreamApi.keepalive_isolated_margin_user_data_stream(
            symbol, listen_key
        )

    def keepalive_margin_user_data_stream(
        self,
        listen_key: Union[str, None],
    ) -> ApiResponse[None]:
        """
                Keepalive Margin User Data Stream (USER_STREAM)

                Keepalive a margin user data stream to prevent a time out.

        Weight: 1

                Args:
                    listen_key (Union[str, None]):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeDataStreamApi.keepalive_margin_user_data_stream(listen_key)

    def start_isolated_margin_user_data_stream(
        self,
        symbol: Union[str, None],
    ) -> ApiResponse[StartIsolatedMarginUserDataStreamResponse]:
        """
                Start Isolated Margin User Data Stream (USER_STREAM)

                Start a new isolated margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.

        Weight: 1

                Args:
                    symbol (Union[str, None]):

                Returns:
                    ApiResponse[StartIsolatedMarginUserDataStreamResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeDataStreamApi.start_isolated_margin_user_data_stream(symbol)

    def start_margin_user_data_stream(
        self,
    ) -> ApiResponse[StartMarginUserDataStreamResponse]:
        """
                Start Margin User Data Stream (USER_STREAM)

                Start a new margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[StartMarginUserDataStreamResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeDataStreamApi.start_margin_user_data_stream()

    def get_cross_margin_transfer_history(
        self,
        asset: Optional[str] = None,
        type: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        isolated_symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetCrossMarginTransferHistoryResponse]:
        """
                Get Cross Margin Transfer History (USER_DATA)

                Get Cross Margin Transfer History

        * Response in descending order
        * The max interval between `startTime` and `endTime` is 30 days.
        * Returns data for last 7 days by default

        Weight: 1(IP)

                Args:
                    asset (Optional[str] = None):
                    type (Optional[str] = None): Transfer Type: ROLL_IN, ROLL_OUT
                    start_time (Optional[int] = None): 只支持查询最近90天的数据
                    end_time (Optional[int] = None):
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    isolated_symbol (Optional[str] = None): isolated symbol
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[GetCrossMarginTransferHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._transferApi.get_cross_margin_transfer_history(
            asset,
            type,
            start_time,
            end_time,
            current,
            size,
            isolated_symbol,
            recv_window,
        )

    def query_max_transfer_out_amount(
        self,
        asset: Union[str, None],
        isolated_symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMaxTransferOutAmountResponse]:
        """
                Query Max Transfer-Out Amount (USER_DATA)

                Query Max Transfer-Out Amount

        * If isolatedSymbol is not sent, crossed margin data will be sent.

        Weight: 50(IP)

                Args:
                    asset (Union[str, None]):
                    isolated_symbol (Optional[str] = None): isolated symbol
                    recv_window (Optional[int] = None): No more than 60000

                Returns:
                    ApiResponse[QueryMaxTransferOutAmountResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._transferApi.query_max_transfer_out_amount(
            asset, isolated_symbol, recv_window
        )
