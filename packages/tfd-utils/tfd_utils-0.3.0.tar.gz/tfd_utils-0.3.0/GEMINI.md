# Gemini Context: tfd_utils

This document provides essential context about the `tfd_utils` library for the Gemini assistant.

## 1. Project Overview

`tfd_utils` is a lightweight, standalone Python library for reading and writing TensorFlow TFRecord files. Its key feature is providing **efficient random access** to records by key, **without requiring TensorFlow** as a dependency. It is fully compatible with TFRecords generated by or read by TensorFlow.

## 2. Key Architectural Concepts

- **TFRecord Compatibility**: The library reads and writes files that are 100% compatible with TensorFlow's `tf.data.TFRecordDataset` and `tf.io.TFRecordWriter`. This is verified by the test suite.
- **Random Access Index**: For random access, the library builds and caches an index file (`.tfd_index`) that maps a record's key to its byte offset in the TFRecord file. This allows for O(1) lookup.
- **Key Feature**: By default, it assumes each `tf.train.Example` has a feature named `'key'` which contains a unique identifier for that record. This key is used for indexing. The key feature name can be customized.
- **Protocol Buffers**: It uses compiled Protobuf definitions (`example_pb2.py`, `feature_pb2.py`) from TensorFlow's `.proto` files to create and parse `tf.train.Example` messages.
- **Minimal Dependencies**: The core library only depends on `numpy`, `protobuf`, and `crc32c`. TensorFlow is not required for its primary functionality.

## 3. Core Modules & File Structure

- `src/tfd_utils/`
  - `random_access.py`: Contains the `TFRecordRandomAccess` class, which is the primary interface for reading records by key. It handles index creation, caching, and retrieval.
  - `writer/tf_writer.py`: Contains the `TFRecordWriter` class for writing data into TFRecord files in a format TensorFlow understands.
  - `pb2/`: Contains the Python files generated from TensorFlow's `Example` and `Feature` protobuf definitions. These are used for serialization and deserialization.
- `tests/`: Contains integration and compatibility tests.
  - `test_tf_writer_compatibility.py`: Verifies that files written by `tfd_utils` can be read by TensorFlow.
  - `test_pb2_compatibility.py`: Verifies that files written by TensorFlow can be read by `tfd_utils`.

## 4. Common Usage Patterns

- **Writing Data**: Instantiate `TFRecordWriter` and use its `write()` method to save serialized `tf.train.Example` protocol buffers.
- **Random Reading**: Instantiate `TFRecordRandomAccess` with a path to one or more TFRecord files. Use `get_record(key)` or dictionary-style access (`reader[key]`) to fetch a specific record.
- **Feature Extraction**: Use `get_feature(key, feature_name)` to directly extract the value of a specific feature from a record without parsing the whole `Example` proto yourself.

## 5. Dependencies

- **Core**: `numpy`, `protobuf`, `crc32c`
- **Development/Testing**: `tensorflow`, `pytest`

## 6. Development

This project uses `uv` for package management.

To create the virtual environment and install dependencies:
```bash
uv venv
uv sync --extra dev
```

To run the test suite:
```bash
uv run pytest
```

## 7. CI/CD

The project uses GitHub Actions for CI/CD. The workflow is defined in `.github/workflows/publish.yml`.

- **Publish to PyPI**: This workflow is triggered when a new release is published on GitHub. It builds the package and publishes it to PyPI.

## 8. Git Workflow

### Branching and Committing

1.  **Create a new branch**:
    ```bash
    git checkout -b feature/your-feature-name
    ```
2.  **Stage your changes**:
    ```bash
    git add .
    ```
3.  **Commit your changes** with a descriptive message:
    ```bash
    git commit -m "feat: add your feature description"
    ```
4.  **Push your branch** to the remote repository:
    ```bash
    git push -u origin feature/your-feature-name
    ```

### Creating a Pull Request

1.  Go to the repository on GitHub.
2.  Click on the "Pull requests" tab.
3.  Click the "New pull request" button.
4.  Choose your feature branch and the `master` branch as the base.
5.  Add a title and description to your pull request.
6.  Request a review from one of the project maintainers.
7.  Once the pull request is approved, you can **squash and merge** it into the `master` branch.
