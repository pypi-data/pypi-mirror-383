
import logging
from typing import Any, Dict

import torch
import torch.nn as nn

log = logging.getLogger(__name__)


class DmcRouting(nn.Module):
    """
    Differentiable Muskingum-Cunge (DMC) Routing Module

    This script defines the DmcRouting module, a component for routing runoff through a river network
    using the Muskingum-Cunge method in a differentiable manner, suitable for integration with deep learning models.

    ---
    Data Requirements:
    ---
    This module expects data to be provided through its `forward` method, which takes the following arguments:

    1.  `runoff`: A dictionary containing the runoff generated by a hydrological model.
        -   `runoff['y']`: A tensor of shape `(batch_size, seq_len, num_reaches)` representing the
        runoff for each river reach over time.

    2.  `batch`: The original input batch provided to the main model.
        -   `batch['hydrofabric']`: A list of 'hydrofabric' objects, one for each sample in the batch.
        Each hydrofabric object must contain the static river network characteristics:
            - `attributes`: A tensor with reach-specific attributes. The configuration specifies
            the indices for 'length' and 'slope' within this tensor.
            - `network`: An object containing the network topology:
                - `explicit_network_matrix`: Adjacency matrix defining upstream/downstream connections.
                - `index_graph`: A graph representation of the river network used for ordered iteration.
                - `gage_indices`: Indices of the reaches that are gaged.

    3.  `static_params` / `dynamic_params`: Dictionaries containing model parameters. These are merged,
        and the following parameters are expected:
        -   `'n'`: Manning's roughness coefficient for each reach.
        -   `'q_spatial'`: A spatial parameter related to channel shape for each reach.

    4.  Configuration (`cfg` object passed during initialization):
        -   `variables`: Contains physical constants for the model:
            - `p`: Spatial parameter for wetted perimeter.
            - `t`: Time step duration in seconds.
            - `x`: Storage coefficient for the Muskingum-Cunge method.
        -   `length.idx`, `slope.idx`: Indices to locate reach length and slope in the `hydrofabric.attributes` tensor.
        -   `slope.min`, `slope.max`: Values for clamping the slope to avoid numerical instability.

    ---
    Model Operation:
    ---
    The model processes data for each basin in the batch sequentially. For each basin, it performs the following steps:

    1.  **Initialization**: It initializes the discharge for all reaches at the first time step using the
        input runoff (`q_prime`).

    2.  **Time-Stepping Loop**: The model iterates through each time step of the input sequence.

    3.  **Network Traversal**: Within each time step, it traverses the river network from upstream to downstream
        based on the provided `index_graph`.

    4.  **Routing Calculation**: For each reach, it calculates the outflow for the next time step (`q_t1`) by:
        a.  Aggregating inflows (`i_t`, `i_t1`) from immediate upstream reaches.
        b.  Calculating the wave celerity (velocity) based on the current discharge and channel properties
            (slope, Manning's n) using a simplified form of the Manning's equation.
        c.  Applying the core Muskingum-Cunge routing equation, which uses the calculated inflows,
            celerity, and the `k` (travel time) and `x` (storage) parameters to compute the outflow.

    5.  **State Update**: The calculated outflow `q_t1` becomes the input discharge for the next time step.

    6.  **Gage Aggregation**: The discharge at specified gage locations is summed up at each time step.

    7.  **Output**: The final output is a tensor of shape `(batch_size, seq_len, num_gages)` representing the
        predicted streamflow at each gage location over time.
    """

    def __init__(self, cfg: Dict):
        super().__init__()
        self.cfg = cfg
        # These are constants based on the config
        self.p_spatial = nn.Parameter(torch.tensor(self.cfg['variables']['p']), requires_grad=False)
        self.t = nn.Parameter(torch.tensor(self.cfg['variables']['t']), requires_grad=False)
        self.x_storage = nn.Parameter(torch.tensor(self.cfg['variables']['x']), requires_grad=False)

    @staticmethod
    def _get_length(cfg: Dict, attributes: torch.Tensor) -> torch.Tensor:
        length_idx = cfg['length']['idx']
        return attributes[:, length_idx].clone()

    @staticmethod
    def _get_slope(cfg: Dict, attributes: torch.Tensor) -> torch.Tensor:
        slope_idx = cfg['slope']['idx']
        s0_ = attributes[:, slope_idx].clone()
        return torch.clamp(s0_, min=cfg['slope']['min'], max=cfg['slope']['max'])

    @staticmethod
    @torch.jit.script
    def _get_velocity(q_t, _n, _q_spatial, _s0, p_spatial) -> torch.Tensor:
        """Calculates wave celerity based on discharge and channel properties."""
        numerator = q_t * _n * (_q_spatial + 1)
        denominator = p_spatial * torch.pow(_s0, 0.5)
        # Add a small epsilon to avoid division by zero or log(0) issues
        denominator = denominator + 1e-6

        # Clamp the argument of the power to be non-negative
        power_base = torch.div(numerator, denominator)
        power_base = torch.clamp(power_base, min=1e-6)

        depth = torch.pow(power_base, torch.div(3.0, 5.0 + 3.0 * _q_spatial))
        v = torch.div(1, _n) * torch.pow(depth, (2 / 3)) * torch.pow(_s0, (1 / 2))
        c_ = torch.clamp(v, 0.3, 15)
        c = c_ * 5 / 3
        return c

    @staticmethod
    @torch.jit.script
    def _muskingum_cunge(
        i_t: torch.Tensor,
        i_t1: torch.Tensor,
        q_t: torch.Tensor,
        q_prime_segment: torch.Tensor,
        length: torch.Tensor,
        velocity: torch.Tensor,
        x_storage: torch.Tensor,
        t: torch.Tensor,
    ) -> torch.Tensor:
        """An explicit Muskingum-Cunge routing solution for a single time step."""
        k = length / (velocity + 1e-6)  # Add epsilon to avoid division by zero
        denom = (2.0 * k * (1.0 - x_storage)) + t
        # Add epsilon to avoid division by zero
        denom = denom + 1e-6
        c_1 = (t - (2.0 * k * x_storage)) / denom
        c_2 = (t + (2.0 * k * x_storage)) / denom
        c_3 = (2.0 * k * (1.0 - x_storage) - t) / denom
        c_4 = (2.0 * t) / denom
        q_t1 = (c_1 * i_t1) + (c_2 * i_t) + (c_3 * q_t) + (c_4 * q_prime_segment)
        return torch.clamp(q_t1, min=1e-4)

    @staticmethod
    @torch.jit.script
    def _read_inflow(discharge_t, discharge_t1, upstream_indexes):
        """Aggregates inflows from upstream reaches."""
        single_index_mask = (upstream_indexes != -1).sum(dim=1) == 1
        masked_indexes = upstream_indexes[single_index_mask]
        single_indices = masked_indexes[masked_indexes != -1]

        many_index_mask = (upstream_indexes != -1).sum(dim=1) > 1
        i_t = torch.zeros(len(upstream_indexes), dtype=torch.float64, device=discharge_t.device)
        i_t1 = torch.zeros(len(upstream_indexes), dtype=torch.float64, device=discharge_t.device)
        if single_index_mask.any():
            i_t[single_index_mask] = discharge_t[single_indices]
            i_t1[single_index_mask] = discharge_t1[single_indices]
        if many_index_mask.sum() > 0:
            masked_indexes = upstream_indexes[many_index_mask]
            actual_indices = torch.arange(len(many_index_mask), device=discharge_t.device)[many_index_mask]
            for i, row in enumerate(masked_indexes):
                valid_indices = row[row != -1]
                idx = actual_indices[i]
                i_t[idx] = discharge_t[valid_indices].sum()
                i_t1[idx] = discharge_t1[valid_indices].sum()
        return i_t, i_t1

    def _route_one_basin(self, q_prime, hydrofabric, n, q_spatial):
        """Performs routing for a single basin in the batch."""
        gage_indices = hydrofabric.network.gage_indices
        A = hydrofabric.network.explicit_network_matrix
        river_index_graph = torch.tensor(hydrofabric.network.index_graph, device=q_prime.device)

        num_timesteps = q_prime.shape[0]
        num_reaches = q_prime.shape[1]

        output = torch.zeros([len(gage_indices), num_timesteps], dtype=torch.float64, device=q_prime.device)

        _discharge_t = q_prime[0, :]
        _discharge_t1 = torch.zeros(num_reaches, dtype=torch.float64, device=q_prime.device)

        for i in range(len(gage_indices)):
            if len(gage_indices[i]) > 0:
                output[i, 0] = torch.sum(_discharge_t[gage_indices[i]])

        length = self.attributes.length
        slope = self.attributes.slope

        for timestep in range(1, num_timesteps):
            for j in range(river_index_graph.shape[0]):
                _downstream_indexes = river_index_graph[j][river_index_graph[j] != -1]
                if len(_downstream_indexes) == 0:
                    continue

                if j == 0:
                    i_t = torch.tensor(0, dtype=torch.float64, device=q_prime.device)
                    i_t1 = torch.tensor(0, dtype=torch.float64, device=q_prime.device)
                else:
                    upstream_indexes = A[_downstream_indexes]
                    mask = upstream_indexes[:, 0] != -1
                    if not mask.any():
                        i_t = torch.tensor(0, dtype=torch.float64, device=q_prime.device)
                        i_t1 = torch.tensor(0, dtype=torch.float64, device=q_prime.device)
                    else:
                        upstream_indexes_filtered = upstream_indexes[mask]
                        i_t, i_t1 = self._read_inflow(_discharge_t, _discharge_t1, upstream_indexes_filtered)

                q_prime_segment = q_prime[timestep, _downstream_indexes]

                _n = n if n.dim() == 0 else n[_downstream_indexes]
                _q_spatial = q_spatial if q_spatial.dim() == 0 else q_spatial[_downstream_indexes]

                q_t = _discharge_t[_downstream_indexes]
                _length = length[_downstream_indexes]
                _slope = slope[_downstream_indexes]

                velocity = self._get_velocity(q_t, _n, _q_spatial, _slope, self.p_spatial)

                q_t1 = self._muskingum_cunge(
                    i_t, i_t1, q_t, q_prime_segment, _length, velocity, self.x_storage, self.t
                )
                _discharge_t1[_downstream_indexes] = q_t1

            for i in range(len(gage_indices)):
                if len(gage_indices[i]) > 0:
                    output[i, timestep] = torch.sum(self._discharge_t1[gage_indices[i]])

            _discharge_t = _discharge_t1.clone()

        return output  # Shape: (num_gages, seq_len)

    def forward(self, runoff: Dict[str, torch.Tensor], batch: Dict[str, Any],
                static_params: Dict[str, torch.Tensor],
                dynamic_params: Dict[str, torch.Tensor]) -> Dict[str, torch.Tensor]:

        q_prime_batch = runoff['q_sim']
        # Assuming hydrofabric is a list of objects, one for each item in the batch
        hydrofabric_batch = batch['hydrofabric']

        params = {**static_params, **dynamic_params}
        n_batch = params['n']
        q_spatial_batch = params['q_spatial']

        batch_size = q_prime_batch.shape[0]

        outputs = []
        for i in range(batch_size):
            single_output = self._route_one_basin(
                q_prime=q_prime_batch[i],
                hydrofabric=hydrofabric_batch[i],
                n=n_batch[i],
                q_spatial=q_spatial_batch[i]
            )
            outputs.append(single_output)

        predicted_streamflow = torch.stack(outputs, dim=0)  # (batch_size, num_gages, seq_len)
        predicted_streamflow = predicted_streamflow.permute(0, 2, 1)  # (batch_size, seq_len, num_gages)

        return {"y": predicted_streamflow}
