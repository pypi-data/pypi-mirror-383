// Copyright (c) Meta Platforms, Inc. and affiliates.
// All rights reserved.
//
// This source code is licensed under the terms described in the LICENSE file in
// the root directory of this source tree.

import { useMemo } from "react";
import { useLazyLoadQuery, graphql } from "react-relay";
import {
  calculateNextDialogTree,
  DialogTree,
  INTERACTIVE_SCENARIOS,
  ScenarioSelection,
} from "../components/user-agent-dialog/Demos";

const GetInteractiveScenariosTreeQuery = graphql`
  query useInteractiveScenarioQuery {
    getInteractiveScenariosTree
  }
`;

/**
 * Custom hook to get available interactive scenarios.
 *
 * This hook:
 * 1. Loads interactive scenarios from the backend if INTERACTIVE_SCENARIOS_TREE env var is set
 * 2. Falls back to hardcoded scenarios if backend data is unavailable
 * 3. Merges scenarios with proper precedence (backend > internal > regular)
 *
 * @returns Record of available scenarios keyed by scenario ID
 */
export function useInteractiveScenario(): Record<string, ScenarioSelection> {
  // Load interactive scenarios tree from backend if available
  const interactiveScenariosTreeData = useLazyLoadQuery(
    GetInteractiveScenariosTreeQuery,
    {},
    { fetchPolicy: "store-and-network" },
  ) as any; // Type will be generated by Relay

  // Check if backend data is actually available (not null/undefined)
  const hasBackendData = useMemo(() => {
    const hasData =
      interactiveScenariosTreeData?.getInteractiveScenariosTree != null;
    return hasData;
  }, [interactiveScenariosTreeData]);

  // Create scenarios from backend data if available
  const backendScenarios: Record<string, ScenarioSelection> = useMemo(() => {
    if (!hasBackendData) {
      return {};
    }

    const treeData = interactiveScenariosTreeData.getInteractiveScenariosTree;

    // Expect tree data to be a dictionary of scenarios (scenarioId => scenarioData)
    if (treeData && typeof treeData === "object" && !Array.isArray(treeData)) {
      const scenarios: Record<string, ScenarioSelection> = {};

      Object.entries(treeData).forEach(
        ([scenarioId, scenarioData]: [string, any]) => {
          scenarios[scenarioId] = {
            id: scenarioData?.id || scenarioId,
            label: scenarioData?.label || "Unknown Scenario",
            defaultQuestions: scenarioData?.defaultQuestions || {},
          };
        },
      );

      return scenarios;
    } else {
      // Log error for invalid format but continue silently
      return {};
    }
  }, [hasBackendData, interactiveScenariosTreeData]);

  // Merge scenarios with proper precedence, backend trumps everything
  const availableScenarios = useMemo(() => {
    const allScenarios: Record<string, ScenarioSelection> = {};

    // Add regular scenarios first (lowest priority)
    Object.assign(allScenarios, INTERACTIVE_SCENARIOS);

    // Add backend scenarios last (highest priority)
    if (hasBackendData && Object.keys(backendScenarios).length > 0) {
      Object.assign(allScenarios, backendScenarios);
    }

    return allScenarios;
  }, [hasBackendData, backendScenarios]);

  return availableScenarios;
}

/**
 * Custom hook to get the dialog tree for a specific interactive scenario.
 *
 * This hook:
 * 1. Gets available scenarios using useInteractiveScenario
 * 2. Finds the current scenario based on scenario_id
 * 3. Calculates the current dialog tree based on user message history
 *
 * @param scenarioId - The ID of the current scenario
 * @param userMessages - Array of user messages to calculate dialog tree state
 * @returns Dialog tree for the current step, or null if no scenario found
 */
export function useInteractiveScenarioDialogTree(
  scenarioId: string | undefined,
  userMessages: string[],
): DialogTree | null {
  const availableScenarios = useInteractiveScenario();

  // Find the current interactive scenario
  const interactiveScenario = useMemo(
    () => (scenarioId ? availableScenarios[scenarioId] : undefined),
    [availableScenarios, scenarioId],
  );

  // Calculate the current dialog tree based on user messages
  const dialogTree: DialogTree | null = useMemo(() => {
    if (!interactiveScenario?.defaultQuestions) {
      return {};
    }

    return calculateNextDialogTree(
      interactiveScenario.defaultQuestions,
      [...userMessages].reverse(), // Reverse to match original logic
    );
  }, [interactiveScenario, userMessages]);

  return dialogTree;
}
