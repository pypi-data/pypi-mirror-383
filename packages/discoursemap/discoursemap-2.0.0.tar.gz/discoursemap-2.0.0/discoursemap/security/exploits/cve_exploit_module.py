#!/usr/bin/env python3
"""
Discourse Security Scanner - CVE Exploit Module (Ruby Runner)

Runs Ruby-based CVE exploits for Discourse forums
Separated by year: 2022, 2023, 2024
"""

import json
import time
import os
import subprocess
import tempfile
from pathlib import Path

class CVEExploitModule:
    """Ruby-based CVE exploit runner for Discourse forums"""

    def __init__(self, scanner):
        self.scanner = scanner
        self.results = {
            'module_name': 'CVE Exploit Testing (Ruby Runner)',
            'target': scanner.target_url,
            'cve_tests': [],
            'exploitable_cves': [],
            'tests_performed': 0,
            'scan_time': 0,
            'ruby_exploits': {
                '2022': [],
                '2023': [],
                '2024': []
            }
        }
        self.start_time = time.time()
        self.ruby_exploits_dir = self._get_ruby_exploits_dir()

    def run(self):
        """Run Ruby-based CVE exploit testing"""
        self.scanner.log("Starting Ruby CVE exploit testing...")

        if not self.ruby_exploits_dir or not os.path.exists(self.ruby_exploits_dir):
            self.scanner.log("Ruby exploits directory not found", 'error')
            return self.results

        # Run Ruby exploits by year
        self._run_ruby_exploits_by_year('2022')
        self._run_ruby_exploits_by_year('2023')
        self._run_ruby_exploits_by_year('2024')

        self.results['scan_time'] = time.time() - self.start_time
        self.scanner.log(f"CVE exploit testing completed in {self.results['scan_time']:.2f} seconds")
        return self.results

    def _get_ruby_exploits_dir(self):
        """Get the Ruby exploits directory path"""
        # Get the project root directory
        current_dir = Path(__file__).parent.parent.parent
        ruby_dir = current_dir / 'ruby_exploits'
        return str(ruby_dir) if ruby_dir.exists() else None

    def _run_ruby_exploits_by_year(self, year):
        """Run Ruby exploits for a specific year"""
        self.scanner.log(f"Running {year} CVE exploits...")

        exploit_file = f"cve_{year}_exploits.rb"
        exploit_path = os.path.join(self.ruby_exploits_dir, exploit_file)

        if not os.path.exists(exploit_path):
            self.scanner.log(f"Ruby exploit file not found: {exploit_file}", 'warning')
            return

        try:
            # Execute Ruby exploit
            result = self._execute_ruby_exploit(exploit_path, year)

            if result['success']:
                self.scanner.log(f"{year} CVE exploits completed successfully")
                self.results['ruby_exploits'][year] = result['vulnerabilities']

                # Add to main results
                for vuln in result['vulnerabilities']:
                    if vuln.get('status') == 'VULNERABLE':
                        self.results['exploitable_cves'].append(vuln)
                    self.results['cve_tests'].append(vuln)

                self.results['tests_performed'] += len(result['vulnerabilities'])
            else:
                self.scanner.log(f"Failed to run {year} CVE exploits: {result['error']}", 'error')

        except Exception as e:
            self.scanner.log(f"Error running {year} CVE exploits: {str(e)}", 'error')

    def _execute_ruby_exploit(self, exploit_path, year):
        """Execute a Ruby exploit script"""
        try:
            # Create temporary output file for results
            with tempfile.NamedTemporaryFile(mode='w+', suffix='.json', delete=False) as temp_file:
                output_file = temp_file.name

            # Prepare Ruby command
            cmd = [
                'ruby',
                exploit_path,
                self.scanner.target_url,
                '--output',
                output_file
            ]

            self.scanner.log(f"Executing Ruby exploit: {exploit_path}", 'debug')

            # Execute Ruby script
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout
                cwd=self.ruby_exploits_dir
            )

            # Parse results
            result = self._parse_ruby_results(output_file, year, process)

            # Clean up temporary file
            try:
                os.unlink(output_file)
            except:
                pass

            return result

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': f'Ruby exploit {year} timed out after 5 minutes',
                'vulnerabilities': []
            }
        except FileNotFoundError:
            return {
                'success': False,
                'error': 'Ruby interpreter not found. Please install Ruby.',
                'vulnerabilities': []
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Failed to execute Ruby exploit {year}: {str(e)}',
                'vulnerabilities': []
            }

    def _parse_ruby_results(self, output_file, year, process_result):
        """Parse results from Ruby exploit execution"""
        vulnerabilities = []

        try:
            # Try to parse JSON output file first
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                with open(output_file, 'r') as f:
                    ruby_results = json.load(f)

                if isinstance(ruby_results, list):
                    for ruby_result in ruby_results:
                        vuln = self._convert_ruby_to_cve_result(ruby_result, year)
                        if vuln:
                            vulnerabilities.append(vuln)

            # If no JSON results, try to parse stdout
            if not vulnerabilities and process_result.stdout:
                vulnerabilities = self._parse_ruby_stdout(process_result.stdout, year)

            # Check for errors
            if process_result.returncode != 0:
                error_msg = process_result.stderr or 'Unknown error'
                self.scanner.log(f"Ruby exploit {year} returned error: {error_msg}", 'warning')

                if not vulnerabilities:
                    return {
                        'success': False,
                        'error': error_msg,
                        'vulnerabilities': []
                    }

            return {
                'success': True,
                'vulnerabilities': vulnerabilities
            }

        except Exception as e:
            return {
                'success': False,
                'error': f'Failed to parse Ruby results for {year}: {str(e)}',
                'vulnerabilities': []
            }

    def _convert_ruby_to_cve_result(self, ruby_result, year):
        """Convert Ruby exploit result to CVE result format"""
        try:
            return {
                'cve_id': ruby_result.get('cve_id', f'CVE-{year}-UNKNOWN'),
                'status': ruby_result.get('status', 'UNKNOWN'),
                'description': ruby_result.get('description', 'No description'),
                'url': ruby_result.get('target', self.scanner.target_url),
                'details': ruby_result.get('details', {}),
                'timestamp': ruby_result.get('timestamp', time.time()),
                'exploit_year': year
            }
        except Exception:
            return None

    def _parse_ruby_stdout(self, stdout, year):
        """Parse Ruby stdout for vulnerability information"""
        results = []

        try:
            lines = stdout.split('\n')
            current_cve = None

            for line in lines:
                line = line.strip()

                # Look for CVE test results
                if '[RESULT]' in line:
                    parts = line.split(': ', 2)
                    if len(parts) >= 3:
                        cve_id = parts[1].split(':')[0].strip()
                        status = parts[1].split(':')[1].strip() if ':' in parts[1] else 'UNKNOWN'
                        description = parts[2] if len(parts) > 2 else 'No description'

                        result = {
                            'cve_id': cve_id,
                            'status': status,
                            'description': description,
                            'url': self.scanner.target_url,
                            'details': {},
                            'timestamp': time.time(),
                            'exploit_year': year
                        }
                        results.append(result)

        except Exception as e:
            self.scanner.log(f"Error parsing Ruby stdout for {year}: {str(e)}", 'debug')

        return results