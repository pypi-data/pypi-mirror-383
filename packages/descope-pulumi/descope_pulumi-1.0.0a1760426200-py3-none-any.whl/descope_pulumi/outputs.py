# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ProjectApplications',
    'ProjectApplicationsOidcApplication',
    'ProjectApplicationsSamlApplication',
    'ProjectApplicationsSamlApplicationAttributeMapping',
    'ProjectApplicationsSamlApplicationDynamicConfiguration',
    'ProjectApplicationsSamlApplicationManualConfiguration',
    'ProjectAttributes',
    'ProjectAttributesTenant',
    'ProjectAttributesTenantAuthorization',
    'ProjectAttributesUser',
    'ProjectAttributesUserWidgetAuthorization',
    'ProjectAuthentication',
    'ProjectAuthenticationEmbeddedLink',
    'ProjectAuthenticationEnchantedLink',
    'ProjectAuthenticationEnchantedLinkEmailService',
    'ProjectAuthenticationEnchantedLinkEmailServiceTemplate',
    'ProjectAuthenticationMagicLink',
    'ProjectAuthenticationMagicLinkEmailService',
    'ProjectAuthenticationMagicLinkEmailServiceTemplate',
    'ProjectAuthenticationMagicLinkTextService',
    'ProjectAuthenticationMagicLinkTextServiceTemplate',
    'ProjectAuthenticationOauth',
    'ProjectAuthenticationOauthCustom',
    'ProjectAuthenticationOauthCustomProviderTokenManagement',
    'ProjectAuthenticationOauthSystem',
    'ProjectAuthenticationOauthSystemApple',
    'ProjectAuthenticationOauthSystemAppleProviderTokenManagement',
    'ProjectAuthenticationOauthSystemDiscord',
    'ProjectAuthenticationOauthSystemDiscordProviderTokenManagement',
    'ProjectAuthenticationOauthSystemFacebook',
    'ProjectAuthenticationOauthSystemFacebookProviderTokenManagement',
    'ProjectAuthenticationOauthSystemGithub',
    'ProjectAuthenticationOauthSystemGithubProviderTokenManagement',
    'ProjectAuthenticationOauthSystemGitlab',
    'ProjectAuthenticationOauthSystemGitlabProviderTokenManagement',
    'ProjectAuthenticationOauthSystemGoogle',
    'ProjectAuthenticationOauthSystemGoogleProviderTokenManagement',
    'ProjectAuthenticationOauthSystemLinkedin',
    'ProjectAuthenticationOauthSystemLinkedinProviderTokenManagement',
    'ProjectAuthenticationOauthSystemMicrosoft',
    'ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagement',
    'ProjectAuthenticationOauthSystemSlack',
    'ProjectAuthenticationOauthSystemSlackProviderTokenManagement',
    'ProjectAuthenticationOtp',
    'ProjectAuthenticationOtpEmailService',
    'ProjectAuthenticationOtpEmailServiceTemplate',
    'ProjectAuthenticationOtpTextService',
    'ProjectAuthenticationOtpTextServiceTemplate',
    'ProjectAuthenticationOtpVoiceService',
    'ProjectAuthenticationOtpVoiceServiceTemplate',
    'ProjectAuthenticationPasskeys',
    'ProjectAuthenticationPassword',
    'ProjectAuthenticationPasswordEmailService',
    'ProjectAuthenticationPasswordEmailServiceTemplate',
    'ProjectAuthenticationSso',
    'ProjectAuthenticationSsoSsoSuiteSettings',
    'ProjectAuthenticationTotp',
    'ProjectAuthorization',
    'ProjectAuthorizationPermission',
    'ProjectAuthorizationRole',
    'ProjectConnectors',
    'ProjectConnectorsAbuseipdb',
    'ProjectConnectorsAmplitude',
    'ProjectConnectorsAuditWebhook',
    'ProjectConnectorsAuditWebhookAuditFilter',
    'ProjectConnectorsAuditWebhookAuthentication',
    'ProjectConnectorsAuditWebhookAuthenticationApiKey',
    'ProjectConnectorsAuditWebhookAuthenticationBasic',
    'ProjectConnectorsAwsS3',
    'ProjectConnectorsAwsS3AuditFilter',
    'ProjectConnectorsAwsTranslate',
    'ProjectConnectorsBitsight',
    'ProjectConnectorsDatadog',
    'ProjectConnectorsDatadogAuditFilter',
    'ProjectConnectorsDevrevGrow',
    'ProjectConnectorsDocebo',
    'ProjectConnectorsEightByEightViber',
    'ProjectConnectorsEightByEightWhatsapp',
    'ProjectConnectorsElephant',
    'ProjectConnectorsExternalTokenHttp',
    'ProjectConnectorsExternalTokenHttpAuthentication',
    'ProjectConnectorsExternalTokenHttpAuthenticationApiKey',
    'ProjectConnectorsExternalTokenHttpAuthenticationBasic',
    'ProjectConnectorsFingerprint',
    'ProjectConnectorsFingerprintDescope',
    'ProjectConnectorsFirebaseAdmin',
    'ProjectConnectorsForter',
    'ProjectConnectorsGenericEmailGateway',
    'ProjectConnectorsGenericEmailGatewayAuthentication',
    'ProjectConnectorsGenericEmailGatewayAuthenticationApiKey',
    'ProjectConnectorsGenericEmailGatewayAuthenticationBasic',
    'ProjectConnectorsGenericSmsGateway',
    'ProjectConnectorsGenericSmsGatewayAuthentication',
    'ProjectConnectorsGenericSmsGatewayAuthenticationApiKey',
    'ProjectConnectorsGenericSmsGatewayAuthenticationBasic',
    'ProjectConnectorsGoogleCloudLogging',
    'ProjectConnectorsGoogleCloudLoggingAuditFilter',
    'ProjectConnectorsGoogleCloudTranslation',
    'ProjectConnectorsGoogleMapsPlace',
    'ProjectConnectorsHibp',
    'ProjectConnectorsHttp',
    'ProjectConnectorsHttpAuthentication',
    'ProjectConnectorsHttpAuthenticationApiKey',
    'ProjectConnectorsHttpAuthenticationBasic',
    'ProjectConnectorsHubspot',
    'ProjectConnectorsIncode',
    'ProjectConnectorsIntercom',
    'ProjectConnectorsLokalise',
    'ProjectConnectorsMparticle',
    'ProjectConnectorsNewrelic',
    'ProjectConnectorsNewrelicAuditFilter',
    'ProjectConnectorsRadar',
    'ProjectConnectorsRecaptcha',
    'ProjectConnectorsRecaptchaEnterprise',
    'ProjectConnectorsRekognition',
    'ProjectConnectorsSalesforce',
    'ProjectConnectorsSalesforceMarketingCloud',
    'ProjectConnectorsSardine',
    'ProjectConnectorsSe',
    'ProjectConnectorsSeSender',
    'ProjectConnectorsSegment',
    'ProjectConnectorsSendgrid',
    'ProjectConnectorsSendgridAuthentication',
    'ProjectConnectorsSendgridSender',
    'ProjectConnectorsSlack',
    'ProjectConnectorsSmartling',
    'ProjectConnectorsSmtp',
    'ProjectConnectorsSmtpAuthentication',
    'ProjectConnectorsSmtpSender',
    'ProjectConnectorsSmtpServer',
    'ProjectConnectorsSn',
    'ProjectConnectorsSumologic',
    'ProjectConnectorsSumologicAuditFilter',
    'ProjectConnectorsSupabase',
    'ProjectConnectorsTelesign',
    'ProjectConnectorsTraceable',
    'ProjectConnectorsTurnstile',
    'ProjectConnectorsTwilioCore',
    'ProjectConnectorsTwilioCoreAuthentication',
    'ProjectConnectorsTwilioCoreSenders',
    'ProjectConnectorsTwilioCoreSendersSms',
    'ProjectConnectorsTwilioCoreSendersVoice',
    'ProjectConnectorsTwilioVerify',
    'ProjectConnectorsTwilioVerifyAuthentication',
    'ProjectFlows',
    'ProjectInviteSettings',
    'ProjectInviteSettingsEmailService',
    'ProjectInviteSettingsEmailServiceTemplate',
    'ProjectJwtTemplates',
    'ProjectJwtTemplatesAccessKeyTemplate',
    'ProjectJwtTemplatesUserTemplate',
    'ProjectProjectSettings',
    'ProjectProjectSettingsSessionMigration',
    'ProjectStyles',
    'ProjectWidgets',
]

@pulumi.output_type
class ProjectApplications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oidcApplications":
            suggest = "oidc_applications"
        elif key == "samlApplications":
            suggest = "saml_applications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApplications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApplications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApplications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oidc_applications: Optional[Sequence['outputs.ProjectApplicationsOidcApplication']] = None,
                 saml_applications: Optional[Sequence['outputs.ProjectApplicationsSamlApplication']] = None):
        """
        :param Sequence['ProjectApplicationsOidcApplicationArgs'] oidc_applications: Applications using OpenID Connect (OIDC) for authentication.
        :param Sequence['ProjectApplicationsSamlApplicationArgs'] saml_applications: Applications using SAML for authentication.
        """
        if oidc_applications is not None:
            pulumi.set(__self__, "oidc_applications", oidc_applications)
        if saml_applications is not None:
            pulumi.set(__self__, "saml_applications", saml_applications)

    @_builtins.property
    @pulumi.getter(name="oidcApplications")
    def oidc_applications(self) -> Optional[Sequence['outputs.ProjectApplicationsOidcApplication']]:
        """
        Applications using OpenID Connect (OIDC) for authentication.
        """
        return pulumi.get(self, "oidc_applications")

    @_builtins.property
    @pulumi.getter(name="samlApplications")
    def saml_applications(self) -> Optional[Sequence['outputs.ProjectApplicationsSamlApplication']]:
        """
        Applications using SAML for authentication.
        """
        return pulumi.get(self, "saml_applications")


@pulumi.output_type
class ProjectApplicationsOidcApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceAuthentication":
            suggest = "force_authentication"
        elif key == "loginPageUrl":
            suggest = "login_page_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApplicationsOidcApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApplicationsOidcApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApplicationsOidcApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 claims: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 force_authentication: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 login_page_url: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A name for the OIDC application.
        :param Sequence[_builtins.str] claims: A list of supported claims. e.g. `sub`, `email`, `exp`.
        :param _builtins.str description: A description for the OIDC application.
        :param _builtins.bool disabled: Whether the application should be enabled or disabled.
        :param _builtins.bool force_authentication: This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        :param _builtins.str id: An optional identifier for the OIDC application.
        :param _builtins.str login_page_url: The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param _builtins.str logo: A logo for the OIDC application. Should be a hosted image URL.
        """
        pulumi.set(__self__, "name", name)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if force_authentication is not None:
            pulumi.set(__self__, "force_authentication", force_authentication)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if login_page_url is not None:
            pulumi.set(__self__, "login_page_url", login_page_url)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for the OIDC application.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def claims(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of supported claims. e.g. `sub`, `email`, `exp`.
        """
        return pulumi.get(self, "claims")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for the OIDC application.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the application should be enabled or disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="forceAuthentication")
    def force_authentication(self) -> Optional[_builtins.bool]:
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        return pulumi.get(self, "force_authentication")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        An optional identifier for the OIDC application.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="loginPageUrl")
    def login_page_url(self) -> Optional[_builtins.str]:
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "login_page_url")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        A logo for the OIDC application. Should be a hosted image URL.
        """
        return pulumi.get(self, "logo")


@pulumi.output_type
class ProjectApplicationsSamlApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acsAllowedCallbackUrls":
            suggest = "acs_allowed_callback_urls"
        elif key == "attributeMappings":
            suggest = "attribute_mappings"
        elif key == "defaultRelayState":
            suggest = "default_relay_state"
        elif key == "dynamicConfiguration":
            suggest = "dynamic_configuration"
        elif key == "forceAuthentication":
            suggest = "force_authentication"
        elif key == "loginPageUrl":
            suggest = "login_page_url"
        elif key == "manualConfiguration":
            suggest = "manual_configuration"
        elif key == "subjectNameIdFormat":
            suggest = "subject_name_id_format"
        elif key == "subjectNameIdType":
            suggest = "subject_name_id_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApplicationsSamlApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApplicationsSamlApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApplicationsSamlApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 acs_allowed_callback_urls: Optional[Sequence[_builtins.str]] = None,
                 attribute_mappings: Optional[Sequence['outputs.ProjectApplicationsSamlApplicationAttributeMapping']] = None,
                 default_relay_state: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 dynamic_configuration: Optional['outputs.ProjectApplicationsSamlApplicationDynamicConfiguration'] = None,
                 force_authentication: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 login_page_url: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manual_configuration: Optional['outputs.ProjectApplicationsSamlApplicationManualConfiguration'] = None,
                 subject_name_id_format: Optional[_builtins.str] = None,
                 subject_name_id_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A name for the SAML application.
        :param Sequence[_builtins.str] acs_allowed_callback_urls: A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        :param Sequence['ProjectApplicationsSamlApplicationAttributeMappingArgs'] attribute_mappings: The `AttributeMapping` object. Read the description below.
        :param _builtins.str default_relay_state: The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        :param _builtins.str description: A description for the SAML application.
        :param _builtins.bool disabled: Whether the application should be enabled or disabled.
        :param 'ProjectApplicationsSamlApplicationDynamicConfigurationArgs' dynamic_configuration: The `DynamicConfiguration` object. Read the description below.
        :param _builtins.bool force_authentication: This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        :param _builtins.str id: An optional identifier for the SAML application.
        :param _builtins.str login_page_url: The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param _builtins.str logo: A logo for the SAML application. Should be a hosted image URL.
        :param 'ProjectApplicationsSamlApplicationManualConfigurationArgs' manual_configuration: The `ManualConfiguration` object. Read the description below.
        :param _builtins.str subject_name_id_format: The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param _builtins.str subject_name_id_type: The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        pulumi.set(__self__, "name", name)
        if acs_allowed_callback_urls is not None:
            pulumi.set(__self__, "acs_allowed_callback_urls", acs_allowed_callback_urls)
        if attribute_mappings is not None:
            pulumi.set(__self__, "attribute_mappings", attribute_mappings)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dynamic_configuration is not None:
            pulumi.set(__self__, "dynamic_configuration", dynamic_configuration)
        if force_authentication is not None:
            pulumi.set(__self__, "force_authentication", force_authentication)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if login_page_url is not None:
            pulumi.set(__self__, "login_page_url", login_page_url)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manual_configuration is not None:
            pulumi.set(__self__, "manual_configuration", manual_configuration)
        if subject_name_id_format is not None:
            pulumi.set(__self__, "subject_name_id_format", subject_name_id_format)
        if subject_name_id_type is not None:
            pulumi.set(__self__, "subject_name_id_type", subject_name_id_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for the SAML application.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="acsAllowedCallbackUrls")
    def acs_allowed_callback_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        """
        return pulumi.get(self, "acs_allowed_callback_urls")

    @_builtins.property
    @pulumi.getter(name="attributeMappings")
    def attribute_mappings(self) -> Optional[Sequence['outputs.ProjectApplicationsSamlApplicationAttributeMapping']]:
        """
        The `AttributeMapping` object. Read the description below.
        """
        return pulumi.get(self, "attribute_mappings")

    @_builtins.property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[_builtins.str]:
        """
        The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        """
        return pulumi.get(self, "default_relay_state")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for the SAML application.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the application should be enabled or disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="dynamicConfiguration")
    def dynamic_configuration(self) -> Optional['outputs.ProjectApplicationsSamlApplicationDynamicConfiguration']:
        """
        The `DynamicConfiguration` object. Read the description below.
        """
        return pulumi.get(self, "dynamic_configuration")

    @_builtins.property
    @pulumi.getter(name="forceAuthentication")
    def force_authentication(self) -> Optional[_builtins.bool]:
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        return pulumi.get(self, "force_authentication")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        An optional identifier for the SAML application.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="loginPageUrl")
    def login_page_url(self) -> Optional[_builtins.str]:
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "login_page_url")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        A logo for the SAML application. Should be a hosted image URL.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manualConfiguration")
    def manual_configuration(self) -> Optional['outputs.ProjectApplicationsSamlApplicationManualConfiguration']:
        """
        The `ManualConfiguration` object. Read the description below.
        """
        return pulumi.get(self, "manual_configuration")

    @_builtins.property
    @pulumi.getter(name="subjectNameIdFormat")
    def subject_name_id_format(self) -> Optional[_builtins.str]:
        """
        The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "subject_name_id_format")

    @_builtins.property
    @pulumi.getter(name="subjectNameIdType")
    def subject_name_id_type(self) -> Optional[_builtins.str]:
        """
        The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "subject_name_id_type")


@pulumi.output_type
class ProjectApplicationsSamlApplicationAttributeMapping(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the attribute.
        :param _builtins.str value: The value of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the attribute.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectApplicationsSamlApplicationDynamicConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataUrl":
            suggest = "metadata_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApplicationsSamlApplicationDynamicConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApplicationsSamlApplicationDynamicConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApplicationsSamlApplicationDynamicConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_url: _builtins.str):
        """
        :param _builtins.str metadata_url: The metadata URL when retrieving the connection details dynamically.
        """
        pulumi.set(__self__, "metadata_url", metadata_url)

    @_builtins.property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> _builtins.str:
        """
        The metadata URL when retrieving the connection details dynamically.
        """
        return pulumi.get(self, "metadata_url")


@pulumi.output_type
class ProjectApplicationsSamlApplicationManualConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acsUrl":
            suggest = "acs_url"
        elif key == "entityId":
            suggest = "entity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApplicationsSamlApplicationManualConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApplicationsSamlApplicationManualConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApplicationsSamlApplicationManualConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acs_url: _builtins.str,
                 certificate: _builtins.str,
                 entity_id: _builtins.str):
        """
        :param _builtins.str acs_url: Enter the `ACS URL` from the SP.
        :param _builtins.str certificate: Enter the `Certificate` from the SP.
        :param _builtins.str entity_id: Enter the `Entity Id` from the SP.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "entity_id", entity_id)

    @_builtins.property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> _builtins.str:
        """
        Enter the `ACS URL` from the SP.
        """
        return pulumi.get(self, "acs_url")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> _builtins.str:
        """
        Enter the `Certificate` from the SP.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> _builtins.str:
        """
        Enter the `Entity Id` from the SP.
        """
        return pulumi.get(self, "entity_id")


@pulumi.output_type
class ProjectAttributes(dict):
    def __init__(__self__, *,
                 tenants: Optional[Sequence['outputs.ProjectAttributesTenant']] = None,
                 users: Optional[Sequence['outputs.ProjectAttributesUser']] = None):
        """
        :param Sequence['ProjectAttributesTenantArgs'] tenants: A list of `TenantAttribute`. Read the description below.
        :param Sequence['ProjectAttributesUserArgs'] users: A list of `UserAttribute`. Read the description below.
        """
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[Sequence['outputs.ProjectAttributesTenant']]:
        """
        A list of `TenantAttribute`. Read the description below.
        """
        return pulumi.get(self, "tenants")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.ProjectAttributesUser']]:
        """
        A list of `UserAttribute`. Read the description below.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class ProjectAttributesTenant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectOptions":
            suggest = "select_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAttributesTenant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAttributesTenant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAttributesTenant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 authorization: Optional['outputs.ProjectAttributesTenantAuthorization'] = None,
                 id: Optional[_builtins.str] = None,
                 select_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The name of the attribute. This value is called `Display Name` in the Descope console.
        :param _builtins.str type: The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        :param 'ProjectAttributesTenantAuthorizationArgs' authorization: Determines the required permissions for this tenant.
        :param _builtins.str id: An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        :param Sequence[_builtins.str] select_options: When the attribute type is "multiselect". A list of options to choose from.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if select_options is not None:
            pulumi.set(__self__, "select_options", select_options)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the attribute. This value is called `Display Name` in the Descope console.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.ProjectAttributesTenantAuthorization']:
        """
        Determines the required permissions for this tenant.
        """
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="selectOptions")
    def select_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        When the attribute type is "multiselect". A list of options to choose from.
        """
        return pulumi.get(self, "select_options")


@pulumi.output_type
class ProjectAttributesTenantAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewPermissions":
            suggest = "view_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAttributesTenantAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAttributesTenantAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAttributesTenantAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view_permissions: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] view_permissions: Determines the required permissions for this tenant.
        """
        if view_permissions is not None:
            pulumi.set(__self__, "view_permissions", view_permissions)

    @_builtins.property
    @pulumi.getter(name="viewPermissions")
    def view_permissions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Determines the required permissions for this tenant.
        """
        return pulumi.get(self, "view_permissions")


@pulumi.output_type
class ProjectAttributesUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectOptions":
            suggest = "select_options"
        elif key == "widgetAuthorization":
            suggest = "widget_authorization"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAttributesUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAttributesUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAttributesUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 select_options: Optional[Sequence[_builtins.str]] = None,
                 widget_authorization: Optional['outputs.ProjectAttributesUserWidgetAuthorization'] = None):
        """
        :param _builtins.str name: The name of the attribute. This value is called `Display Name` in the Descope console.
        :param _builtins.str type: The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        :param _builtins.str id: An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        :param Sequence[_builtins.str] select_options: When the attribute type is "multiselect". A list of options to choose from.
        :param 'ProjectAttributesUserWidgetAuthorizationArgs' widget_authorization: Determines the permissions users are required to have to access this attribute in the user management widget.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if select_options is not None:
            pulumi.set(__self__, "select_options", select_options)
        if widget_authorization is not None:
            pulumi.set(__self__, "widget_authorization", widget_authorization)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the attribute. This value is called `Display Name` in the Descope console.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="selectOptions")
    def select_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        When the attribute type is "multiselect". A list of options to choose from.
        """
        return pulumi.get(self, "select_options")

    @_builtins.property
    @pulumi.getter(name="widgetAuthorization")
    def widget_authorization(self) -> Optional['outputs.ProjectAttributesUserWidgetAuthorization']:
        """
        Determines the permissions users are required to have to access this attribute in the user management widget.
        """
        return pulumi.get(self, "widget_authorization")


@pulumi.output_type
class ProjectAttributesUserWidgetAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "editPermissions":
            suggest = "edit_permissions"
        elif key == "viewPermissions":
            suggest = "view_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAttributesUserWidgetAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAttributesUserWidgetAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAttributesUserWidgetAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 edit_permissions: Optional[Sequence[_builtins.str]] = None,
                 view_permissions: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] edit_permissions: The permissions users are required to have to edit this attribute in the user management widget.
        :param Sequence[_builtins.str] view_permissions: The permissions users are required to have to view this attribute in the user management widget.
        """
        if edit_permissions is not None:
            pulumi.set(__self__, "edit_permissions", edit_permissions)
        if view_permissions is not None:
            pulumi.set(__self__, "view_permissions", view_permissions)

    @_builtins.property
    @pulumi.getter(name="editPermissions")
    def edit_permissions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The permissions users are required to have to edit this attribute in the user management widget.
        """
        return pulumi.get(self, "edit_permissions")

    @_builtins.property
    @pulumi.getter(name="viewPermissions")
    def view_permissions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The permissions users are required to have to view this attribute in the user management widget.
        """
        return pulumi.get(self, "view_permissions")


@pulumi.output_type
class ProjectAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddedLink":
            suggest = "embedded_link"
        elif key == "enchantedLink":
            suggest = "enchanted_link"
        elif key == "magicLink":
            suggest = "magic_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedded_link: Optional['outputs.ProjectAuthenticationEmbeddedLink'] = None,
                 enchanted_link: Optional['outputs.ProjectAuthenticationEnchantedLink'] = None,
                 magic_link: Optional['outputs.ProjectAuthenticationMagicLink'] = None,
                 oauth: Optional['outputs.ProjectAuthenticationOauth'] = None,
                 otp: Optional['outputs.ProjectAuthenticationOtp'] = None,
                 passkeys: Optional['outputs.ProjectAuthenticationPasskeys'] = None,
                 password: Optional['outputs.ProjectAuthenticationPassword'] = None,
                 sso: Optional['outputs.ProjectAuthenticationSso'] = None,
                 totp: Optional['outputs.ProjectAuthenticationTotp'] = None):
        """
        :param 'ProjectAuthenticationEmbeddedLinkArgs' embedded_link: Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        :param 'ProjectAuthenticationEnchantedLinkArgs' enchanted_link: An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        :param 'ProjectAuthenticationMagicLinkArgs' magic_link: An authentication method where a user receives a unique link via email to log in.
        :param 'ProjectAuthenticationOauthArgs' oauth: Authentication using Open Authorization, which allows users to authenticate with various external services.
        :param 'ProjectAuthenticationOtpArgs' otp: A dynamically generated set of numbers, granting the user one-time access.
        :param 'ProjectAuthenticationPasskeysArgs' passkeys: Device-based passwordless authentication, using fingerprint, face scan, and more.
        :param 'ProjectAuthenticationPasswordArgs' password: The classic username and password combination used for authentication.
        :param 'ProjectAuthenticationSsoArgs' sso: Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        :param 'ProjectAuthenticationTotpArgs' totp: A one-time code generated for the user using a shared secret and time.
        """
        if embedded_link is not None:
            pulumi.set(__self__, "embedded_link", embedded_link)
        if enchanted_link is not None:
            pulumi.set(__self__, "enchanted_link", enchanted_link)
        if magic_link is not None:
            pulumi.set(__self__, "magic_link", magic_link)
        if oauth is not None:
            pulumi.set(__self__, "oauth", oauth)
        if otp is not None:
            pulumi.set(__self__, "otp", otp)
        if passkeys is not None:
            pulumi.set(__self__, "passkeys", passkeys)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if sso is not None:
            pulumi.set(__self__, "sso", sso)
        if totp is not None:
            pulumi.set(__self__, "totp", totp)

    @_builtins.property
    @pulumi.getter(name="embeddedLink")
    def embedded_link(self) -> Optional['outputs.ProjectAuthenticationEmbeddedLink']:
        """
        Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        """
        return pulumi.get(self, "embedded_link")

    @_builtins.property
    @pulumi.getter(name="enchantedLink")
    def enchanted_link(self) -> Optional['outputs.ProjectAuthenticationEnchantedLink']:
        """
        An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        """
        return pulumi.get(self, "enchanted_link")

    @_builtins.property
    @pulumi.getter(name="magicLink")
    def magic_link(self) -> Optional['outputs.ProjectAuthenticationMagicLink']:
        """
        An authentication method where a user receives a unique link via email to log in.
        """
        return pulumi.get(self, "magic_link")

    @_builtins.property
    @pulumi.getter
    def oauth(self) -> Optional['outputs.ProjectAuthenticationOauth']:
        """
        Authentication using Open Authorization, which allows users to authenticate with various external services.
        """
        return pulumi.get(self, "oauth")

    @_builtins.property
    @pulumi.getter
    def otp(self) -> Optional['outputs.ProjectAuthenticationOtp']:
        """
        A dynamically generated set of numbers, granting the user one-time access.
        """
        return pulumi.get(self, "otp")

    @_builtins.property
    @pulumi.getter
    def passkeys(self) -> Optional['outputs.ProjectAuthenticationPasskeys']:
        """
        Device-based passwordless authentication, using fingerprint, face scan, and more.
        """
        return pulumi.get(self, "passkeys")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.ProjectAuthenticationPassword']:
        """
        The classic username and password combination used for authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def sso(self) -> Optional['outputs.ProjectAuthenticationSso']:
        """
        Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        """
        return pulumi.get(self, "sso")

    @_builtins.property
    @pulumi.getter
    def totp(self) -> Optional['outputs.ProjectAuthenticationTotp']:
        """
        A one-time code generated for the user using a shared secret and time.
        """
        return pulumi.get(self, "totp")


@pulumi.output_type
class ProjectAuthenticationEmbeddedLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationTime":
            suggest = "expiration_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationEmbeddedLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationEmbeddedLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationEmbeddedLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 expiration_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str expiration_time: How long the embedded link remains valid before it expires.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[_builtins.str]:
        """
        How long the embedded link remains valid before it expires.
        """
        return pulumi.get(self, "expiration_time")


@pulumi.output_type
class ProjectAuthenticationEnchantedLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailService":
            suggest = "email_service"
        elif key == "expirationTime":
            suggest = "expiration_time"
        elif key == "redirectUrl":
            suggest = "redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationEnchantedLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationEnchantedLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationEnchantedLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 email_service: Optional['outputs.ProjectAuthenticationEnchantedLinkEmailService'] = None,
                 expiration_time: Optional[_builtins.str] = None,
                 redirect_url: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param 'ProjectAuthenticationEnchantedLinkEmailServiceArgs' email_service: Settings related to sending emails as part of the enchanted link authentication.
        :param _builtins.str expiration_time: How long the enchanted link remains valid before it expires.
        :param _builtins.str redirect_url: The URL to redirect users to after they log in using the enchanted link.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional['outputs.ProjectAuthenticationEnchantedLinkEmailService']:
        """
        Settings related to sending emails as part of the enchanted link authentication.
        """
        return pulumi.get(self, "email_service")

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[_builtins.str]:
        """
        How long the enchanted link remains valid before it expires.
        """
        return pulumi.get(self, "expiration_time")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        The URL to redirect users to after they log in using the enchanted link.
        """
        return pulumi.get(self, "redirect_url")


@pulumi.output_type
class ProjectAuthenticationEnchantedLinkEmailService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectAuthenticationEnchantedLinkEmailServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the email connector to use for sending emails.
        :param Sequence['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs'] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectAuthenticationEnchantedLinkEmailServiceTemplate']]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectAuthenticationEnchantedLinkEmailServiceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "plainTextBody":
            suggest = "plain_text_body"
        elif key == "usePlainTextBody":
            suggest = "use_plain_text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationEnchantedLinkEmailServiceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationEnchantedLinkEmailServiceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationEnchantedLinkEmailServiceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subject: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 html_body: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 plain_text_body: Optional[_builtins.str] = None,
                 use_plain_text_body: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name for this email template.
        :param _builtins.str subject: Subject line of the email message.
        :param _builtins.bool active: Whether this email template is currently active and in use.
        :param _builtins.str html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param _builtins.str plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param _builtins.bool use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[_builtins.str]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[_builtins.str]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[_builtins.bool]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")


@pulumi.output_type
class ProjectAuthenticationMagicLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailService":
            suggest = "email_service"
        elif key == "expirationTime":
            suggest = "expiration_time"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "textService":
            suggest = "text_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationMagicLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationMagicLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationMagicLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 email_service: Optional['outputs.ProjectAuthenticationMagicLinkEmailService'] = None,
                 expiration_time: Optional[_builtins.str] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 text_service: Optional['outputs.ProjectAuthenticationMagicLinkTextService'] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param 'ProjectAuthenticationMagicLinkEmailServiceArgs' email_service: Settings related to sending emails as part of the magic link authentication.
        :param _builtins.str expiration_time: How long the magic link remains valid before it expires.
        :param _builtins.str redirect_url: The URL to redirect users to after they log in using the magic link.
        :param 'ProjectAuthenticationMagicLinkTextServiceArgs' text_service: Settings related to sending SMS messages as part of the magic link authentication.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if text_service is not None:
            pulumi.set(__self__, "text_service", text_service)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional['outputs.ProjectAuthenticationMagicLinkEmailService']:
        """
        Settings related to sending emails as part of the magic link authentication.
        """
        return pulumi.get(self, "email_service")

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[_builtins.str]:
        """
        How long the magic link remains valid before it expires.
        """
        return pulumi.get(self, "expiration_time")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        The URL to redirect users to after they log in using the magic link.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="textService")
    def text_service(self) -> Optional['outputs.ProjectAuthenticationMagicLinkTextService']:
        """
        Settings related to sending SMS messages as part of the magic link authentication.
        """
        return pulumi.get(self, "text_service")


@pulumi.output_type
class ProjectAuthenticationMagicLinkEmailService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectAuthenticationMagicLinkEmailServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the email connector to use for sending emails.
        :param Sequence['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs'] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectAuthenticationMagicLinkEmailServiceTemplate']]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectAuthenticationMagicLinkEmailServiceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "plainTextBody":
            suggest = "plain_text_body"
        elif key == "usePlainTextBody":
            suggest = "use_plain_text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationMagicLinkEmailServiceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationMagicLinkEmailServiceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationMagicLinkEmailServiceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subject: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 html_body: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 plain_text_body: Optional[_builtins.str] = None,
                 use_plain_text_body: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name for this email template.
        :param _builtins.str subject: Subject line of the email message.
        :param _builtins.bool active: Whether this email template is currently active and in use.
        :param _builtins.str html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param _builtins.str plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param _builtins.bool use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[_builtins.str]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[_builtins.str]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[_builtins.bool]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")


@pulumi.output_type
class ProjectAuthenticationMagicLinkTextService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectAuthenticationMagicLinkTextServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the SMS/text connector to use for sending text messages.
        :param Sequence['ProjectAuthenticationMagicLinkTextServiceTemplateArgs'] templates: A list of text message templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the SMS/text connector to use for sending text messages.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectAuthenticationMagicLinkTextServiceTemplate']]:
        """
        A list of text message templates for different authentication flows.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectAuthenticationMagicLinkTextServiceTemplate(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 name: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str body: The content of the text message.
        :param _builtins.str name: Unique name for this text template.
        :param _builtins.bool active: Whether this text template is currently active and in use.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The content of the text message.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this text template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this text template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectAuthenticationOauth(dict):
    def __init__(__self__, *,
                 custom: Optional[Mapping[str, 'outputs.ProjectAuthenticationOauthCustom']] = None,
                 disabled: Optional[_builtins.bool] = None,
                 system: Optional['outputs.ProjectAuthenticationOauthSystem'] = None):
        """
        :param Mapping[str, 'ProjectAuthenticationOauthCustomArgs'] custom: Custom OAuth providers configured for this project.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param 'ProjectAuthenticationOauthSystemArgs' system: Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if system is not None:
            pulumi.set(__self__, "system", system)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[Mapping[str, 'outputs.ProjectAuthenticationOauthCustom']]:
        """
        Custom OAuth providers configured for this project.
        """
        return pulumi.get(self, "custom")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional['outputs.ProjectAuthenticationOauthSystem']:
        """
        Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
        return pulumi.get(self, "system")


@pulumi.output_type
class ProjectAuthenticationOauthCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthCustomProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthCustomProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthCustomProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthCustomProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystem(dict):
    def __init__(__self__, *,
                 apple: Optional['outputs.ProjectAuthenticationOauthSystemApple'] = None,
                 discord: Optional['outputs.ProjectAuthenticationOauthSystemDiscord'] = None,
                 facebook: Optional['outputs.ProjectAuthenticationOauthSystemFacebook'] = None,
                 github: Optional['outputs.ProjectAuthenticationOauthSystemGithub'] = None,
                 gitlab: Optional['outputs.ProjectAuthenticationOauthSystemGitlab'] = None,
                 google: Optional['outputs.ProjectAuthenticationOauthSystemGoogle'] = None,
                 linkedin: Optional['outputs.ProjectAuthenticationOauthSystemLinkedin'] = None,
                 microsoft: Optional['outputs.ProjectAuthenticationOauthSystemMicrosoft'] = None,
                 slack: Optional['outputs.ProjectAuthenticationOauthSystemSlack'] = None):
        """
        :param 'ProjectAuthenticationOauthSystemAppleArgs' apple: Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        :param 'ProjectAuthenticationOauthSystemDiscordArgs' discord: Discord's OAuth provider, allowing users to authenticate with their Discord account.
        :param 'ProjectAuthenticationOauthSystemFacebookArgs' facebook: Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        :param 'ProjectAuthenticationOauthSystemGithubArgs' github: GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        :param 'ProjectAuthenticationOauthSystemGitlabArgs' gitlab: GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        :param 'ProjectAuthenticationOauthSystemGoogleArgs' google: Google's OAuth provider, allowing users to authenticate with their Google account.
        :param 'ProjectAuthenticationOauthSystemLinkedinArgs' linkedin: LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        :param 'ProjectAuthenticationOauthSystemMicrosoftArgs' microsoft: Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        :param 'ProjectAuthenticationOauthSystemSlackArgs' slack: Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if discord is not None:
            pulumi.set(__self__, "discord", discord)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if linkedin is not None:
            pulumi.set(__self__, "linkedin", linkedin)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)

    @_builtins.property
    @pulumi.getter
    def apple(self) -> Optional['outputs.ProjectAuthenticationOauthSystemApple']:
        """
        Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        """
        return pulumi.get(self, "apple")

    @_builtins.property
    @pulumi.getter
    def discord(self) -> Optional['outputs.ProjectAuthenticationOauthSystemDiscord']:
        """
        Discord's OAuth provider, allowing users to authenticate with their Discord account.
        """
        return pulumi.get(self, "discord")

    @_builtins.property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.ProjectAuthenticationOauthSystemFacebook']:
        """
        Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        """
        return pulumi.get(self, "facebook")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.ProjectAuthenticationOauthSystemGithub']:
        """
        GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.ProjectAuthenticationOauthSystemGitlab']:
        """
        GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def google(self) -> Optional['outputs.ProjectAuthenticationOauthSystemGoogle']:
        """
        Google's OAuth provider, allowing users to authenticate with their Google account.
        """
        return pulumi.get(self, "google")

    @_builtins.property
    @pulumi.getter
    def linkedin(self) -> Optional['outputs.ProjectAuthenticationOauthSystemLinkedin']:
        """
        LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        """
        return pulumi.get(self, "linkedin")

    @_builtins.property
    @pulumi.getter
    def microsoft(self) -> Optional['outputs.ProjectAuthenticationOauthSystemMicrosoft']:
        """
        Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        """
        return pulumi.get(self, "microsoft")

    @_builtins.property
    @pulumi.getter
    def slack(self) -> Optional['outputs.ProjectAuthenticationOauthSystemSlack']:
        """
        Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
        return pulumi.get(self, "slack")


@pulumi.output_type
class ProjectAuthenticationOauthSystemApple(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemApple. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemApple.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemApple.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemAppleProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemAppleProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemAppleProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemDiscord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemDiscord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemDiscord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemDiscord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemDiscordProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemDiscordProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemDiscordProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemFacebookProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemFacebookProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemFacebookProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemGithubProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemGithubProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemGithubProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemGitlabProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemGitlabProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemGitlabProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemGoogleProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemGoogleProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemGoogleProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemLinkedin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemLinkedin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemLinkedin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemLinkedin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemLinkedinProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemLinkedinProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemLinkedinProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOauthSystemSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedGrantTypes":
            suggest = "allowed_grant_types"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "callbackDomain":
            suggest = "callback_domain"
        elif key == "claimMapping":
            suggest = "claim_mapping"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "jwksEndpoint":
            suggest = "jwks_endpoint"
        elif key == "manageProviderTokens":
            suggest = "manage_provider_tokens"
        elif key == "mergeUserAccounts":
            suggest = "merge_user_accounts"
        elif key == "providerTokenManagement":
            suggest = "provider_token_management"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useClientAssertion":
            suggest = "use_client_assertion"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOauthSystemSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOauthSystemSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOauthSystemSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_grant_types: Optional[Sequence[_builtins.str]] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 callback_domain: Optional[_builtins.str] = None,
                 claim_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_endpoint: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 manage_provider_tokens: Optional[_builtins.bool] = None,
                 merge_user_accounts: Optional[_builtins.bool] = None,
                 prompts: Optional[Sequence[_builtins.str]] = None,
                 provider_token_management: Optional['outputs.ProjectAuthenticationOauthSystemSlackProviderTokenManagement'] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 use_client_assertion: Optional[_builtins.bool] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param _builtins.str authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param _builtins.str callback_domain: Use a custom domain in your OAuth verification screen.
        :param Mapping[str, _builtins.str] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param _builtins.str client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param _builtins.str client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param _builtins.str description: A brief description of the OAuth provider.
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str issuer: The issuer identifier for the OAuth provider.
        :param _builtins.str jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param _builtins.str logo: The URL of the logo associated with the OAuth provider.
        :param _builtins.bool manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param _builtins.bool merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param Sequence[_builtins.str] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param 'ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs' provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param _builtins.str redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param Sequence[_builtins.str] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param _builtins.str token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param _builtins.bool use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param _builtins.str user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[_builtins.str]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[_builtins.bool]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional['outputs.ProjectAuthenticationOauthSystemSlackProviderTokenManagement']:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[_builtins.bool]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class ProjectAuthenticationOauthSystemSlackProviderTokenManagement(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ProjectAuthenticationOtp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailService":
            suggest = "email_service"
        elif key == "expirationTime":
            suggest = "expiration_time"
        elif key == "textService":
            suggest = "text_service"
        elif key == "voiceService":
            suggest = "voice_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOtp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOtp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOtp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 domain: Optional[_builtins.str] = None,
                 email_service: Optional['outputs.ProjectAuthenticationOtpEmailService'] = None,
                 expiration_time: Optional[_builtins.str] = None,
                 text_service: Optional['outputs.ProjectAuthenticationOtpTextService'] = None,
                 voice_service: Optional['outputs.ProjectAuthenticationOtpVoiceService'] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str domain: The domain to embed in OTP messages.
        :param 'ProjectAuthenticationOtpEmailServiceArgs' email_service: Settings related to sending emails with OTP codes.
        :param _builtins.str expiration_time: The amount of time that an OTP code will be valid for.
        :param 'ProjectAuthenticationOtpTextServiceArgs' text_service: Settings related to sending SMS messages with OTP codes.
        :param 'ProjectAuthenticationOtpVoiceServiceArgs' voice_service: Settings related to voice calls with OTP codes.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if text_service is not None:
            pulumi.set(__self__, "text_service", text_service)
        if voice_service is not None:
            pulumi.set(__self__, "voice_service", voice_service)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        The domain to embed in OTP messages.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional['outputs.ProjectAuthenticationOtpEmailService']:
        """
        Settings related to sending emails with OTP codes.
        """
        return pulumi.get(self, "email_service")

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[_builtins.str]:
        """
        The amount of time that an OTP code will be valid for.
        """
        return pulumi.get(self, "expiration_time")

    @_builtins.property
    @pulumi.getter(name="textService")
    def text_service(self) -> Optional['outputs.ProjectAuthenticationOtpTextService']:
        """
        Settings related to sending SMS messages with OTP codes.
        """
        return pulumi.get(self, "text_service")

    @_builtins.property
    @pulumi.getter(name="voiceService")
    def voice_service(self) -> Optional['outputs.ProjectAuthenticationOtpVoiceService']:
        """
        Settings related to voice calls with OTP codes.
        """
        return pulumi.get(self, "voice_service")


@pulumi.output_type
class ProjectAuthenticationOtpEmailService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectAuthenticationOtpEmailServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the email connector to use for sending emails.
        :param Sequence['ProjectAuthenticationOtpEmailServiceTemplateArgs'] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectAuthenticationOtpEmailServiceTemplate']]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectAuthenticationOtpEmailServiceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "plainTextBody":
            suggest = "plain_text_body"
        elif key == "usePlainTextBody":
            suggest = "use_plain_text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationOtpEmailServiceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationOtpEmailServiceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationOtpEmailServiceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subject: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 html_body: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 plain_text_body: Optional[_builtins.str] = None,
                 use_plain_text_body: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name for this email template.
        :param _builtins.str subject: Subject line of the email message.
        :param _builtins.bool active: Whether this email template is currently active and in use.
        :param _builtins.str html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param _builtins.str plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param _builtins.bool use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[_builtins.str]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[_builtins.str]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[_builtins.bool]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")


@pulumi.output_type
class ProjectAuthenticationOtpTextService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectAuthenticationOtpTextServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the SMS/text connector to use for sending text messages.
        :param Sequence['ProjectAuthenticationOtpTextServiceTemplateArgs'] templates: A list of text message templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the SMS/text connector to use for sending text messages.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectAuthenticationOtpTextServiceTemplate']]:
        """
        A list of text message templates for different authentication flows.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectAuthenticationOtpTextServiceTemplate(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 name: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str body: The content of the text message.
        :param _builtins.str name: Unique name for this text template.
        :param _builtins.bool active: Whether this text template is currently active and in use.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The content of the text message.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this text template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this text template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectAuthenticationOtpVoiceService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectAuthenticationOtpVoiceServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the voice connector to use for making voice calls.
        :param Sequence['ProjectAuthenticationOtpVoiceServiceTemplateArgs'] templates: A list of voice message templates for different purposes.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the voice connector to use for making voice calls.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectAuthenticationOtpVoiceServiceTemplate']]:
        """
        A list of voice message templates for different purposes.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectAuthenticationOtpVoiceServiceTemplate(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 name: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str body: The content of the voice message that will be spoken.
        :param _builtins.str name: Unique name for this voice template.
        :param _builtins.bool active: Whether this voice template is currently active and in use.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The content of the voice message that will be spoken.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this voice template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this voice template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectAuthenticationPasskeys(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topLevelDomain":
            suggest = "top_level_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationPasskeys. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationPasskeys.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationPasskeys.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 top_level_domain: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.str top_level_domain: Passkeys will be usable in the following domain and all its subdomains.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if top_level_domain is not None:
            pulumi.set(__self__, "top_level_domain", top_level_domain)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="topLevelDomain")
    def top_level_domain(self) -> Optional[_builtins.str]:
        """
        Passkeys will be usable in the following domain and all its subdomains.
        """
        return pulumi.get(self, "top_level_domain")


@pulumi.output_type
class ProjectAuthenticationPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailService":
            suggest = "email_service"
        elif key == "expirationWeeks":
            suggest = "expiration_weeks"
        elif key == "lockAttempts":
            suggest = "lock_attempts"
        elif key == "maskErrors":
            suggest = "mask_errors"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "nonAlphanumeric":
            suggest = "non_alphanumeric"
        elif key == "reuseAmount":
            suggest = "reuse_amount"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 email_service: Optional['outputs.ProjectAuthenticationPasswordEmailService'] = None,
                 expiration: Optional[_builtins.bool] = None,
                 expiration_weeks: Optional[_builtins.int] = None,
                 lock: Optional[_builtins.bool] = None,
                 lock_attempts: Optional[_builtins.int] = None,
                 lowercase: Optional[_builtins.bool] = None,
                 mask_errors: Optional[_builtins.bool] = None,
                 min_length: Optional[_builtins.int] = None,
                 non_alphanumeric: Optional[_builtins.bool] = None,
                 number: Optional[_builtins.bool] = None,
                 reuse: Optional[_builtins.bool] = None,
                 reuse_amount: Optional[_builtins.int] = None,
                 uppercase: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param 'ProjectAuthenticationPasswordEmailServiceArgs' email_service: Settings related to sending password reset emails as part of the password feature.
        :param _builtins.bool expiration: Whether users are required to change their password periodically.
        :param _builtins.int expiration_weeks: The number of weeks after which a user's password expires and they need to replace it.
        :param _builtins.bool lock: Whether the user account should be locked after a specified number of failed login attempts.
        :param _builtins.int lock_attempts: The number of failed login attempts allowed before an account is locked.
        :param _builtins.bool lowercase: Whether passwords must contain at least one lowercase letter.
        :param _builtins.bool mask_errors: Prevents information about user accounts from being revealed in error messages, e.g., whether a user already exists.
        :param _builtins.int min_length: The minimum length of the password that users are required to use. The maximum length is always `64`.
        :param _builtins.bool non_alphanumeric: Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        :param _builtins.bool number: Whether passwords must contain at least one number.
        :param _builtins.bool reuse: Whether to forbid password reuse when users change their password.
        :param _builtins.int reuse_amount: The number of previous passwords whose hashes are kept to prevent users from reusing old passwords.
        :param _builtins.bool uppercase: Whether passwords must contain at least one uppercase letter.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if expiration_weeks is not None:
            pulumi.set(__self__, "expiration_weeks", expiration_weeks)
        if lock is not None:
            pulumi.set(__self__, "lock", lock)
        if lock_attempts is not None:
            pulumi.set(__self__, "lock_attempts", lock_attempts)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if mask_errors is not None:
            pulumi.set(__self__, "mask_errors", mask_errors)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if non_alphanumeric is not None:
            pulumi.set(__self__, "non_alphanumeric", non_alphanumeric)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if reuse is not None:
            pulumi.set(__self__, "reuse", reuse)
        if reuse_amount is not None:
            pulumi.set(__self__, "reuse_amount", reuse_amount)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional['outputs.ProjectAuthenticationPasswordEmailService']:
        """
        Settings related to sending password reset emails as part of the password feature.
        """
        return pulumi.get(self, "email_service")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[_builtins.bool]:
        """
        Whether users are required to change their password periodically.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="expirationWeeks")
    def expiration_weeks(self) -> Optional[_builtins.int]:
        """
        The number of weeks after which a user's password expires and they need to replace it.
        """
        return pulumi.get(self, "expiration_weeks")

    @_builtins.property
    @pulumi.getter
    def lock(self) -> Optional[_builtins.bool]:
        """
        Whether the user account should be locked after a specified number of failed login attempts.
        """
        return pulumi.get(self, "lock")

    @_builtins.property
    @pulumi.getter(name="lockAttempts")
    def lock_attempts(self) -> Optional[_builtins.int]:
        """
        The number of failed login attempts allowed before an account is locked.
        """
        return pulumi.get(self, "lock_attempts")

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[_builtins.bool]:
        """
        Whether passwords must contain at least one lowercase letter.
        """
        return pulumi.get(self, "lowercase")

    @_builtins.property
    @pulumi.getter(name="maskErrors")
    def mask_errors(self) -> Optional[_builtins.bool]:
        """
        Prevents information about user accounts from being revealed in error messages, e.g., whether a user already exists.
        """
        return pulumi.get(self, "mask_errors")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[_builtins.int]:
        """
        The minimum length of the password that users are required to use. The maximum length is always `64`.
        """
        return pulumi.get(self, "min_length")

    @_builtins.property
    @pulumi.getter(name="nonAlphanumeric")
    def non_alphanumeric(self) -> Optional[_builtins.bool]:
        """
        Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        """
        return pulumi.get(self, "non_alphanumeric")

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[_builtins.bool]:
        """
        Whether passwords must contain at least one number.
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter
    def reuse(self) -> Optional[_builtins.bool]:
        """
        Whether to forbid password reuse when users change their password.
        """
        return pulumi.get(self, "reuse")

    @_builtins.property
    @pulumi.getter(name="reuseAmount")
    def reuse_amount(self) -> Optional[_builtins.int]:
        """
        The number of previous passwords whose hashes are kept to prevent users from reusing old passwords.
        """
        return pulumi.get(self, "reuse_amount")

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[_builtins.bool]:
        """
        Whether passwords must contain at least one uppercase letter.
        """
        return pulumi.get(self, "uppercase")


@pulumi.output_type
class ProjectAuthenticationPasswordEmailService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectAuthenticationPasswordEmailServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the email connector to use for sending emails.
        :param Sequence['ProjectAuthenticationPasswordEmailServiceTemplateArgs'] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectAuthenticationPasswordEmailServiceTemplate']]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectAuthenticationPasswordEmailServiceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "plainTextBody":
            suggest = "plain_text_body"
        elif key == "usePlainTextBody":
            suggest = "use_plain_text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationPasswordEmailServiceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationPasswordEmailServiceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationPasswordEmailServiceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subject: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 html_body: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 plain_text_body: Optional[_builtins.str] = None,
                 use_plain_text_body: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name for this email template.
        :param _builtins.str subject: Subject line of the email message.
        :param _builtins.bool active: Whether this email template is currently active and in use.
        :param _builtins.str html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param _builtins.str plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param _builtins.bool use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[_builtins.str]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[_builtins.str]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[_builtins.bool]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")


@pulumi.output_type
class ProjectAuthenticationSso(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mergeUsers":
            suggest = "merge_users"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "ssoSuiteSettings":
            suggest = "sso_suite_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationSso. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationSso.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationSso.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 merge_users: Optional[_builtins.bool] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 sso_suite_settings: Optional['outputs.ProjectAuthenticationSsoSsoSuiteSettings'] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param _builtins.bool merge_users: Whether to merge existing user accounts with new ones created through SSO authentication.
        :param _builtins.str redirect_url: The URL the end user is redirected to after a successful authentication. If one is specified in tenant level settings or SDK/API call, they will override this value.
        :param 'ProjectAuthenticationSsoSsoSuiteSettingsArgs' sso_suite_settings: Configuration block for the SSO Suite.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if merge_users is not None:
            pulumi.set(__self__, "merge_users", merge_users)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if sso_suite_settings is not None:
            pulumi.set(__self__, "sso_suite_settings", sso_suite_settings)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="mergeUsers")
    def merge_users(self) -> Optional[_builtins.bool]:
        """
        Whether to merge existing user accounts with new ones created through SSO authentication.
        """
        return pulumi.get(self, "merge_users")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        The URL the end user is redirected to after a successful authentication. If one is specified in tenant level settings or SDK/API call, they will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="ssoSuiteSettings")
    def sso_suite_settings(self) -> Optional['outputs.ProjectAuthenticationSsoSsoSuiteSettings']:
        """
        Configuration block for the SSO Suite.
        """
        return pulumi.get(self, "sso_suite_settings")


@pulumi.output_type
class ProjectAuthenticationSsoSsoSuiteSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceDomainVerification":
            suggest = "force_domain_verification"
        elif key == "hideDomains":
            suggest = "hide_domains"
        elif key == "hideGroupsMapping":
            suggest = "hide_groups_mapping"
        elif key == "hideOidc":
            suggest = "hide_oidc"
        elif key == "hideSaml":
            suggest = "hide_saml"
        elif key == "hideScim":
            suggest = "hide_scim"
        elif key == "styleId":
            suggest = "style_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAuthenticationSsoSsoSuiteSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAuthenticationSsoSsoSuiteSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAuthenticationSsoSsoSuiteSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 force_domain_verification: Optional[_builtins.bool] = None,
                 hide_domains: Optional[_builtins.bool] = None,
                 hide_groups_mapping: Optional[_builtins.bool] = None,
                 hide_oidc: Optional[_builtins.bool] = None,
                 hide_saml: Optional[_builtins.bool] = None,
                 hide_scim: Optional[_builtins.bool] = None,
                 style_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool force_domain_verification: Setting this to `true` will allow only verified domains to be used.
        :param _builtins.bool hide_domains: Setting this to `true` will hide the domains configuration section in the SSO Suite interface.
        :param _builtins.bool hide_groups_mapping: Setting this to `true` will hide the groups mapping configuration section in the SSO Suite interface.
        :param _builtins.bool hide_oidc: Setting this to `true` will hide the OIDC configuration option.
        :param _builtins.bool hide_saml: Setting this to `true` will hide the SAML configuration option.
        :param _builtins.bool hide_scim: Setting this to `true` will hide the SCIM configuration in the SSO Suite interface.
        :param _builtins.str style_id: Specifies the style ID to apply in the SSO Suite. Ensure a style with this ID exists in the console for it to be used.
        """
        if force_domain_verification is not None:
            pulumi.set(__self__, "force_domain_verification", force_domain_verification)
        if hide_domains is not None:
            pulumi.set(__self__, "hide_domains", hide_domains)
        if hide_groups_mapping is not None:
            pulumi.set(__self__, "hide_groups_mapping", hide_groups_mapping)
        if hide_oidc is not None:
            pulumi.set(__self__, "hide_oidc", hide_oidc)
        if hide_saml is not None:
            pulumi.set(__self__, "hide_saml", hide_saml)
        if hide_scim is not None:
            pulumi.set(__self__, "hide_scim", hide_scim)
        if style_id is not None:
            pulumi.set(__self__, "style_id", style_id)

    @_builtins.property
    @pulumi.getter(name="forceDomainVerification")
    def force_domain_verification(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will allow only verified domains to be used.
        """
        return pulumi.get(self, "force_domain_verification")

    @_builtins.property
    @pulumi.getter(name="hideDomains")
    def hide_domains(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will hide the domains configuration section in the SSO Suite interface.
        """
        return pulumi.get(self, "hide_domains")

    @_builtins.property
    @pulumi.getter(name="hideGroupsMapping")
    def hide_groups_mapping(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will hide the groups mapping configuration section in the SSO Suite interface.
        """
        return pulumi.get(self, "hide_groups_mapping")

    @_builtins.property
    @pulumi.getter(name="hideOidc")
    def hide_oidc(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will hide the OIDC configuration option.
        """
        return pulumi.get(self, "hide_oidc")

    @_builtins.property
    @pulumi.getter(name="hideSaml")
    def hide_saml(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will hide the SAML configuration option.
        """
        return pulumi.get(self, "hide_saml")

    @_builtins.property
    @pulumi.getter(name="hideScim")
    def hide_scim(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will hide the SCIM configuration in the SSO Suite interface.
        """
        return pulumi.get(self, "hide_scim")

    @_builtins.property
    @pulumi.getter(name="styleId")
    def style_id(self) -> Optional[_builtins.str]:
        """
        Specifies the style ID to apply in the SSO Suite. Ensure a style with this ID exists in the console for it to be used.
        """
        return pulumi.get(self, "style_id")


@pulumi.output_type
class ProjectAuthenticationTotp(dict):
    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class ProjectAuthorization(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence['outputs.ProjectAuthorizationPermission']] = None,
                 roles: Optional[Sequence['outputs.ProjectAuthorizationRole']] = None):
        """
        :param Sequence['ProjectAuthorizationPermissionArgs'] permissions: A list of `Permission` objects.
        :param Sequence['ProjectAuthorizationRoleArgs'] roles: A list of `Role` objects.
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.ProjectAuthorizationPermission']]:
        """
        A list of `Permission` objects.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence['outputs.ProjectAuthorizationRole']]:
        """
        A list of `Role` objects.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class ProjectAuthorizationPermission(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A name for the permission.
        :param _builtins.str description: A description for the permission.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for the permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for the permission.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectAuthorizationRole(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 default: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 permissions: Optional[Sequence[_builtins.str]] = None,
                 private: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A name for the role.
        :param _builtins.bool default: Whether this role should automatically be assigned to users that are created without any roles.
        :param _builtins.str description: A description for the role.
        :param Sequence[_builtins.str] permissions: A list of permissions by name to be included in the role.
        :param _builtins.bool private: Whether this role should not be displayed to tenant admins.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if private is not None:
            pulumi.set(__self__, "private", private)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for the role.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.bool]:
        """
        Whether this role should automatically be assigned to users that are created without any roles.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for the role.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of permissions by name to be included in the role.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def private(self) -> Optional[_builtins.bool]:
        """
        Whether this role should not be displayed to tenant admins.
        """
        return pulumi.get(self, "private")


@pulumi.output_type
class ProjectConnectors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditWebhooks":
            suggest = "audit_webhooks"
        elif key == "awsS3s":
            suggest = "aws_s3s"
        elif key == "awsTranslates":
            suggest = "aws_translates"
        elif key == "devrevGrows":
            suggest = "devrev_grows"
        elif key == "eightByEightVibers":
            suggest = "eight_by_eight_vibers"
        elif key == "eightByEightWhatsapps":
            suggest = "eight_by_eight_whatsapps"
        elif key == "externalTokenHttps":
            suggest = "external_token_https"
        elif key == "fingerprintDescopes":
            suggest = "fingerprint_descopes"
        elif key == "firebaseAdmins":
            suggest = "firebase_admins"
        elif key == "genericEmailGateways":
            suggest = "generic_email_gateways"
        elif key == "genericSmsGateways":
            suggest = "generic_sms_gateways"
        elif key == "googleCloudLoggings":
            suggest = "google_cloud_loggings"
        elif key == "googleCloudTranslations":
            suggest = "google_cloud_translations"
        elif key == "googleMapsPlaces":
            suggest = "google_maps_places"
        elif key == "recaptchaEnterprises":
            suggest = "recaptcha_enterprises"
        elif key == "salesforceMarketingClouds":
            suggest = "salesforce_marketing_clouds"
        elif key == "twilioCores":
            suggest = "twilio_cores"
        elif key == "twilioVerifies":
            suggest = "twilio_verifies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abuseipdbs: Optional[Sequence['outputs.ProjectConnectorsAbuseipdb']] = None,
                 amplitudes: Optional[Sequence['outputs.ProjectConnectorsAmplitude']] = None,
                 audit_webhooks: Optional[Sequence['outputs.ProjectConnectorsAuditWebhook']] = None,
                 aws_s3s: Optional[Sequence['outputs.ProjectConnectorsAwsS3']] = None,
                 aws_translates: Optional[Sequence['outputs.ProjectConnectorsAwsTranslate']] = None,
                 bitsights: Optional[Sequence['outputs.ProjectConnectorsBitsight']] = None,
                 datadogs: Optional[Sequence['outputs.ProjectConnectorsDatadog']] = None,
                 devrev_grows: Optional[Sequence['outputs.ProjectConnectorsDevrevGrow']] = None,
                 docebos: Optional[Sequence['outputs.ProjectConnectorsDocebo']] = None,
                 eight_by_eight_vibers: Optional[Sequence['outputs.ProjectConnectorsEightByEightViber']] = None,
                 eight_by_eight_whatsapps: Optional[Sequence['outputs.ProjectConnectorsEightByEightWhatsapp']] = None,
                 elephants: Optional[Sequence['outputs.ProjectConnectorsElephant']] = None,
                 external_token_https: Optional[Sequence['outputs.ProjectConnectorsExternalTokenHttp']] = None,
                 fingerprint_descopes: Optional[Sequence['outputs.ProjectConnectorsFingerprintDescope']] = None,
                 fingerprints: Optional[Sequence['outputs.ProjectConnectorsFingerprint']] = None,
                 firebase_admins: Optional[Sequence['outputs.ProjectConnectorsFirebaseAdmin']] = None,
                 forters: Optional[Sequence['outputs.ProjectConnectorsForter']] = None,
                 generic_email_gateways: Optional[Sequence['outputs.ProjectConnectorsGenericEmailGateway']] = None,
                 generic_sms_gateways: Optional[Sequence['outputs.ProjectConnectorsGenericSmsGateway']] = None,
                 google_cloud_loggings: Optional[Sequence['outputs.ProjectConnectorsGoogleCloudLogging']] = None,
                 google_cloud_translations: Optional[Sequence['outputs.ProjectConnectorsGoogleCloudTranslation']] = None,
                 google_maps_places: Optional[Sequence['outputs.ProjectConnectorsGoogleMapsPlace']] = None,
                 hibps: Optional[Sequence['outputs.ProjectConnectorsHibp']] = None,
                 https: Optional[Sequence['outputs.ProjectConnectorsHttp']] = None,
                 hubspots: Optional[Sequence['outputs.ProjectConnectorsHubspot']] = None,
                 incodes: Optional[Sequence['outputs.ProjectConnectorsIncode']] = None,
                 intercoms: Optional[Sequence['outputs.ProjectConnectorsIntercom']] = None,
                 lokalises: Optional[Sequence['outputs.ProjectConnectorsLokalise']] = None,
                 mparticles: Optional[Sequence['outputs.ProjectConnectorsMparticle']] = None,
                 newrelics: Optional[Sequence['outputs.ProjectConnectorsNewrelic']] = None,
                 radars: Optional[Sequence['outputs.ProjectConnectorsRadar']] = None,
                 recaptcha_enterprises: Optional[Sequence['outputs.ProjectConnectorsRecaptchaEnterprise']] = None,
                 recaptchas: Optional[Sequence['outputs.ProjectConnectorsRecaptcha']] = None,
                 rekognitions: Optional[Sequence['outputs.ProjectConnectorsRekognition']] = None,
                 salesforce_marketing_clouds: Optional[Sequence['outputs.ProjectConnectorsSalesforceMarketingCloud']] = None,
                 salesforces: Optional[Sequence['outputs.ProjectConnectorsSalesforce']] = None,
                 sardines: Optional[Sequence['outputs.ProjectConnectorsSardine']] = None,
                 segments: Optional[Sequence['outputs.ProjectConnectorsSegment']] = None,
                 sendgrids: Optional[Sequence['outputs.ProjectConnectorsSendgrid']] = None,
                 ses: Optional[Sequence['outputs.ProjectConnectorsSe']] = None,
                 slacks: Optional[Sequence['outputs.ProjectConnectorsSlack']] = None,
                 smartlings: Optional[Sequence['outputs.ProjectConnectorsSmartling']] = None,
                 smtps: Optional[Sequence['outputs.ProjectConnectorsSmtp']] = None,
                 sns: Optional[Sequence['outputs.ProjectConnectorsSn']] = None,
                 sumologics: Optional[Sequence['outputs.ProjectConnectorsSumologic']] = None,
                 supabases: Optional[Sequence['outputs.ProjectConnectorsSupabase']] = None,
                 telesigns: Optional[Sequence['outputs.ProjectConnectorsTelesign']] = None,
                 traceables: Optional[Sequence['outputs.ProjectConnectorsTraceable']] = None,
                 turnstiles: Optional[Sequence['outputs.ProjectConnectorsTurnstile']] = None,
                 twilio_cores: Optional[Sequence['outputs.ProjectConnectorsTwilioCore']] = None,
                 twilio_verifies: Optional[Sequence['outputs.ProjectConnectorsTwilioVerify']] = None):
        """
        :param Sequence['ProjectConnectorsAbuseipdbArgs'] abuseipdbs: Utilize IP threat intelligence to block malicious login attempts with the AbuseIPDB connector.
        :param Sequence['ProjectConnectorsAmplitudeArgs'] amplitudes: Track user activity and traits at any point in your user journey with the Amplitude connector.
        :param Sequence['ProjectConnectorsAuditWebhookArgs'] audit_webhooks: Send audit events to a custom webhook.
        :param Sequence['ProjectConnectorsAwsS3Args'] aws_s3s: Stream authentication audit logs with the Amazon S3 connector.
        :param Sequence['ProjectConnectorsAwsTranslateArgs'] aws_translates: Localize the language of your login and user journey screens with the Amazon Translate connector.
        :param Sequence['ProjectConnectorsBitsightArgs'] bitsights: Utilize threat intelligence to block malicious login attempts or check leaks with the Bitsight Threat Intelligence connector.
        :param Sequence['ProjectConnectorsDatadogArgs'] datadogs: Stream authentication audit logs with the Datadog connector.
        :param Sequence['ProjectConnectorsDevrevGrowArgs'] devrev_grows: DevRev Grow is a Growth CRM that brings salespeople, product marketers, and PMs onto an AI-native platform to follow the journey of a visitor to a lead, to a contact, and then to a user - to create a champion, not a churned user.
        :param Sequence['ProjectConnectorsDoceboArgs'] docebos: Get user information from Docebo in your Descope user journeys with the Docebo connector.
        :param Sequence['ProjectConnectorsEightByEightViberArgs'] eight_by_eight_vibers: Send Viber messages to the user.
        :param Sequence['ProjectConnectorsEightByEightWhatsappArgs'] eight_by_eight_whatsapps: Send WhatsApp messages to the user.
        :param Sequence['ProjectConnectorsElephantArgs'] elephants: Use this connector to obtain an identity trust score.
        :param Sequence['ProjectConnectorsExternalTokenHttpArgs'] external_token_https: A generic HTTP token connector.
        :param Sequence['ProjectConnectorsFingerprintDescopeArgs'] fingerprint_descopes: Descope Fingerprint capabilities for fraud detection and risk assessment.
        :param Sequence['ProjectConnectorsFingerprintArgs'] fingerprints: Prevent fraud by adding device intelligence with the Fingerprint connector.
        :param Sequence['ProjectConnectorsFirebaseAdminArgs'] firebase_admins: Firebase connector enables you to utilize Firebase's APIs to generate a Firebase user token for a given Descope user.
        :param Sequence['ProjectConnectorsForterArgs'] forters: Leverage ML-based risk scores for fraud prevention with the Forter connector.
        :param Sequence['ProjectConnectorsGenericEmailGatewayArgs'] generic_email_gateways: Send emails using a generic Email gateway.
        :param Sequence['ProjectConnectorsGenericSmsGatewayArgs'] generic_sms_gateways: Send messages using a generic SMS gateway.
        :param Sequence['ProjectConnectorsGoogleCloudLoggingArgs'] google_cloud_loggings: Stream logs and audit events with the Google Cloud Logging connector.
        :param Sequence['ProjectConnectorsGoogleCloudTranslationArgs'] google_cloud_translations: Localize the language of your login and user journey screens with the Google Cloud Translation connector.
        :param Sequence['ProjectConnectorsGoogleMapsPlaceArgs'] google_maps_places: Get address autocompletions from Place Autocomplete Data API.
        :param Sequence['ProjectConnectorsHibpArgs'] hibps: Check if passwords have been previously exposed in data breaches with the Have I Been Pwned connector.
        :param Sequence['ProjectConnectorsHttpArgs'] https: A general purpose HTTP client
        :param Sequence['ProjectConnectorsHubspotArgs'] hubspots: Orchestrate customer identity information from your Descope user journey with the HubSpot connector.
        :param Sequence['ProjectConnectorsIncodeArgs'] incodes: Use the Incode connection to run identity verification processes like document checks or facial recognition.
        :param Sequence['ProjectConnectorsIntercomArgs'] intercoms: Orchestrate customer identity information from your Descope user journey with the Intercom connector.
        :param Sequence['ProjectConnectorsLokaliseArgs'] lokalises: Localize the language of your login and user journey screens with the Lokalise connector.
        :param Sequence['ProjectConnectorsMparticleArgs'] mparticles: Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        :param Sequence['ProjectConnectorsNewrelicArgs'] newrelics: Stream authentication audit logs with the New Relic connector.
        :param Sequence['ProjectConnectorsRadarArgs'] radars: Get address autocompletions from Radar Autocomplete API.
        :param Sequence['ProjectConnectorsRecaptchaEnterpriseArgs'] recaptcha_enterprises: Mitigate fraud using advanced risk analysis and add adaptive MFA with the reCAPTCHA Enterprise connector.
        :param Sequence['ProjectConnectorsRecaptchaArgs'] recaptchas: Prevent bot attacks on your login pages with the reCAPTCHA v3 connector.
        :param Sequence['ProjectConnectorsRekognitionArgs'] rekognitions: Add image recognition capabilities for identity verification and fraud prevention with the Amazon Rekognition connector.
        :param Sequence['ProjectConnectorsSalesforceMarketingCloudArgs'] salesforce_marketing_clouds: Send transactional messages with the Salesforce Marketing Cloud connector.
        :param Sequence['ProjectConnectorsSalesforceArgs'] salesforces: Run SQL queries to retrieve user roles, profiles, account status, and more with the Salesforce connector.
        :param Sequence['ProjectConnectorsSardineArgs'] sardines: Evaluate customer risk using Sardine
        :param Sequence['ProjectConnectorsSegmentArgs'] segments: Orchestrate customer identity traits and signals from your Descope user journey with the Segment connector.
        :param Sequence['ProjectConnectorsSendgridArgs'] sendgrids: SendGrid is a cloud-based SMTP provider that allows you to send emails without having to maintain email servers.
        :param Sequence['ProjectConnectorsSeArgs'] ses: Amazon Simple Email Service (SES) for sending emails through AWS infrastructure.
        :param Sequence['ProjectConnectorsSlackArgs'] slacks: Send updates to your team on Slack.
        :param Sequence['ProjectConnectorsSmartlingArgs'] smartlings: Localize the language of your login and user journey screens with the Smartling connector.
        :param Sequence['ProjectConnectorsSmtpArgs'] smtps: Simple Mail Transfer Protocol (SMTP) server for sending emails.
        :param Sequence['ProjectConnectorsSnArgs'] sns: Amazon Simple Notification Service (SNS) for sending SMS messages through AWS.
        :param Sequence['ProjectConnectorsSumologicArgs'] sumologics: Stream logs and audit events with the Sumo Logic connector.
        :param Sequence['ProjectConnectorsSupabaseArgs'] supabases: Generate external tokens for user authentication in Supabase projects.
        :param Sequence['ProjectConnectorsTelesignArgs'] telesigns: Verify phone numbers and leverage granular risk scores for adaptive MFA with the Telesign Intelligence connector.
        :param Sequence['ProjectConnectorsTraceableArgs'] traceables: Identify and respond to fraudulent login activity with the Traceable Digital Fraud Prevention connector.
        :param Sequence['ProjectConnectorsTurnstileArgs'] turnstiles: Prevent bot attacks on your login pages with the Turnstile connector.
        :param Sequence['ProjectConnectorsTwilioCoreArgs'] twilio_cores: Twilio is a cloud-based communication provider of communication tools for making and receiving phone calls, sending and receiving text messages, and performing other communication functions.
        :param Sequence['ProjectConnectorsTwilioVerifyArgs'] twilio_verifies: Twilio Verify is an OTP service that can be used via text messages, instant messaging platforms, voice and e-mail. Choose this connector only if you are a Twilio Verify customer.
        """
        if abuseipdbs is not None:
            pulumi.set(__self__, "abuseipdbs", abuseipdbs)
        if amplitudes is not None:
            pulumi.set(__self__, "amplitudes", amplitudes)
        if audit_webhooks is not None:
            pulumi.set(__self__, "audit_webhooks", audit_webhooks)
        if aws_s3s is not None:
            pulumi.set(__self__, "aws_s3s", aws_s3s)
        if aws_translates is not None:
            pulumi.set(__self__, "aws_translates", aws_translates)
        if bitsights is not None:
            pulumi.set(__self__, "bitsights", bitsights)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if devrev_grows is not None:
            pulumi.set(__self__, "devrev_grows", devrev_grows)
        if docebos is not None:
            pulumi.set(__self__, "docebos", docebos)
        if eight_by_eight_vibers is not None:
            pulumi.set(__self__, "eight_by_eight_vibers", eight_by_eight_vibers)
        if eight_by_eight_whatsapps is not None:
            pulumi.set(__self__, "eight_by_eight_whatsapps", eight_by_eight_whatsapps)
        if elephants is not None:
            pulumi.set(__self__, "elephants", elephants)
        if external_token_https is not None:
            pulumi.set(__self__, "external_token_https", external_token_https)
        if fingerprint_descopes is not None:
            pulumi.set(__self__, "fingerprint_descopes", fingerprint_descopes)
        if fingerprints is not None:
            pulumi.set(__self__, "fingerprints", fingerprints)
        if firebase_admins is not None:
            pulumi.set(__self__, "firebase_admins", firebase_admins)
        if forters is not None:
            pulumi.set(__self__, "forters", forters)
        if generic_email_gateways is not None:
            pulumi.set(__self__, "generic_email_gateways", generic_email_gateways)
        if generic_sms_gateways is not None:
            pulumi.set(__self__, "generic_sms_gateways", generic_sms_gateways)
        if google_cloud_loggings is not None:
            pulumi.set(__self__, "google_cloud_loggings", google_cloud_loggings)
        if google_cloud_translations is not None:
            pulumi.set(__self__, "google_cloud_translations", google_cloud_translations)
        if google_maps_places is not None:
            pulumi.set(__self__, "google_maps_places", google_maps_places)
        if hibps is not None:
            pulumi.set(__self__, "hibps", hibps)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if hubspots is not None:
            pulumi.set(__self__, "hubspots", hubspots)
        if incodes is not None:
            pulumi.set(__self__, "incodes", incodes)
        if intercoms is not None:
            pulumi.set(__self__, "intercoms", intercoms)
        if lokalises is not None:
            pulumi.set(__self__, "lokalises", lokalises)
        if mparticles is not None:
            pulumi.set(__self__, "mparticles", mparticles)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if radars is not None:
            pulumi.set(__self__, "radars", radars)
        if recaptcha_enterprises is not None:
            pulumi.set(__self__, "recaptcha_enterprises", recaptcha_enterprises)
        if recaptchas is not None:
            pulumi.set(__self__, "recaptchas", recaptchas)
        if rekognitions is not None:
            pulumi.set(__self__, "rekognitions", rekognitions)
        if salesforce_marketing_clouds is not None:
            pulumi.set(__self__, "salesforce_marketing_clouds", salesforce_marketing_clouds)
        if salesforces is not None:
            pulumi.set(__self__, "salesforces", salesforces)
        if sardines is not None:
            pulumi.set(__self__, "sardines", sardines)
        if segments is not None:
            pulumi.set(__self__, "segments", segments)
        if sendgrids is not None:
            pulumi.set(__self__, "sendgrids", sendgrids)
        if ses is not None:
            pulumi.set(__self__, "ses", ses)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)
        if smartlings is not None:
            pulumi.set(__self__, "smartlings", smartlings)
        if smtps is not None:
            pulumi.set(__self__, "smtps", smtps)
        if sns is not None:
            pulumi.set(__self__, "sns", sns)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if supabases is not None:
            pulumi.set(__self__, "supabases", supabases)
        if telesigns is not None:
            pulumi.set(__self__, "telesigns", telesigns)
        if traceables is not None:
            pulumi.set(__self__, "traceables", traceables)
        if turnstiles is not None:
            pulumi.set(__self__, "turnstiles", turnstiles)
        if twilio_cores is not None:
            pulumi.set(__self__, "twilio_cores", twilio_cores)
        if twilio_verifies is not None:
            pulumi.set(__self__, "twilio_verifies", twilio_verifies)

    @_builtins.property
    @pulumi.getter
    def abuseipdbs(self) -> Optional[Sequence['outputs.ProjectConnectorsAbuseipdb']]:
        """
        Utilize IP threat intelligence to block malicious login attempts with the AbuseIPDB connector.
        """
        return pulumi.get(self, "abuseipdbs")

    @_builtins.property
    @pulumi.getter
    def amplitudes(self) -> Optional[Sequence['outputs.ProjectConnectorsAmplitude']]:
        """
        Track user activity and traits at any point in your user journey with the Amplitude connector.
        """
        return pulumi.get(self, "amplitudes")

    @_builtins.property
    @pulumi.getter(name="auditWebhooks")
    def audit_webhooks(self) -> Optional[Sequence['outputs.ProjectConnectorsAuditWebhook']]:
        """
        Send audit events to a custom webhook.
        """
        return pulumi.get(self, "audit_webhooks")

    @_builtins.property
    @pulumi.getter(name="awsS3s")
    def aws_s3s(self) -> Optional[Sequence['outputs.ProjectConnectorsAwsS3']]:
        """
        Stream authentication audit logs with the Amazon S3 connector.
        """
        return pulumi.get(self, "aws_s3s")

    @_builtins.property
    @pulumi.getter(name="awsTranslates")
    def aws_translates(self) -> Optional[Sequence['outputs.ProjectConnectorsAwsTranslate']]:
        """
        Localize the language of your login and user journey screens with the Amazon Translate connector.
        """
        return pulumi.get(self, "aws_translates")

    @_builtins.property
    @pulumi.getter
    def bitsights(self) -> Optional[Sequence['outputs.ProjectConnectorsBitsight']]:
        """
        Utilize threat intelligence to block malicious login attempts or check leaks with the Bitsight Threat Intelligence connector.
        """
        return pulumi.get(self, "bitsights")

    @_builtins.property
    @pulumi.getter
    def datadogs(self) -> Optional[Sequence['outputs.ProjectConnectorsDatadog']]:
        """
        Stream authentication audit logs with the Datadog connector.
        """
        return pulumi.get(self, "datadogs")

    @_builtins.property
    @pulumi.getter(name="devrevGrows")
    def devrev_grows(self) -> Optional[Sequence['outputs.ProjectConnectorsDevrevGrow']]:
        """
        DevRev Grow is a Growth CRM that brings salespeople, product marketers, and PMs onto an AI-native platform to follow the journey of a visitor to a lead, to a contact, and then to a user - to create a champion, not a churned user.
        """
        return pulumi.get(self, "devrev_grows")

    @_builtins.property
    @pulumi.getter
    def docebos(self) -> Optional[Sequence['outputs.ProjectConnectorsDocebo']]:
        """
        Get user information from Docebo in your Descope user journeys with the Docebo connector.
        """
        return pulumi.get(self, "docebos")

    @_builtins.property
    @pulumi.getter(name="eightByEightVibers")
    def eight_by_eight_vibers(self) -> Optional[Sequence['outputs.ProjectConnectorsEightByEightViber']]:
        """
        Send Viber messages to the user.
        """
        return pulumi.get(self, "eight_by_eight_vibers")

    @_builtins.property
    @pulumi.getter(name="eightByEightWhatsapps")
    def eight_by_eight_whatsapps(self) -> Optional[Sequence['outputs.ProjectConnectorsEightByEightWhatsapp']]:
        """
        Send WhatsApp messages to the user.
        """
        return pulumi.get(self, "eight_by_eight_whatsapps")

    @_builtins.property
    @pulumi.getter
    def elephants(self) -> Optional[Sequence['outputs.ProjectConnectorsElephant']]:
        """
        Use this connector to obtain an identity trust score.
        """
        return pulumi.get(self, "elephants")

    @_builtins.property
    @pulumi.getter(name="externalTokenHttps")
    def external_token_https(self) -> Optional[Sequence['outputs.ProjectConnectorsExternalTokenHttp']]:
        """
        A generic HTTP token connector.
        """
        return pulumi.get(self, "external_token_https")

    @_builtins.property
    @pulumi.getter(name="fingerprintDescopes")
    def fingerprint_descopes(self) -> Optional[Sequence['outputs.ProjectConnectorsFingerprintDescope']]:
        """
        Descope Fingerprint capabilities for fraud detection and risk assessment.
        """
        return pulumi.get(self, "fingerprint_descopes")

    @_builtins.property
    @pulumi.getter
    def fingerprints(self) -> Optional[Sequence['outputs.ProjectConnectorsFingerprint']]:
        """
        Prevent fraud by adding device intelligence with the Fingerprint connector.
        """
        return pulumi.get(self, "fingerprints")

    @_builtins.property
    @pulumi.getter(name="firebaseAdmins")
    def firebase_admins(self) -> Optional[Sequence['outputs.ProjectConnectorsFirebaseAdmin']]:
        """
        Firebase connector enables you to utilize Firebase's APIs to generate a Firebase user token for a given Descope user.
        """
        return pulumi.get(self, "firebase_admins")

    @_builtins.property
    @pulumi.getter
    def forters(self) -> Optional[Sequence['outputs.ProjectConnectorsForter']]:
        """
        Leverage ML-based risk scores for fraud prevention with the Forter connector.
        """
        return pulumi.get(self, "forters")

    @_builtins.property
    @pulumi.getter(name="genericEmailGateways")
    def generic_email_gateways(self) -> Optional[Sequence['outputs.ProjectConnectorsGenericEmailGateway']]:
        """
        Send emails using a generic Email gateway.
        """
        return pulumi.get(self, "generic_email_gateways")

    @_builtins.property
    @pulumi.getter(name="genericSmsGateways")
    def generic_sms_gateways(self) -> Optional[Sequence['outputs.ProjectConnectorsGenericSmsGateway']]:
        """
        Send messages using a generic SMS gateway.
        """
        return pulumi.get(self, "generic_sms_gateways")

    @_builtins.property
    @pulumi.getter(name="googleCloudLoggings")
    def google_cloud_loggings(self) -> Optional[Sequence['outputs.ProjectConnectorsGoogleCloudLogging']]:
        """
        Stream logs and audit events with the Google Cloud Logging connector.
        """
        return pulumi.get(self, "google_cloud_loggings")

    @_builtins.property
    @pulumi.getter(name="googleCloudTranslations")
    def google_cloud_translations(self) -> Optional[Sequence['outputs.ProjectConnectorsGoogleCloudTranslation']]:
        """
        Localize the language of your login and user journey screens with the Google Cloud Translation connector.
        """
        return pulumi.get(self, "google_cloud_translations")

    @_builtins.property
    @pulumi.getter(name="googleMapsPlaces")
    def google_maps_places(self) -> Optional[Sequence['outputs.ProjectConnectorsGoogleMapsPlace']]:
        """
        Get address autocompletions from Place Autocomplete Data API.
        """
        return pulumi.get(self, "google_maps_places")

    @_builtins.property
    @pulumi.getter
    def hibps(self) -> Optional[Sequence['outputs.ProjectConnectorsHibp']]:
        """
        Check if passwords have been previously exposed in data breaches with the Have I Been Pwned connector.
        """
        return pulumi.get(self, "hibps")

    @_builtins.property
    @pulumi.getter
    def https(self) -> Optional[Sequence['outputs.ProjectConnectorsHttp']]:
        """
        A general purpose HTTP client
        """
        return pulumi.get(self, "https")

    @_builtins.property
    @pulumi.getter
    def hubspots(self) -> Optional[Sequence['outputs.ProjectConnectorsHubspot']]:
        """
        Orchestrate customer identity information from your Descope user journey with the HubSpot connector.
        """
        return pulumi.get(self, "hubspots")

    @_builtins.property
    @pulumi.getter
    def incodes(self) -> Optional[Sequence['outputs.ProjectConnectorsIncode']]:
        """
        Use the Incode connection to run identity verification processes like document checks or facial recognition.
        """
        return pulumi.get(self, "incodes")

    @_builtins.property
    @pulumi.getter
    def intercoms(self) -> Optional[Sequence['outputs.ProjectConnectorsIntercom']]:
        """
        Orchestrate customer identity information from your Descope user journey with the Intercom connector.
        """
        return pulumi.get(self, "intercoms")

    @_builtins.property
    @pulumi.getter
    def lokalises(self) -> Optional[Sequence['outputs.ProjectConnectorsLokalise']]:
        """
        Localize the language of your login and user journey screens with the Lokalise connector.
        """
        return pulumi.get(self, "lokalises")

    @_builtins.property
    @pulumi.getter
    def mparticles(self) -> Optional[Sequence['outputs.ProjectConnectorsMparticle']]:
        """
        Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        """
        return pulumi.get(self, "mparticles")

    @_builtins.property
    @pulumi.getter
    def newrelics(self) -> Optional[Sequence['outputs.ProjectConnectorsNewrelic']]:
        """
        Stream authentication audit logs with the New Relic connector.
        """
        return pulumi.get(self, "newrelics")

    @_builtins.property
    @pulumi.getter
    def radars(self) -> Optional[Sequence['outputs.ProjectConnectorsRadar']]:
        """
        Get address autocompletions from Radar Autocomplete API.
        """
        return pulumi.get(self, "radars")

    @_builtins.property
    @pulumi.getter(name="recaptchaEnterprises")
    def recaptcha_enterprises(self) -> Optional[Sequence['outputs.ProjectConnectorsRecaptchaEnterprise']]:
        """
        Mitigate fraud using advanced risk analysis and add adaptive MFA with the reCAPTCHA Enterprise connector.
        """
        return pulumi.get(self, "recaptcha_enterprises")

    @_builtins.property
    @pulumi.getter
    def recaptchas(self) -> Optional[Sequence['outputs.ProjectConnectorsRecaptcha']]:
        """
        Prevent bot attacks on your login pages with the reCAPTCHA v3 connector.
        """
        return pulumi.get(self, "recaptchas")

    @_builtins.property
    @pulumi.getter
    def rekognitions(self) -> Optional[Sequence['outputs.ProjectConnectorsRekognition']]:
        """
        Add image recognition capabilities for identity verification and fraud prevention with the Amazon Rekognition connector.
        """
        return pulumi.get(self, "rekognitions")

    @_builtins.property
    @pulumi.getter(name="salesforceMarketingClouds")
    def salesforce_marketing_clouds(self) -> Optional[Sequence['outputs.ProjectConnectorsSalesforceMarketingCloud']]:
        """
        Send transactional messages with the Salesforce Marketing Cloud connector.
        """
        return pulumi.get(self, "salesforce_marketing_clouds")

    @_builtins.property
    @pulumi.getter
    def salesforces(self) -> Optional[Sequence['outputs.ProjectConnectorsSalesforce']]:
        """
        Run SQL queries to retrieve user roles, profiles, account status, and more with the Salesforce connector.
        """
        return pulumi.get(self, "salesforces")

    @_builtins.property
    @pulumi.getter
    def sardines(self) -> Optional[Sequence['outputs.ProjectConnectorsSardine']]:
        """
        Evaluate customer risk using Sardine
        """
        return pulumi.get(self, "sardines")

    @_builtins.property
    @pulumi.getter
    def segments(self) -> Optional[Sequence['outputs.ProjectConnectorsSegment']]:
        """
        Orchestrate customer identity traits and signals from your Descope user journey with the Segment connector.
        """
        return pulumi.get(self, "segments")

    @_builtins.property
    @pulumi.getter
    def sendgrids(self) -> Optional[Sequence['outputs.ProjectConnectorsSendgrid']]:
        """
        SendGrid is a cloud-based SMTP provider that allows you to send emails without having to maintain email servers.
        """
        return pulumi.get(self, "sendgrids")

    @_builtins.property
    @pulumi.getter
    def ses(self) -> Optional[Sequence['outputs.ProjectConnectorsSe']]:
        """
        Amazon Simple Email Service (SES) for sending emails through AWS infrastructure.
        """
        return pulumi.get(self, "ses")

    @_builtins.property
    @pulumi.getter
    def slacks(self) -> Optional[Sequence['outputs.ProjectConnectorsSlack']]:
        """
        Send updates to your team on Slack.
        """
        return pulumi.get(self, "slacks")

    @_builtins.property
    @pulumi.getter
    def smartlings(self) -> Optional[Sequence['outputs.ProjectConnectorsSmartling']]:
        """
        Localize the language of your login and user journey screens with the Smartling connector.
        """
        return pulumi.get(self, "smartlings")

    @_builtins.property
    @pulumi.getter
    def smtps(self) -> Optional[Sequence['outputs.ProjectConnectorsSmtp']]:
        """
        Simple Mail Transfer Protocol (SMTP) server for sending emails.
        """
        return pulumi.get(self, "smtps")

    @_builtins.property
    @pulumi.getter
    def sns(self) -> Optional[Sequence['outputs.ProjectConnectorsSn']]:
        """
        Amazon Simple Notification Service (SNS) for sending SMS messages through AWS.
        """
        return pulumi.get(self, "sns")

    @_builtins.property
    @pulumi.getter
    def sumologics(self) -> Optional[Sequence['outputs.ProjectConnectorsSumologic']]:
        """
        Stream logs and audit events with the Sumo Logic connector.
        """
        return pulumi.get(self, "sumologics")

    @_builtins.property
    @pulumi.getter
    def supabases(self) -> Optional[Sequence['outputs.ProjectConnectorsSupabase']]:
        """
        Generate external tokens for user authentication in Supabase projects.
        """
        return pulumi.get(self, "supabases")

    @_builtins.property
    @pulumi.getter
    def telesigns(self) -> Optional[Sequence['outputs.ProjectConnectorsTelesign']]:
        """
        Verify phone numbers and leverage granular risk scores for adaptive MFA with the Telesign Intelligence connector.
        """
        return pulumi.get(self, "telesigns")

    @_builtins.property
    @pulumi.getter
    def traceables(self) -> Optional[Sequence['outputs.ProjectConnectorsTraceable']]:
        """
        Identify and respond to fraudulent login activity with the Traceable Digital Fraud Prevention connector.
        """
        return pulumi.get(self, "traceables")

    @_builtins.property
    @pulumi.getter
    def turnstiles(self) -> Optional[Sequence['outputs.ProjectConnectorsTurnstile']]:
        """
        Prevent bot attacks on your login pages with the Turnstile connector.
        """
        return pulumi.get(self, "turnstiles")

    @_builtins.property
    @pulumi.getter(name="twilioCores")
    def twilio_cores(self) -> Optional[Sequence['outputs.ProjectConnectorsTwilioCore']]:
        """
        Twilio is a cloud-based communication provider of communication tools for making and receiving phone calls, sending and receiving text messages, and performing other communication functions.
        """
        return pulumi.get(self, "twilio_cores")

    @_builtins.property
    @pulumi.getter(name="twilioVerifies")
    def twilio_verifies(self) -> Optional[Sequence['outputs.ProjectConnectorsTwilioVerify']]:
        """
        Twilio Verify is an OTP service that can be used via text messages, instant messaging platforms, voice and e-mail. Choose this connector only if you are a Twilio Verify customer.
        """
        return pulumi.get(self, "twilio_verifies")


@pulumi.output_type
class ProjectConnectorsAbuseipdb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsAbuseipdb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsAbuseipdb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsAbuseipdb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: The unique AbuseIPDB API key.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The unique AbuseIPDB API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsAmplitude(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "serverUrl":
            suggest = "server_url"
        elif key == "serverZone":
            suggest = "server_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsAmplitude. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsAmplitude.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsAmplitude.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 server_url: Optional[_builtins.str] = None,
                 server_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: The Amplitude API Key generated for the Descope service.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str server_url: The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        :param _builtins.str server_zone: `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if server_zone is not None:
            pulumi.set(__self__, "server_zone", server_zone)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The Amplitude API Key generated for the Descope service.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[_builtins.str]:
        """
        The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        """
        return pulumi.get(self, "server_url")

    @_builtins.property
    @pulumi.getter(name="serverZone")
    def server_zone(self) -> Optional[_builtins.str]:
        """
        `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
        return pulumi.get(self, "server_zone")


@pulumi.output_type
class ProjectConnectorsAuditWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "auditFilters":
            suggest = "audit_filters"
        elif key == "hmacSecret":
            suggest = "hmac_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsAuditWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsAuditWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsAuditWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: _builtins.str,
                 name: _builtins.str,
                 audit_filters: Optional[Sequence['outputs.ProjectConnectorsAuditWebhookAuditFilter']] = None,
                 authentication: Optional['outputs.ProjectConnectorsAuditWebhookAuthentication'] = None,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 hmac_secret: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None):
        """
        :param _builtins.str base_url: The base URL to fetch
        :param _builtins.str name: A custom name for your connector.
        :param Sequence['ProjectConnectorsAuditWebhookAuditFilterArgs'] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param 'ProjectConnectorsAuditWebhookAuthenticationArgs' authentication: Authentication Information
        :param _builtins.str description: A description of what your connector is used for.
        :param Mapping[str, _builtins.str] headers: The headers to send with the request
        :param _builtins.str hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param _builtins.bool insecure: Will ignore certificate errors raised by the client
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "name", name)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> _builtins.str:
        """
        The base URL to fetch
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[Sequence['outputs.ProjectConnectorsAuditWebhookAuditFilter']]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ProjectConnectorsAuditWebhookAuthentication']:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[_builtins.str]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")


@pulumi.output_type
class ProjectConnectorsAuditWebhookAuditFilter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The field name to filter on (either 'actions' or 'tenants').
        :param _builtins.str operator: The filter operation to apply ('includes' or 'excludes').
        :param Sequence[_builtins.str] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProjectConnectorsAuditWebhookAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "bearerToken":
            suggest = "bearer_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsAuditWebhookAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsAuditWebhookAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsAuditWebhookAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.ProjectConnectorsAuditWebhookAuthenticationApiKey'] = None,
                 basic: Optional['outputs.ProjectConnectorsAuditWebhookAuthenticationBasic'] = None,
                 bearer_token: Optional[_builtins.str] = None):
        """
        :param 'ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs' api_key: API key authentication configuration.
        :param 'ProjectConnectorsAuditWebhookAuthenticationBasicArgs' basic: Basic authentication credentials (username and password).
        :param _builtins.str bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.ProjectConnectorsAuditWebhookAuthenticationApiKey']:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional['outputs.ProjectConnectorsAuditWebhookAuthenticationBasic']:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[_builtins.str]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")


@pulumi.output_type
class ProjectConnectorsAuditWebhookAuthenticationApiKey(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 token: _builtins.str):
        """
        :param _builtins.str key: The API key.
        :param _builtins.str token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The API secret.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ProjectConnectorsAuditWebhookAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: Password for basic HTTP authentication.
        :param _builtins.str username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ProjectConnectorsAwsS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "auditFilters":
            suggest = "audit_filters"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "troubleshootLogEnabled":
            suggest = "troubleshoot_log_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsAwsS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsAwsS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsAwsS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 access_key_id: Optional[_builtins.str] = None,
                 audit_enabled: Optional[_builtins.bool] = None,
                 audit_filters: Optional[Sequence['outputs.ProjectConnectorsAwsS3AuditFilter']] = None,
                 auth_type: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 troubleshoot_log_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket: The AWS S3 bucket. This bucket should already exist for the connector to work.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str region: The AWS S3 region, e.g. `us-east-1`.
        :param _builtins.str access_key_id: The unique AWS access key ID.
        :param _builtins.bool audit_enabled: Whether to enable streaming of audit events.
        :param Sequence['ProjectConnectorsAwsS3AuditFilterArgs'] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param _builtins.str auth_type: The authentication type to use.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str external_id: The external ID to use when assuming the role.
        :param _builtins.str role_arn: The Amazon Resource Name (ARN) of the role to assume.
        :param _builtins.str secret_access_key: The secret AWS access key.
        :param _builtins.bool troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The AWS S3 bucket. This bucket should already exist for the connector to work.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS S3 region, e.g. `us-east-1`.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[_builtins.str]:
        """
        The unique AWS access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[Sequence['outputs.ProjectConnectorsAwsS3AuditFilter']]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The secret AWS access key.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")


@pulumi.output_type
class ProjectConnectorsAwsS3AuditFilter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The field name to filter on (either 'actions' or 'tenants').
        :param _builtins.str operator: The filter operation to apply ('includes' or 'excludes').
        :param Sequence[_builtins.str] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProjectConnectorsAwsTranslate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "sessionToken":
            suggest = "session_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsAwsTranslate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsAwsTranslate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsAwsTranslate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 secret_access_key: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 session_token: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key_id: AWS access key ID.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str region: The AWS region to which this client will send requests. (e.g. us-east-1.)
        :param _builtins.str secret_access_key: AWS secret access key.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str session_token: (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        """
        AWS access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to which this client will send requests. (e.g. us-east-1.)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        """
        AWS secret access key.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[_builtins.str]:
        """
        (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
        return pulumi.get(self, "session_token")


@pulumi.output_type
class ProjectConnectorsBitsight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsBitsight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsBitsight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsBitsight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: API Client ID issued when you create the credentials in Bitsight Threat Intelligence.
        :param _builtins.str client_secret: Client secret issued when you create the credentials in Bitsight Threat Intelligence.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        API Client ID issued when you create the credentials in Bitsight Threat Intelligence.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        Client secret issued when you create the credentials in Bitsight Threat Intelligence.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "auditFilters":
            suggest = "audit_filters"
        elif key == "troubleshootLogEnabled":
            suggest = "troubleshoot_log_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 audit_enabled: Optional[_builtins.bool] = None,
                 audit_filters: Optional[Sequence['outputs.ProjectConnectorsDatadogAuditFilter']] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 site: Optional[_builtins.str] = None,
                 troubleshoot_log_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_key: The unique Datadog organization key.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.bool audit_enabled: Whether to enable streaming of audit events.
        :param Sequence['ProjectConnectorsDatadogAuditFilterArgs'] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str site: The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        :param _builtins.bool troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The unique Datadog organization key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[Sequence['outputs.ProjectConnectorsDatadogAuditFilter']]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def site(self) -> Optional[_builtins.str]:
        """
        The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        """
        return pulumi.get(self, "site")

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")


@pulumi.output_type
class ProjectConnectorsDatadogAuditFilter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The field name to filter on (either 'actions' or 'tenants').
        :param _builtins.str operator: The filter operation to apply ('includes' or 'excludes').
        :param Sequence[_builtins.str] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProjectConnectorsDevrevGrow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsDevrevGrow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsDevrevGrow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsDevrevGrow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Authentication to DevRev APIs requires a personal access token (PAT).
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Authentication to DevRev APIs requires a personal access token (PAT).
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsDocebo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsDocebo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsDocebo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsDocebo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: _builtins.str,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 name: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str base_url: The Docebo api base url.
        :param _builtins.str client_id: The Docebo OAuth 2.0 app client ID.
        :param _builtins.str client_secret: The Docebo OAuth 2.0 app client secret.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str password: The Docebo user's password.
        :param _builtins.str username: The Docebo username.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> _builtins.str:
        """
        The Docebo api base url.
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Docebo OAuth 2.0 app client ID.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The Docebo OAuth 2.0 app client secret.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Docebo user's password.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Docebo username.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsEightByEightViber(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "subAccountId":
            suggest = "sub_account_id"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsEightByEightViber. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsEightByEightViber.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsEightByEightViber.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 sub_account_id: _builtins.str,
                 country: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_key: The 8x8 API key for authentication.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str sub_account_id: The 8x8 sub-account ID is required for the Messaging API.
        :param _builtins.str country: The country code or region where your Viber messaging service is configured.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sub_account_id", sub_account_id)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The 8x8 API key for authentication.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subAccountId")
    def sub_account_id(self) -> _builtins.str:
        """
        The 8x8 sub-account ID is required for the Messaging API.
        """
        return pulumi.get(self, "sub_account_id")

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[_builtins.str]:
        """
        The country code or region where your Viber messaging service is configured.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsEightByEightWhatsapp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "subAccountId":
            suggest = "sub_account_id"
        elif key == "templateId":
            suggest = "template_id"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsEightByEightWhatsapp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsEightByEightWhatsapp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsEightByEightWhatsapp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 sub_account_id: _builtins.str,
                 template_id: _builtins.str,
                 country: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_key: The 8x8 API key for authentication.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str sub_account_id: The 8x8 sub-account ID is required for the Messaging API.
        :param _builtins.str template_id: The ID of a WhatsApp message template.
        :param _builtins.str country: The country code or region where your Viber messaging service is configured.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sub_account_id", sub_account_id)
        pulumi.set(__self__, "template_id", template_id)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The 8x8 API key for authentication.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subAccountId")
    def sub_account_id(self) -> _builtins.str:
        """
        The 8x8 sub-account ID is required for the Messaging API.
        """
        return pulumi.get(self, "sub_account_id")

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        """
        The ID of a WhatsApp message template.
        """
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[_builtins.str]:
        """
        The country code or region where your Viber messaging service is configured.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsElephant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsElephant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsElephant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsElephant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key: The Elephant access key.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        The Elephant access key.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsExternalTokenHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hmacSecret":
            suggest = "hmac_secret"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsExternalTokenHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsExternalTokenHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsExternalTokenHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 authentication: Optional['outputs.ProjectConnectorsExternalTokenHttpAuthentication'] = None,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 hmac_secret: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str endpoint: The endpoint to get the token from (Using POST method). Descope will send the user information in the body of the request, and should return a JSON response with a 'token' string field.
        :param _builtins.str name: A custom name for your connector.
        :param 'ProjectConnectorsExternalTokenHttpAuthenticationArgs' authentication: Authentication Information
        :param _builtins.str description: A description of what your connector is used for.
        :param Mapping[str, _builtins.str] headers: The headers to send with the request
        :param _builtins.str hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param _builtins.bool insecure: Will ignore certificate errors raised by the client
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The endpoint to get the token from (Using POST method). Descope will send the user information in the body of the request, and should return a JSON response with a 'token' string field.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ProjectConnectorsExternalTokenHttpAuthentication']:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[_builtins.str]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsExternalTokenHttpAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "bearerToken":
            suggest = "bearer_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsExternalTokenHttpAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsExternalTokenHttpAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsExternalTokenHttpAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.ProjectConnectorsExternalTokenHttpAuthenticationApiKey'] = None,
                 basic: Optional['outputs.ProjectConnectorsExternalTokenHttpAuthenticationBasic'] = None,
                 bearer_token: Optional[_builtins.str] = None):
        """
        :param 'ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgs' api_key: API key authentication configuration.
        :param 'ProjectConnectorsExternalTokenHttpAuthenticationBasicArgs' basic: Basic authentication credentials (username and password).
        :param _builtins.str bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.ProjectConnectorsExternalTokenHttpAuthenticationApiKey']:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional['outputs.ProjectConnectorsExternalTokenHttpAuthenticationBasic']:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[_builtins.str]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")


@pulumi.output_type
class ProjectConnectorsExternalTokenHttpAuthenticationApiKey(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 token: _builtins.str):
        """
        :param _builtins.str key: The API key.
        :param _builtins.str token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The API secret.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ProjectConnectorsExternalTokenHttpAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: Password for basic HTTP authentication.
        :param _builtins.str username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ProjectConnectorsFingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicApiKey":
            suggest = "public_api_key"
        elif key == "secretApiKey":
            suggest = "secret_api_key"
        elif key == "cloudflareEndpointUrl":
            suggest = "cloudflare_endpoint_url"
        elif key == "cloudflareScriptUrl":
            suggest = "cloudflare_script_url"
        elif key == "useCloudflareIntegration":
            suggest = "use_cloudflare_integration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsFingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsFingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsFingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 public_api_key: _builtins.str,
                 secret_api_key: _builtins.str,
                 cloudflare_endpoint_url: Optional[_builtins.str] = None,
                 cloudflare_script_url: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 use_cloudflare_integration: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str public_api_key: The Fingerprint public API key.
        :param _builtins.str secret_api_key: The Fingerprint secret API key.
        :param _builtins.str cloudflare_endpoint_url: The Cloudflare integration Endpoint URL.
        :param _builtins.str cloudflare_script_url: The Cloudflare integration Script URL.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool use_cloudflare_integration: Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_api_key", public_api_key)
        pulumi.set(__self__, "secret_api_key", secret_api_key)
        if cloudflare_endpoint_url is not None:
            pulumi.set(__self__, "cloudflare_endpoint_url", cloudflare_endpoint_url)
        if cloudflare_script_url is not None:
            pulumi.set(__self__, "cloudflare_script_url", cloudflare_script_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_cloudflare_integration is not None:
            pulumi.set(__self__, "use_cloudflare_integration", use_cloudflare_integration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicApiKey")
    def public_api_key(self) -> _builtins.str:
        """
        The Fingerprint public API key.
        """
        return pulumi.get(self, "public_api_key")

    @_builtins.property
    @pulumi.getter(name="secretApiKey")
    def secret_api_key(self) -> _builtins.str:
        """
        The Fingerprint secret API key.
        """
        return pulumi.get(self, "secret_api_key")

    @_builtins.property
    @pulumi.getter(name="cloudflareEndpointUrl")
    def cloudflare_endpoint_url(self) -> Optional[_builtins.str]:
        """
        The Cloudflare integration Endpoint URL.
        """
        return pulumi.get(self, "cloudflare_endpoint_url")

    @_builtins.property
    @pulumi.getter(name="cloudflareScriptUrl")
    def cloudflare_script_url(self) -> Optional[_builtins.str]:
        """
        The Cloudflare integration Script URL.
        """
        return pulumi.get(self, "cloudflare_script_url")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="useCloudflareIntegration")
    def use_cloudflare_integration(self) -> Optional[_builtins.bool]:
        """
        Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
        return pulumi.get(self, "use_cloudflare_integration")


@pulumi.output_type
class ProjectConnectorsFingerprintDescope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomain":
            suggest = "custom_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsFingerprintDescope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsFingerprintDescope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsFingerprintDescope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 custom_domain: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str custom_domain: The custom domain to fetch
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[_builtins.str]:
        """
        The custom domain to fetch
        """
        return pulumi.get(self, "custom_domain")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsFirebaseAdmin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsFirebaseAdmin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsFirebaseAdmin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsFirebaseAdmin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 service_account: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str service_account: The Firebase service account JSON.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_account", service_account)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> _builtins.str:
        """
        The Firebase service account JSON.
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsForter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "siteId":
            suggest = "site_id"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "overrideIpAddress":
            suggest = "override_ip_address"
        elif key == "overrideUserEmail":
            suggest = "override_user_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsForter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsForter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsForter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 secret_key: _builtins.str,
                 site_id: _builtins.str,
                 api_version: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 override_ip_address: Optional[_builtins.str] = None,
                 override_user_email: Optional[_builtins.str] = None,
                 overrides: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str secret_key: The Forter secret key.
        :param _builtins.str site_id: The Forter site ID.
        :param _builtins.str api_version: The Forter API version.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str override_ip_address: Override the user IP address.
        :param _builtins.str override_user_email: Override the user email.
        :param _builtins.bool overrides: Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_id", site_id)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_ip_address is not None:
            pulumi.set(__self__, "override_ip_address", override_ip_address)
        if override_user_email is not None:
            pulumi.set(__self__, "override_user_email", override_user_email)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The Forter secret key.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        """
        The Forter site ID.
        """
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        The Forter API version.
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="overrideIpAddress")
    def override_ip_address(self) -> Optional[_builtins.str]:
        """
        Override the user IP address.
        """
        return pulumi.get(self, "override_ip_address")

    @_builtins.property
    @pulumi.getter(name="overrideUserEmail")
    def override_user_email(self) -> Optional[_builtins.str]:
        """
        Override the user email.
        """
        return pulumi.get(self, "override_user_email")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[_builtins.bool]:
        """
        Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class ProjectConnectorsGenericEmailGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postUrl":
            suggest = "post_url"
        elif key == "hmacSecret":
            suggest = "hmac_secret"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsGenericEmailGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsGenericEmailGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsGenericEmailGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 post_url: _builtins.str,
                 authentication: Optional['outputs.ProjectConnectorsGenericEmailGatewayAuthentication'] = None,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 hmac_secret: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None,
                 sender: Optional[_builtins.str] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str post_url: The URL of the post email request
        :param 'ProjectConnectorsGenericEmailGatewayAuthenticationArgs' authentication: Authentication Information
        :param _builtins.str description: A description of what your connector is used for.
        :param Mapping[str, _builtins.str] headers: The headers to send with the request
        :param _builtins.str hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param _builtins.bool insecure: Will ignore certificate errors raised by the client
        :param _builtins.str sender: The sender address
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "post_url", post_url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="postUrl")
    def post_url(self) -> _builtins.str:
        """
        The URL of the post email request
        """
        return pulumi.get(self, "post_url")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ProjectConnectorsGenericEmailGatewayAuthentication']:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[_builtins.str]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter
    def sender(self) -> Optional[_builtins.str]:
        """
        The sender address
        """
        return pulumi.get(self, "sender")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsGenericEmailGatewayAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "bearerToken":
            suggest = "bearer_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsGenericEmailGatewayAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsGenericEmailGatewayAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsGenericEmailGatewayAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.ProjectConnectorsGenericEmailGatewayAuthenticationApiKey'] = None,
                 basic: Optional['outputs.ProjectConnectorsGenericEmailGatewayAuthenticationBasic'] = None,
                 bearer_token: Optional[_builtins.str] = None):
        """
        :param 'ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgs' api_key: API key authentication configuration.
        :param 'ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgs' basic: Basic authentication credentials (username and password).
        :param _builtins.str bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.ProjectConnectorsGenericEmailGatewayAuthenticationApiKey']:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional['outputs.ProjectConnectorsGenericEmailGatewayAuthenticationBasic']:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[_builtins.str]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")


@pulumi.output_type
class ProjectConnectorsGenericEmailGatewayAuthenticationApiKey(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 token: _builtins.str):
        """
        :param _builtins.str key: The API key.
        :param _builtins.str token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The API secret.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ProjectConnectorsGenericEmailGatewayAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: Password for basic HTTP authentication.
        :param _builtins.str username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ProjectConnectorsGenericSmsGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postUrl":
            suggest = "post_url"
        elif key == "hmacSecret":
            suggest = "hmac_secret"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsGenericSmsGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsGenericSmsGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsGenericSmsGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 post_url: _builtins.str,
                 authentication: Optional['outputs.ProjectConnectorsGenericSmsGatewayAuthentication'] = None,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 hmac_secret: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None,
                 sender: Optional[_builtins.str] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str post_url: The URL of the post message request
        :param 'ProjectConnectorsGenericSmsGatewayAuthenticationArgs' authentication: Authentication Information
        :param _builtins.str description: A description of what your connector is used for.
        :param Mapping[str, _builtins.str] headers: The headers to send with the request
        :param _builtins.str hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param _builtins.bool insecure: Will ignore certificate errors raised by the client
        :param _builtins.str sender: The sender number
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "post_url", post_url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="postUrl")
    def post_url(self) -> _builtins.str:
        """
        The URL of the post message request
        """
        return pulumi.get(self, "post_url")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ProjectConnectorsGenericSmsGatewayAuthentication']:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[_builtins.str]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter
    def sender(self) -> Optional[_builtins.str]:
        """
        The sender number
        """
        return pulumi.get(self, "sender")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsGenericSmsGatewayAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "bearerToken":
            suggest = "bearer_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsGenericSmsGatewayAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsGenericSmsGatewayAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsGenericSmsGatewayAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.ProjectConnectorsGenericSmsGatewayAuthenticationApiKey'] = None,
                 basic: Optional['outputs.ProjectConnectorsGenericSmsGatewayAuthenticationBasic'] = None,
                 bearer_token: Optional[_builtins.str] = None):
        """
        :param 'ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs' api_key: API key authentication configuration.
        :param 'ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs' basic: Basic authentication credentials (username and password).
        :param _builtins.str bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.ProjectConnectorsGenericSmsGatewayAuthenticationApiKey']:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional['outputs.ProjectConnectorsGenericSmsGatewayAuthenticationBasic']:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[_builtins.str]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")


@pulumi.output_type
class ProjectConnectorsGenericSmsGatewayAuthenticationApiKey(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 token: _builtins.str):
        """
        :param _builtins.str key: The API key.
        :param _builtins.str token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The API secret.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ProjectConnectorsGenericSmsGatewayAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: Password for basic HTTP authentication.
        :param _builtins.str username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ProjectConnectorsGoogleCloudLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountKey":
            suggest = "service_account_key"
        elif key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "auditFilters":
            suggest = "audit_filters"
        elif key == "troubleshootLogEnabled":
            suggest = "troubleshoot_log_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsGoogleCloudLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsGoogleCloudLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsGoogleCloudLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 service_account_key: _builtins.str,
                 audit_enabled: Optional[_builtins.bool] = None,
                 audit_filters: Optional[Sequence['outputs.ProjectConnectorsGoogleCloudLoggingAuditFilter']] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 troubleshoot_log_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str service_account_key: A Service Account Key JSON file created from a service account on your Google Cloud project. This file is used to authenticate and authorize the connector to access Google Cloud Logging. The service account this key belongs to must have the appropriate permissions to write logs.
        :param _builtins.bool audit_enabled: Whether to enable streaming of audit events.
        :param Sequence['ProjectConnectorsGoogleCloudLoggingAuditFilterArgs'] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_account_key", service_account_key)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> _builtins.str:
        """
        A Service Account Key JSON file created from a service account on your Google Cloud project. This file is used to authenticate and authorize the connector to access Google Cloud Logging. The service account this key belongs to must have the appropriate permissions to write logs.
        """
        return pulumi.get(self, "service_account_key")

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[Sequence['outputs.ProjectConnectorsGoogleCloudLoggingAuditFilter']]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")


@pulumi.output_type
class ProjectConnectorsGoogleCloudLoggingAuditFilter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The field name to filter on (either 'actions' or 'tenants').
        :param _builtins.str operator: The filter operation to apply ('includes' or 'excludes').
        :param Sequence[_builtins.str] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProjectConnectorsGoogleCloudTranslation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "serviceAccountJson":
            suggest = "service_account_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsGoogleCloudTranslation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsGoogleCloudTranslation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsGoogleCloudTranslation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 service_account_json: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str project_id: The Google Cloud project ID where the Google Cloud Translation is managed.
        :param _builtins.str service_account_json: Service Account JSON associated with the current project.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "service_account_json", service_account_json)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The Google Cloud project ID where the Google Cloud Translation is managed.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountJson")
    def service_account_json(self) -> _builtins.str:
        """
        Service Account JSON associated with the current project.
        """
        return pulumi.get(self, "service_account_json")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsGoogleMapsPlace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicApiKey":
            suggest = "public_api_key"
        elif key == "addressTypes":
            suggest = "address_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsGoogleMapsPlace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsGoogleMapsPlace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsGoogleMapsPlace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 public_api_key: _builtins.str,
                 address_types: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 language: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str public_api_key: The Google Maps Places public API key.
        :param _builtins.str address_types: The address types to return.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str language: The language in which to return results.
        :param _builtins.str region: The region code, specified as a CLDR two-character region code.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_api_key", public_api_key)
        if address_types is not None:
            pulumi.set(__self__, "address_types", address_types)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicApiKey")
    def public_api_key(self) -> _builtins.str:
        """
        The Google Maps Places public API key.
        """
        return pulumi.get(self, "public_api_key")

    @_builtins.property
    @pulumi.getter(name="addressTypes")
    def address_types(self) -> Optional[_builtins.str]:
        """
        The address types to return.
        """
        return pulumi.get(self, "address_types")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[_builtins.str]:
        """
        The language in which to return results.
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region code, specified as a CLDR two-character region code.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ProjectConnectorsHibp(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "hmacSecret":
            suggest = "hmac_secret"
        elif key == "includeHeadersInContext":
            suggest = "include_headers_in_context"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: _builtins.str,
                 name: _builtins.str,
                 authentication: Optional['outputs.ProjectConnectorsHttpAuthentication'] = None,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 hmac_secret: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 include_headers_in_context: Optional[_builtins.bool] = None,
                 insecure: Optional[_builtins.bool] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str base_url: The base URL to fetch
        :param _builtins.str name: A custom name for your connector.
        :param 'ProjectConnectorsHttpAuthenticationArgs' authentication: Authentication Information
        :param _builtins.str description: A description of what your connector is used for.
        :param Mapping[str, _builtins.str] headers: The headers to send with the request
        :param _builtins.str hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param _builtins.bool include_headers_in_context: The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        :param _builtins.bool insecure: Will ignore certificate errors raised by the client
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_headers_in_context is not None:
            pulumi.set(__self__, "include_headers_in_context", include_headers_in_context)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> _builtins.str:
        """
        The base URL to fetch
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ProjectConnectorsHttpAuthentication']:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[_builtins.str]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="includeHeadersInContext")
    def include_headers_in_context(self) -> Optional[_builtins.bool]:
        """
        The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        """
        return pulumi.get(self, "include_headers_in_context")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsHttpAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "bearerToken":
            suggest = "bearer_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsHttpAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsHttpAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsHttpAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.ProjectConnectorsHttpAuthenticationApiKey'] = None,
                 basic: Optional['outputs.ProjectConnectorsHttpAuthenticationBasic'] = None,
                 bearer_token: Optional[_builtins.str] = None):
        """
        :param 'ProjectConnectorsHttpAuthenticationApiKeyArgs' api_key: API key authentication configuration.
        :param 'ProjectConnectorsHttpAuthenticationBasicArgs' basic: Basic authentication credentials (username and password).
        :param _builtins.str bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.ProjectConnectorsHttpAuthenticationApiKey']:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional['outputs.ProjectConnectorsHttpAuthenticationBasic']:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[_builtins.str]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")


@pulumi.output_type
class ProjectConnectorsHttpAuthenticationApiKey(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 token: _builtins.str):
        """
        :param _builtins.str key: The API key.
        :param _builtins.str token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The API secret.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ProjectConnectorsHttpAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: Password for basic HTTP authentication.
        :param _builtins.str username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ProjectConnectorsHubspot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "baseUrl":
            suggest = "base_url"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsHubspot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsHubspot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsHubspot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: _builtins.str,
                 name: _builtins.str,
                 base_url: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str access_token: The HubSpot private API access token generated for the Descope service.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str base_url: The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "name", name)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> _builtins.str:
        """
        The HubSpot private API access token generated for the Descope service.
        """
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsIncode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiUrl":
            suggest = "api_url"
        elif key == "flowId":
            suggest = "flow_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsIncode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsIncode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsIncode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 api_url: _builtins.str,
                 flow_id: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Your InCode API key.
        :param _builtins.str api_url: The base URL of the Incode API
        :param _builtins.str flow_id: Your wanted InCode's flow ID.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Your InCode API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> _builtins.str:
        """
        The base URL of the Incode API
        """
        return pulumi.get(self, "api_url")

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> _builtins.str:
        """
        Your wanted InCode's flow ID.
        """
        return pulumi.get(self, "flow_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsIntercom(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 token: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str token: The Intercom access token.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str region: Regional Hosting - US, EU, or AU. default: US
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The Intercom access token.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Regional Hosting - US, EU, or AU. default: US
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ProjectConnectorsLokalise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "cardId":
            suggest = "card_id"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "translationProvider":
            suggest = "translation_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsLokalise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsLokalise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsLokalise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 card_id: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 team_id: Optional[_builtins.str] = None,
                 translation_provider: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_token: Lokalise API token.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str project_id: Lokalise project ID.
        :param _builtins.str card_id: (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str team_id: Lokalise team ID. If not provided, the oldest available team will be used.
        :param _builtins.str translation_provider: The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if card_id is not None:
            pulumi.set(__self__, "card_id", card_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if translation_provider is not None:
            pulumi.set(__self__, "translation_provider", translation_provider)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> _builtins.str:
        """
        Lokalise API token.
        """
        return pulumi.get(self, "api_token")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Lokalise project ID.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="cardId")
    def card_id(self) -> Optional[_builtins.str]:
        """
        (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        """
        return pulumi.get(self, "card_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[_builtins.str]:
        """
        Lokalise team ID. If not provided, the oldest available team will be used.
        """
        return pulumi.get(self, "team_id")

    @_builtins.property
    @pulumi.getter(name="translationProvider")
    def translation_provider(self) -> Optional[_builtins.str]:
        """
        The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
        return pulumi.get(self, "translation_provider")


@pulumi.output_type
class ProjectConnectorsMparticle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "baseUrl":
            suggest = "base_url"
        elif key == "defaultEnvironment":
            suggest = "default_environment"
        elif key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsMparticle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsMparticle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsMparticle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 api_secret: _builtins.str,
                 name: _builtins.str,
                 base_url: Optional[_builtins.str] = None,
                 default_environment: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_key: The mParticle Server to Server Key generated for the Descope service.
        :param _builtins.str api_secret: The mParticle Server to Server Secret generated for the Descope service.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str base_url: The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        :param _builtins.str default_environment: The default environment of which connector send data to, either “production” or “development“. default value: production. This field can be overridden per event (see at flows).
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "name", name)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if default_environment is not None:
            pulumi.set(__self__, "default_environment", default_environment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The mParticle Server to Server Key generated for the Descope service.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> _builtins.str:
        """
        The mParticle Server to Server Secret generated for the Descope service.
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="defaultEnvironment")
    def default_environment(self) -> Optional[_builtins.str]:
        """
        The default environment of which connector send data to, either “production” or “development“. default value: production. This field can be overridden per event (see at flows).
        """
        return pulumi.get(self, "default_environment")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsNewrelic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "auditFilters":
            suggest = "audit_filters"
        elif key == "dataCenter":
            suggest = "data_center"
        elif key == "logsPrefix":
            suggest = "logs_prefix"
        elif key == "overrideLogsPrefix":
            suggest = "override_logs_prefix"
        elif key == "troubleshootLogEnabled":
            suggest = "troubleshoot_log_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsNewrelic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsNewrelic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsNewrelic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 audit_enabled: Optional[_builtins.bool] = None,
                 audit_filters: Optional[Sequence['outputs.ProjectConnectorsNewrelicAuditFilter']] = None,
                 data_center: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 logs_prefix: Optional[_builtins.str] = None,
                 override_logs_prefix: Optional[_builtins.bool] = None,
                 troubleshoot_log_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_key: Ingest License Key of the account you want to report data to.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.bool audit_enabled: Whether to enable streaming of audit events.
        :param Sequence['ProjectConnectorsNewrelicAuditFilterArgs'] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param _builtins.str data_center: The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str logs_prefix: Specify a custom prefix for all log fields. The default prefix is `descope.`.
        :param _builtins.bool override_logs_prefix: Enable this option to use a custom prefix for log fields.
        :param _builtins.bool troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if data_center is not None:
            pulumi.set(__self__, "data_center", data_center)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logs_prefix is not None:
            pulumi.set(__self__, "logs_prefix", logs_prefix)
        if override_logs_prefix is not None:
            pulumi.set(__self__, "override_logs_prefix", override_logs_prefix)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Ingest License Key of the account you want to report data to.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[Sequence['outputs.ProjectConnectorsNewrelicAuditFilter']]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @_builtins.property
    @pulumi.getter(name="dataCenter")
    def data_center(self) -> Optional[_builtins.str]:
        """
        The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        """
        return pulumi.get(self, "data_center")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="logsPrefix")
    def logs_prefix(self) -> Optional[_builtins.str]:
        """
        Specify a custom prefix for all log fields. The default prefix is `descope.`.
        """
        return pulumi.get(self, "logs_prefix")

    @_builtins.property
    @pulumi.getter(name="overrideLogsPrefix")
    def override_logs_prefix(self) -> Optional[_builtins.bool]:
        """
        Enable this option to use a custom prefix for log fields.
        """
        return pulumi.get(self, "override_logs_prefix")

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")


@pulumi.output_type
class ProjectConnectorsNewrelicAuditFilter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The field name to filter on (either 'actions' or 'tenants').
        :param _builtins.str operator: The filter operation to apply ('includes' or 'excludes').
        :param Sequence[_builtins.str] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProjectConnectorsRadar(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicApiKey":
            suggest = "public_api_key"
        elif key == "addressTypes":
            suggest = "address_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsRadar. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsRadar.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsRadar.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 public_api_key: _builtins.str,
                 address_types: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 language: Optional[_builtins.str] = None,
                 limit: Optional[_builtins.float] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str public_api_key: The Radar publishable API key.
        :param _builtins.str address_types: The address types to return.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str language: The language in which to return results.
        :param _builtins.float limit: The maximum number of results to return.
        :param _builtins.str region: The region code, specified as a two-letter ISO 3166 code.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_api_key", public_api_key)
        if address_types is not None:
            pulumi.set(__self__, "address_types", address_types)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicApiKey")
    def public_api_key(self) -> _builtins.str:
        """
        The Radar publishable API key.
        """
        return pulumi.get(self, "public_api_key")

    @_builtins.property
    @pulumi.getter(name="addressTypes")
    def address_types(self) -> Optional[_builtins.str]:
        """
        The address types to return.
        """
        return pulumi.get(self, "address_types")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[_builtins.str]:
        """
        The language in which to return results.
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.float]:
        """
        The maximum number of results to return.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region code, specified as a two-letter ISO 3166 code.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ProjectConnectorsRecaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "siteKey":
            suggest = "site_key"
        elif key == "assessmentScore":
            suggest = "assessment_score"
        elif key == "overrideAssessment":
            suggest = "override_assessment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsRecaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsRecaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsRecaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 secret_key: _builtins.str,
                 site_key: _builtins.str,
                 assessment_score: Optional[_builtins.float] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 override_assessment: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str secret_key: The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        :param _builtins.str site_key: The site key is used to invoke reCAPTCHA service on your site or mobile application.
        :param _builtins.float assessment_score: When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool override_assessment: Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_key", site_key)
        if assessment_score is not None:
            pulumi.set(__self__, "assessment_score", assessment_score)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_assessment is not None:
            pulumi.set(__self__, "override_assessment", override_assessment)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> _builtins.str:
        """
        The site key is used to invoke reCAPTCHA service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @_builtins.property
    @pulumi.getter(name="assessmentScore")
    def assessment_score(self) -> Optional[_builtins.float]:
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        return pulumi.get(self, "assessment_score")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="overrideAssessment")
    def override_assessment(self) -> Optional[_builtins.bool]:
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        return pulumi.get(self, "override_assessment")


@pulumi.output_type
class ProjectConnectorsRecaptchaEnterprise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "siteKey":
            suggest = "site_key"
        elif key == "assessmentScore":
            suggest = "assessment_score"
        elif key == "baseUrl":
            suggest = "base_url"
        elif key == "botThreshold":
            suggest = "bot_threshold"
        elif key == "overrideAssessment":
            suggest = "override_assessment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsRecaptchaEnterprise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsRecaptchaEnterprise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsRecaptchaEnterprise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 site_key: _builtins.str,
                 assessment_score: Optional[_builtins.float] = None,
                 base_url: Optional[_builtins.str] = None,
                 bot_threshold: Optional[_builtins.float] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 override_assessment: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_key: API key associated with the current project.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str project_id: The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        :param _builtins.str site_key: The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        :param _builtins.float assessment_score: When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        :param _builtins.str base_url: Apply a custom url to the reCAPTCHA Enterprise scripts. This is useful when attempting to use reCAPTCHA globally. Defaults to https://www.google.com
        :param _builtins.float bot_threshold: The bot threshold is used to determine whether the request is a bot or a human. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot. If the score is below this threshold, the request is considered a bot.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool override_assessment: Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "site_key", site_key)
        if assessment_score is not None:
            pulumi.set(__self__, "assessment_score", assessment_score)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if bot_threshold is not None:
            pulumi.set(__self__, "bot_threshold", bot_threshold)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_assessment is not None:
            pulumi.set(__self__, "override_assessment", override_assessment)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        API key associated with the current project.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> _builtins.str:
        """
        The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @_builtins.property
    @pulumi.getter(name="assessmentScore")
    def assessment_score(self) -> Optional[_builtins.float]:
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        return pulumi.get(self, "assessment_score")

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        Apply a custom url to the reCAPTCHA Enterprise scripts. This is useful when attempting to use reCAPTCHA globally. Defaults to https://www.google.com
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="botThreshold")
    def bot_threshold(self) -> Optional[_builtins.float]:
        """
        The bot threshold is used to determine whether the request is a bot or a human. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot. If the score is below this threshold, the request is considered a bot.
        """
        return pulumi.get(self, "bot_threshold")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="overrideAssessment")
    def override_assessment(self) -> Optional[_builtins.bool]:
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        return pulumi.get(self, "override_assessment")


@pulumi.output_type
class ProjectConnectorsRekognition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "collectionId":
            suggest = "collection_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsRekognition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsRekognition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsRekognition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 collection_id: _builtins.str,
                 name: _builtins.str,
                 secret_access_key: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key_id: The AWS access key ID
        :param _builtins.str collection_id: The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str secret_access_key: The AWS secret access key
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        """
        The AWS access key ID
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> _builtins.str:
        """
        The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        """
        return pulumi.get(self, "collection_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        """
        The AWS secret access key
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsSalesforce(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSalesforce. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSalesforce.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSalesforce.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: _builtins.str,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 name: _builtins.str,
                 version: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str base_url: The Salesforce API base URL.
        :param _builtins.str client_id: The consumer key of the connected app.
        :param _builtins.str client_secret: The consumer secret of the connected app.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str version: REST API Version.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> _builtins.str:
        """
        The Salesforce API base URL.
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The consumer key of the connected app.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The consumer secret of the connected app.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        REST API Version.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsSalesforceMarketingCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accountId":
            suggest = "account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSalesforceMarketingCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSalesforceMarketingCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSalesforceMarketingCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 name: _builtins.str,
                 subdomain: _builtins.str,
                 account_id: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Client ID issued when you create the API integration in Installed Packages.
        :param _builtins.str client_secret: Client secret issued when you create the API integration in Installed Packages.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str subdomain: The Salesforce Marketing Cloud endpoint subdomain.
        :param _builtins.str account_id: Account identifier, or MID, of the target business unit.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str scope: Space-separated list of data-access permissions for your connector.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Client ID issued when you create the API integration in Installed Packages.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        Client secret issued when you create the API integration in Installed Packages.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        The Salesforce Marketing Cloud endpoint subdomain.
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        Account identifier, or MID, of the target business unit.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        Space-separated list of data-access permissions for your connector.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class ProjectConnectorsSardine(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSardine. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSardine.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSardine.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: _builtins.str,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str base_url: The base URL for the Sardine API, e.g.: https://api.sandbox.sardine.ai, https://api.sardine.ai, https://api.eu.sardine.ai.
        :param _builtins.str client_id: The Sardine Client ID.
        :param _builtins.str client_secret: The Sardine Client Secret.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> _builtins.str:
        """
        The base URL for the Sardine API, e.g.: https://api.sandbox.sardine.ai, https://api.sardine.ai, https://api.eu.sardine.ai.
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Sardine Client ID.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The Sardine Client Secret.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsSe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 region: _builtins.str,
                 sender: 'outputs.ProjectConnectorsSeSender',
                 access_key_id: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str region: AWS region to send requests to (e.g. `us-west-2`).
        :param 'ProjectConnectorsSeSenderArgs' sender: The sender details that should be displayed in the email message.
        :param _builtins.str access_key_id: AWS Access key ID.
        :param _builtins.str auth_type: The authentication type to use.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str endpoint: An optional endpoint URL (hostname only or fully qualified URI).
        :param _builtins.str external_id: The external ID to use when assuming the role.
        :param _builtins.str role_arn: The Amazon Resource Name (ARN) of the role to assume.
        :param _builtins.str secret: AWS Secret Access Key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "sender", sender)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def sender(self) -> 'outputs.ProjectConnectorsSeSender':
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[_builtins.str]:
        """
        AWS Access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        AWS Secret Access Key.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ProjectConnectorsSeSender(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: The email address that will appear as the sender of the email.
        :param _builtins.str name: The display name that will appear as the sender of the email.
        """
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address that will appear as the sender of the email.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The display name that will appear as the sender of the email.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProjectConnectorsSegment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeKey":
            suggest = "write_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSegment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSegment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSegment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 write_key: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str write_key: The Segment Write Key generated for the Descope service.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str host: The base URL of the Segment API, when using a custom domain in Segment.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "write_key", write_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="writeKey")
    def write_key(self) -> _builtins.str:
        """
        The Segment Write Key generated for the Descope service.
        """
        return pulumi.get(self, "write_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The base URL of the Segment API, when using a custom domain in Segment.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsSendgrid(dict):
    def __init__(__self__, *,
                 authentication: 'outputs.ProjectConnectorsSendgridAuthentication',
                 name: _builtins.str,
                 sender: 'outputs.ProjectConnectorsSendgridSender',
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param 'ProjectConnectorsSendgridAuthenticationArgs' authentication: SendGrid API authentication configuration.
        :param _builtins.str name: A custom name for your connector.
        :param 'ProjectConnectorsSendgridSenderArgs' sender: The sender details that should be displayed in the email message.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sender", sender)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.ProjectConnectorsSendgridAuthentication':
        """
        SendGrid API authentication configuration.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def sender(self) -> 'outputs.ProjectConnectorsSendgridSender':
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsSendgridAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSendgridAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSendgridAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSendgridAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str):
        """
        :param _builtins.str api_key: SendGrid API key for authentication.
        """
        pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        SendGrid API key for authentication.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class ProjectConnectorsSendgridSender(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: The email address that will appear as the sender of the email.
        :param _builtins.str name: The display name that will appear as the sender of the email.
        """
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address that will appear as the sender of the email.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The display name that will appear as the sender of the email.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProjectConnectorsSlack(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 token: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str token: The OAuth token for Slack's Bot User, used to authenticate API requests.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The OAuth token for Slack's Bot User, used to authenticate API requests.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsSmartling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountUid":
            suggest = "account_uid"
        elif key == "userIdentifier":
            suggest = "user_identifier"
        elif key == "userSecret":
            suggest = "user_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSmartling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSmartling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSmartling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_uid: _builtins.str,
                 name: _builtins.str,
                 user_identifier: _builtins.str,
                 user_secret: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_uid: The account UID for the Smartling account.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str user_identifier: The user identifier for the Smartling account.
        :param _builtins.str user_secret: The user secret for the Smartling account.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "account_uid", account_uid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user_identifier", user_identifier)
        pulumi.set(__self__, "user_secret", user_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accountUid")
    def account_uid(self) -> _builtins.str:
        """
        The account UID for the Smartling account.
        """
        return pulumi.get(self, "account_uid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="userIdentifier")
    def user_identifier(self) -> _builtins.str:
        """
        The user identifier for the Smartling account.
        """
        return pulumi.get(self, "user_identifier")

    @_builtins.property
    @pulumi.getter(name="userSecret")
    def user_secret(self) -> _builtins.str:
        """
        The user secret for the Smartling account.
        """
        return pulumi.get(self, "user_secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsSmtp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useStaticIps":
            suggest = "use_static_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSmtp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSmtp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSmtp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.ProjectConnectorsSmtpAuthentication',
                 name: _builtins.str,
                 sender: 'outputs.ProjectConnectorsSmtpSender',
                 server: 'outputs.ProjectConnectorsSmtpServer',
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 use_static_ips: Optional[_builtins.bool] = None):
        """
        :param 'ProjectConnectorsSmtpAuthenticationArgs' authentication: SMTP server authentication credentials and method.
        :param _builtins.str name: A custom name for your connector.
        :param 'ProjectConnectorsSmtpSenderArgs' sender: The sender details that should be displayed in the email message.
        :param 'ProjectConnectorsSmtpServerArgs' server: SMTP server connection details including hostname and port.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sender", sender)
        pulumi.set(__self__, "server", server)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.ProjectConnectorsSmtpAuthentication':
        """
        SMTP server authentication credentials and method.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def sender(self) -> 'outputs.ProjectConnectorsSmtpSender':
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @_builtins.property
    @pulumi.getter
    def server(self) -> 'outputs.ProjectConnectorsSmtpServer':
        """
        SMTP server connection details including hostname and port.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[_builtins.bool]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")


@pulumi.output_type
class ProjectConnectorsSmtpAuthentication(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str,
                 method: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for SMTP server authentication.
        :param _builtins.str username: Username for SMTP server authentication.
        :param _builtins.str method: SMTP authentication method (`plain` or `login`).
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for SMTP server authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for SMTP server authentication.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        SMTP authentication method (`plain` or `login`).
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class ProjectConnectorsSmtpSender(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: The email address that will appear as the sender of the email.
        :param _builtins.str name: The display name that will appear as the sender of the email.
        """
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address that will appear as the sender of the email.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The display name that will appear as the sender of the email.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProjectConnectorsSmtpServer(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str host: The hostname or IP address of the SMTP server.
        :param _builtins.int port: The port number to connect to on the SMTP server.
        """
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The hostname or IP address of the SMTP server.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number to connect to on the SMTP server.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ProjectConnectorsSn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "organizationNumber":
            suggest = "organization_number"
        elif key == "originationNumber":
            suggest = "origination_number"
        elif key == "senderId":
            suggest = "sender_id"
        elif key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 secret: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 entity_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 organization_number: Optional[_builtins.str] = None,
                 origination_number: Optional[_builtins.str] = None,
                 sender_id: Optional[_builtins.str] = None,
                 template_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key_id: AWS Access key ID.
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str region: AWS region to send requests to (e.g. `us-west-2`).
        :param _builtins.str secret: AWS Secret Access Key.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str endpoint: An optional endpoint URL (hostname only or fully qualified URI).
        :param _builtins.str entity_id: The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        :param _builtins.str organization_number: Use the `origination_number` attribute instead.
        :param _builtins.str origination_number: An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        :param _builtins.str sender_id: The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        :param _builtins.str template_id: The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret", secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if organization_number is not None:
            pulumi.set(__self__, "organization_number", organization_number)
        if origination_number is not None:
            pulumi.set(__self__, "origination_number", origination_number)
        if sender_id is not None:
            pulumi.set(__self__, "sender_id", sender_id)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        """
        AWS Access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        AWS Secret Access Key.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[_builtins.str]:
        """
        The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        """
        return pulumi.get(self, "entity_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="organizationNumber")
    @_utilities.deprecated("""The organization_number attribute has been renamed, set the origination_number attribute instead. This attribute will be removed in a future version of the provider.""")
    def organization_number(self) -> Optional[_builtins.str]:
        """
        Use the `origination_number` attribute instead.
        """
        return pulumi.get(self, "organization_number")

    @_builtins.property
    @pulumi.getter(name="originationNumber")
    def origination_number(self) -> Optional[_builtins.str]:
        """
        An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        """
        return pulumi.get(self, "origination_number")

    @_builtins.property
    @pulumi.getter(name="senderId")
    def sender_id(self) -> Optional[_builtins.str]:
        """
        The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        """
        return pulumi.get(self, "sender_id")

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[_builtins.str]:
        """
        The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class ProjectConnectorsSumologic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpSourceUrl":
            suggest = "http_source_url"
        elif key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "auditFilters":
            suggest = "audit_filters"
        elif key == "troubleshootLogEnabled":
            suggest = "troubleshoot_log_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSumologic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSumologic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSumologic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_source_url: _builtins.str,
                 name: _builtins.str,
                 audit_enabled: Optional[_builtins.bool] = None,
                 audit_filters: Optional[Sequence['outputs.ProjectConnectorsSumologicAuditFilter']] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 troubleshoot_log_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str http_source_url: The URL associated with an HTTP Hosted collector
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.bool audit_enabled: Whether to enable streaming of audit events.
        :param Sequence['ProjectConnectorsSumologicAuditFilterArgs'] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "http_source_url", http_source_url)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter(name="httpSourceUrl")
    def http_source_url(self) -> _builtins.str:
        """
        The URL associated with an HTTP Hosted collector
        """
        return pulumi.get(self, "http_source_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[Sequence['outputs.ProjectConnectorsSumologicAuditFilter']]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")


@pulumi.output_type
class ProjectConnectorsSumologicAuditFilter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The field name to filter on (either 'actions' or 'tenants').
        :param _builtins.str operator: The filter operation to apply ('includes' or 'excludes').
        :param Sequence[_builtins.str] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProjectConnectorsSupabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createUsers":
            suggest = "create_users"
        elif key == "customClaimsMapping":
            suggest = "custom_claims_mapping"
        elif key == "expirationTime":
            suggest = "expiration_time"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "projectBaseUrl":
            suggest = "project_base_url"
        elif key == "serviceRoleApiKey":
            suggest = "service_role_api_key"
        elif key == "signingSecret":
            suggest = "signing_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsSupabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsSupabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsSupabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 auth_type: Optional[_builtins.str] = None,
                 create_users: Optional[_builtins.bool] = None,
                 custom_claims_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 expiration_time: Optional[_builtins.float] = None,
                 id: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None,
                 project_base_url: Optional[_builtins.str] = None,
                 service_role_api_key: Optional[_builtins.str] = None,
                 signing_secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str auth_type: The authentication type to use.
        :param _builtins.bool create_users: Enable to automatically create users in Supabase when generating tokens. Will only create a new user if one does not already exist. When disabled, only JWT tokens will be generated, WITHOUT user creation.
        :param Mapping[str, _builtins.str] custom_claims_mapping: A mapping of Descope user fields or JWT claims to Supabase custom claims
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.float expiration_time: The duration in minutes for which the token is valid.
        :param _builtins.str private_key: The private key in JWK format used to sign the JWT. You can generate a key using tools like `npx supabase gen signing-key --algorithm ES256`. Make sure to use the ES256 algorithm.
        :param _builtins.str project_base_url: Your Supabase Project's API base URL, e.g.: https://\\n\\n.supabase.co.
        :param _builtins.str service_role_api_key: The service role API key for your Supabase project, required to create users.
        :param _builtins.str signing_secret: The signing secret for your Supabase project.
        """
        pulumi.set(__self__, "name", name)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if create_users is not None:
            pulumi.set(__self__, "create_users", create_users)
        if custom_claims_mapping is not None:
            pulumi.set(__self__, "custom_claims_mapping", custom_claims_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if project_base_url is not None:
            pulumi.set(__self__, "project_base_url", project_base_url)
        if service_role_api_key is not None:
            pulumi.set(__self__, "service_role_api_key", service_role_api_key)
        if signing_secret is not None:
            pulumi.set(__self__, "signing_secret", signing_secret)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="createUsers")
    def create_users(self) -> Optional[_builtins.bool]:
        """
        Enable to automatically create users in Supabase when generating tokens. Will only create a new user if one does not already exist. When disabled, only JWT tokens will be generated, WITHOUT user creation.
        """
        return pulumi.get(self, "create_users")

    @_builtins.property
    @pulumi.getter(name="customClaimsMapping")
    def custom_claims_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A mapping of Descope user fields or JWT claims to Supabase custom claims
        """
        return pulumi.get(self, "custom_claims_mapping")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[_builtins.float]:
        """
        The duration in minutes for which the token is valid.
        """
        return pulumi.get(self, "expiration_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The private key in JWK format used to sign the JWT. You can generate a key using tools like `npx supabase gen signing-key --algorithm ES256`. Make sure to use the ES256 algorithm.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="projectBaseUrl")
    def project_base_url(self) -> Optional[_builtins.str]:
        """
        Your Supabase Project's API base URL, e.g.: https://\\n\\n.supabase.co.
        """
        return pulumi.get(self, "project_base_url")

    @_builtins.property
    @pulumi.getter(name="serviceRoleApiKey")
    def service_role_api_key(self) -> Optional[_builtins.str]:
        """
        The service role API key for your Supabase project, required to create users.
        """
        return pulumi.get(self, "service_role_api_key")

    @_builtins.property
    @pulumi.getter(name="signingSecret")
    def signing_secret(self) -> Optional[_builtins.str]:
        """
        The signing secret for your Supabase project.
        """
        return pulumi.get(self, "signing_secret")


@pulumi.output_type
class ProjectConnectorsTelesign(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "customerId":
            suggest = "customer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTelesign. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTelesign.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTelesign.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 customer_id: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: The unique Telesign API key
        :param _builtins.str customer_id: The unique Telesign account Customer ID
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "customer_id", customer_id)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        The unique Telesign API key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> _builtins.str:
        """
        The unique Telesign account Customer ID
        """
        return pulumi.get(self, "customer_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsTraceable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "euRegion":
            suggest = "eu_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTraceable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTraceable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTraceable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 secret_key: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 eu_region: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str secret_key: The Traceable secret key.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.bool eu_region: EU(Europe) Region deployment of Traceable platform.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if eu_region is not None:
            pulumi.set(__self__, "eu_region", eu_region)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The Traceable secret key.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="euRegion")
    def eu_region(self) -> Optional[_builtins.bool]:
        """
        EU(Europe) Region deployment of Traceable platform.
        """
        return pulumi.get(self, "eu_region")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsTurnstile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "siteKey":
            suggest = "site_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTurnstile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTurnstile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTurnstile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 secret_key: _builtins.str,
                 site_key: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str secret_key: The secret key authorizes communication between Descope backend and the Turnstile server to verify the user's response.
        :param _builtins.str site_key: The site key is used to invoke Turnstile service on your site or mobile application.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_key", site_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The secret key authorizes communication between Descope backend and the Turnstile server to verify the user's response.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> _builtins.str:
        """
        The site key is used to invoke Turnstile service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsTwilioCore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountSid":
            suggest = "account_sid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTwilioCore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTwilioCore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTwilioCore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_sid: _builtins.str,
                 authentication: 'outputs.ProjectConnectorsTwilioCoreAuthentication',
                 name: _builtins.str,
                 senders: 'outputs.ProjectConnectorsTwilioCoreSenders',
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_sid: Twilio Account SID from your Twilio Console.
        :param 'ProjectConnectorsTwilioCoreAuthenticationArgs' authentication: Twilio authentication credentials (either auth token or API key/secret).
        :param _builtins.str name: A custom name for your connector.
        :param 'ProjectConnectorsTwilioCoreSendersArgs' senders: Configuration for SMS and voice message senders.
        :param _builtins.str description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "senders", senders)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> _builtins.str:
        """
        Twilio Account SID from your Twilio Console.
        """
        return pulumi.get(self, "account_sid")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.ProjectConnectorsTwilioCoreAuthentication':
        """
        Twilio authentication credentials (either auth token or API key/secret).
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def senders(self) -> 'outputs.ProjectConnectorsTwilioCoreSenders':
        """
        Configuration for SMS and voice message senders.
        """
        return pulumi.get(self, "senders")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectConnectorsTwilioCoreAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "authToken":
            suggest = "auth_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTwilioCoreAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTwilioCoreAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTwilioCoreAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None,
                 api_secret: Optional[_builtins.str] = None,
                 auth_token: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Twilio API Key for authentication (used with API Secret).
        :param _builtins.str api_secret: Twilio API Secret for authentication (used with API Key).
        :param _builtins.str auth_token: Twilio Auth Token for authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        Twilio API Key for authentication (used with API Secret).
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[_builtins.str]:
        """
        Twilio API Secret for authentication (used with API Key).
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[_builtins.str]:
        """
        Twilio Auth Token for authentication.
        """
        return pulumi.get(self, "auth_token")


@pulumi.output_type
class ProjectConnectorsTwilioCoreSenders(dict):
    def __init__(__self__, *,
                 sms: 'outputs.ProjectConnectorsTwilioCoreSendersSms',
                 voice: Optional['outputs.ProjectConnectorsTwilioCoreSendersVoice'] = None):
        """
        :param 'ProjectConnectorsTwilioCoreSendersSmsArgs' sms: SMS sender configuration using either a phone number or messaging service.
        :param 'ProjectConnectorsTwilioCoreSendersVoiceArgs' voice: Voice call sender configuration.
        """
        pulumi.set(__self__, "sms", sms)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter
    def sms(self) -> 'outputs.ProjectConnectorsTwilioCoreSendersSms':
        """
        SMS sender configuration using either a phone number or messaging service.
        """
        return pulumi.get(self, "sms")

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional['outputs.ProjectConnectorsTwilioCoreSendersVoice']:
        """
        Voice call sender configuration.
        """
        return pulumi.get(self, "voice")


@pulumi.output_type
class ProjectConnectorsTwilioCoreSendersSms(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messagingServiceSid":
            suggest = "messaging_service_sid"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTwilioCoreSendersSms. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTwilioCoreSendersSms.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTwilioCoreSendersSms.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 messaging_service_sid: Optional[_builtins.str] = None,
                 phone_number: Optional[_builtins.str] = None):
        """
        :param _builtins.str messaging_service_sid: Twilio Messaging Service SID for sending SMS messages.
        :param _builtins.str phone_number: Twilio phone number for sending SMS messages.
        """
        if messaging_service_sid is not None:
            pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> Optional[_builtins.str]:
        """
        Twilio Messaging Service SID for sending SMS messages.
        """
        return pulumi.get(self, "messaging_service_sid")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[_builtins.str]:
        """
        Twilio phone number for sending SMS messages.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ProjectConnectorsTwilioCoreSendersVoice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTwilioCoreSendersVoice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTwilioCoreSendersVoice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTwilioCoreSendersVoice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: _builtins.str):
        """
        :param _builtins.str phone_number: Twilio phone number for making voice calls.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> _builtins.str:
        """
        Twilio phone number for making voice calls.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ProjectConnectorsTwilioVerify(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountSid":
            suggest = "account_sid"
        elif key == "serviceSid":
            suggest = "service_sid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTwilioVerify. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTwilioVerify.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTwilioVerify.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_sid: _builtins.str,
                 authentication: 'outputs.ProjectConnectorsTwilioVerifyAuthentication',
                 name: _builtins.str,
                 service_sid: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 sender: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_sid: Twilio Account SID from your Twilio Console.
        :param 'ProjectConnectorsTwilioVerifyAuthenticationArgs' authentication: Twilio authentication credentials (either auth token or API key/secret).
        :param _builtins.str name: A custom name for your connector.
        :param _builtins.str service_sid: Twilio Verify Service SID for verification services.
        :param _builtins.str description: A description of what your connector is used for.
        :param _builtins.str sender: Optional sender identifier for verification messages.
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_sid", service_sid)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)

    @_builtins.property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> _builtins.str:
        """
        Twilio Account SID from your Twilio Console.
        """
        return pulumi.get(self, "account_sid")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.ProjectConnectorsTwilioVerifyAuthentication':
        """
        Twilio authentication credentials (either auth token or API key/secret).
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceSid")
    def service_sid(self) -> _builtins.str:
        """
        Twilio Verify Service SID for verification services.
        """
        return pulumi.get(self, "service_sid")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def sender(self) -> Optional[_builtins.str]:
        """
        Optional sender identifier for verification messages.
        """
        return pulumi.get(self, "sender")


@pulumi.output_type
class ProjectConnectorsTwilioVerifyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "authToken":
            suggest = "auth_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectConnectorsTwilioVerifyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectConnectorsTwilioVerifyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectConnectorsTwilioVerifyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None,
                 api_secret: Optional[_builtins.str] = None,
                 auth_token: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Twilio API Key for authentication (used with API Secret).
        :param _builtins.str api_secret: Twilio API Secret for authentication (used with API Key).
        :param _builtins.str auth_token: Twilio Auth Token for authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        Twilio API Key for authentication (used with API Secret).
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[_builtins.str]:
        """
        Twilio API Secret for authentication (used with API Key).
        """
        return pulumi.get(self, "api_secret")

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[_builtins.str]:
        """
        Twilio Auth Token for authentication.
        """
        return pulumi.get(self, "auth_token")


@pulumi.output_type
class ProjectFlows(dict):
    def __init__(__self__, *,
                 data: _builtins.str):
        """
        :param _builtins.str data: The JSON data defining the authentication flow configuration, including metadata, screens, contents, and references.
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        The JSON data defining the authentication flow configuration, including metadata, screens, contents, and references.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ProjectInviteSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addMagiclinkToken":
            suggest = "add_magiclink_token"
        elif key == "emailService":
            suggest = "email_service"
        elif key == "inviteUrl":
            suggest = "invite_url"
        elif key == "requireInvitation":
            suggest = "require_invitation"
        elif key == "sendEmail":
            suggest = "send_email"
        elif key == "sendText":
            suggest = "send_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectInviteSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectInviteSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectInviteSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_magiclink_token: Optional[_builtins.bool] = None,
                 email_service: Optional['outputs.ProjectInviteSettingsEmailService'] = None,
                 invite_url: Optional[_builtins.str] = None,
                 require_invitation: Optional[_builtins.bool] = None,
                 send_email: Optional[_builtins.bool] = None,
                 send_text: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool add_magiclink_token: Whether to include a magic link token in invitation messages.
        :param 'ProjectInviteSettingsEmailServiceArgs' email_service: Settings related to sending invitation emails.
        :param _builtins.str invite_url: Custom URL to include in the message sent to invited users.
        :param _builtins.bool require_invitation: Whether users must be invited before they can sign up to the project.
        :param _builtins.bool send_email: Whether to send invitation emails to users.
        :param _builtins.bool send_text: Whether to send invitation SMS messages to users.
        """
        if add_magiclink_token is not None:
            pulumi.set(__self__, "add_magiclink_token", add_magiclink_token)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if invite_url is not None:
            pulumi.set(__self__, "invite_url", invite_url)
        if require_invitation is not None:
            pulumi.set(__self__, "require_invitation", require_invitation)
        if send_email is not None:
            pulumi.set(__self__, "send_email", send_email)
        if send_text is not None:
            pulumi.set(__self__, "send_text", send_text)

    @_builtins.property
    @pulumi.getter(name="addMagiclinkToken")
    def add_magiclink_token(self) -> Optional[_builtins.bool]:
        """
        Whether to include a magic link token in invitation messages.
        """
        return pulumi.get(self, "add_magiclink_token")

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional['outputs.ProjectInviteSettingsEmailService']:
        """
        Settings related to sending invitation emails.
        """
        return pulumi.get(self, "email_service")

    @_builtins.property
    @pulumi.getter(name="inviteUrl")
    def invite_url(self) -> Optional[_builtins.str]:
        """
        Custom URL to include in the message sent to invited users.
        """
        return pulumi.get(self, "invite_url")

    @_builtins.property
    @pulumi.getter(name="requireInvitation")
    def require_invitation(self) -> Optional[_builtins.bool]:
        """
        Whether users must be invited before they can sign up to the project.
        """
        return pulumi.get(self, "require_invitation")

    @_builtins.property
    @pulumi.getter(name="sendEmail")
    def send_email(self) -> Optional[_builtins.bool]:
        """
        Whether to send invitation emails to users.
        """
        return pulumi.get(self, "send_email")

    @_builtins.property
    @pulumi.getter(name="sendText")
    def send_text(self) -> Optional[_builtins.bool]:
        """
        Whether to send invitation SMS messages to users.
        """
        return pulumi.get(self, "send_text")


@pulumi.output_type
class ProjectInviteSettingsEmailService(dict):
    def __init__(__self__, *,
                 connector: _builtins.str,
                 templates: Optional[Sequence['outputs.ProjectInviteSettingsEmailServiceTemplate']] = None):
        """
        :param _builtins.str connector: The name of the email connector to use for sending emails.
        :param Sequence['ProjectInviteSettingsEmailServiceTemplateArgs'] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> _builtins.str:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.ProjectInviteSettingsEmailServiceTemplate']]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class ProjectInviteSettingsEmailServiceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "plainTextBody":
            suggest = "plain_text_body"
        elif key == "usePlainTextBody":
            suggest = "use_plain_text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectInviteSettingsEmailServiceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectInviteSettingsEmailServiceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectInviteSettingsEmailServiceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subject: _builtins.str,
                 active: Optional[_builtins.bool] = None,
                 html_body: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 plain_text_body: Optional[_builtins.str] = None,
                 use_plain_text_body: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Unique name for this email template.
        :param _builtins.str subject: Subject line of the email message.
        :param _builtins.bool active: Whether this email template is currently active and in use.
        :param _builtins.str html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param _builtins.str plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param _builtins.bool use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.bool]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[_builtins.str]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[_builtins.str]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[_builtins.bool]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")


@pulumi.output_type
class ProjectJwtTemplates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyTemplates":
            suggest = "access_key_templates"
        elif key == "userTemplates":
            suggest = "user_templates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectJwtTemplates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectJwtTemplates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectJwtTemplates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_templates: Optional[Sequence['outputs.ProjectJwtTemplatesAccessKeyTemplate']] = None,
                 user_templates: Optional[Sequence['outputs.ProjectJwtTemplatesUserTemplate']] = None):
        """
        :param Sequence['ProjectJwtTemplatesAccessKeyTemplateArgs'] access_key_templates: A list of `Access Key` type JWT Templates.
        :param Sequence['ProjectJwtTemplatesUserTemplateArgs'] user_templates: A list of `User` type JWT Templates.
        """
        if access_key_templates is not None:
            pulumi.set(__self__, "access_key_templates", access_key_templates)
        if user_templates is not None:
            pulumi.set(__self__, "user_templates", user_templates)

    @_builtins.property
    @pulumi.getter(name="accessKeyTemplates")
    def access_key_templates(self) -> Optional[Sequence['outputs.ProjectJwtTemplatesAccessKeyTemplate']]:
        """
        A list of `Access Key` type JWT Templates.
        """
        return pulumi.get(self, "access_key_templates")

    @_builtins.property
    @pulumi.getter(name="userTemplates")
    def user_templates(self) -> Optional[Sequence['outputs.ProjectJwtTemplatesUserTemplate']]:
        """
        A list of `User` type JWT Templates.
        """
        return pulumi.get(self, "user_templates")


@pulumi.output_type
class ProjectJwtTemplatesAccessKeyTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSchema":
            suggest = "auth_schema"
        elif key == "autoTenantClaim":
            suggest = "auto_tenant_claim"
        elif key == "conformanceIssuer":
            suggest = "conformance_issuer"
        elif key == "emptyClaimPolicy":
            suggest = "empty_claim_policy"
        elif key == "enforceIssuer":
            suggest = "enforce_issuer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectJwtTemplatesAccessKeyTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectJwtTemplatesAccessKeyTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectJwtTemplatesAccessKeyTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 template: _builtins.str,
                 auth_schema: Optional[_builtins.str] = None,
                 auto_tenant_claim: Optional[_builtins.bool] = None,
                 conformance_issuer: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 empty_claim_policy: Optional[_builtins.str] = None,
                 enforce_issuer: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the JWT Template.
        :param _builtins.str template: The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        :param _builtins.str auth_schema: The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        :param _builtins.bool auto_tenant_claim: When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        :param _builtins.bool conformance_issuer: Whether to use OIDC conformance for the JWT issuer field.
        :param _builtins.str description: Description of the JWT Template.
        :param _builtins.str empty_claim_policy: Policy for empty claims - `none`, `nil` or `delete`.
        :param _builtins.bool enforce_issuer: Whether to enforce that the JWT issuer matches the project configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)
        if auth_schema is not None:
            pulumi.set(__self__, "auth_schema", auth_schema)
        if auto_tenant_claim is not None:
            pulumi.set(__self__, "auto_tenant_claim", auto_tenant_claim)
        if conformance_issuer is not None:
            pulumi.set(__self__, "conformance_issuer", conformance_issuer)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if empty_claim_policy is not None:
            pulumi.set(__self__, "empty_claim_policy", empty_claim_policy)
        if enforce_issuer is not None:
            pulumi.set(__self__, "enforce_issuer", enforce_issuer)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the JWT Template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def template(self) -> _builtins.str:
        """
        The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter(name="authSchema")
    def auth_schema(self) -> Optional[_builtins.str]:
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        return pulumi.get(self, "auth_schema")

    @_builtins.property
    @pulumi.getter(name="autoTenantClaim")
    def auto_tenant_claim(self) -> Optional[_builtins.bool]:
        """
        When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        """
        return pulumi.get(self, "auto_tenant_claim")

    @_builtins.property
    @pulumi.getter(name="conformanceIssuer")
    def conformance_issuer(self) -> Optional[_builtins.bool]:
        """
        Whether to use OIDC conformance for the JWT issuer field.
        """
        return pulumi.get(self, "conformance_issuer")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the JWT Template.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="emptyClaimPolicy")
    def empty_claim_policy(self) -> Optional[_builtins.str]:
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        return pulumi.get(self, "empty_claim_policy")

    @_builtins.property
    @pulumi.getter(name="enforceIssuer")
    def enforce_issuer(self) -> Optional[_builtins.bool]:
        """
        Whether to enforce that the JWT issuer matches the project configuration.
        """
        return pulumi.get(self, "enforce_issuer")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectJwtTemplatesUserTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSchema":
            suggest = "auth_schema"
        elif key == "autoTenantClaim":
            suggest = "auto_tenant_claim"
        elif key == "conformanceIssuer":
            suggest = "conformance_issuer"
        elif key == "emptyClaimPolicy":
            suggest = "empty_claim_policy"
        elif key == "enforceIssuer":
            suggest = "enforce_issuer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectJwtTemplatesUserTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectJwtTemplatesUserTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectJwtTemplatesUserTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 template: _builtins.str,
                 auth_schema: Optional[_builtins.str] = None,
                 auto_tenant_claim: Optional[_builtins.bool] = None,
                 conformance_issuer: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 empty_claim_policy: Optional[_builtins.str] = None,
                 enforce_issuer: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the JWT Template.
        :param _builtins.str template: The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        :param _builtins.str auth_schema: The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        :param _builtins.bool auto_tenant_claim: When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        :param _builtins.bool conformance_issuer: Whether to use OIDC conformance for the JWT issuer field.
        :param _builtins.str description: Description of the JWT Template.
        :param _builtins.str empty_claim_policy: Policy for empty claims - `none`, `nil` or `delete`.
        :param _builtins.bool enforce_issuer: Whether to enforce that the JWT issuer matches the project configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)
        if auth_schema is not None:
            pulumi.set(__self__, "auth_schema", auth_schema)
        if auto_tenant_claim is not None:
            pulumi.set(__self__, "auto_tenant_claim", auto_tenant_claim)
        if conformance_issuer is not None:
            pulumi.set(__self__, "conformance_issuer", conformance_issuer)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if empty_claim_policy is not None:
            pulumi.set(__self__, "empty_claim_policy", empty_claim_policy)
        if enforce_issuer is not None:
            pulumi.set(__self__, "enforce_issuer", enforce_issuer)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the JWT Template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def template(self) -> _builtins.str:
        """
        The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter(name="authSchema")
    def auth_schema(self) -> Optional[_builtins.str]:
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        return pulumi.get(self, "auth_schema")

    @_builtins.property
    @pulumi.getter(name="autoTenantClaim")
    def auto_tenant_claim(self) -> Optional[_builtins.bool]:
        """
        When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        """
        return pulumi.get(self, "auto_tenant_claim")

    @_builtins.property
    @pulumi.getter(name="conformanceIssuer")
    def conformance_issuer(self) -> Optional[_builtins.bool]:
        """
        Whether to use OIDC conformance for the JWT issuer field.
        """
        return pulumi.get(self, "conformance_issuer")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the JWT Template.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="emptyClaimPolicy")
    def empty_claim_policy(self) -> Optional[_builtins.str]:
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        return pulumi.get(self, "empty_claim_policy")

    @_builtins.property
    @pulumi.getter(name="enforceIssuer")
    def enforce_issuer(self) -> Optional[_builtins.bool]:
        """
        Whether to enforce that the JWT issuer matches the project configuration.
        """
        return pulumi.get(self, "enforce_issuer")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ProjectProjectSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyJwtTemplate":
            suggest = "access_key_jwt_template"
        elif key == "accessKeySessionTokenExpiration":
            suggest = "access_key_session_token_expiration"
        elif key == "appUrl":
            suggest = "app_url"
        elif key == "approvedDomains":
            suggest = "approved_domains"
        elif key == "customDomain":
            suggest = "custom_domain"
        elif key == "defaultNoSsoApps":
            suggest = "default_no_sso_apps"
        elif key == "enableInactivity":
            suggest = "enable_inactivity"
        elif key == "inactivityTime":
            suggest = "inactivity_time"
        elif key == "refreshTokenCookieDomain":
            suggest = "refresh_token_cookie_domain"
        elif key == "refreshTokenCookiePolicy":
            suggest = "refresh_token_cookie_policy"
        elif key == "refreshTokenExpiration":
            suggest = "refresh_token_expiration"
        elif key == "refreshTokenResponseMethod":
            suggest = "refresh_token_response_method"
        elif key == "refreshTokenRotation":
            suggest = "refresh_token_rotation"
        elif key == "sessionMigration":
            suggest = "session_migration"
        elif key == "sessionTokenCookieDomain":
            suggest = "session_token_cookie_domain"
        elif key == "sessionTokenCookiePolicy":
            suggest = "session_token_cookie_policy"
        elif key == "sessionTokenExpiration":
            suggest = "session_token_expiration"
        elif key == "sessionTokenResponseMethod":
            suggest = "session_token_response_method"
        elif key == "stepUpTokenExpiration":
            suggest = "step_up_token_expiration"
        elif key == "testUsersLoginidRegexp":
            suggest = "test_users_loginid_regexp"
        elif key == "testUsersStaticOtp":
            suggest = "test_users_static_otp"
        elif key == "testUsersVerifierRegexp":
            suggest = "test_users_verifier_regexp"
        elif key == "trustedDeviceTokenExpiration":
            suggest = "trusted_device_token_expiration"
        elif key == "userJwtTemplate":
            suggest = "user_jwt_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectProjectSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectProjectSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectProjectSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_jwt_template: Optional[_builtins.str] = None,
                 access_key_session_token_expiration: Optional[_builtins.str] = None,
                 app_url: Optional[_builtins.str] = None,
                 approved_domains: Optional[Sequence[_builtins.str]] = None,
                 custom_domain: Optional[_builtins.str] = None,
                 default_no_sso_apps: Optional[_builtins.bool] = None,
                 enable_inactivity: Optional[_builtins.bool] = None,
                 inactivity_time: Optional[_builtins.str] = None,
                 refresh_token_cookie_domain: Optional[_builtins.str] = None,
                 refresh_token_cookie_policy: Optional[_builtins.str] = None,
                 refresh_token_expiration: Optional[_builtins.str] = None,
                 refresh_token_response_method: Optional[_builtins.str] = None,
                 refresh_token_rotation: Optional[_builtins.bool] = None,
                 session_migration: Optional['outputs.ProjectProjectSettingsSessionMigration'] = None,
                 session_token_cookie_domain: Optional[_builtins.str] = None,
                 session_token_cookie_policy: Optional[_builtins.str] = None,
                 session_token_expiration: Optional[_builtins.str] = None,
                 session_token_response_method: Optional[_builtins.str] = None,
                 step_up_token_expiration: Optional[_builtins.str] = None,
                 test_users_loginid_regexp: Optional[_builtins.str] = None,
                 test_users_static_otp: Optional[_builtins.str] = None,
                 test_users_verifier_regexp: Optional[_builtins.str] = None,
                 trusted_device_token_expiration: Optional[_builtins.str] = None,
                 user_jwt_template: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key_jwt_template: Name of the access key JWT Template.
        :param _builtins.str access_key_session_token_expiration: The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        :param _builtins.str app_url: The URL which your application resides on.
        :param Sequence[_builtins.str] approved_domains: The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        :param _builtins.str custom_domain: A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param _builtins.bool default_no_sso_apps: Define whether a user created with no federated apps, will have access to all apps, or will not have access to any app.
        :param _builtins.bool enable_inactivity: Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        :param _builtins.str inactivity_time: The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        :param _builtins.str refresh_token_cookie_domain: The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param _builtins.str refresh_token_cookie_policy: Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param _builtins.str refresh_token_expiration: The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        :param _builtins.str refresh_token_response_method: Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        :param _builtins.bool refresh_token_rotation: Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        :param 'ProjectProjectSettingsSessionMigrationArgs' session_migration: Configure seamless migration of existing user sessions from another vendor to Descope.
        :param _builtins.str session_token_cookie_domain: The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param _builtins.str session_token_cookie_policy: Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param _builtins.str session_token_expiration: The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        :param _builtins.str session_token_response_method: Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        :param _builtins.str step_up_token_expiration: The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        :param _builtins.str test_users_loginid_regexp: Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        :param _builtins.str test_users_static_otp: A 6 digit static OTP code for use with test users.
        :param _builtins.str test_users_verifier_regexp: The pattern of the verifiers that will be used for testing.
        :param _builtins.str trusted_device_token_expiration: The expiry time for the trusted device token. The minimum value is "3 minutes".
        :param _builtins.str user_jwt_template: Name of the user JWT Template.
        """
        if access_key_jwt_template is not None:
            pulumi.set(__self__, "access_key_jwt_template", access_key_jwt_template)
        if access_key_session_token_expiration is not None:
            pulumi.set(__self__, "access_key_session_token_expiration", access_key_session_token_expiration)
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if default_no_sso_apps is not None:
            pulumi.set(__self__, "default_no_sso_apps", default_no_sso_apps)
        if enable_inactivity is not None:
            pulumi.set(__self__, "enable_inactivity", enable_inactivity)
        if inactivity_time is not None:
            pulumi.set(__self__, "inactivity_time", inactivity_time)
        if refresh_token_cookie_domain is not None:
            pulumi.set(__self__, "refresh_token_cookie_domain", refresh_token_cookie_domain)
        if refresh_token_cookie_policy is not None:
            pulumi.set(__self__, "refresh_token_cookie_policy", refresh_token_cookie_policy)
        if refresh_token_expiration is not None:
            pulumi.set(__self__, "refresh_token_expiration", refresh_token_expiration)
        if refresh_token_response_method is not None:
            pulumi.set(__self__, "refresh_token_response_method", refresh_token_response_method)
        if refresh_token_rotation is not None:
            pulumi.set(__self__, "refresh_token_rotation", refresh_token_rotation)
        if session_migration is not None:
            pulumi.set(__self__, "session_migration", session_migration)
        if session_token_cookie_domain is not None:
            pulumi.set(__self__, "session_token_cookie_domain", session_token_cookie_domain)
        if session_token_cookie_policy is not None:
            pulumi.set(__self__, "session_token_cookie_policy", session_token_cookie_policy)
        if session_token_expiration is not None:
            pulumi.set(__self__, "session_token_expiration", session_token_expiration)
        if session_token_response_method is not None:
            pulumi.set(__self__, "session_token_response_method", session_token_response_method)
        if step_up_token_expiration is not None:
            pulumi.set(__self__, "step_up_token_expiration", step_up_token_expiration)
        if test_users_loginid_regexp is not None:
            pulumi.set(__self__, "test_users_loginid_regexp", test_users_loginid_regexp)
        if test_users_static_otp is not None:
            pulumi.set(__self__, "test_users_static_otp", test_users_static_otp)
        if test_users_verifier_regexp is not None:
            pulumi.set(__self__, "test_users_verifier_regexp", test_users_verifier_regexp)
        if trusted_device_token_expiration is not None:
            pulumi.set(__self__, "trusted_device_token_expiration", trusted_device_token_expiration)
        if user_jwt_template is not None:
            pulumi.set(__self__, "user_jwt_template", user_jwt_template)

    @_builtins.property
    @pulumi.getter(name="accessKeyJwtTemplate")
    def access_key_jwt_template(self) -> Optional[_builtins.str]:
        """
        Name of the access key JWT Template.
        """
        return pulumi.get(self, "access_key_jwt_template")

    @_builtins.property
    @pulumi.getter(name="accessKeySessionTokenExpiration")
    def access_key_session_token_expiration(self) -> Optional[_builtins.str]:
        """
        The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        """
        return pulumi.get(self, "access_key_session_token_expiration")

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[_builtins.str]:
        """
        The URL which your application resides on.
        """
        return pulumi.get(self, "app_url")

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        """
        return pulumi.get(self, "approved_domains")

    @_builtins.property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[_builtins.str]:
        """
        A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "custom_domain")

    @_builtins.property
    @pulumi.getter(name="defaultNoSsoApps")
    def default_no_sso_apps(self) -> Optional[_builtins.bool]:
        """
        Define whether a user created with no federated apps, will have access to all apps, or will not have access to any app.
        """
        return pulumi.get(self, "default_no_sso_apps")

    @_builtins.property
    @pulumi.getter(name="enableInactivity")
    def enable_inactivity(self) -> Optional[_builtins.bool]:
        """
        Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        """
        return pulumi.get(self, "enable_inactivity")

    @_builtins.property
    @pulumi.getter(name="inactivityTime")
    def inactivity_time(self) -> Optional[_builtins.str]:
        """
        The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        """
        return pulumi.get(self, "inactivity_time")

    @_builtins.property
    @pulumi.getter(name="refreshTokenCookieDomain")
    def refresh_token_cookie_domain(self) -> Optional[_builtins.str]:
        """
        The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "refresh_token_cookie_domain")

    @_builtins.property
    @pulumi.getter(name="refreshTokenCookiePolicy")
    def refresh_token_cookie_policy(self) -> Optional[_builtins.str]:
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "refresh_token_cookie_policy")

    @_builtins.property
    @pulumi.getter(name="refreshTokenExpiration")
    def refresh_token_expiration(self) -> Optional[_builtins.str]:
        """
        The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        """
        return pulumi.get(self, "refresh_token_expiration")

    @_builtins.property
    @pulumi.getter(name="refreshTokenResponseMethod")
    def refresh_token_response_method(self) -> Optional[_builtins.str]:
        """
        Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        return pulumi.get(self, "refresh_token_response_method")

    @_builtins.property
    @pulumi.getter(name="refreshTokenRotation")
    def refresh_token_rotation(self) -> Optional[_builtins.bool]:
        """
        Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        """
        return pulumi.get(self, "refresh_token_rotation")

    @_builtins.property
    @pulumi.getter(name="sessionMigration")
    def session_migration(self) -> Optional['outputs.ProjectProjectSettingsSessionMigration']:
        """
        Configure seamless migration of existing user sessions from another vendor to Descope.
        """
        return pulumi.get(self, "session_migration")

    @_builtins.property
    @pulumi.getter(name="sessionTokenCookieDomain")
    def session_token_cookie_domain(self) -> Optional[_builtins.str]:
        """
        The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "session_token_cookie_domain")

    @_builtins.property
    @pulumi.getter(name="sessionTokenCookiePolicy")
    def session_token_cookie_policy(self) -> Optional[_builtins.str]:
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "session_token_cookie_policy")

    @_builtins.property
    @pulumi.getter(name="sessionTokenExpiration")
    def session_token_expiration(self) -> Optional[_builtins.str]:
        """
        The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        """
        return pulumi.get(self, "session_token_expiration")

    @_builtins.property
    @pulumi.getter(name="sessionTokenResponseMethod")
    def session_token_response_method(self) -> Optional[_builtins.str]:
        """
        Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        return pulumi.get(self, "session_token_response_method")

    @_builtins.property
    @pulumi.getter(name="stepUpTokenExpiration")
    def step_up_token_expiration(self) -> Optional[_builtins.str]:
        """
        The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        """
        return pulumi.get(self, "step_up_token_expiration")

    @_builtins.property
    @pulumi.getter(name="testUsersLoginidRegexp")
    def test_users_loginid_regexp(self) -> Optional[_builtins.str]:
        """
        Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        """
        return pulumi.get(self, "test_users_loginid_regexp")

    @_builtins.property
    @pulumi.getter(name="testUsersStaticOtp")
    def test_users_static_otp(self) -> Optional[_builtins.str]:
        """
        A 6 digit static OTP code for use with test users.
        """
        return pulumi.get(self, "test_users_static_otp")

    @_builtins.property
    @pulumi.getter(name="testUsersVerifierRegexp")
    def test_users_verifier_regexp(self) -> Optional[_builtins.str]:
        """
        The pattern of the verifiers that will be used for testing.
        """
        return pulumi.get(self, "test_users_verifier_regexp")

    @_builtins.property
    @pulumi.getter(name="trustedDeviceTokenExpiration")
    def trusted_device_token_expiration(self) -> Optional[_builtins.str]:
        """
        The expiry time for the trusted device token. The minimum value is "3 minutes".
        """
        return pulumi.get(self, "trusted_device_token_expiration")

    @_builtins.property
    @pulumi.getter(name="userJwtTemplate")
    def user_jwt_template(self) -> Optional[_builtins.str]:
        """
        Name of the user JWT Template.
        """
        return pulumi.get(self, "user_jwt_template")


@pulumi.output_type
class ProjectProjectSettingsSessionMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "loginidMatchedAttributes":
            suggest = "loginid_matched_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectProjectSettingsSessionMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectProjectSettingsSessionMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectProjectSettingsSessionMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None,
                 issuer: Optional[_builtins.str] = None,
                 loginid_matched_attributes: Optional[Sequence[_builtins.str]] = None,
                 vendor: Optional[_builtins.str] = None):
        """
        :param _builtins.str audience: The audience value if needed by the vendor.
        :param _builtins.str client_id: The unique client ID for the vendor.
        :param _builtins.str domain: The domain value if needed by the vendor.
        :param _builtins.str issuer: An issuer URL if needed by the vendor.
        :param Sequence[_builtins.str] loginid_matched_attributes: A set of attributes from the vendor's user that should be used to match with the Descope user's login ID.
        :param _builtins.str vendor: The name of the vendor the sessions are migrated from, in all lowercase.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if loginid_matched_attributes is not None:
            pulumi.set(__self__, "loginid_matched_attributes", loginid_matched_attributes)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[_builtins.str]:
        """
        The audience value if needed by the vendor.
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The unique client ID for the vendor.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        The domain value if needed by the vendor.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        An issuer URL if needed by the vendor.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="loginidMatchedAttributes")
    def loginid_matched_attributes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A set of attributes from the vendor's user that should be used to match with the Descope user's login ID.
        """
        return pulumi.get(self, "loginid_matched_attributes")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional[_builtins.str]:
        """
        The name of the vendor the sessions are migrated from, in all lowercase.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class ProjectStyles(dict):
    def __init__(__self__, *,
                 data: _builtins.str):
        """
        :param _builtins.str data: The JSON data defining the visual styling and theme configuration used for authentication, widgets, etc.
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        The JSON data defining the visual styling and theme configuration used for authentication, widgets, etc.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ProjectWidgets(dict):
    def __init__(__self__, *,
                 data: _builtins.str):
        """
        :param _builtins.str data: The JSON data defining the widget. This will usually be exported as a `.json` file from the Descope console, and set in the `.tf` file using the `data = file("...")` syntax.
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        The JSON data defining the widget. This will usually be exported as a `.json` file from the Descope console, and set in the `.tf` file using the `data = file("...")` syntax.
        """
        return pulumi.get(self, "data")


